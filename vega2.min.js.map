{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index","vega2.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/aggregate/aggregator.js","node_modules/datalib/src/aggregate/collector.js","node_modules/datalib/src/aggregate/groupby.js","node_modules/datalib/src/aggregate/measures.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/bins/histogram.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/formats/dsv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/import/readers.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/index.js","node_modules/datalib/src/print.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/template.js","node_modules/datalib/src/time-units.js","node_modules/datalib/src/util.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","src/core/Bounds.js","src/core/HeadlessView.js","src/core/Model.js","src/core/View.js","src/dataflow/Collector.js","src/dataflow/Datasource.js","src/dataflow/Graph.js","src/dataflow/Node.js","src/dataflow/Signal.js","src/dataflow/changeset.js","src/dataflow/tuple.js","src/expression/codegen.js","src/expression/constants.js","src/expression/functions.js","src/expression/index.js","src/expression/parser.js","src/parse/axes.js","src/parse/data.js","src/parse/events.js","src/parse/expr.js","src/parse/interactors.js","src/parse/mark.js","src/parse/marks.js","src/parse/modify.js","src/parse/padding.js","src/parse/predicates.js","src/parse/properties.js","src/parse/signals.js","src/parse/spec.js","src/parse/streams.js","src/parse/transforms.js","src/render/canvas/Handler.js","src/render/canvas/Renderer.js","src/render/canvas/index.js","src/render/canvas/marks.js","src/render/canvas/path.js","src/render/svg-headless/Renderer.js","src/render/svg-headless/index.js","src/render/svg-headless/svg.js","src/render/svg/Handler.js","src/render/svg/Renderer.js","src/render/svg/marks.js","src/scene/Bounder.js","src/scene/Builder.js","src/scene/Encoder.js","src/scene/GroupBuilder.js","src/scene/Item.js","src/scene/Scale.js","src/scene/Transition.js","src/scene/axis.js","src/transforms/Aggregate.js","src/transforms/BatchTransform.js","src/transforms/Bin.js","src/transforms/Cross.js","src/transforms/Facet.js","src/transforms/Filter.js","src/transforms/Fold.js","src/transforms/Force.js","src/transforms/Formula.js","src/transforms/Geo.js","src/transforms/GeoPath.js","src/transforms/GroupBy.js","src/transforms/LinkPath.js","src/transforms/Parameter.js","src/transforms/Pie.js","src/transforms/Sort.js","src/transforms/Stack.js","src/transforms/Transform.js","src/transforms/Treemap.js","src/transforms/Zip.js","src/transforms/index.js","src/util/bounds.js","src/util/config.js","src/util/constants.js","src/util/debug.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vg","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"core","View","dataflow","changeset","Datasource","Graph","Node","parse","spec","scene","Builder","GroupBuilder","transforms","config","util","./src/core/View","./src/dataflow/Datasource","./src/dataflow/Graph","./src/dataflow/Node","./src/dataflow/changeset","./src/parse/spec","./src/scene/Builder","./src/scene/GroupBuilder","./src/transforms/index","./src/util/config","datalib",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"Aggregator","_cells","_aggr","_stream","summarize_args","fields","isArray","ops","array","Measures","Collector","Flags","ADD_CELL","MOD_CELL","proto","prototype","stream","v","groupby","dims","_dims","map","d","isString","get","$","isFunction","summarize","m","j","op","as","aggr","measures","create","_assign","count","*","object","value","accessors","clear","_keys","x","k","Array","key","keystr","keys","_cell","_newcell","cell","num","tuple","_newtuple","flag","aggs","collect","data","_ingest","identity","add","rem","result","results","set","execute","input","insert","remove","../util","./collector","./measures",5,"_add","_rem","stats","REM","values","_f","extent","_ext","index","min","max","quartile","_q","q1","q2","q3","../stats",6,"args","reduce","arguments","concat","./aggregator",7,"measure","base","out","extend","init","idx","resolve","agg","helper","types","req","forEach","str","vals","sort","b","accessor","mutator","all","ctr","slice","Function","assign","mod","distinct","isValid","v_new","v_old","undefined","missing","valid","sum","mean","average","variance","variancep","stdev","stdevp","median","argmin","argmax","modeskew",8,"bins","opt","step","level","minstep","precision","eps","maxb","maxbins","logb","Math","log","div","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","lo","hi","mid","cmp","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","raw","../time-units",9,"$bin","options","$func","histogram","numerical","categorical","type","qtype","ext","h","gen","range","isFinite","unique","c","counts","comparator","integer","number","../generate","../import/type","./bins",10,"repeat","val","zeros","Infinity","random","uniform","samples","normal","next","rds","y","sqrt",11,"dsv","format","header","join","delimiter","d3","delim","fmt","../../util",12,"json","topojson","treejson","csv","tsv","./dsv","./json","./topojson","./treejson",13,"isObject","isBuffer","JSON","property",14,"obj","feature","objects","features","mesh",15,"toTable","root","childrenField","visit","node","table","children",16,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","test","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","lastIndexOf","load","callback","error","err","indexOf","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","filename","fs","readFile","readFileSync","body","statusCode","getBody","sync-request",17,"read","formats","cols","parsers","clen","inferAll","duplicate","annotation","./formats","./type",18,"./load","./read",19,"TYPES","isDate","isNumber","isBoolean","typeAll","infer","TESTS","splice","PARSERS","boolean","string","isNaN","Date",20,"dl","print","template","timeunits","./aggregate/groupby","./bins/bins","./bins/histogram","./generate","./import/load","./import/read","./import/readers","./import/type","./print","./stats","./template","./time-units","./util",21,"printQuantitativeProfile","p","printCategoricalProfile","list","top","FMT","POS","separator","minwidth","maxwidth","limit","lens","head","truncate","pad","tmpl","summary","__summary__","field",22,"filter","quantile","q","H","delta","M2","avg","med","std","dot","Number","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","L2","abs","R","M","entropy","LN2","mutual","z","px","py","I","info","profile","sd",23,"text","src","source","bind","context","variable","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","stringCast","filters","split","prop","shift","trim","pidx","template_format","time","template_escapes","pattern","format_map","clearFormatCache","'","\\","\r","\n"," "," ",24,"STEPS","entries","UTC","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",25,"util_escape_str","escape_str_re","strrep","truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","Buffer","stderr","FNAME","namedfunc","stringify","equal","toMap","String","toString","Object","apply","$valid","$length","$year","$month","$date","$day","$hour","$minute","$in","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","searchString","pos","padchar","word","ellipsis","l1","l2","_process","buffer",26,"./lib/heap",27,"Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","item","lastelt","returnitem","pop","_ref","_i","_len","_ref1","_results","_results1","_j","elem","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","pushpop","peek","contains","empty","size","clone","heap","toArray","front","has","copy","factory",28,"bounds","union","x1","MAX_VALUE","y1","x2","y2","expand","translate","dx","dy","rotate","angle","cos","sin","cx","cy","encloses","intersects","width","height",29,"canvas","svg","HeadlessView","model","_el","_type","_renderers","_canvas","renderer","canvasAsync","wait","pendingImages","view","render","_renderer","initialize","_width","_height","_padding","_viewport","left","right","bottom","_io","Renderer","initSVG","initCanvas","Canvas","tw","th","ctx","getContext","setAttribute","setTransform","resize","../render/canvas/index","../render/svg-headless/index","../util/debug","./View",30,"Model","_defs","_predicates","_scene","_node","_builder","predicates","defs","pipeline","predicate","disconnect","marks","connect","fire","cs","propagate","../dataflow/Graph","../dataflow/Node","../dataflow/changeset","../scene/GroupBuilder",31,"streaming","ds","_model","listener","streamer","_streamer","_changeset","api","signals","_api","update","build","_renderNode","router","evaluate","debug","trans","items","revises","finalize","last","parseStreams","Encoder","Transition","el","__width","__height","_autopad","_handler","dataValues","signal","setter","signalValues","reflow","_strict","padding","autopad","inset","autopadInset","viewport","_build","prevHandler","parentNode","select","append","attr","style","Handler","handlers","handler","duration","ease","props","listeners","onSignal","offSignal","../parse/streams","../render/svg/index","../scene/Encoder","../scene/Transition","../util/config","./HeadlessView",32,"graph","_data","collector","ids","_id","../util/constants","./Node","./changeset",33,"facet","_graph","_name","_source","_facet","_input","_output","_pipeline","_collector","_revises","set_prev","_prev","C","SENTINEL","prev","ingest","where","func","idMap","unshift","output","dest","_srcMap","derive","./Collector","./tuple",34,"_signals","forEachNode","branch","Signal","_stamp","_rank","doNotPropagate","db","names","sg","signalRef","ref","schedule","pulse","reflowed","pq","stamp","_listeners","dependency","DATA","SIGNALS","reevaluate","run","./Datasource","./Signal",35,"REEVAL","FIELDS","SCALES","node_id","_registered","_deps","scales","_isRouter","_isCollector","deps","bool","cur","foundSending","reeval",36,"_value","_handlers",37,"reset_prev",38,"datum","tuple_id","has_prev","reset",39,"codegen_wrap","ast","retval","codegen","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","DATUM","SIGNAL_PREFIX","Literal","Identifier","id","hasOwnProperty","Program","MemberExpression","computed","CallExpression","callee","ArrayExpression","elements","BinaryExpression","operator","UnaryExpression","argument","UpdateExpression","prefix","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","Property","ExpressionStatement","expression","./constants","./functions",40,"E","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2",41,"fncall","cast","DATE","STRING","REGEXP","acos","asin","atan","atan2","tan","now","datetime","hours","minutes","seconds","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseFloat","parseInt","upper","lower","substring","if",42,"parser","./codegen","./parser",43,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","charCodeAt","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","token","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","EOF","collectToken","entry","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","msg","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","expr","state","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",44,"axes","group","def","axs","axis","scale","orient","ORIENT","layer","grid","titleOffset","tickValues","tickFormat","tickSubdivide","subdivide","tickPadding","tickSize","ts","tickSizeMajor","tickSizeMinor","tickSizeEnd","ticks","majorTickProperties","majorTicks","minorTickProperties","minorTicks","tickLabelProperties","labels","titleProperties","gridLineProperties","domainProperties","../scene/axis",45,"parseTransforms","parseModify","parseData","loaded","datasource","transform","modify","./modify","./transforms",46,"peg$subclass","child","ctor","constructor","SyntaxError","expected","peg$computePosDetails","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","buildMessage","stringEscape","hex","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","peg$parsemerged","s1","s2","s3","s4","s5","peg$parseordered","peg$FAILED","peg$parsesep","peg$c1","peg$silentFails","peg$c2","peg$reportedPos","peg$c3","peg$c0","peg$c4","s6","s7","s8","s9","s10","s11","s12","s13","peg$c5","peg$c6","peg$parsefiltered","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$parsestream","peg$parsefilter","peg$c13","peg$c14","peg$parseclass","peg$parseid","peg$c15","peg$parseeventType","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$parsevalue","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$result","peg$startRuleFunctions","peg$startRuleFunction","f1","f2","middle","event","target","startRule",47,"eval","../expression",48,"defFactory","interactor","inject","pd","nsSignals","nsPredicates","nsMarks","mk","injectMarks","from","ENTER","UPDATE","EXIT","ns","streams","operands","nsOperand","nsProperties","enter","exit","propset","rule","interactors",49,"parseProperties","parseMark","mark","delay","./properties",50,"./mark",51,"signalName","ADD","REMOVE","TOGGLE","CLEAR","../dataflow/tuple",52,53,"parseSignal","parseOperands","decl","arg","pred","parseComparator","parseLogical","parseIn","parseScale","scope","invert","=","==","!=",">",">=","<","<=","and","&&","or","||","in",54,"compile","vars","valueRef","DEPS","hasPath","encoder","tpl","encode","path","tension","rules","inputs","predName","colorRef","sgRef","fRef","sRef","fieldRef","scaleRef","band","mult","xx","color","yy","zz","nested","fr",55,"dep","./expr",56,"parsePadding","parseMarks","parseSignals","parsePredicates","parseInteractors","viewFactory","../core/Model","../core/View","../parse/data","../parse/interactors","../parse/marks","../parse/padding","../parse/predicates","../parse/signals",57,"changset","selector","START","MIDDLE","END","sig","register","orderedStream","trueFn","sp","mergedStream","sel","evt","filtered","preventDefault","mouse","./events",58,"tx","../transforms/index",59,"eventName","_active","_obj","that","events","addEventListener","touchmove","mousemove","getBoundingClientRect","clientX","clientY","pick","touchend","mouseout","DOMMouseScroll","gx","gy","marktype","picker","./marks",60,"scaleCanvas","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","initializeLineDash","vgLineDash","NODASH","setLineDash","dash","vgLineDashOffset","lineDashOffset","webkitLineDash","webkitLineDashOffset","mozDash","translatedBounds","Bounds","getBounds","setBounds","bbox","beginPath","rect","clip","_ctx","_imgload","selectAll","_ratio","element","bb2","save","clearRect","draw","renderAsync","_async_id","clearTimeout","loadImage","uri","image","Image","../../core/Bounds","../../util/config",61,"./Handler","./Renderer",62,"fontString","fontStyle","fontVariant","fontWeight","fontSize","font","arcPath","ir","innerRadius","outerRadius","startAngle","ea","endAngle","moveTo","arc","closePath","areaPath","pathCache","parsePath","area","renderPath","linePath","pathPath","symbolPath","rx","ry","shape","lineTo","tan30","sqrt3","lineStroke","lw","strokeWidth","lc","strokeCap","lineWidth","lineCap","ruleStroke","drawPathOne","opac","fill","stroke","opacity","globalAlpha","fillOpacity","fillStyle","strokeOpacity","strokeStyle","strokeDash","strokeDashOffset","drawPathAll","drawRect","fillRect","strokeRect","drawRule","drawImage","align","baseline","drawText","textAlign","textBaseline","radius","theta","fillText","strokeText","drawAll","pathFunc","drawOne","drawGroup","legends","axisItems","legendItems","gradient","grad","createLinearGradient","stops","addColorStop","pickGroup","subscene","hit","interactive","pickAll","hitTests","pickArea","pickLine","textHit","boundsCalc","tmpBounds","isPointInStroke","isPointInPath","symbol","../../util/bounds","./path",63,"currentPath","chunks","parsed","re","chunksParsed","jlen","command","commandLength","cmdLength","klen","drawArc","coords","rot","large","sweep","ex","ey","segs","arcToSegments","bez","segmentToBezier","bezierCurveTo","boundArc","rotateX","ox","oy","argsStr","arcToSegmentsCache","sin_th","cos_th","pl","a00","a01","a10","a11","x0","y0","sfactor_sq","sfactor","xc","yc","th0","th1","th_arc","segments","th2","th3","segmentToBezierCache","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","current","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","quadraticCurveTo",64,"SVGBuilder","./svg",65,66,"tag","close","escape_text","escape_font","group_bg","styl","class","clip_id","clipping","arc_path","area_path_h","area_path_v","line_path","symbol_path","xlink:href","text-anchor","cssClass","cls","xw","yh","styleProps","styles","_gid","_text","foot","svgNamespace","buildDefs","dgrad","dclip","stop-color","meta","MARKS","sty","nest","center",67,"svgHandler","__data__","_svg","dom","removeEventListener",68,"updateDefs","each","grd","cr","renderItems",69,"dup",70,"setProperty","removeProperty","area_path","setAttributeNS","removeAttribute","textContent","drawMark","evts","grps","childNodes","notG","mark_id",71,"Bounder","_mark","GROUP","../util/bounds",72,"inlineDs","sibling","_def","geom","_parent_id","_from","_ds","_isSuper","_bounder","newItem","Item","keyf","_map","joinDatasource","fullUpdate","keyFunction","joinValues","_items","parent_id","inheritFrom","_parent","_encoder","builder","fcs","./Bounder","./Encoder","./Item",73,"preds","enc","EMPTY",74,"_children","_scaler","_recursor","_scales","recurse","hasMarks","hasAxes","inline","buildMarks","buildAxes","MARK","parseAxes","buildGroup","inherit","axisDef","AXIS","Scale","acc","group_id","../dataflow/Collector","../parse/axes","./Builder","./Scale",75,"hasPropertySet","cousin","iidx","midx","touch",76,"_updated","instance","ORDINAL","ordinal","quantitative","rng","LINEAR","scaleName","dataDrivenRange","dataRef","RANGE","DOMAIN","points","rangePoints","rangeRoundBands","rangeBands","interval","QUANTILE","domainMinMax","rangeRound","exponent","POWER","clamp","nice","TIME","which","rlen","flen","refs","uniques","ck","cache","Aggregate","dataref","stat","MIN","MAX","order","DESC","min_dataref","max_dataref","domainMin","domainMax","LOG","zero","GROUP_PROPERTY","rangeMin","rangeMax","SIGNAL","../transforms/Aggregate",77,"updates","elapsed","curr","calcBounds","skip","interp","timer",78,"axis_def","newScale","oldScale","rangeBand","vg_axisScaleRange","gridLines","vg_axisTicks","tickLabels","vg_axisTickLabels","vg_axisDomain","vg_axisTitle","gridColor","vg_axisTicksExtend","tickMajorSize","tickMinorSize","vg_axisLabelExtend","vg_axisDomainExtend","tickEndSize","vg_axisTitleExtend","gridLineStyle","majorTickStyle","minorTickStyle","tickLabelStyle","domainStyle","titleStyle","vg_axisUpdate","tickFormatString","tickArguments","injest","major","minor","vg_axisSubdivide","label","tdata","vg_axisOrients","subticks","vg_axisScaleExtent","rangeExtent","vg_axisBaseline","vg_axisAlign","tickColor","tickWidth","tickLabelColor","tickLabelFont","tickLabelFontSize","titleFont","titleFontSize","titleFontWeight","titleColor","axisColor","axisWidth","../parse/mark",79,"Transform","addParameters","_fieldsDef","_reset","changes","./Transform",80,"BatchTransform","batchTransform",81,"Bin","default","bin",82,"Cross","with","diagonal","_lastRem","_lastWith","_ids","_cache","wdata","diag","cross","upFields","selfCross","woutput",83,"Facet","GroupBy","_new_tuple","_new_cell","_mod","flg","_gb","./GroupBy",84,"Filter","_skip","../parse/expr",85,"Fold","rst","get_tuple","dlen","fold",86,"Force","links","linkDistance","linkStrength","charge","chargeDistance","iterations","friction","gravity","alpha","_nodes","_links","_layout","layout","force","nodeInput","linkInput","iter","link","tick","nodeIds","linkIds",87,"Formula",88,"Geo","Parameters","lon","lat","projection","clipAngle","clipExtent","d3Projection","proj","param","_mode","_projection","geo","ll","xy",89,"GeoPath","geojson","./Geo",90,"gb","groupBy",91,"LinkPath","sx","sy","ty","curve","ix","iy","diagonalX","diagonalY","shapes",92,"Parameter","_accessors","_resolution","arrayType","dataType","fieldType","exprType","_get","isData","isField","sources","isExpr",93,"Pie","ones","./BatchTransform",94,"Sort","by",95,"Stack","sortby","partition","groups",96,"params","_parameters","./Parameter",97,"Treemap","sticky","mode","treemap",98,"Zip","withKey","_lastJoin","mp","wds","dflt","prevm","wlen",99,"aggregate","linkpath","formula","geopath","pie","zip","./Aggregate","./Bin","./Cross","./Facet","./Filter","./Fold","./Force","./Formula","./GeoPath","./LinkPath","./Pie","./Sort","./Stack","./Treemap","./Zip",100,"gfx","pathBounds","boundPath","halfpi","xmin","xmax","ymin","ymax","angles","noRotate","measureText","includeLegends","itemBounds","methods","bounds_prev","pb","markBounds","../core/Bounds","../render/canvas/path","./config",101,"utc","legend","gradientStrokeColor","gradientStrokeWidth","gradientHeight","gradientWidth","labelColor","labelFontSize","labelFont","labelAlign","labelBaseline","labelOffset","symbolShape","symbolSize","symbolColor","symbolStrokeWidth","rgb","lab","hcl","hsl","category10","category20",102,"sentinel","SINGLETON","COUNT","ASC",103,"console"],"mappings":"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","file":"vega2.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};\n},{\"./src/core/View\":31,\"./src/dataflow/Datasource\":33,\"./src/dataflow/Graph\":34,\"./src/dataflow/Node\":35,\"./src/dataflow/changeset\":37,\"./src/parse/spec\":56,\"./src/scene/Builder\":72,\"./src/scene/GroupBuilder\":74,\"./src/transforms/index\":99,\"./src/util/config\":101,\"datalib\":20}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        f.get || util.$(f.name), // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this;\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nproto.accessors = function(fields) {\n  var aggr = this._aggr, i, n, f;\n  for (i=0, n=aggr.length; i<n; ++i) {\n    if ((f = fields[aggr[i].name])) {\n      aggr[i].measures.prototype.get = util.$(f);\n    }\n  }\n  return this;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._keys = function(x) {\n  var d = this._dims,\n      n = d.length,\n      k = Array(n), i;\n  for (i=0; i<n; ++i) { k[i] = d[i].get(x); }\n  return {key: util.keystr(k), keys: k};\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._newcell(x, k));\n};\n\nproto._newcell = function(x, k) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x, k),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector();\n  }\n\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for(i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto.add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (cell.collect) cell.data.add(x);\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name].add(x);\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto.rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (cell.collect) cell.data.rem(x);\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name].rem(x);\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var results = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      results.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  return results;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  for (var i=0; i<input.length; ++i) {\n    this.add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this.rem(input[i]);\n  }\n  return this;\n};\n\nmodule.exports = Aggregator;\n},{\"../util\":25,\"./collector\":5,\"./measures\":7}],5:[function(require,module,exports){\nvar stats = require('../stats');\n\nvar REM = '$!_rem_!#';\n\nfunction Collector() {\n  this._add = [];\n  this._rem = [];\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return this._add;\n  var a = this._add,\n      r = this._rem,\n      x = Array(a.length - r.length),\n      i, j, n;\n\n  for (i=0, n=r.length; i<n; ++i) {\n    r[i][REM] = 1;\n  }\n  for (i=0, j=0, n=a.length; i<n; ++i) {\n    if (!a[i][REM]) { x[j++] = a[i]; }\n  }\n  for (i=0, n=r.length; i<n; ++i) {\n    delete r[i][REM];\n  }\n  \n  this._rem = [];\n  this._f = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._f !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._f = get;    \n  }\n  return this._ext;\n};\nproto.min = function(f) { return this.extent(f)[0]; };\nproto.max = function(f) { return this.extent(f)[1]; };\n\nproto.quartile = function(get) {\n  if (this._f !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._f = get;    \n  }\n  return this._q;\n};\nproto.q1 = function(f) { return this.quartile(f)[0]; };\nproto.q2 = function(f) { return this.quartile(f)[1]; };\nproto.q3 = function(f) { return this.quartile(f)[2]; };\n\nmodule.exports = Collector;\n},{\"../stats\":22}],6:[function(require,module,exports){\nvar util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = Array.prototype.reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n\n},{\"../util\":25,\"./aggregator\":4}],7:[function(require,module,exports){\nvar util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'this.argmin = null;',\n    set:  'this.argmin || cell.data.min(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'this.argmax = null;',\n    set:  'this.argmax || cell.data.max(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? this.get(cell.data.min(this.get)) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'this.max = null;',\n    set:  'this.max = (isNaN(this.max) ? this.get(cell.data.max(this.get)) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;\n},{\"../stats\":22,\"../util\":25}],8:[function(require,module,exports){\nvar util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time-units\":24,\"../util\":25}],9:[function(require,module,exports){\nvar stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f), c = u.counts;\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n},{\"../generate\":10,\"../import/type\":19,\"../stats\":22,\"../util\":25,\"./bins\":8}],10:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],11:[function(require,module,exports){\n(function (global){\nvar util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util\":25}],12:[function(require,module,exports){\nvar dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n},{\"./dsv\":11,\"./json\":13,\"./topojson\":14,\"./treejson\":15}],13:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":25}],14:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":13}],15:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":13}],16:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":25,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],17:[function(require,module,exports){\nvar util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n\n},{\"../util\":25,\"./formats\":12,\"./type\":19}],18:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":25,\"./load\":16,\"./read\":17}],19:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":25}],20:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;\n},{\"./aggregate/groupby\":6,\"./bins/bins\":8,\"./bins/histogram\":9,\"./generate\":10,\"./import/load\":16,\"./import/read\":17,\"./import/readers\":18,\"./import/type\":19,\"./print\":21,\"./stats\":22,\"./template\":23,\"./time-units\":24,\"./util\":25}],21:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}\n},{\"./import/type\":19,\"./stats\":22,\"./template\":23,\"./util\":25}],22:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":10,\"./import/type\":19,\"./util\":25}],23:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util\":25}],24:[function(require,module,exports){\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{}],25:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : 0;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); };\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"./time-units\":24,\"_process\":3,\"buffer\":2}],26:[function(require,module,exports){\nmodule.exports = require('./lib/heap');\n\n},{\"./lib/heap\":27}],27:[function(require,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n},{}],28:[function(require,module,exports){\nvar bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;\n},{}],29:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/index\":61,\"../render/svg-headless/index\":65,\"../util/debug\":103,\"./View\":31,\"datalib\":20}],30:[function(require,module,exports){\nvar Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;\n},{\"../dataflow/Graph\":34,\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../scene/GroupBuilder\":74,\"datalib\":20}],31:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../parse/streams\":57,\"../render/canvas/index\":61,\"../render/svg/index\":69,\"../scene/Encoder\":73,\"../scene/Transition\":77,\"../util/config\":101,\"../util/debug\":103,\"./HeadlessView\":29,\"datalib\":20}],32:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"../util/constants\":102,\"../util/debug\":103,\"./Node\":35,\"./changeset\":37}],33:[function(require,module,exports){\nvar dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;\n},{\"../util/constants\":102,\"../util/debug\":103,\"./Collector\":32,\"./Node\":35,\"./changeset\":37,\"./tuple\":38,\"datalib\":20}],34:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;\n},{\"../util/constants\":102,\"../util/debug\":103,\"./Datasource\":33,\"./Signal\":36,\"./changeset\":37,\"datalib\":20,\"heap\":26}],35:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;\n},{\"../util/constants\":102,\"datalib\":20}],36:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;\n},{\"./Node\":35,\"./changeset\":37}],37:[function(require,module,exports){\nvar C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};\n},{\"../util/constants\":102}],38:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\n// Spoof the previous tuple\nfunction prev(t) {\n  return dl.extend(dl.duplicate(t), t._prev);\n}\n\nfunction has_prev(t) {\n  return t._prev && t._prev !== C.SENTINEL;\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   prev,\n  set_prev: set_prev,\n  has_prev: has_prev,\n  reset:  reset,\n  idMap:  idMap\n};\n},{\"../util/constants\":102,\"datalib\":20}],39:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};\n},{\"./constants\":40,\"./functions\":41,\"datalib\":20}],40:[function(require,module,exports){\nmodule.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};\n},{}],41:[function(require,module,exports){\nvar datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};\n},{\"datalib\":20}],42:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n\n},{\"./codegen\":39,\"./parser\":43}],43:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],44:[function(require,module,exports){\nvar dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;\n},{\"../scene/axis\":78,\"../util/config\":101,\"datalib\":20}],45:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n\n},{\"../util/config\":101,\"./modify\":51,\"./transforms\":58,\"datalib\":20}],46:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};\n},{}],47:[function(require,module,exports){\nvar dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;\n},{\"../expression\":42,\"datalib\":20}],48:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}\n},{\"../util/config\":101,\"../util/constants\":102,\"datalib\":20}],49:[function(require,module,exports){\nvar dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};\n},{\"./properties\":54,\"datalib\":20}],50:[function(require,module,exports){\nvar parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};\n},{\"./mark\":49}],51:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}\n},{\"../dataflow/Node\":35,\"../dataflow/tuple\":38,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],52:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}\n},{\"datalib\":20}],53:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n},{\"datalib\":20}],54:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"../util/config\":101,\"datalib\":20}],55:[function(require,module,exports){\nvar expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n},{\"../util/constants\":102,\"./expr\":47}],56:[function(require,module,exports){\nvar dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n\n},{\"../core/Model\":30,\"../core/View\":31,\"../parse/data\":45,\"../parse/interactors\":48,\"../parse/marks\":50,\"../parse/padding\":52,\"../parse/predicates\":53,\"../parse/signals\":55,\"datalib\":20}],57:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../util/constants\":102,\"./events\":46,\"./expr\":47,\"datalib\":20}],58:[function(require,module,exports){\nvar dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};\n},{\"../transforms/index\":99,\"datalib\":20}],59:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":62,\"datalib\":20}],60:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":28,\"../../util/config\":101,\"./marks\":62,\"datalib\":20}],61:[function(require,module,exports){\nmodule.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};\n},{\"./Handler\":59,\"./Renderer\":60}],62:[function(require,module,exports){\nvar Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};\n},{\"../../core/Bounds\":28,\"../../util/bounds\":100,\"../../util/config\":101,\"./path\":63}],63:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":28}],64:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":101,\"./svg\":66,\"datalib\":20}],65:[function(require,module,exports){\nmodule.exports = {\n  Renderer: require('./Renderer')\n};\n\n},{\"./Renderer\":64}],66:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":101,\"datalib\":20}],67:[function(require,module,exports){\nvar dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;\n},{\"datalib\":20}],68:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":70,\"datalib\":20}],69:[function(require,module,exports){\narguments[4][61][0].apply(exports,arguments)\n},{\"./Handler\":67,\"./Renderer\":68,\"dup\":61}],70:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":101,\"datalib\":20}],71:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;\n},{\"../dataflow/Node\":35,\"../util/bounds\":100,\"../util/constants\":102,\"../util/debug\":103}],72:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../parse/data\":45,\"../util/constants\":102,\"../util/debug\":103,\"./Bounder\":71,\"./Encoder\":73,\"./Item\":75,\"datalib\":20}],73:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;\n},{\"../dataflow/Node\":35,\"../util/bounds\":100,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],74:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n},{\"../dataflow/Collector\":32,\"../dataflow/Node\":35,\"../parse/axes\":44,\"../util/constants\":102,\"../util/debug\":103,\"./Builder\":72,\"./Scale\":76,\"datalib\":20}],75:[function(require,module,exports){\nfunction Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;\n},{}],76:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      aggr = cache ? cache.aggr() : null,  // dl.Aggregator\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph)\n    cache.groupby.set(cache, [])\n      .summarize.set(cache, {});\n\n    aggr = cache.aggr();\n    if(uniques && sort) {\n      aggr.summarize({ \"dataref\": [sort.stat] })\n    } else if(!uniques) {\n      aggr.summarize({ \"dataref\": [C.MIN, C.MAX] })\n    }\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      aggr.accessors({ \"dataref\": sort ? (r.sort || sort.field) : \"_id\" });\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        aggr.groupby({ name: \"key\", get: dl.accessor(fields[j]) });\n        cache.evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        aggr.accessors({ \"dataref\": fields[j] });\n        cache.evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = aggr.result();\n  if (uniques) {\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + sort.stat + \"_dataref\";\n      sort = dl.comparator(sort);\n      data = data.sort(sort);\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return data.map(function(d) { return d.key; });\n  } else {\n    data = data[0];\n    return (data === null) ? [] : [data.min_dataref, data.max_dataref];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../transforms/Aggregate\":79,\"../util/config\":101,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],77:[function(require,module,exports){\nvar tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;\n},{\"../dataflow/tuple\":38,\"../util/bounds\":100,\"../util/constants\":102}],78:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"../parse/mark\":49,\"../util/config\":101,\"datalib\":20}],79:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tpl = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"}\n  });\n\n  this._fieldsDef = null;\n  this._aggr = null;  // dl.Aggregator\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new Transform());\n\nproto.summarize = {\n  set: function(transform, summarize) {\n    var i, len, f, fields, name, ops, signals = {};\n    if(!dl.isArray(fields = summarize)) { // Object syntax from dl\n      fields = [];\n      for (name in summarize) {\n        ops = util.array(summarize[name]);\n        fields.push({name: name, ops: ops});\n      }\n    }\n\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._aggr = null;\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nfunction ingest(t) { return tpl.ingest(t, null) }\n\nproto.aggr = function() {\n  if(this._aggr) return this._aggr;\n\n  var graph = this._graph,\n      groupby = this.groupby.get(graph).fields;\n\n  var fields = this._fieldsDef.map(function(field) {\n    var f = dl.duplicate(field);\n    f.name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    f.ops  = f.ops.signal ? graph.signalRef(f.ops.signal) : dl.array(f.ops).map(function(o) {\n      return o.signal ? graph.signalRef(o.signal) : o;\n    });\n\n    return f;\n  });\n\n  var aggr = this._aggr = dl.groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  aggr._assign = tpl.set;\n  aggr._ingest = ingest;\n\n  return aggr;\n};\n\nproto._reset = function(input, output) {\n  output.rem.push.apply(output.rem, this.aggr().result());\n  this._aggr = null;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  var output = changeset.create(input);\n  if(reset) this._reset(input, output);\n\n  var aggr = this.aggr();\n\n  input.add.forEach(aggr.add.bind(aggr));\n\n  input.mod.forEach(function(x) {\n    if(reset) {\n      aggr.add(x);  // Signal change triggered reflow\n    } else if(tpl.has_prev(x)) {\n      aggr.rem(tpl.prev(x));\n      aggr.add(x);\n    }\n  });\n\n  input.rem.forEach(function(x) {\n    aggr.rem(tpl.has_prev(x) ? tpl.prev(x) : x);\n  });\n\n  var changes = aggr.changes();\n  output.add.push.apply(output.add, changes.add);\n  output.mod.push.apply(output.mod, changes.mod);\n  output.rem.push.apply(output.rem, changes.rem);\n\n  return output;\n}\n\nmodule.exports = Aggregate;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/constants\":102,\"../util/debug\":103,\"./Transform\":96,\"datalib\":20}],80:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n\n},{\"../dataflow/Collector\":32,\"./Transform\":96}],81:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n\n},{\"../dataflow/tuple\":38,\"./Transform\":96,\"datalib\":20}],82:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;\n},{\"../dataflow/Collector\":32,\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/debug\":103,\"./Transform\":96}],83:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/constants\":102,\"../util/debug\":103,\"./GroupBy\":90,\"./Transform\":96}],84:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n},{\"../dataflow/changeset\":37,\"../parse/expr\":47,\"../util/constants\":102,\"../util/debug\":103,\"./Transform\":96}],85:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/debug\":103,\"./Transform\":96}],86:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./Transform\":96}],87:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n},{\"../dataflow/tuple\":38,\"../parse/expr\":47,\"../util/constants\":102,\"../util/debug\":103,\"./Transform\":96}],88:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./Transform\":96,\"datalib\":20}],89:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./Geo\":88,\"./Transform\":96,\"datalib\":20}],90:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/constants\":102,\"./Transform\":96}],91:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n},{\"../dataflow/tuple\":38,\"./Transform\":96}],92:[function(require,module,exports){\nvar dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":47,\"../util/constants\":102,\"datalib\":20}],93:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./BatchTransform\":80,\"./Transform\":96,\"datalib\":20}],94:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;\n},{\"../parse/expr\":47,\"../util/debug\":103,\"./Transform\":96,\"datalib\":20}],95:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n},{\"../dataflow/tuple\":38,\"./BatchTransform\":80,\"./Transform\":96,\"datalib\":20}],96:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"../dataflow/Node\":35,\"../util/constants\":102,\"./Parameter\":92}],97:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./BatchTransform\":80,\"./Transform\":96,\"datalib\":20}],98:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;\n},{\"../dataflow/Collector\":32,\"../util/debug\":103,\"./Transform\":96,\"datalib\":20}],99:[function(require,module,exports){\nmodule.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  zip:        require('./Zip')\n};\n},{\"./Aggregate\":79,\"./Bin\":81,\"./Cross\":82,\"./Facet\":83,\"./Filter\":84,\"./Fold\":85,\"./Force\":86,\"./Formula\":87,\"./Geo\":88,\"./GeoPath\":89,\"./LinkPath\":91,\"./Pie\":93,\"./Sort\":94,\"./Stack\":95,\"./Treemap\":97,\"./Zip\":98}],100:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../core/Bounds\":28,\"../render/canvas/path\":63,\"./config\":101}],101:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],102:[function(require,module,exports){\nmodule.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};\n},{}],103:[function(require,module,exports){\nvar config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};\n},{\"./config\":101}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleCIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9jb2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2dyb3VwYnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL21lYXN1cmVzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9kc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90cmVlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90aW1lLXVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwic3JjL2NvcmUvQm91bmRzLmpzIiwic3JjL2NvcmUvSGVhZGxlc3NWaWV3LmpzIiwic3JjL2NvcmUvTW9kZWwuanMiLCJzcmMvY29yZS9WaWV3LmpzIiwic3JjL2RhdGFmbG93L0NvbGxlY3Rvci5qcyIsInNyYy9kYXRhZmxvdy9EYXRhc291cmNlLmpzIiwic3JjL2RhdGFmbG93L0dyYXBoLmpzIiwic3JjL2RhdGFmbG93L05vZGUuanMiLCJzcmMvZGF0YWZsb3cvU2lnbmFsLmpzIiwic3JjL2RhdGFmbG93L2NoYW5nZXNldC5qcyIsInNyYy9kYXRhZmxvdy90dXBsZS5qcyIsInNyYy9leHByZXNzaW9uL2NvZGVnZW4uanMiLCJzcmMvZXhwcmVzc2lvbi9jb25zdGFudHMuanMiLCJzcmMvZXhwcmVzc2lvbi9mdW5jdGlvbnMuanMiLCJzcmMvZXhwcmVzc2lvbi9pbmRleC5qcyIsInNyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsInNyYy9wYXJzZS9heGVzLmpzIiwic3JjL3BhcnNlL2RhdGEuanMiLCJzcmMvcGFyc2UvZXZlbnRzLmpzIiwic3JjL3BhcnNlL2V4cHIuanMiLCJzcmMvcGFyc2UvaW50ZXJhY3RvcnMuanMiLCJzcmMvcGFyc2UvbWFyay5qcyIsInNyYy9wYXJzZS9tYXJrcy5qcyIsInNyYy9wYXJzZS9tb2RpZnkuanMiLCJzcmMvcGFyc2UvcGFkZGluZy5qcyIsInNyYy9wYXJzZS9wcmVkaWNhdGVzLmpzIiwic3JjL3BhcnNlL3Byb3BlcnRpZXMuanMiLCJzcmMvcGFyc2Uvc2lnbmFscy5qcyIsInNyYy9wYXJzZS9zcGVjLmpzIiwic3JjL3BhcnNlL3N0cmVhbXMuanMiLCJzcmMvcGFyc2UvdHJhbnNmb3Jtcy5qcyIsInNyYy9yZW5kZXIvY2FudmFzL0hhbmRsZXIuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvY2FudmFzL2luZGV4LmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3MuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9wYXRoLmpzIiwic3JjL3JlbmRlci9zdmctaGVhZGxlc3MvUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy1oZWFkbGVzcy9pbmRleC5qcyIsInNyYy9yZW5kZXIvc3ZnLWhlYWRsZXNzL3N2Zy5qcyIsInNyYy9yZW5kZXIvc3ZnL0hhbmRsZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvc3ZnL21hcmtzLmpzIiwic3JjL3NjZW5lL0JvdW5kZXIuanMiLCJzcmMvc2NlbmUvQnVpbGRlci5qcyIsInNyYy9zY2VuZS9FbmNvZGVyLmpzIiwic3JjL3NjZW5lL0dyb3VwQnVpbGRlci5qcyIsInNyYy9zY2VuZS9JdGVtLmpzIiwic3JjL3NjZW5lL1NjYWxlLmpzIiwic3JjL3NjZW5lL1RyYW5zaXRpb24uanMiLCJzcmMvc2NlbmUvYXhpcy5qcyIsInNyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsInNyYy90cmFuc2Zvcm1zL0JhdGNoVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvQmluLmpzIiwic3JjL3RyYW5zZm9ybXMvQ3Jvc3MuanMiLCJzcmMvdHJhbnNmb3Jtcy9GYWNldC5qcyIsInNyYy90cmFuc2Zvcm1zL0ZpbHRlci5qcyIsInNyYy90cmFuc2Zvcm1zL0ZvbGQuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb3JjZS5qcyIsInNyYy90cmFuc2Zvcm1zL0Zvcm11bGEuanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW8uanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW9QYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvR3JvdXBCeS5qcyIsInNyYy90cmFuc2Zvcm1zL0xpbmtQYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvUGFyYW1ldGVyLmpzIiwic3JjL3RyYW5zZm9ybXMvUGllLmpzIiwic3JjL3RyYW5zZm9ybXMvU29ydC5qcyIsInNyYy90cmFuc2Zvcm1zL1N0YWNrLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJlZW1hcC5qcyIsInNyYy90cmFuc2Zvcm1zL1ppcC5qcyIsInNyYy90cmFuc2Zvcm1zL2luZGV4LmpzIiwic3JjL3V0aWwvYm91bmRzLmpzIiwic3JjL3V0aWwvY29uZmlnLmpzIiwic3JjL3V0aWwvY29uc3RhbnRzLmpzIiwic3JjL3V0aWwvZGVidWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlRBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjb3JlOiB7XG4gICAgVmlldzogcmVxdWlyZSgnLi9zcmMvY29yZS9WaWV3JylcbiAgfSxcbiAgZGF0YWZsb3c6IHtcbiAgICBjaGFuZ2VzZXQ6IHJlcXVpcmUoJy4vc3JjL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIERhdGFzb3VyY2U6IHJlcXVpcmUoJy4vc3JjL2RhdGFmbG93L0RhdGFzb3VyY2UnKSxcbiAgICBHcmFwaDogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvR3JhcGgnKSxcbiAgICBOb2RlOiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9Ob2RlJylcbiAgfSxcbiAgcGFyc2U6IHtcbiAgICBzcGVjOiByZXF1aXJlKCcuL3NyYy9wYXJzZS9zcGVjJylcbiAgfSxcbiAgc2NlbmU6IHtcbiAgICBCdWlsZGVyOiByZXF1aXJlKCcuL3NyYy9zY2VuZS9CdWlsZGVyJyksXG4gICAgR3JvdXBCdWlsZGVyOiByZXF1aXJlKCcuL3NyYy9zY2VuZS9Hcm91cEJ1aWxkZXInKVxuICB9LFxuICB0cmFuc2Zvcm1zOiByZXF1aXJlKCcuL3NyYy90cmFuc2Zvcm1zL2luZGV4JyksXG4gIGNvbmZpZzogcmVxdWlyZSgnLi9zcmMvdXRpbC9jb25maWcnKSxcbiAgdXRpbDogcmVxdWlyZSgnZGF0YWxpYicpXG59OyIsbnVsbCwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICAgIE1lYXN1cmVzID0gcmVxdWlyZSgnLi9tZWFzdXJlcycpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4vY29sbGVjdG9yJyk7XG5cbmZ1bmN0aW9uIEFnZ3JlZ2F0b3IoKSB7XG4gIHRoaXMuX2NlbGxzID0ge307XG4gIHRoaXMuX2FnZ3IgPSBbXTtcbiAgdGhpcy5fc3RyZWFtID0gZmFsc2U7XG59XG5cbnZhciBGbGFncyA9IEFnZ3JlZ2F0b3IuRmxhZ3MgPSB7XG4gIEFERF9DRUxMOiAxLFxuICBNT0RfQ0VMTDogMlxufTtcblxudmFyIHByb3RvID0gQWdncmVnYXRvci5wcm90b3R5cGU7XG5cbi8vIFBhcmFtZXRlcnNcblxucHJvdG8uc3RyZWFtID0gZnVuY3Rpb24odikge1xuICBpZiAodiA9PSBudWxsKSByZXR1cm4gdGhpcy5fc3RyZWFtO1xuICB0aGlzLl9zdHJlYW0gPSAhIXY7XG4gIHRoaXMuX2FnZ3IgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgZ2V0OiBmdW5jdGlvbn1cbnByb3RvLmdyb3VwYnkgPSBmdW5jdGlvbihkaW1zKSB7XG4gIHRoaXMuX2RpbXMgPSB1dGlsLmFycmF5KGRpbXMpLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgZCA9IHV0aWwuaXNTdHJpbmcoZCkgPyB7bmFtZTogZCwgZ2V0OiB1dGlsLiQoZCl9XG4gICAgICA6IHV0aWwuaXNGdW5jdGlvbihkKSA/IHtuYW1lOiB1dGlsLm5hbWUoZCkgfHwgZC5uYW1lIHx8ICgnXycgKyBpKSwgZ2V0OiBkfVxuICAgICAgOiAoZC5uYW1lICYmIHV0aWwuaXNGdW5jdGlvbihkLmdldCkpID8gZCA6IG51bGw7XG4gICAgaWYgKGQgPT0gbnVsbCkgdGhyb3cgJ0ludmFsaWQgZ3JvdXBieSBhcmd1bWVudDogJyArIGQ7XG4gICAgcmV0dXJuIGQ7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIElucHV0OiBhcnJheSBvZiBvYmplY3RzIG9mIHRoZSBmb3JtXG4vLyB7bmFtZTogc3RyaW5nLCBvcHM6IFtzdHJpbmcsIC4uLl19XG5wcm90by5zdW1tYXJpemUgPSBmdW5jdGlvbihmaWVsZHMpIHtcbiAgZmllbGRzID0gc3VtbWFyaXplX2FyZ3MoZmllbGRzKTtcbiAgdmFyIGFnZ3IgPSAodGhpcy5fYWdnciA9IFtdKSxcbiAgICAgIG0sIGYsIGksIGosIG9wLCBhcztcblxuICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKGo9MCwgbT1bXSwgZj1maWVsZHNbaV07IGo8Zi5vcHMubGVuZ3RoOyArK2opIHtcbiAgICAgIG9wID0gZi5vcHNbal07XG4gICAgICBhcyA9IChmLmFzICYmIGYuYXNbal0pIHx8IChvcCArIChmLm5hbWU9PT0nKicgPyAnJyA6ICdfJytmLm5hbWUpKTtcbiAgICAgIG0ucHVzaChNZWFzdXJlc1tvcF0oYXMpKTtcbiAgICB9XG4gICAgYWdnci5wdXNoKHtcbiAgICAgIG5hbWU6IGYubmFtZSxcbiAgICAgIG1lYXN1cmVzOiBNZWFzdXJlcy5jcmVhdGUoXG4gICAgICAgIG0sXG4gICAgICAgIHRoaXMuX3N0cmVhbSwgLy8gc3RyZWFtaW5nIHJlbW92ZSBmbGFnXG4gICAgICAgIGYuZ2V0IHx8IHV0aWwuJChmLm5hbWUpLCAvLyBpbnB1dCB0dXBsZSBnZXR0ZXJcbiAgICAgICAgdGhpcy5fYXNzaWduKSAvLyBvdXRwdXQgdHVwbGUgc2V0dGVyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gc3VtbWFyaXplIGJ5IGNvdW50XG5wcm90by5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5zdW1tYXJpemUoeycqJzonY291bnQnfSk7XG59O1xuXG4vLyBPdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSB0dXBsZSB2YWx1ZSBhc3NpZ25tZW50XG5wcm90by5fYXNzaWduID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICBvYmplY3RbbmFtZV0gPSB2YWx1ZTtcbn07XG5cbnByb3RvLmFjY2Vzc29ycyA9IGZ1bmN0aW9uKGZpZWxkcykge1xuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IsIGksIG4sIGY7XG4gIGZvciAoaT0wLCBuPWFnZ3IubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGlmICgoZiA9IGZpZWxkc1thZ2dyW2ldLm5hbWVdKSkge1xuICAgICAgYWdncltpXS5tZWFzdXJlcy5wcm90b3R5cGUuZ2V0ID0gdXRpbC4kKGYpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHN1bW1hcml6ZV9hcmdzKGZpZWxkcykge1xuICBpZiAodXRpbC5pc0FycmF5KGZpZWxkcykpIHsgcmV0dXJuIGZpZWxkczsgfVxuICBpZiAoZmllbGRzID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG4gIHZhciBhID0gW10sIG5hbWUsIG9wcztcbiAgZm9yIChuYW1lIGluIGZpZWxkcykge1xuICAgIG9wcyA9IHV0aWwuYXJyYXkoZmllbGRzW25hbWVdKTtcbiAgICBhLnB1c2goe25hbWU6IG5hbWUsIG9wczogb3BzfSk7XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8vIENlbGwgTWFuYWdlbWVudFxuXG5wcm90by5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX2NlbGxzID0ge30sIHRoaXMpO1xufTtcblxucHJvdG8uX2tleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBkID0gdGhpcy5fZGltcyxcbiAgICAgIG4gPSBkLmxlbmd0aCxcbiAgICAgIGsgPSBBcnJheShuKSwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7IGtbaV0gPSBkW2ldLmdldCh4KTsgfVxuICByZXR1cm4ge2tleTogdXRpbC5rZXlzdHIoayksIGtleXM6IGt9O1xufTtcblxucHJvdG8uX2NlbGwgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrID0gdGhpcy5fa2V5cyh4KTtcbiAgcmV0dXJuIHRoaXMuX2NlbGxzW2sua2V5XSB8fCAodGhpcy5fY2VsbHNbay5rZXldID0gdGhpcy5fbmV3Y2VsbCh4LCBrKSk7XG59O1xuXG5wcm90by5fbmV3Y2VsbCA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgdmFyIGNlbGwgPSB7XG4gICAgbnVtOiAgIDAsXG4gICAgdHVwbGU6IHRoaXMuX25ld3R1cGxlKHgsIGspLFxuICAgIGZsYWc6ICBGbGFncy5BRERfQ0VMTCxcbiAgICBhZ2dzOiAge31cbiAgfTtcblxuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG4gIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXSA9IG5ldyBhZ2dyW2ldLm1lYXN1cmVzKGNlbGwsIGNlbGwudHVwbGUpO1xuICB9XG4gIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICBjZWxsLmRhdGEgPSBuZXcgQ29sbGVjdG9yKCk7XG4gIH1cblxuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9uZXd0dXBsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgdCA9IHt9LCBpLCBuO1xuICBmb3IoaT0wLCBuPWRpbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHRbZGltc1tpXS5uYW1lXSA9IGRpbXNbaV0uZ2V0KHgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbmdlc3QodCk7XG59O1xuXG4vLyBPdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSB0dXBsZSBpbmdlc3Rpb25cbnByb3RvLl9pbmdlc3QgPSB1dGlsLmlkZW50aXR5O1xuXG4vLyBQcm9jZXNzIFR1cGxlc1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGNlbGwubnVtICs9IDE7XG4gIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5hZGQoeCk7XG4gIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXS5hZGQoeCk7XG4gIH1cbiAgY2VsbC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xufTtcblxucHJvdG8ucmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSAtPSAxO1xuICBpZiAoY2VsbC5jb2xsZWN0KSBjZWxsLmRhdGEucmVtKHgpO1xuICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0ucmVtKHgpO1xuICB9XG4gIGNlbGwuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbn07XG5cbnByb3RvLnJlc3VsdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0cyA9IFtdLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZiAoY2VsbC5udW0gPiAwKSB7XG4gICAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKGNlbGwudHVwbGUpO1xuICAgIH1cbiAgICBjZWxsLmZsYWcgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5wcm90by5leGVjdXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMuY2xlYXIoKS5pbnNlcnQoaW5wdXQpLnJlc3VsdCgpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5hZGQoaW5wdXRbaV0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYgKCF0aGlzLl9zdHJlYW0pIHtcbiAgICB0aHJvdyAnQWdncmVnYXRvciBub3QgY29uZmlndXJlZCBmb3Igc3RyZWFtaW5nIHJlbW92ZXMuJyArXG4gICAgICAnIENhbGwgc3RyZWFtKHRydWUpIHByaW9yIHRvIGNhbGxpbmcgc3VtbWFyaXplLic7XG4gIH1cbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5yZW0oaW5wdXRbaV0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZ2dyZWdhdG9yOyIsInZhciBzdGF0cyA9IHJlcXVpcmUoJy4uL3N0YXRzJyk7XG5cbnZhciBSRU0gPSAnJCFfcmVtXyEjJztcblxuZnVuY3Rpb24gQ29sbGVjdG9yKCkge1xuICB0aGlzLl9hZGQgPSBbXTtcbiAgdGhpcy5fcmVtID0gW107XG59XG5cbnZhciBwcm90byA9IENvbGxlY3Rvci5wcm90b3R5cGU7XG5cbnByb3RvLmFkZCA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5fYWRkLnB1c2godik7XG59O1xuXG5wcm90by5yZW0gPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuX3JlbS5wdXNoKHYpO1xufTtcblxucHJvdG8udmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9yZW0ubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fYWRkO1xuICB2YXIgYSA9IHRoaXMuX2FkZCxcbiAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICB4ID0gQXJyYXkoYS5sZW5ndGggLSByLmxlbmd0aCksXG4gICAgICBpLCBqLCBuO1xuXG4gIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHJbaV1bUkVNXSA9IDE7XG4gIH1cbiAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBpZiAoIWFbaV1bUkVNXSkgeyB4W2orK10gPSBhW2ldOyB9XG4gIH1cbiAgZm9yIChpPTAsIG49ci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZGVsZXRlIHJbaV1bUkVNXTtcbiAgfVxuICBcbiAgdGhpcy5fcmVtID0gW107XG4gIHRoaXMuX2YgPSBudWxsO1xuICByZXR1cm4gKHRoaXMuX2FkZCA9IHgpO1xufTtcblxuLy8gbWVtb2l6aW5nIHN0YXRpc3RpY3MgbWV0aG9kc1xuXG5wcm90by5leHRlbnQgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2YgIT09IGdldCB8fCAhdGhpcy5fZXh0KSB7XG4gICAgdmFyIHYgPSB0aGlzLnZhbHVlcygpLFxuICAgICAgICBpID0gc3RhdHMuZXh0ZW50LmluZGV4KHYsIGdldCk7XG4gICAgdGhpcy5fZXh0ID0gW3ZbaVswXV0sIHZbaVsxXV1dO1xuICAgIHRoaXMuX2YgPSBnZXQ7ICAgIFxuICB9XG4gIHJldHVybiB0aGlzLl9leHQ7XG59O1xucHJvdG8ubWluID0gZnVuY3Rpb24oZikgeyByZXR1cm4gdGhpcy5leHRlbnQoZilbMF07IH07XG5wcm90by5tYXggPSBmdW5jdGlvbihmKSB7IHJldHVybiB0aGlzLmV4dGVudChmKVsxXTsgfTtcblxucHJvdG8ucXVhcnRpbGUgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2YgIT09IGdldCB8fCAhdGhpcy5fcSkge1xuICAgIHRoaXMuX3EgPSBzdGF0cy5xdWFydGlsZSh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2YgPSBnZXQ7ICAgIFxuICB9XG4gIHJldHVybiB0aGlzLl9xO1xufTtcbnByb3RvLnExID0gZnVuY3Rpb24oZikgeyByZXR1cm4gdGhpcy5xdWFydGlsZShmKVswXTsgfTtcbnByb3RvLnEyID0gZnVuY3Rpb24oZikgeyByZXR1cm4gdGhpcy5xdWFydGlsZShmKVsxXTsgfTtcbnByb3RvLnEzID0gZnVuY3Rpb24oZikgeyByZXR1cm4gdGhpcy5xdWFydGlsZShmKVsyXTsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vYWdncmVnYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBmbGF0dGVuIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgeCkge1xuICAgIHJldHVybiBhLmNvbmNhdCh1dGlsLmFycmF5KHgpKTtcbiAgfSwgW10pO1xuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhbiBhZ2dyZWdhdG9yXG4gIHJldHVybiBuZXcgQWdncmVnYXRvcigpXG4gICAgLmdyb3VwYnkoYXJncylcbiAgICAuc3VtbWFyaXplKHsnKic6J3ZhbHVlcyd9KTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIHR5cGVzID0ge1xuICAndmFsdWVzJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbHVlcycsXG4gICAgaW5pdDogJ2NlbGwuY29sbGVjdCA9IHRydWU7JyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnZhbHVlcygpJywgaWR4OiAtMVxuICB9KSxcbiAgJ2NvdW50JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2NvdW50JyxcbiAgICBzZXQ6ICAnY2VsbC5udW0nXG4gIH0pLFxuICAnbWlzc2luZyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaXNzaW5nJyxcbiAgICBzZXQ6ICAndGhpcy5taXNzaW5nJ1xuICB9KSxcbiAgJ3ZhbGlkJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbGlkJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCdcbiAgfSksXG4gICdzdW0nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3VtJyxcbiAgICBpbml0OiAndGhpcy5zdW0gPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuc3VtICs9IHY7JyxcbiAgICByZW06ICAndGhpcy5zdW0gLT0gdjsnLFxuICAgIHNldDogICd0aGlzLnN1bSdcbiAgfSksXG4gICdtZWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lYW4nLFxuICAgIGluaXQ6ICd0aGlzLm1lYW4gPSAwOycsXG4gICAgYWRkOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuICs9IGQgLyB0aGlzLnZhbGlkOycsXG4gICAgcmVtOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuIC09IGQgLyB0aGlzLnZhbGlkOycsXG4gICAgc2V0OiAgJ3RoaXMubWVhbidcbiAgfSksXG4gICdhdmVyYWdlJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2F2ZXJhZ2UnLFxuICAgIHNldDogICd0aGlzLm1lYW4nLFxuICAgIHJlcTogIFsnbWVhbiddLCBpZHg6IDFcbiAgfSksXG4gICd2YXJpYW5jZSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YXJpYW5jZScsXG4gICAgaW5pdDogJ3RoaXMuZGV2ID0gMDsnLFxuICAgIGFkZDogICd0aGlzLmRldiArPSBkICogKHYgLSB0aGlzLm1lYW4pOycsXG4gICAgcmVtOiAgJ3RoaXMuZGV2IC09IGQgKiAodiAtIHRoaXMubWVhbik7JyxcbiAgICBzZXQ6ICAndGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKScsXG4gICAgcmVxOiAgWydtZWFuJ10sIGlkeDogMVxuICB9KSxcbiAgJ3ZhcmlhbmNlcCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YXJpYW5jZXAnLFxuICAgIHNldDogICd0aGlzLmRldiAvIHRoaXMudmFsaWQnLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnc3RkZXYnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3RkZXYnLFxuICAgIHNldDogICdNYXRoLnNxcnQodGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKSknLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnc3RkZXZwJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3N0ZGV2cCcsXG4gICAgc2V0OiAgJ01hdGguc3FydCh0aGlzLmRldiAvIHRoaXMudmFsaWQpJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ21lZGlhbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtZWRpYW4nLFxuICAgIHNldDogICdjZWxsLmRhdGEucTIodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdxMSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdxMScsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMSh0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ3EzJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3EzJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnEzKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnZGlzdGluY3QnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnZGlzdGluY3QnLFxuICAgIHNldDogICd0aGlzLmRpc3RpbmN0KGNlbGwuZGF0YS52YWx1ZXMoKSwgdGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdhcmdtaW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXJnbWluJyxcbiAgICBhZGQ6ICAnaWYgKHYgPCB0aGlzLm1pbikgdGhpcy5hcmdtaW4gPSB0OycsXG4gICAgcmVtOiAgJ3RoaXMuYXJnbWluID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21pbiB8fCBjZWxsLmRhdGEubWluKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWydtaW4nXSwgc3RyOiBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdhcmdtYXgnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXJnbWF4JyxcbiAgICBhZGQ6ICAnaWYgKHYgPiB0aGlzLm1heCkgdGhpcy5hcmdtYXggPSB0OycsXG4gICAgcmVtOiAgJ3RoaXMuYXJnbWF4ID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21heCB8fCBjZWxsLmRhdGEubWF4KHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWydtYXgnXSwgc3RyOiBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdtaW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWluJyxcbiAgICBpbml0OiAndGhpcy5taW4gPSArSW5maW5pdHk7JyxcbiAgICBhZGQ6ICAnaWYgKHYgPCB0aGlzLm1pbikgdGhpcy5taW4gPSB2OycsXG4gICAgcmVtOiAgJ3RoaXMubWluID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWluID0gKGlzTmFOKHRoaXMubWluKSA/IHRoaXMuZ2V0KGNlbGwuZGF0YS5taW4odGhpcy5nZXQpKSA6IHRoaXMubWluKScsXG4gICAgc3RyOiAgWyd2YWx1ZXMnXSwgaWR4OiA0XG4gIH0pLFxuICAnbWF4JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21heCcsXG4gICAgaW5pdDogJ3RoaXMubWF4ID0gLUluZmluaXR5OycsXG4gICAgYWRkOiAgJ2lmICh2ID4gdGhpcy5tYXgpIHRoaXMubWF4ID0gdjsnLFxuICAgIHJlbTogICd0aGlzLm1heCA9IG51bGw7JyxcbiAgICBzZXQ6ICAndGhpcy5tYXggPSAoaXNOYU4odGhpcy5tYXgpID8gdGhpcy5nZXQoY2VsbC5kYXRhLm1heCh0aGlzLmdldCkpIDogdGhpcy5tYXgpJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtb2Rlc2tldyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtb2Rlc2tldycsXG4gICAgc2V0OiAgJ3RoaXMuZGV2PT09MCA/IDAgOiAodGhpcy5tZWFuIC0gY2VsbC5kYXRhLnEyKHRoaXMuZ2V0KSkgLyBNYXRoLnNxcnQodGhpcy5kZXYvKHRoaXMudmFsaWQtMSkpJyxcbiAgICByZXE6ICBbJ21lYW4nLCAnc3RkZXYnLCAnbWVkaWFuJ10sIGlkeDogNVxuICB9KVxufTtcblxuZnVuY3Rpb24gbWVhc3VyZShiYXNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvdXQpIHtcbiAgICB2YXIgbSA9IHV0aWwuZXh0ZW5kKHtpbml0OicnLCBhZGQ6JycsIHJlbTonJywgaWR4OjB9LCBiYXNlKTtcbiAgICBtLm91dCA9IG91dCB8fCBiYXNlLm5hbWU7XG4gICAgcmV0dXJuIG07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYWdnLCBzdHJlYW0pIHtcbiAgZnVuY3Rpb24gY29sbGVjdChtLCBhKSB7XG4gICAgZnVuY3Rpb24gaGVscGVyKHIpIHsgaWYgKCFtW3JdKSBjb2xsZWN0KG0sIG1bcl0gPSB0eXBlc1tyXSgpKTsgfVxuICAgIGlmIChhLnJlcSkgYS5yZXEuZm9yRWFjaChoZWxwZXIpO1xuICAgIGlmIChzdHJlYW0gJiYgYS5zdHIpIGEuc3RyLmZvckVhY2goaGVscGVyKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICB2YXIgbWFwID0gYWdnLnJlZHVjZShcbiAgICBjb2xsZWN0LFxuICAgIGFnZy5yZWR1Y2UoZnVuY3Rpb24obSwgYSkgeyByZXR1cm4gKG1bYS5uYW1lXSA9IGEsIG0pOyB9LCB7fSlcbiAgKTtcbiAgcmV0dXJuIHV0aWwudmFscyhtYXApLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShhZ2csIHN0cmVhbSwgYWNjZXNzb3IsIG11dGF0b3IpIHtcbiAgdmFyIGFsbCA9IHJlc29sdmUoYWdnLCBzdHJlYW0pLFxuICAgICAgY3RyID0gJ3RoaXMuY2VsbCA9IGNlbGw7IHRoaXMudHVwbGUgPSB0OyB0aGlzLnZhbGlkID0gMDsgdGhpcy5taXNzaW5nID0gMDsnLFxuICAgICAgYWRkID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmcrKzsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgdGhpcy52YWxpZCsrOycsXG4gICAgICByZW0gPSAnaWYgKHY9PW51bGwpIHRoaXMubWlzc2luZy0tOyBpZiAoIXRoaXMuaXNWYWxpZCh2KSkgcmV0dXJuOyB0aGlzLnZhbGlkLS07JyxcbiAgICAgIHNldCA9ICd2YXIgdCA9IHRoaXMudHVwbGU7IHZhciBjZWxsID0gdGhpcy5jZWxsOyc7XG5cbiAgYWxsLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIGlmIChhLmlkeCA8IDApIHtcbiAgICAgIGN0ciA9IGEuaW5pdCArIGN0cjtcbiAgICAgIGFkZCA9IGEuYWRkICsgYWRkO1xuICAgICAgcmVtID0gYS5yZW0gKyByZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0ciArPSBhLmluaXQ7XG4gICAgICBhZGQgKz0gYS5hZGQ7XG4gICAgICByZW0gKz0gYS5yZW07XG4gICAgfVxuICB9KTtcbiAgYWdnLnNsaWNlKClcbiAgICAuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmlkeCAtIGIuaWR4OyB9KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIHNldCArPSAndGhpcy5hc3NpZ24odCxcXCcnK2Eub3V0KydcXCcsJythLnNldCsnKTsnO1xuICAgIH0pO1xuICBzZXQgKz0gJ3JldHVybiB0Oyc7XG5cbiAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgY3RyID0gRnVuY3Rpb24oJ2NlbGwnLCAndCcsIGN0cik7XG4gIGN0ci5wcm90b3R5cGUuYXNzaWduID0gbXV0YXRvcjtcbiAgY3RyLnByb3RvdHlwZS5hZGQgPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyBhZGQpO1xuICBjdHIucHJvdG90eXBlLnJlbSA9IEZ1bmN0aW9uKCd0JywgJ3ZhciB2ID0gdGhpcy5nZXQodCk7JyArIHJlbSk7XG4gIGN0ci5wcm90b3R5cGUuc2V0ID0gRnVuY3Rpb24oc2V0KTtcbiAgY3RyLnByb3RvdHlwZS5nZXQgPSBhY2Nlc3NvcjtcbiAgY3RyLnByb3RvdHlwZS5tb2QgPSBtb2Q7XG4gIGN0ci5wcm90b3R5cGUuZGlzdGluY3QgPSByZXF1aXJlKCcuLi9zdGF0cycpLmNvdW50LmRpc3RpbmN0O1xuICBjdHIucHJvdG90eXBlLmlzVmFsaWQgPSB1dGlsLmlzVmFsaWQ7XG4gIHJldHVybiBjdHI7XG59XG5cbmZ1bmN0aW9uIG1vZCh2X25ldywgdl9vbGQpIHtcbiAgaWYgKHZfb2xkID09PSB1bmRlZmluZWQgfHwgdl9vbGQgPT09IHZfbmV3KSByZXR1cm47XG4gIHRoaXMucmVtKHZfb2xkKTtcbiAgdGhpcy5hZGQodl9uZXcpO1xufVxuXG50eXBlcy5jcmVhdGUgPSBjcmVhdGU7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIHVuaXRzID0gcmVxdWlyZSgnLi4vdGltZS11bml0cycpO1xudmFyIEVQU0lMT04gPSAxZS0xNTtcblxuZnVuY3Rpb24gYmlucyhvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIC8vIGRldGVybWluZSByYW5nZVxuICB2YXIgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDE1LFxuICAgICAgYmFzZSA9IG9wdC5iYXNlIHx8IDEwLFxuICAgICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgICAgZGl2ID0gb3B0LmRpdiB8fCBbNSwgMl0sICAgICAgXG4gICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgbWF4ID0gb3B0Lm1heCxcbiAgICAgIHNwYW4gPSBtYXggLSBtaW4sXG4gICAgICBzdGVwLCBsZXZlbCwgbWluc3RlcCwgcHJlY2lzaW9uLCB2LCBpLCBlcHM7XG5cbiAgaWYgKG9wdC5zdGVwKSB7XG4gICAgLy8gaWYgc3RlcCBzaXplIGlzIGV4cGxpY2l0bHkgZ2l2ZW4sIHVzZSB0aGF0XG4gICAgc3RlcCA9IG9wdC5zdGVwO1xuICB9IGVsc2UgaWYgKG9wdC5zdGVwcykge1xuICAgIC8vIGlmIHByb3ZpZGVkLCBsaW1pdCBjaG9pY2UgdG8gYWNjZXB0YWJsZSBzdGVwIHNpemVzXG4gICAgc3RlcCA9IG9wdC5zdGVwc1tNYXRoLm1pbihcbiAgICAgIG9wdC5zdGVwcy5sZW5ndGggLSAxLFxuICAgICAgYmlzZWN0KG9wdC5zdGVwcywgc3Bhbi9tYXhiLCAwLCBvcHQuc3RlcHMubGVuZ3RoKVxuICAgICldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IG9wdC5taW5zdGVwIHx8IDA7XG4gICAgc3RlcCA9IE1hdGgubWF4KFxuICAgICAgbWluc3RlcCxcbiAgICAgIE1hdGgucG93KGJhc2UsIE1hdGgucm91bmQoTWF0aC5sb2coc3BhbikgLyBsb2diKSAtIGxldmVsKVxuICAgICk7XG4gICAgXG4gICAgLy8gaW5jcmVhc2Ugc3RlcCBzaXplIGlmIHRvbyBtYW55IGJpbnNcbiAgICBkbyB7IHN0ZXAgKj0gYmFzZTsgfSB3aGlsZSAoTWF0aC5jZWlsKHNwYW4vc3RlcCkgPiBtYXhiKTtcblxuICAgIC8vIGRlY3JlYXNlIHN0ZXAgc2l6ZSBpZiBhbGxvd2VkXG4gICAgZm9yIChpPTA7IGk8ZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnN0ZXAgJiYgc3BhbiAvIHYgPD0gbWF4Yikgc3RlcCA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDE7XG4gIGVwcyA9IE1hdGgucG93KGJhc2UsIC1wcmVjaXNpb24gLSAxKTtcbiAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmZsb29yKG1pbiAvIHN0ZXAgKyBlcHMpICogc3RlcCk7XG4gIG1heCA9IE1hdGguY2VpbChtYXggLyBzdGVwKSAqIHN0ZXA7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogbWluLFxuICAgIHN0b3A6ICBtYXgsXG4gICAgc3RlcDogIHN0ZXAsXG4gICAgdW5pdDogIHtwcmVjaXNpb246IHByZWNpc2lvbn0sXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGluZGV4OiBpbmRleFxuICB9O1xufVxuXG5mdW5jdGlvbiBiaXNlY3QoYSwgeCwgbG8sIGhpKSB7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKHV0aWwuY21wKGFbbWlkXSwgeCkgPCAwKSB7IGxvID0gbWlkICsgMTsgfVxuICAgIGVsc2UgeyBoaSA9IG1pZDsgfVxuICB9XG4gIHJldHVybiBsbztcbn1cblxuZnVuY3Rpb24gdmFsdWUodikge1xuICByZXR1cm4gdGhpcy5zdGVwICogTWF0aC5mbG9vcih2IC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGluZGV4KHYpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHYgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBkYXRlX3ZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMudW5pdC5kYXRlKHZhbHVlLmNhbGwodGhpcywgdikpO1xufVxuXG5mdW5jdGlvbiBkYXRlX2luZGV4KHYpIHtcbiAgcmV0dXJuIGluZGV4LmNhbGwodGhpcywgdGhpcy51bml0LnVuaXQodikpO1xufVxuXG5iaW5zLmRhdGUgPSBmdW5jdGlvbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIC8vIGZpbmQgdGltZSBzdGVwLCB0aGVuIGJpblxuICB2YXIgZG1pbiA9IG9wdC5taW4sXG4gICAgICBkbWF4ID0gb3B0Lm1heCxcbiAgICAgIG1heGIgPSBvcHQubWF4YmlucyB8fCAyMCxcbiAgICAgIG1pbmIgPSBvcHQubWluYmlucyB8fCA0LFxuICAgICAgc3BhbiA9ICgrZG1heCkgLSAoK2RtaW4pLFxuICAgICAgdW5pdCA9IG9wdC51bml0ID8gdW5pdHNbb3B0LnVuaXRdIDogdW5pdHMuZmluZChzcGFuLCBtaW5iLCBtYXhiKSxcbiAgICAgIHNwZWMgPSBiaW5zKHtcbiAgICAgICAgbWluOiAgICAgdW5pdC5taW4gIT0gbnVsbCA/IHVuaXQubWluIDogdW5pdC51bml0KGRtaW4pLFxuICAgICAgICBtYXg6ICAgICB1bml0Lm1heCAhPSBudWxsID8gdW5pdC5tYXggOiB1bml0LnVuaXQoZG1heCksXG4gICAgICAgIG1heGJpbnM6IG1heGIsXG4gICAgICAgIG1pbnN0ZXA6IHVuaXQubWluc3RlcCxcbiAgICAgICAgc3RlcHM6ICAgdW5pdC5zdGVwXG4gICAgICB9KTtcblxuICBzcGVjLnVuaXQgPSB1bml0O1xuICBzcGVjLmluZGV4ID0gZGF0ZV9pbmRleDtcbiAgaWYgKCFvcHQucmF3KSBzcGVjLnZhbHVlID0gZGF0ZV92YWx1ZTtcbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbnM7XG4iLCJ2YXIgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuLi9pbXBvcnQvdHlwZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi4vZ2VuZXJhdGUnKTtcbnZhciBiaW5zID0gcmVxdWlyZSgnLi9iaW5zJyk7XG5cbnZhciBxdHlwZSA9IHtcbiAgJ2ludGVnZXInOiAxLFxuICAnbnVtYmVyJzogMSxcbiAgJ2RhdGUnOiAxXG59O1xuXG5mdW5jdGlvbiAkYmluKHZhbHVlcywgZiwgb3B0KSB7XG4gIG9wdCA9IG9wdGlvbnModmFsdWVzLCBmLCBvcHQpO1xuICB2YXIgYiA9IHNwZWMob3B0KTtcbiAgcmV0dXJuICFiID8gKG9wdC5hY2Nlc3NvciB8fCB1dGlsLmlkZW50aXR5KSA6XG4gICAgdXRpbC4kZnVuYygnYmluJywgYi51bml0LnVuaXQgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYi52YWx1ZShiLnVuaXQudW5pdCh4KSk7IH0gOlxuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gYi52YWx1ZSh4KTsgfVxuICAgICkob3B0LmFjY2Vzc29yKTtcbn1cblxuZnVuY3Rpb24gaGlzdG9ncmFtKHZhbHVlcywgZiwgb3B0KSB7XG4gIG9wdCA9IG9wdGlvbnModmFsdWVzLCBmLCBvcHQpO1xuICB2YXIgYiA9IHNwZWMob3B0KTtcbiAgcmV0dXJuIGIgP1xuICAgIG51bWVyaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3NvciwgYikgOlxuICAgIGNhdGVnb3JpY2FsKHZhbHVlcywgb3B0LmFjY2Vzc29yLCBvcHQgJiYgb3B0LnNvcnQpO1xufVxuXG5mdW5jdGlvbiBzcGVjKG9wdCkge1xuICB2YXIgdCA9IG9wdC50eXBlLCBiID0gbnVsbDtcbiAgaWYgKHQgPT0gbnVsbCB8fCBxdHlwZVt0XSkge1xuICAgIGlmICh0ID09PSAnaW50ZWdlcicgJiYgb3B0Lm1pbnN0ZXAgPT0gbnVsbCkgb3B0Lm1pbnN0ZXAgPSAxO1xuICAgIGIgPSAodCA9PT0gJ2RhdGUnKSA/IGJpbnMuZGF0ZShvcHQpIDogYmlucyhvcHQpO1xuICB9XG4gIHJldHVybiBiO1xufVxuXG5mdW5jdGlvbiBvcHRpb25zKCkge1xuICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgIGkgPSAwLFxuICAgICAgdmFsdWVzID0gdXRpbC5pc0FycmF5KGFbaV0pID8gYVtpKytdIDogbnVsbCxcbiAgICAgIGYgPSB1dGlsLmlzRnVuY3Rpb24oYVtpXSkgfHwgdXRpbC5pc1N0cmluZyhhW2ldKSA/IHV0aWwuJChhW2krK10pIDogbnVsbCxcbiAgICAgIG9wdCA9IHV0aWwuZXh0ZW5kKHt9LCBhW2ldKTtcbiAgXG4gIGlmICh2YWx1ZXMpIHtcbiAgICBvcHQudHlwZSA9IG9wdC50eXBlIHx8IHR5cGUodmFsdWVzLCBmKTtcbiAgICBpZiAocXR5cGVbb3B0LnR5cGVdKSB7XG4gICAgICB2YXIgZXh0ID0gc3RhdHMuZXh0ZW50KHZhbHVlcywgZik7XG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7bWluOiBleHRbMF0sIG1heDogZXh0WzFdfSwgb3B0KTtcbiAgICB9XG4gIH1cbiAgaWYgKGYpIHsgb3B0LmFjY2Vzc29yID0gZjsgfVxuICByZXR1cm4gb3B0O1xufVxuXG5mdW5jdGlvbiBudW1lcmljYWwodmFsdWVzLCBmLCBiKSB7XG4gIHZhciBoID0gZ2VuLnJhbmdlKGIuc3RhcnQsIGIuc3RvcCArIGIuc3RlcC8yLCBiLnN0ZXApXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB7dmFsdWU6IGIudmFsdWUodiksIGNvdW50OiAwfTsgfSk7XG5cbiAgZm9yICh2YXIgaT0wLCB2LCBqOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGogPSBiLmluZGV4KHYpO1xuICAgICAgaWYgKGogPCAwIHx8IGogPj0gaC5sZW5ndGggfHwgIWlzRmluaXRlKGopKSBjb250aW51ZTtcbiAgICAgIGhbal0uY291bnQgKz0gMTtcbiAgICB9XG4gIH1cbiAgaC5iaW5zID0gYjtcbiAgcmV0dXJuIGg7XG59XG5cbmZ1bmN0aW9uIGNhdGVnb3JpY2FsKHZhbHVlcywgZiwgc29ydCkge1xuICB2YXIgdSA9IHN0YXRzLnVuaXF1ZSh2YWx1ZXMsIGYpLCBjID0gdS5jb3VudHM7XG4gIHJldHVybiB1Lm1hcChmdW5jdGlvbihrKSB7IHJldHVybiB7dmFsdWU6IGssIGNvdW50OiBjW2tdfTsgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3Ioc29ydCA/ICctY291bnQnIDogJyt2YWx1ZScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICRiaW46ICRiaW4sXG4gIGhpc3RvZ3JhbTogaGlzdG9ncmFtXG59OyIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG5mdW5jdGlvbiBkc3YoZGF0YSwgZm9ybWF0KSB7XG4gIGlmIChkYXRhKSB7XG4gICAgdmFyIGggPSBmb3JtYXQuaGVhZGVyO1xuICAgIGRhdGEgPSAoaCA/IGguam9pbihmb3JtYXQuZGVsaW1pdGVyKSArICdcXG4nIDogJycpICsgZGF0YTtcbiAgfVxuICByZXR1cm4gZDMuZHN2KGZvcm1hdC5kZWxpbWl0ZXIpLnBhcnNlKGRhdGEpO1xufVxuXG5kc3YuZGVsaW1pdGVyID0gZnVuY3Rpb24oZGVsaW0pIHtcbiAgdmFyIGZtdCA9IHtkZWxpbWl0ZXI6IGRlbGltfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICAgIHJldHVybiBkc3YoZGF0YSwgZm9ybWF0ID8gdXRpbC5leHRlbmQoZm9ybWF0LCBmbXQpIDogZm10KTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZHN2OyIsInZhciBkc3YgPSByZXF1aXJlKCcuL2RzdicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganNvbjogcmVxdWlyZSgnLi9qc29uJyksXG4gIHRvcG9qc29uOiByZXF1aXJlKCcuL3RvcG9qc29uJyksXG4gIHRyZWVqc29uOiByZXF1aXJlKCcuL3RyZWVqc29uJyksXG4gIGRzdjogZHN2LFxuICBjc3Y6IGRzdi5kZWxpbWl0ZXIoJywnKSxcbiAgdHN2OiBkc3YuZGVsaW1pdGVyKCdcXHQnKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSB1dGlsLmlzT2JqZWN0KGRhdGEpICYmICF1dGlsLmlzQnVmZmVyKGRhdGEpID9cbiAgICBkYXRhIDogSlNPTi5wYXJzZShkYXRhKTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucHJvcGVydHkpIHtcbiAgICBkID0gdXRpbC5hY2Nlc3Nvcihmb3JtYXQucHJvcGVydHkpKGQpO1xuICB9XG4gIHJldHVybiBkO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG52YXIgdG9wb2pzb24gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy50b3BvanNvbiA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudG9wb2pzb24gOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKHRvcG9qc29uID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ1RvcG9KU09OIGxpYnJhcnkgbm90IGxvYWRlZC4nKTsgfVxuXG4gIHZhciB0ID0ganNvbihkYXRhLCBmb3JtYXQpLCBvYmo7XG5cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuZmVhdHVyZSkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5mZWF0dXJlXSkpIHtcbiAgICAgIHJldHVybiB0b3BvanNvbi5mZWF0dXJlKHQsIG9iaikuZmVhdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJytmb3JtYXQuZmVhdHVyZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCAmJiBmb3JtYXQubWVzaCkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSkpIHtcbiAgICAgIHJldHVybiBbdG9wb2pzb24ubWVzaCh0LCB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIGZvcm1hdC5tZXNoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ01pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn07XG4iLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdG9UYWJsZShkYXRhLCAoZm9ybWF0ICYmIGZvcm1hdC5jaGlsZHJlbikpO1xufTtcblxuZnVuY3Rpb24gdG9UYWJsZShyb290LCBjaGlsZHJlbkZpZWxkKSB7XG4gIGNoaWxkcmVuRmllbGQgPSBjaGlsZHJlbkZpZWxkIHx8ICdjaGlsZHJlbic7XG4gIHZhciB0YWJsZSA9IFtdO1xuICBcbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB2aXNpdChyb290LCBudWxsKTtcbiAgcmV0dXJuICh0YWJsZS5yb290ID0gcm9vdCwgdGFibGUpO1xufSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGFic29sdXRlIFVSTHMgd2l0aCBvcHRpb25hbCBwcm90b2NvbFxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG52YXIgcHJvdG9jb2xfcmUgPSAvXihbQS1aYS16XSs6KT9cXC9cXC8vO1xuXG4vLyBTcGVjaWFsIHRyZWF0bWVudCBpbiBub2RlLmpzIGZvciB0aGUgZmlsZTogcHJvdG9jb2xcbnZhciBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG5cbi8vIFZhbGlkYXRlIGFuZCBjbGVhbnVwIFVSTCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGJlIGFjY2Vzc2VkXG4vLyBSZXR1cm5zIGNsZWFuZWQgdXAgVVJMLCBvciBmYWxzZSBpZiBhY2Nlc3MgaXMgbm90IGFsbG93ZWRcbmZ1bmN0aW9uIHNhbml0aXplVXJsKG9wdCkge1xuICB2YXIgdXJsID0gb3B0LnVybDtcbiAgaWYgKCF1cmwgJiYgb3B0LmZpbGUpIHsgcmV0dXJuIGZpbGVQcm90b2NvbCArIG9wdC5maWxlOyB9XG5cbiAgLy8gSW4gY2FzZSB0aGlzIGlzIGEgcmVsYXRpdmUgdXJsIChoYXMgbm8gaG9zdCksIHByZXBlbmQgb3B0LmJhc2VVUkxcbiAgaWYgKG9wdC5iYXNlVVJMICYmICFwcm90b2NvbF9yZS50ZXN0KHVybCkpIHtcbiAgICBpZiAoIXV0aWwuc3RhcnRzV2l0aCh1cmwsICcvJykgJiYgb3B0LmJhc2VVUkxbb3B0LmJhc2VVUkwubGVuZ3RoLTFdICE9PSAnLycpIHtcbiAgICAgIHVybCA9ICcvJyArIHVybDsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgfVxuICAgIHVybCA9IG9wdC5iYXNlVVJMICsgdXJsO1xuICB9XG4gIC8vIHJlbGF0aXZlIHByb3RvY29sLCBzdGFydHMgd2l0aCAnLy8nXG4gIGlmICh1dGlsLmlzTm9kZSAmJiB1dGlsLnN0YXJ0c1dpdGgodXJsLCAnLy8nKSkge1xuICAgIHVybCA9IChvcHQuZGVmYXVsdFByb3RvY29sIHx8ICdodHRwJykgKyAnOicgKyB1cmw7XG4gIH1cbiAgLy8gSWYgb3B0LmRvbWFpbldoaXRlTGlzdCBpcyBzZXQsIG9ubHkgYWxsb3dzIHVybCwgd2hvc2UgaG9zdG5hbWVcbiAgLy8gKiBJcyB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpXG4gIC8vICogRXF1YWxzIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgLy8gKiBJcyBhIHByb3BlciBzdWJkb21haW4gb2Ygb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICBpZiAob3B0LmRvbWFpbldoaXRlTGlzdCkge1xuICAgIHZhciBkb21haW4sIG9yaWdpbjtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgIC8vIHJlbGF0aXZlIHByb3RvY29sIGlzIGJyb2tlbjogaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS11cmwvaXNzdWVzLzVcbiAgICAgIHZhciBwYXJ0cyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHVybCk7XG4gICAgICBkb21haW4gPSBwYXJ0cy5ob3N0bmFtZTtcbiAgICAgIG9yaWdpbiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNjUxMy9ob3ctZG8taS1wYXJzZS1hLXVybC1pbnRvLWhvc3RuYW1lLWFuZC1wYXRoLWluLWphdmFzY3JpcHRcbiAgICAgIC8vIElFIGRvZXNuJ3QgcG9wdWxhdGUgYWxsIGxpbmsgcHJvcGVydGllcyB3aGVuIHNldHRpbmcgLmhyZWYgd2l0aCBhIHJlbGF0aXZlIFVSTCxcbiAgICAgIC8vIGhvd2V2ZXIgLmhyZWYgd2lsbCByZXR1cm4gYW4gYWJzb2x1dGUgVVJMIHdoaWNoIHRoZW4gY2FuIGJlIHVzZWQgb24gaXRzZWxmXG4gICAgICAvLyB0byBwb3B1bGF0ZSB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkcy5cbiAgICAgIGlmIChhLmhvc3QgPT09ICcnKSB7XG4gICAgICAgIGEuaHJlZiA9IGEuaHJlZjtcbiAgICAgIH1cbiAgICAgIGRvbWFpbiA9IGEuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3JpZ2luICE9PSBkb21haW4pIHtcbiAgICAgIHZhciB3aGl0ZUxpc3RlZCA9IG9wdC5kb21haW5XaGl0ZUxpc3Quc29tZShmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpZHggPSBkb21haW4ubGVuZ3RoIC0gZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkID09PSBkb21haW4gfHxcbiAgICAgICAgICAoaWR4ID4gMSAmJiBkb21haW5baWR4LTFdID09PSAnLicgJiYgZG9tYWluLmxhc3RJbmRleE9mKGQpID09PSBpZHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXdoaXRlTGlzdGVkKSB7XG4gICAgICAgIHRocm93ICdVUkwgaXMgbm90IHdoaXRlbGlzdGVkOiAnICsgdXJsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBsb2FkKG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZSkgeyB0aHJvdyBlOyB9LCB1cmw7XG5cbiAgdHJ5IHtcbiAgICB1cmwgPSBsb2FkLnNhbml0aXplVXJsKG9wdCk7IC8vIGVuYWJsZSBvdmVycmlkZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcihlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgVVJMOiAnICsgdXJsKTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUpIHtcbiAgICAvLyBpbiBicm93c2VyLCB1c2UgeGhyXG4gICAgcmV0dXJuIHhocih1cmwsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh1dGlsLnN0YXJ0c1dpdGgodXJsLCBmaWxlUHJvdG9jb2wpKSB7XG4gICAgLy8gaW4gbm9kZS5qcywgaWYgdXJsIHN0YXJ0cyB3aXRoICdmaWxlOi8vJywgc3RyaXAgaXQgYW5kIGxvYWQgZnJvbSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLnNsaWNlKGZpbGVQcm90b2NvbC5sZW5ndGgpLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodXJsLmluZGV4T2YoJzovLycpIDwgMCkgeyAvLyBUT0RPIGJldHRlciBwcm90b2NvbCBjaGVjaz9cbiAgICAvLyBpZiBub2RlLmpzLCBpZiBubyBwcm90b2NvbCBhc3N1bWUgZmlsZVxuICAgIHJldHVybiBmaWxlKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgaW4gbm9kZS5qc1xuICAgIHJldHVybiBodHRwKHVybCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gJ3RleHQnID9cbiAgICByZXF1ZXN0LnJlc3BvbnNlIDogLy8gbnVsbCBvbiBlcnJvclxuICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0OyAvLyAnJyBvbiBlcnJvclxufVxuXG5mdW5jdGlvbiB4aHIodXJsLCBjYWxsYmFjaykge1xuICB2YXIgYXN5bmMgPSAhIWNhbGxiYWNrO1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAvLyBJZiBJRSBkb2VzIG5vdCBzdXBwb3J0IENPUlMsIHVzZSBYRG9tYWluUmVxdWVzdCAoY29waWVkIGZyb20gZDMueGhyKVxuICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdCAmJlxuICAgICAgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgL14oaHR0cChzKT86KT9cXC9cXC8vLnRlc3QodXJsKSkgcmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzO1xuICAgIGlmICghc3RhdHVzICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlcXVlc3QsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3luYykge1xuICAgIGlmICgnb25sb2FkJyBpbiByZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPiAzKSByZXNwb25kKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcbiAgcmVxdWVzdC5zZW5kKCk7XG4gIFxuICBpZiAoIWFzeW5jICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpO1xuICB9XG4gIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3luYy1yZXF1ZXN0JykoJ0dFVCcsIHVybCkuZ2V0Qm9keSgpO1xuICB9XG4gIHJlcXVpcmUoJ3JlcXVlc3QnKSh1cmwsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmxvYWQuc2FuaXRpemVVcmwgPSBzYW5pdGl6ZVVybDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxuZnVuY3Rpb24gcmVhZChkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIHR5cGUgPSAoZm9ybWF0ICYmIGZvcm1hdC50eXBlKSB8fCAnanNvbic7XG4gIGRhdGEgPSBmb3JtYXRzW3R5cGVdKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnBhcnNlKSBwYXJzZShkYXRhLCBmb3JtYXQucGFyc2UpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMpIHtcbiAgdmFyIGNvbHMsIHBhcnNlcnMsIGQsIGksIGosIGNsZW4sIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gIHR5cGVzID0gKHR5cGVzPT09J2F1dG8nKSA/IHR5cGUuaW5mZXJBbGwoZGF0YSkgOiB1dGlsLmR1cGxpY2F0ZSh0eXBlcyk7XG4gIGNvbHMgPSB1dGlsLmtleXModHlwZXMpO1xuICBwYXJzZXJzID0gY29scy5tYXAoZnVuY3Rpb24oYykgeyByZXR1cm4gdHlwZS5wYXJzZXJzW3R5cGVzW2NdXTsgfSk7XG5cbiAgZm9yIChpPTAsIGNsZW49Y29scy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBmb3IgKGo9MDsgajxjbGVuOyArK2opIHtcbiAgICAgIGRbY29sc1tqXV0gPSBwYXJzZXJzW2pdKGRbY29sc1tqXV0pO1xuICAgIH1cbiAgfVxuICB0eXBlLmFubm90YXRpb24oZGF0YSwgdHlwZXMpO1xufVxuXG5yZWFkLmZvcm1hdHMgPSBmb3JtYXRzO1xubW9kdWxlLmV4cG9ydHMgPSByZWFkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgbG9hZCA9IHJlcXVpcmUoJy4vbG9hZCcpO1xudmFyIHJlYWQgPSByZXF1aXJlKCcuL3JlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsXG4gIC5rZXlzKHJlYWQuZm9ybWF0cylcbiAgLnJlZHVjZShmdW5jdGlvbihvdXQsIHR5cGUpIHtcbiAgICBvdXRbdHlwZV0gPSBmdW5jdGlvbihvcHQsIGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIHByb2Nlc3MgYXJndW1lbnRzXG4gICAgICBpZiAodXRpbC5pc1N0cmluZyhvcHQpKSB7IG9wdCA9IHt1cmw6IG9wdH07IH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHV0aWwuaXNGdW5jdGlvbihmb3JtYXQpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB1cCByZWFkIGZvcm1hdFxuICAgICAgZm9ybWF0ID0gdXRpbC5leHRlbmQoe3BhcnNlOiAnYXV0byd9LCBmb3JtYXQpO1xuICAgICAgZm9ybWF0LnR5cGUgPSB0eXBlO1xuXG4gICAgICAvLyBsb2FkIGRhdGFcbiAgICAgIHZhciBkYXRhID0gbG9hZChvcHQsIGNhbGxiYWNrID8gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoYXN5bmMpXG4gICAgICAgICAgZGF0YSA9IHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIC8vIGRhdGEgbG9hZGVkLCBub3cgcGFyc2UgaXQgKHN5bmMpXG4gICAgICBpZiAoZGF0YSkgcmV0dXJuIHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBvdXQ7XG4gIH0sIHt9KTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgVFlQRVMgPSAnX190eXBlc19fJztcblxudmFyIFBBUlNFUlMgPSB7XG4gIGJvb2xlYW46IHV0aWwuYm9vbGVhbixcbiAgaW50ZWdlcjogdXRpbC5udW1iZXIsXG4gIG51bWJlcjogIHV0aWwubnVtYmVyLFxuICBkYXRlOiAgICB1dGlsLmRhdGUsXG4gIHN0cmluZzogIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0nJyA/IG51bGwgOiB4OyB9XG59O1xuXG52YXIgVEVTVFMgPSB7XG4gIGJvb2xlYW46IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0ndHJ1ZScgfHwgeD09PSdmYWxzZScgfHwgdXRpbC5pc0Jvb2xlYW4oeCk7IH0sXG4gIGludGVnZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFRFU1RTLm51bWJlcih4KSAmJiAoeD0reCkgPT09IH5+eDsgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oK3gpICYmICF1dGlsLmlzRGF0ZSh4KTsgfSxcbiAgZGF0ZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKERhdGUucGFyc2UoeCkpOyB9XG59O1xuXG5mdW5jdGlvbiBhbm5vdGF0aW9uKGRhdGEsIHR5cGVzKSB7XG4gIGlmICghdHlwZXMpIHJldHVybiBkYXRhICYmIGRhdGFbVFlQRVNdIHx8IG51bGw7XG4gIGRhdGFbVFlQRVNdID0gdHlwZXM7XG59XG5cbmZ1bmN0aW9uIHR5cGUodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuO1xuXG4gIC8vIGlmIGRhdGEgYXJyYXkgaGFzIHR5cGUgYW5ub3RhdGlvbnMsIHVzZSB0aGVtXG4gIGlmICh2YWx1ZXNbVFlQRVNdKSB7XG4gICAgdiA9IGYodmFsdWVzW1RZUEVTXSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgIXV0aWwuaXNWYWxpZCh2KSAmJiBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDpcbiAgICB1dGlsLmlzTnVtYmVyKHYpICAgID8gJ251bWJlcicgOlxuICAgIHV0aWwuaXNCb29sZWFuKHYpICAgPyAnYm9vbGVhbicgOlxuICAgIHV0aWwuaXNTdHJpbmcodikgICAgPyAnc3RyaW5nJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICByZXR1cm4gKHR5cGVzW2ZdID0gdHlwZShkYXRhLCBmKSwgdHlwZXMpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgaiwgdjtcblxuICAvLyB0eXBlcyB0byB0ZXN0IGZvciwgaW4gcHJlY2VkZW5jZSBvcmRlclxuICB2YXIgdHlwZXMgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGdldCBuZXh0IHZhbHVlIHRvIHRlc3RcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICAvLyB0ZXN0IHZhbHVlIGFnYWluc3QgcmVtYWluaW5nIHR5cGVzXG4gICAgZm9yIChqPTA7IGo8dHlwZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh1dGlsLmlzVmFsaWQodikgJiYgIVRFU1RTW3R5cGVzW2pdXSh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzWzBdO1xufVxuXG5mdW5jdGlvbiBpbmZlckFsbChkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB2YXIgdHlwZSA9IGluZmVyKGRhdGEsIGYpO1xuICAgIGlmIChQQVJTRVJTW3R5cGVdKSB0eXBlc1tmXSA9IHR5cGU7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9LCB7fSk7XG59XG5cbnR5cGUuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG50eXBlLmFsbCA9IHR5cGVBbGw7XG50eXBlLmluZmVyID0gaW5mZXI7XG50eXBlLmluZmVyQWxsID0gaW5mZXJBbGw7XG50eXBlLnBhcnNlcnMgPSBQQVJTRVJTO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBkbCA9IHtcbiAgbG9hZDogICAgICByZXF1aXJlKCcuL2ltcG9ydC9sb2FkJyksXG4gIHJlYWQ6ICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZCcpLFxuICB0eXBlOiAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKSxcbiAgYmluczogICAgICByZXF1aXJlKCcuL2JpbnMvYmlucycpLFxuICAkYmluOiAgICAgIHJlcXVpcmUoJy4vYmlucy9oaXN0b2dyYW0nKS4kYmluLFxuICBncm91cGJ5OiAgIHJlcXVpcmUoJy4vYWdncmVnYXRlL2dyb3VwYnknKSxcbiAgaGlzdG9ncmFtOiByZXF1aXJlKCcuL2JpbnMvaGlzdG9ncmFtJykuaGlzdG9ncmFtLFxuICBwcmludDogICAgIHJlcXVpcmUoJy4vcHJpbnQnKSxcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL3RlbXBsYXRlJyksXG4gIHRpbWV1bml0czogcmVxdWlyZSgnLi90aW1lLXVuaXRzJylcbn07XG5cbnV0aWwuZXh0ZW5kKGRsLCB1dGlsKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2dlbmVyYXRlJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vc3RhdHMnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZGVycycpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkbDsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbnZhciBGTVQgPSB7XG4gICdkYXRlJzogICAgJ3x0aW1lOlwiJW0vJWQvJVkgJUg6JU06JVNcIicsXG4gICdudW1iZXInOiAgJ3xudW1iZXI6XCIuNGZcIicsXG4gICdpbnRlZ2VyJzogJ3xudW1iZXI6XCJkXCInXG59O1xuXG52YXIgUE9TID0ge1xuICAnbnVtYmVyJzogICdsZWZ0JyxcbiAgJ2ludGVnZXInOiAnbGVmdCdcbn07XG5cbm1vZHVsZS5leHBvcnRzLnRhYmxlID0gZnVuY3Rpb24oZGF0YSwgb3B0KSB7XG4gIG9wdCA9IHV0aWwuZXh0ZW5kKHtzZXBhcmF0b3I6JyAnLCBtaW53aWR0aDogOCwgbWF4d2lkdGg6IDE1fSwgb3B0KTtcbiAgdmFyIGZpZWxkcyA9IG9wdC5maWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pLFxuICAgICAgdHlwZXMgPSB0eXBlLmFsbChkYXRhKTtcblxuICBpZiAob3B0LnN0YXJ0IHx8IG9wdC5saW1pdCkge1xuICAgIHZhciBhID0gb3B0LnN0YXJ0IHx8IDAsXG4gICAgICAgIGIgPSBvcHQubGltaXQgPyBhICsgb3B0LmxpbWl0IDogZGF0YS5sZW5ndGg7XG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoYSwgYik7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgY2hhciB3aWR0aCBvZiBmaWVsZHNcbiAgdmFyIGxlbnMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gRk1UW3R5cGVzW25hbWVdXSB8fCAnJyxcbiAgICAgICAgdCA9IHRlbXBsYXRlKCd7eycgKyBuYW1lICsgZm9ybWF0ICsgJ319JyksXG4gICAgICAgIGwgPSBzdGF0cy5tYXgoZGF0YSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gdCh4KS5sZW5ndGg7IH0pO1xuICAgIGwgPSBNYXRoLm1heChNYXRoLm1pbihuYW1lLmxlbmd0aCwgb3B0Lm1pbndpZHRoKSwgbCk7XG4gICAgcmV0dXJuIG9wdC5tYXh3aWR0aCA+IDAgPyBNYXRoLm1pbihsLCBvcHQubWF4d2lkdGgpIDogbDtcbiAgfSk7XG5cbiAgLy8gcHJpbnQgaGVhZGVyIHJvd1xuICB2YXIgaGVhZCA9IGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiB1dGlsLnRydW5jYXRlKHV0aWwucGFkKG5hbWUsIGxlbnNbaV0sICdjZW50ZXInKSwgbGVuc1tpXSk7XG4gIH0pLmpvaW4ob3B0LnNlcGFyYXRvcik7XG5cbiAgLy8gYnVpbGQgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIGVhY2ggcm93XG4gIHZhciB0bXBsID0gdGVtcGxhdGUoZmllbGRzLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuICd7eycgK1xuICAgICAgbmFtZSArXG4gICAgICAoRk1UW3R5cGVzW25hbWVdXSB8fCAnJykgK1xuICAgICAgKCd8cGFkOicgKyBsZW5zW2ldICsgJywnICsgUE9TW3R5cGVzW25hbWVdXSB8fCAncmlnaHQnKSArXG4gICAgICAoJ3x0cnVuY2F0ZTonICsgbGVuc1tpXSkgK1xuICAgICd9fSc7XG4gIH0pLmpvaW4ob3B0LnNlcGFyYXRvcikpO1xuXG4gIC8vIHByaW50IHRhYmxlXG4gIHJldHVybiBoZWFkICsgXCJcXG5cIiArIGRhdGEubWFwKHRtcGwpLmpvaW4oJ1xcbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3VtbWFyeSA9IGZ1bmN0aW9uKHMpIHtcbiAgcyA9IHMgPyBzLl9fc3VtbWFyeV9fID8gcyA6IHN0YXRzLnN1bW1hcnkocykgOiB0aGlzO1xuICB2YXIgc3RyID0gW10sIGksIG47XG4gIGZvciAoaT0wLCBuPXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ci5wdXNoKCctLSAnICsgc1tpXS5maWVsZCArICcgLS0nKTtcbiAgICBpZiAoc1tpXS50eXBlID09PSAnc3RyaW5nJyB8fCBzW2ldLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHNbaV0pKTtcbiAgICB9XG4gICAgc3RyLnB1c2goJycpO1xuICB9XG4gIHJldHVybiBzdHIuam9pbignXFxuJyk7XG59O1xuXG5mdW5jdGlvbiBwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUocCkge1xuICByZXR1cm4gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ21pbjogICAgICAnICsgcC5taW4sXG4gICAgJ21heDogICAgICAnICsgcC5tYXgsXG4gICAgJ21lZGlhbjogICAnICsgcC5tZWRpYW4sXG4gICAgJ21lYW46ICAgICAnICsgcC5tZWFuLFxuICAgICdzdGRldjogICAgJyArIHAuc3RkZXYsXG4gICAgJ21vZGVza2V3OiAnICsgcC5tb2Rlc2tld1xuICBdLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludENhdGVnb3JpY2FsUHJvZmlsZShwKSB7XG4gIHZhciBsaXN0ID0gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ3RvcCB2YWx1ZXM6ICdcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiAnIFxcJycgKyB2ICsgJ1xcJyAoJyArIHVbdl0gKyAnKSc7IH0pO1xuICByZXR1cm4gbGlzdC5jb25jYXQodG9wKS5qb2luKCdcXG4nKTtcbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xudmFyIHN0YXRzID0ge307XG5cbi8vIENvbGxlY3QgdW5pcXVlIHZhbHVlcyBhbmQgYXNzb2NpYXRlZCBjb3VudHMuXG4vLyBPdXRwdXQ6IGFuIGFycmF5IG9mIHVuaXF1ZSB2YWx1ZXMsIGluIG9ic2VydmVkIG9yZGVyXG4vLyBUaGUgYXJyYXkgaW5jbHVkZXMgYW4gYWRkaXRpb25hbCAnY291bnRzJyBwcm9wZXJ0eSxcbi8vIHdoaWNoIGlzIGEgaGFzaCBmcm9tIHVuaXF1ZSB2YWx1ZXMgdG8gb2NjdXJyZW5jZSBjb3VudHMuXG5zdGF0cy51bmlxdWUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHJlc3VsdHMpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkge1xuICAgICAgdVt2XSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB1W3ZdID0gMTtcbiAgICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0cy5jb3VudHMgPSB1O1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBhcnJheS5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCB8fCAwO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBub24tbnVsbCwgbm9uLXVuZGVmaW5lZCwgbm9uLU5hTiB2YWx1ZXMuXG5zdGF0cy5jb3VudC52YWxpZCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgdmFsaWQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHZhbGlkICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5taXNzaW5nID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgPT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbi8vIE51bGwsIHVuZGVmaW5lZCBhbmQgTmFOIGFyZSBlYWNoIGNvbnNpZGVyZWQgZGlzdGluY3QgdmFsdWVzLlxuc3RhdHMuY291bnQuZGlzdGluY3QgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVkaWFuIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICByZXR1cm4gc3RhdHMucXVhbnRpbGUodmFsdWVzLCAwLjUpO1xufTtcblxuLy8gQ29tcHV0ZXMgdGhlIHF1YXJ0aWxlIGJvdW5kYXJpZXMgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnF1YXJ0aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgdmFyIHEgPSBzdGF0cy5xdWFudGlsZTtcbiAgcmV0dXJuIFtxKHZhbHVlcywgMC4yNSksIHEodmFsdWVzLCAwLjUwKSwgcSh2YWx1ZXMsIDAuNzUpXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHF1YW50aWxlIG9mIGEgc29ydGVkIGFycmF5IG9mIG51bWJlcnMuXG4vLyBBZGFwdGVkIGZyb20gdGhlIEQzLmpzIGltcGxlbWVudGF0aW9uLlxuc3RhdHMucXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYsIHApIHtcbiAgaWYgKHAgPT09IHVuZGVmaW5lZCkgeyBwID0gZjsgZiA9IHV0aWwuaWRlbnRpdHk7IH1cbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIEggPSAodmFsdWVzLmxlbmd0aCAtIDEpICogcCArIDEsXG4gICAgICBoID0gTWF0aC5mbG9vcihIKSxcbiAgICAgIHYgPSArZih2YWx1ZXNbaCAtIDFdKSxcbiAgICAgIGUgPSBIIC0gaDtcbiAgcmV0dXJuIGUgPyB2ICsgZSAqIChmKHZhbHVlc1toXSkgLSB2KSA6IHY7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzdW0gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN1bSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBmb3IgKHZhciBzdW09MCwgaT0wLCBuPXZhbHVlcy5sZW5ndGgsIHY7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgc3VtICs9IHY7XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lYW4gKGF2ZXJhZ2UpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tZWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtZWFuID0gMCwgZGVsdGEsIGksIG4sIGMsIHY7XG4gIGZvciAoaT0wLCBjPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVhbjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSB2YXJpYW5jZSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMudmFyaWFuY2UgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIHZhciBtZWFuID0gMCwgTTIgPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHYgLSBtZWFuKTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvIChjIC0gMSk7XG4gIHJldHVybiBNMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UodmFsdWVzLCBmKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBQZWFyc29uIG1vZGUgc2tld25lc3MgKChtZWRpYW4tbWVhbikvc3RkZXYpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tb2Rlc2tldyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYXZnID0gc3RhdHMubWVhbih2YWx1ZXMsIGYpLFxuICAgICAgbWVkID0gc3RhdHMubWVkaWFuKHZhbHVlcywgZiksXG4gICAgICBzdGQgPSBzdGF0cy5zdGRldih2YWx1ZXMsIGYpO1xuICByZXR1cm4gc3RkID09PSAwID8gMCA6IChhdmcgLSBtZWQpIC8gc3RkO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1pbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMF07XG59O1xuXG4vLyBGaW5kIHRoZSBtYXhpbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWF4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVsxXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gb2YgYW4gYXJyYXkgb2YgdmFsdWVzLlxuc3RhdHMuZXh0ZW50ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IGJyZWFrOyB9XG4gIH1cbiAgZm9yICg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaWYgKHYgPCBhKSBhID0gdjtcbiAgICAgIGlmICh2ID4gYikgYiA9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBbYSwgYl07XG59O1xuXG4vLyBGaW5kIHRoZSBpbnRlZ2VyIGluZGljZXMgb2YgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLlxuc3RhdHMuZXh0ZW50LmluZGV4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBhLCBiLCB4LCB5LCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgYXNjZW5kaW5nIHJhbmsgc2NvcmVzIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4vLyBUaWVzIGFyZSBhc3NpZ25lZCB0aGVpciBjb2xsZWN0aXZlIG1lYW4gcmFuay5cbnN0YXRzLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKSB8fCB1dGlsLmlkZW50aXR5O1xuICB2YXIgYSA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgcmV0dXJuIHtpZHg6IGksIHZhbDogZih2KX07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoJ3ZhbCcpKTtcblxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByID0gQXJyYXkobiksXG4gICAgICB0aWUgPSAtMSwgcCA9IHt9LCBpLCB2LCBtdTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gYVtpXS52YWw7XG4gICAgaWYgKHRpZSA8IDAgJiYgcCA9PT0gdikge1xuICAgICAgdGllID0gaSAtIDE7XG4gICAgfSBlbHNlIGlmICh0aWUgPiAtMSAmJiBwICE9PSB2KSB7XG4gICAgICBtdSA9IDEgKyAoaS0xICsgdGllKSAvIDI7XG4gICAgICBmb3IgKDsgdGllPGk7ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gICAgICB0aWUgPSAtMTtcbiAgICB9XG4gICAgclthW2ldLmlkeF0gPSBpICsgMTtcbiAgICBwID0gdjtcbiAgfVxuXG4gIGlmICh0aWUgPiAtMSkge1xuICAgIG11ID0gMSArIChuLTEgKyB0aWUpIC8gMjtcbiAgICBmb3IgKDsgdGllPG47ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBQZWFyc29uIHByb2R1Y3QtbW9tZW50IGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvciA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgZm4gPSBiO1xuICBiID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuICBhID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXM7XG5cbiAgdmFyIGRvdCA9IHN0YXRzLmRvdChhLCBiKSxcbiAgICAgIG11YSA9IHN0YXRzLm1lYW4oYSksXG4gICAgICBtdWIgPSBzdGF0cy5tZWFuKGIpLFxuICAgICAgc2RhID0gc3RhdHMuc3RkZXYoYSksXG4gICAgICBzZGIgPSBzdGF0cy5zdGRldihiKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHJldHVybiAoZG90IC0gbiptdWEqbXViKSAvICgobi0xKSAqIHNkYSAqIHNkYik7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTcGVhcm1hbiByYW5rIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgdmFsdWVzLlxuc3RhdHMuY29yLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHJhID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYSkpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChiKSkgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuXG4gIHZhciBBID0gc3RhdHMuZGlzdC5tYXQoWCksXG4gICAgICBCID0gc3RhdHMuZGlzdC5tYXQoWSksXG4gICAgICBuID0gQS5sZW5ndGgsXG4gICAgICBpLCBhYSwgYmIsIGFiO1xuXG4gIGZvciAoaT0wLCBhYT0wLCBiYj0wLCBhYj0wOyBpPG47ICsraSkge1xuICAgIGFhICs9IEFbaV0qQVtpXTtcbiAgICBiYiArPSBCW2ldKkJbaV07XG4gICAgYWIgKz0gQVtpXSpCW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChhYiAvIE1hdGguc3FydChhYSpiYikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgdmVjdG9yIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gRGVmYXVsdCBpcyBFdWNsaWRlYW4gKGV4cD0yKSBkaXN0YW5jZSwgY29uZmlndXJhYmxlIHZpYSBleHAgYXJndW1lbnQuXG5zdGF0cy5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBleHApIHtcbiAgdmFyIGYgPSB1dGlsLmlzRnVuY3Rpb24oYikgfHwgdXRpbC5pc1N0cmluZyhiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBMMiA9IGUgPT09IDIgfHwgZSA9PSBudWxsLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIHMgPSAwLCBkLCBpO1xuICBpZiAoZikge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgfVxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgcyArPSBMMiA/IGQqZCA6IE1hdGgucG93KE1hdGguYWJzKGQpLCBlKTtcbiAgfVxuICByZXR1cm4gTDIgPyBNYXRoLnNxcnQocykgOiBNYXRoLnBvdyhzLCAxL2UpO1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV0gXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIHogPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChjb3VudHMpKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG4gICAgICBweSA9IHt9LFxuICAgICAgbiA9IHoubGVuZ3RoLFxuICAgICAgcyA9IDAsIEkgPSAwLCBIID0gMCwgcCwgdCwgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSA9IDA7XG4gICAgcHlbeVtpXV0gPSAwO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gKz0geltpXTtcbiAgICBweVt5W2ldXSArPSB6W2ldO1xuICAgIHMgKz0geltpXTtcbiAgfVxuXG4gIHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcbiAgICBwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcbiAgICBJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG4gICAgSCArPSB6W2ldICogdCAqIE1hdGgubG9nKHpbaV0vcyk7XG4gIH1cblxuICByZXR1cm4gW0ksIDEgKyBJL0hdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbnN0YXRzLm11dHVhbC5pbmZvID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuc3RhdHMubXV0dWFsLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVsxXTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIG1lYW4gPSAwLFxuICAgICAgdmFsaWQgPSAwLFxuICAgICAgbWlzc2luZyA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIE0yID0gMCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4O1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcblxuICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgdVt2XSA9ICh2IGluIHUpID8gdVt2XSArIDEgOiAoZGlzdGluY3QgKz0gMSwgMSk7XG5cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICArK21pc3Npbmc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgeCA9ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpID8gdi5sZW5ndGggOiB2O1xuICAgICAgaWYgKG1pbj09PW51bGwgfHwgeCA8IG1pbikgbWluID0geDtcbiAgICAgIGlmIChtYXg9PT1udWxsIHx8IHggPiBtYXgpIG1heCA9IHg7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK3ZhbGlkKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAodmFsaWQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogICAgIHR5cGUodmFsdWVzLCBmKSxcbiAgICB1bmlxdWU6ICAgdSxcbiAgICBjb3VudDogICAgdmFsdWVzLmxlbmd0aCxcbiAgICB2YWxpZDogICAgdmFsaWQsXG4gICAgbWlzc2luZzogIG1pc3NpbmcsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgcTE6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLFxuICAgIHEzOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KSxcbiAgICBtb2Rlc2tldzogc2QgPT09IDAgPyAwIDogKG1lYW4gLSB2KSAvIHNkXG4gIH07XG59O1xuXG4vLyBDb21wdXRlIHByb2ZpbGVzIGZvciBhbGwgdmFyaWFibGVzIGluIGEgZGF0YSBzZXQuXG5zdGF0cy5zdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHZhciBzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuJChmKSk7XG4gICAgcmV0dXJuIChwLmZpZWxkID0gZiwgcCk7XG4gIH0pO1xuICByZXR1cm4gKHMuX19zdW1tYXJ5X18gPSB0cnVlLCBzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICB1dGlsLnRydW5jYXRlLFxuICBwYWQ6ICAgICAgICB1dGlsLnBhZFxufTtcblxuZnVuY3Rpb24gdGVtcGxhdGUodGV4dCkge1xuICB2YXIgc3JjID0gc291cmNlKHRleHQsICdkJyk7XG4gIHNyYyA9ICd2YXIgX190OyByZXR1cm4gJyArIHNyYyArICc7JztcblxuICB0cnkge1xuICAgIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ2QnLCBzcmMpKS5iaW5kKGNvbnRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5zb3VyY2UgPSBzcmM7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG4vLyBjbGVhciBjYWNoZSBvZiBmb3JtYXQgb2JqZWN0c1xuLy8gY2FuICpicmVhayogcHJpb3IgdGVtcGxhdGUgZnVuY3Rpb25zLCBzbyBpbnZva2Ugd2l0aCBjYXJlXG50ZW1wbGF0ZS5jbGVhckZvcm1hdENhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnRleHQuZm9ybWF0cyA9IFtdO1xuICBjb250ZXh0LmZvcm1hdF9tYXAgPSB7fTtcbn07XG5cbmZ1bmN0aW9uIHNvdXJjZSh0ZXh0LCB2YXJpYWJsZSkge1xuICB2YXJpYWJsZSA9IHZhcmlhYmxlIHx8ICdvYmonO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc3JjID0gJ1xcJyc7XG4gIHZhciByZWdleCA9IHRlbXBsYXRlX3JlO1xuXG4gIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gIHRleHQucmVwbGFjZShyZWdleCwgZnVuY3Rpb24obWF0Y2gsIGludGVycG9sYXRlLCBvZmZzZXQpIHtcbiAgICBzcmMgKz0gdGV4dFxuICAgICAgLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAucmVwbGFjZSh0ZW1wbGF0ZV9lc2NhcGVyLCB0ZW1wbGF0ZV9lc2NhcGVDaGFyKTtcbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgc3JjICs9ICdcXCdcXG4rKChfX3Q9KCcgK1xuICAgICAgICB0ZW1wbGF0ZV92YXIoaW50ZXJwb2xhdGUsIHZhcmlhYmxlKSArXG4gICAgICAgICcpKT09bnVsbD9cXCdcXCc6X190KStcXG5cXCcnO1xuICAgIH1cblxuICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gc3JjICsgJ1xcJyc7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX3Zhcih0ZXh0LCB2YXJpYWJsZSkge1xuICB2YXIgZmlsdGVycyA9IHRleHQuc3BsaXQoJ3wnKTtcbiAgdmFyIHByb3AgPSBmaWx0ZXJzLnNoaWZ0KCkudHJpbSgpO1xuICB2YXIgc3RyaW5nQ2FzdCA9IHRydWU7XG4gIFxuICBmdW5jdGlvbiBzdHJjYWxsKGZuKSB7XG4gICAgZm4gPSBmbiB8fCAnJztcbiAgICBpZiAoc3RyaW5nQ2FzdCkge1xuICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgc3JjID0gJ1N0cmluZygnICsgc3JjICsgJyknICsgZm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyArPSBmbjtcbiAgICB9XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICBcbiAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gJyh0eXBlb2YgJyArIHNyYyArICc9PT1cIm51bWJlclwiP25ldyBEYXRlKCcrc3JjKycpOicrc3JjKycpJztcbiAgfVxuICBcbiAgdmFyIHNyYyA9IHV0aWwuZmllbGQocHJvcCkubWFwKHV0aWwuc3RyKS5qb2luKCddWycpO1xuICBzcmMgPSB2YXJpYWJsZSArICdbJyArIHNyYyArICddJztcbiAgXG4gIGZvciAodmFyIGk9MDsgaTxmaWx0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGYgPSBmaWx0ZXJzW2ldLCBhcmdzID0gbnVsbCwgcGlkeCwgYSwgYjtcblxuICAgIGlmICgocGlkeD1mLmluZGV4T2YoJzonKSkgPiAwKSB7XG4gICAgICBmID0gZi5zbGljZSgwLCBwaWR4KTtcbiAgICAgIGFyZ3MgPSBmaWx0ZXJzW2ldLnNsaWNlKHBpZHgrMSkuc3BsaXQoJywnKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9KTtcbiAgICB9XG4gICAgZiA9IGYudHJpbSgpO1xuXG4gICAgc3dpdGNoIChmKSB7XG4gICAgICBjYXNlICdsZW5ndGgnOlxuICAgICAgICBzdHJjYWxsKCcubGVuZ3RoJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbG93ZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb3dlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VwcGVyJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlci1sb2NhbGUnOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb2NhbGVMb3dlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VwcGVyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZVVwcGVyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJpbSc6XG4gICAgICAgIHN0cmNhbGwoJy50cmltKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoMCwnICsgYSArICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgtJyArIGEgKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYSArIHV0aWwubnVtYmVyKGFyZ3NbMV0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoKycrYSsnLCcrYisnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NsaWNlJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoJysgYSArXG4gICAgICAgICAgKGFyZ3MubGVuZ3RoID4gMSA/ICcsJyArIHV0aWwubnVtYmVyKGFyZ3NbMV0pIDogJycpICtcbiAgICAgICAgICAnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYXJnc1sxXTtcbiAgICAgICAgYiA9IChiIT09J2xlZnQnICYmIGIhPT0nbWlkZGxlJyAmJiBiIT09J2NlbnRlcicpID8gJ3JpZ2h0JyA6IGI7XG4gICAgICAgIHNyYyA9ICd0aGlzLnRydW5jYXRlKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcXCcnICsgYiArICdcXCcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT0nbGVmdCcgJiYgYiE9PSdtaWRkbGUnICYmIGIhPT0nY2VudGVyJykgPyAncmlnaHQnIDogYjtcbiAgICAgICAgc3JjID0gJ3RoaXMucGFkKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcXCcnICsgYiArICdcXCcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGQzLmZvcm1hdCk7XG4gICAgICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICAgICAgc3JjID0gJ3RoaXMuZm9ybWF0c1snK2ErJ10oJytzcmMrJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGQzLnRpbWUuZm9ybWF0KTtcbiAgICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK2RhdGUoKSsnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCB0ZW1wbGF0ZSBmaWx0ZXI6ICcgKyBmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuXG52YXIgdGVtcGxhdGVfcmUgPSAvXFx7XFx7KC4rPylcXH1cXH18JC9nO1xuXG4vLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuLy8gc3RyaW5nIGxpdGVyYWwuXG52YXIgdGVtcGxhdGVfZXNjYXBlcyA9IHtcbiAgJ1xcJyc6ICAgICAnXFwnJyxcbiAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAnXFxyJzogICAgICdyJyxcbiAgJ1xcbic6ICAgICAnbicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG52YXIgdGVtcGxhdGVfZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuZnVuY3Rpb24gdGVtcGxhdGVfZXNjYXBlQ2hhcihtYXRjaCkge1xuICByZXR1cm4gJ1xcXFwnICsgdGVtcGxhdGVfZXNjYXBlc1ttYXRjaF07XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2Zvcm1hdChwYXR0ZXJuLCBmbXQpIHtcbiAgaWYgKChwYXR0ZXJuWzBdID09PSAnXFwnJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXFwnJykgfHxcbiAgICAgIChwYXR0ZXJuWzBdID09PSAnXCInICAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXCInKSkge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignRm9ybWF0IHBhdHRlcm4gbXVzdCBiZSBxdW90ZWQ6ICcgKyBwYXR0ZXJuKTtcbiAgfVxuICBpZiAoIWNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSkge1xuICAgIHZhciBmID0gZm10KHBhdHRlcm4pO1xuICAgIHZhciBpID0gY29udGV4dC5mb3JtYXRzLmxlbmd0aDtcbiAgICBjb250ZXh0LmZvcm1hdHMucHVzaChmKTtcbiAgICBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl07XG59XG4iLCJ2YXIgU1RFUFMgPSBbXG4gIFszMTUzNmU2LCA1XSwgIC8vIDEteWVhclxuICBbNzc3NmU2LCA0XSwgICAvLyAzLW1vbnRoXG4gIFsyNTkyZTYsIDRdLCAgIC8vIDEtbW9udGhcbiAgWzEyMDk2ZTUsIDNdLCAgLy8gMi13ZWVrXG4gIFs2MDQ4ZTUsIDNdLCAgIC8vIDEtd2Vla1xuICBbMTcyOGU1LCAzXSwgICAvLyAyLWRheVxuICBbODY0ZTUsIDNdLCAgICAvLyAxLWRheVxuICBbNDMyZTUsIDJdLCAgICAvLyAxMi1ob3VyXG4gIFsyMTZlNSwgMl0sICAgIC8vIDYtaG91clxuICBbMTA4ZTUsIDJdLCAgICAvLyAzLWhvdXJcbiAgWzM2ZTUsIDJdLCAgICAgLy8gMS1ob3VyXG4gIFsxOGU1LCAxXSwgICAgIC8vIDMwLW1pbnV0ZVxuICBbOWU1LCAxXSwgICAgICAvLyAxNS1taW51dGVcbiAgWzNlNSwgMV0sICAgICAgLy8gNS1taW51dGVcbiAgWzZlNCwgMV0sICAgICAgLy8gMS1taW51dGVcbiAgWzNlNCwgMF0sICAgICAgLy8gMzAtc2Vjb25kXG4gIFsxNWUzLCAwXSwgICAgIC8vIDE1LXNlY29uZFxuICBbNWUzLCAwXSwgICAgICAvLyA1LXNlY29uZFxuICBbMWUzLCAwXSAgICAgICAvLyAxLXNlY29uZFxuXTtcblxuZnVuY3Rpb24gaXNOdW1iZXIoZCkgeyByZXR1cm4gdHlwZW9mIGQgPT09ICdudW1iZXInOyB9XG5cbnZhciBlbnRyaWVzID0gW1xuICB7XG4gICAgdHlwZTogJ3NlY29uZCcsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWSAlYiAlLWQgJUg6JU06JVMuJUwnLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogMWUzKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAoK2QgLyAxZTMpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdtaW51dGUnLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kICVIOiVNJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDZlNCk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyA2ZTQpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdob3VyJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogJyVZICViICUtZCAlSDowMCcsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiAzNmU1KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDM2ZTUpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdkYXknLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgc3RlcDogWzEsIDddLFxuICAgIGZvcm1hdDogJyVZICViICUtZCcsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiA4NjRlNSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyA4NjRlNSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ21vbnRoJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIHN0ZXA6IFsxLCAzLCA2XSxcbiAgICBmb3JtYXQ6ICclYiAlWScsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKH5+KGQgLyAxMiksIGQgJSAxMiwgMSkpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKGlzTnVtYmVyKGQpKSBkID0gbmV3IERhdGUoZCk7XG4gICAgICByZXR1cm4gMTIgKiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyBkLmdldFVUQ01vbnRoKCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ3llYXInLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVknLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLCAwLCAxKSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENGdWxsWWVhcigpO1xuICAgIH1cbiAgfVxuXTtcblxudmFyIG1pbnV0ZU9mSG91ciA9IHtcbiAgdHlwZTogJ21pbnV0ZU9mSG91cicsXG4gIG1pbjogMCxcbiAgbWF4OiA1OSxcbiAgbWluc3RlcDogMSxcbiAgZm9ybWF0OiAnJU0nLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ01pbnV0ZXMoKTtcbiAgfVxufTtcblxudmFyIGhvdXJPZkRheSA9IHtcbiAgdHlwZTogJ2hvdXJPZkRheScsXG4gIG1pbjogMCxcbiAgbWF4OiAyMyxcbiAgbWluc3RlcDogMSxcbiAgZm9ybWF0OiAnJUgnLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0hvdXJzKCk7XG4gIH1cbn07XG5cbnZhciBkYXlPZldlZWsgPSB7XG4gIHR5cGU6ICdkYXlPZldlZWsnLFxuICBtaW46IDAsXG4gIG1heDogNixcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6ICclYScsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgNCArIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0RheSgpO1xuICB9XG59O1xuXG52YXIgZGF5T2ZNb250aCA9IHtcbiAgdHlwZTogJ2RheU9mTW9udGgnLFxuICBtaW46IDEsXG4gIG1heDogMzEsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiAnJS1kJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENEYXRlKCk7XG4gIH1cbn07XG5cbnZhciBtb250aE9mWWVhciA9IHtcbiAgdHlwZTogJ21vbnRoT2ZZZWFyJyxcbiAgbWluOiAwLFxuICBtYXg6IDExLFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogJyViJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCBkICUgMTIsIDEpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ01vbnRoKCk7XG4gIH1cbn07XG5cbnZhciB1bml0cyA9IHtcbiAgJ3NlY29uZCc6ICAgICAgIGVudHJpZXNbMF0sXG4gICdtaW51dGUnOiAgICAgICBlbnRyaWVzWzFdLFxuICAnaG91cic6ICAgICAgICAgZW50cmllc1syXSxcbiAgJ2RheSc6ICAgICAgICAgIGVudHJpZXNbM10sXG4gICdtb250aCc6ICAgICAgICBlbnRyaWVzWzRdLFxuICAneWVhcic6ICAgICAgICAgZW50cmllc1s1XSxcbiAgJ21pbnV0ZU9mSG91cic6IG1pbnV0ZU9mSG91cixcbiAgJ2hvdXJPZkRheSc6ICAgIGhvdXJPZkRheSxcbiAgJ2RheU9mV2Vlayc6ICAgIGRheU9mV2VlayxcbiAgJ2RheU9mTW9udGgnOiAgIGRheU9mTW9udGgsXG4gICdtb250aE9mWWVhcic6ICBtb250aE9mWWVhcixcbiAgJ3RpbWVzdGVwcyc6ICAgIGVudHJpZXNcbn07XG5cbnVuaXRzLmZpbmQgPSBmdW5jdGlvbihzcGFuLCBtaW5iLCBtYXhiKSB7XG4gIHZhciBpLCBsZW4sIGJpbnMsIHN0ZXAgPSBTVEVQU1swXTtcblxuICBmb3IgKGkgPSAxLCBsZW4gPSBTVEVQUy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHN0ZXAgPSBTVEVQU1tpXTtcbiAgICBpZiAoc3BhbiA+IHN0ZXBbMF0pIHtcbiAgICAgIGJpbnMgPSBzcGFuIC8gc3RlcFswXTtcbiAgICAgIGlmIChiaW5zID4gbWF4Yikge1xuICAgICAgICByZXR1cm4gZW50cmllc1tTVEVQU1tpIC0gMV1bMV1dO1xuICAgICAgfVxuICAgICAgaWYgKGJpbnMgPj0gbWluYikge1xuICAgICAgICByZXR1cm4gZW50cmllc1tzdGVwWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVudHJpZXNbU1RFUFNbU1RFUFMubGVuZ3RoIC0gMV1bMV1dO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bml0cztcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgdW5pdHMgPSByZXF1aXJlKCcuL3RpbWUtdW5pdHMnKTtcbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gd2hlcmUgYXJlIHdlP1xuXG51LmlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5zdGRlcnIgIT09ICd1bmRlZmluZWQnO1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG52YXIgRk5BTUUgPSAnX19uYW1lX18nO1xuXG51Lm5hbWVkZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIGYpIHsgcmV0dXJuIChmW0ZOQU1FXSA9IG5hbWUsIGYpOyB9O1xuXG51Lm5hbWUgPSBmdW5jdGlvbihmKSB7IHJldHVybiBmPT1udWxsID8gbnVsbCA6IGZbRk5BTUVdOyB9O1xuXG51LmlkZW50aXR5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcblxudS50cnVlID0gdS5uYW1lZGZ1bmMoJ3RydWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0pO1xuXG51LmZhbHNlID0gdS5uYW1lZGZ1bmMoJ2ZhbHNlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XG5cbnUuZHVwbGljYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudS5lcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcbn07XG5cbnUuZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvciAodmFyIHgsIG5hbWUsIGk9MSwgbGVuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAobmFtZSBpbiB4KSB7IG9ialtuYW1lXSA9IHhbbmFtZV07IH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxudS5sZW5ndGggPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgeC5sZW5ndGggIT0gbnVsbCA/IHgubGVuZ3RoIDogMDtcbn07XG5cbnUua2V5cyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGtleXMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIGtleXMucHVzaChrKTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG51LnZhbHMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB2YWxzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSB2YWxzLnB1c2goeFtrXSk7XG4gIHJldHVybiB2YWxzO1xufTtcblxudS50b01hcCA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgcmV0dXJuIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkge1xuICAgIHJldHVybiAob2JqW3hdID0gMSwgb2JqKTtcbiAgfSwge30pO1xufTtcblxudS5rZXlzdHIgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgLy8gdXNlIHRvIGVuc3VyZSBjb25zaXN0ZW50IGtleSBnZW5lcmF0aW9uIGFjcm9zcyBtb2R1bGVzXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgaWYgKCFuKSByZXR1cm4gJyc7XG4gIGZvciAodmFyIHM9U3RyaW5nKHZhbHVlc1swXSksIGk9MTsgaTxuOyArK2kpIHtcbiAgICBzICs9ICd8JyArIFN0cmluZyh2YWx1ZXNbaV0pO1xuICB9XG4gIHJldHVybiBzO1xufTtcblxuLy8gdHlwZSBjaGVja2luZyBmdW5jdGlvbnNcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxudS5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSBPYmplY3Qob2JqKTtcbn07XG5cbnUuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnUuaXNOdW1iZXIgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG51LmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEJvb2xlYW5dJztcbn07XG5cbnUuaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJztcbn07XG5cbnUuaXNWYWxpZCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgIU51bWJlci5pc05hTihvYmopO1xufTtcblxudS5pc0J1ZmZlciA9IChCdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKSB8fCB1LmZhbHNlO1xuXG4vLyB0eXBlIGNvZXJjaW9uIGZ1bmN0aW9uc1xuXG51Lm51bWJlciA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgPT0gbnVsbCA/IG51bGwgOiArczsgfTtcblxudS5ib29sZWFuID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PSBudWxsID8gbnVsbCA6IHM9PT0nZmFsc2UnID8gZmFsc2UgOiAhIXM7IH07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgPT0gbnVsbCA/IG51bGwgOiBEYXRlLnBhcnNlKHMpOyB9O1xuXG51LmFycmF5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geCAhPSBudWxsID8gKHUuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107IH07XG5cbnUuc3RyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdS5pc0FycmF5KHgpID8gJ1snICsgeC5tYXAodS5zdHIpICsgJ10nXG4gICAgOiB1LmlzT2JqZWN0KHgpID8gSlNPTi5zdHJpbmdpZnkoeClcbiAgICA6IHUuaXNTdHJpbmcoeCkgPyAoJ1xcJycrdXRpbF9lc2NhcGVfc3RyKHgpKydcXCcnKSA6IHg7XG59O1xuXG52YXIgZXNjYXBlX3N0cl9yZSA9IC8oXnxbXlxcXFxdKScvZztcblxuZnVuY3Rpb24gdXRpbF9lc2NhcGVfc3RyKHgpIHtcbiAgcmV0dXJuIHgucmVwbGFjZShlc2NhcGVfc3RyX3JlLCAnJDFcXFxcXFwnJyk7XG59XG5cbi8vIGRhdGEgYWNjZXNzIGZ1bmN0aW9uc1xuXG51LmZpZWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gU3RyaW5nKGYpLnNwbGl0KCdcXFxcLicpXG4gICAgLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnNwbGl0KCcuJyk7IH0pXG4gICAgLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAoYS5sZW5ndGgpIHsgYVthLmxlbmd0aC0xXSArPSAnLicgKyBiLnNoaWZ0KCk7IH1cbiAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFtdKTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gZj09bnVsbCB8fCB1LmlzRnVuY3Rpb24oZikgPyBmIDpcbiAgICB1Lm5hbWVkZnVuYyhmLCAocyA9IHUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7IHJldHVybiB4W2ZdOyB9LCB4KTsgfSA6XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiB4W2ZdOyB9XG4gICAgKTtcbn07XG5cbnUuJCA9IHUuYWNjZXNzb3I7XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgIGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aC0xOyArK2kpIHggPSB4W3NbaV1dO1xuICAgICAgeFtzW2ldXSA9IHY7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cbnUuJGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBvcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgIGYgPSB1LiQoZikgfHwgdS5pZGVudGl0eTtcbiAgICB2YXIgbiA9IG5hbWUgKyAodS5uYW1lKGYpID8gJ18nK3UubmFtZShmKSA6ICcnKTtcbiAgICByZXR1cm4gdS5uYW1lZGZ1bmMobiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gb3AoZihkKSk7IH0pO1xuICB9O1xufTtcblxudS4kdmFsaWQgID0gdS4kZnVuYygndmFsaWQnLCB1LmlzVmFsaWQpO1xudS4kbGVuZ3RoID0gdS4kZnVuYygnbGVuZ3RoJywgdS5sZW5ndGgpO1xudS4keWVhciAgID0gdS4kZnVuYygneWVhcicsIHVuaXRzLnllYXIudW5pdCk7XG51LiRtb250aCAgPSB1LiRmdW5jKCdtb250aCcsIHVuaXRzLm1vbnRoT2ZZZWFyLnVuaXQpO1xudS4kZGF0ZSAgID0gdS4kZnVuYygnZGF0ZScsIHVuaXRzLmRheU9mTW9udGgudW5pdCk7XG51LiRkYXkgICAgPSB1LiRmdW5jKCdkYXknLCB1bml0cy5kYXlPZldlZWsudW5pdCk7XG51LiRob3VyICAgPSB1LiRmdW5jKCdob3VyJywgdW5pdHMuaG91ck9mRGF5LnVuaXQpO1xudS4kbWludXRlID0gdS4kZnVuYygnbWludXRlJywgdW5pdHMubWludXRlT2ZIb3VyLnVuaXQpO1xuXG51LiRpbiA9IGZ1bmN0aW9uKGYsIHZhbHVlcykge1xuICBmID0gdS4kKGYpO1xuICB2YXIgbWFwID0gdS5pc0FycmF5KHZhbHVlcykgPyB1LnRvTWFwKHZhbHVlcykgOiB2YWx1ZXM7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7IHJldHVybiAhIW1hcFtmKGQpXTsgfTtcbn07XG5cbi8vIGNvbXBhcmlzb24gLyBzb3J0aW5nIGZ1bmN0aW9uc1xuXG51LmNvbXBhcmF0b3IgPSBmdW5jdGlvbihzb3J0KSB7XG4gIHZhciBzaWduID0gW107XG4gIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHNvcnQgPSBbXTtcbiAgc29ydCA9IHUuYXJyYXkoc29ydCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcyA9IDE7XG4gICAgaWYgICAgICAoZlswXSA9PT0gJy0nKSB7IHMgPSAtMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBlbHNlIGlmIChmWzBdID09PSAnKycpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbi8vIEVTNiBjb21wYXRpYmlsaXR5IHBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aCNQb2x5ZmlsbFxuLy8gV2UgY291bGQgaGF2ZSB1c2VkIHRoZSBwb2x5ZmlsbCBjb2RlLCBidXQgbGV0cyB3YWl0IHVudGlsIEVTNiBiZWNvbWVzIGEgc3RhbmRhcmQgZmlyc3RcbnUuc3RhcnRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA/XG4gIGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XG4gIH0gOlxuICBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCAwKSA9PT0gMDtcbiAgfTtcblxudS5wYWQgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgcGFkY2hhcikge1xuICBwYWRjaGFyID0gcGFkY2hhciB8fCBcIiBcIjtcbiAgdmFyIGQgPSBsZW5ndGggLSBzLmxlbmd0aDtcbiAgaWYgKGQgPD0gMCkgcmV0dXJuIHM7XG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gc3RycmVwKGQsIHBhZGNoYXIpICsgcztcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4gc3RycmVwKE1hdGguZmxvb3IoZC8yKSwgcGFkY2hhcikgK1xuICAgICAgICAgcyArIHN0cnJlcChNYXRoLmNlaWwoZC8yKSwgcGFkY2hhcik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzICsgc3RycmVwKGQsIHBhZGNoYXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJyZXAobiwgc3RyKSB7XG4gIHZhciBzID0gXCJcIiwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBzICs9IHN0cjtcbiAgcmV0dXJuIHM7XG59XG5cbnUudHJ1bmNhdGUgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbGxpcHNpcykgOiAnXFx1MjAyNic7XG4gIHZhciBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZWxsaXBzaXMubGVuZ3RoKTtcblxuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdmFyIGwxID0gTWF0aC5jZWlsKGwvMiksIGwyID0gTWF0aC5mbG9vcihsLzIpO1xuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMSkgOiBzLnNsaWNlKDAsbDEpKSArXG4gICAgICAgIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwyLDEpIDogcy5zbGljZShsZW4tbDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsKSA6IHMuc2xpY2UoMCxsKSkgKyBlbGxpcHNpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJ1bmNhdGVPbldvcmQocywgbGVuLCByZXYpIHtcbiAgdmFyIGNudCA9IDAsIHRvayA9IHMuc3BsaXQodHJ1bmNhdGVfd29yZF9yZSk7XG4gIGlmIChyZXYpIHtcbiAgICBzID0gKHRvayA9IHRvay5yZXZlcnNlKCkpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHRvay5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyBzLmpvaW4oJycpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgLypcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICovXG5cbiAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cblxuICAvKlxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICBcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICBcbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgKi9cblxuICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgIHZhciBtaWQ7XG4gICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobG8gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICBoaSA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICB9O1xuXG5cbiAgLypcbiAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gIFxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAqL1xuXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgKi9cblxuICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cblxuICAvKlxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgKi9cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cblxuICAvKlxuICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cbiAgICovXG5cbiAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcbiAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGVhcDtcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICByZXR1cm4gaGVhcDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICByZXR1cm4gSGVhcDtcblxuICB9KSgpO1xuXG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgcmV0dXJuIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3QuSGVhcCA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIZWFwO1xuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBib3VuZHMgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59O1xuXG52YXIgcHJvdG90eXBlID0gYm91bmRzLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLngyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueTIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG4gIHRoaXMueDIgPSB4MjtcbiAgdGhpcy55MiA9IHkyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gIGlmICh5IDwgdGhpcy55MSkgdGhpcy55MSA9IHk7XG4gIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgdGhpcy54MSAtPSBkO1xuICB0aGlzLnkxIC09IGQ7XG4gIHRoaXMueDIgKz0gZDtcbiAgdGhpcy55MiArPSBkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLngxID0gTWF0aC5mbG9vcih0aGlzLngxKTtcbiAgdGhpcy55MSA9IE1hdGguZmxvb3IodGhpcy55MSk7XG4gIHRoaXMueDIgPSBNYXRoLmNlaWwodGhpcy54Mik7XG4gIHRoaXMueTIgPSBNYXRoLmNlaWwodGhpcy55Mik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICB0aGlzLngxICs9IGR4O1xuICB0aGlzLngyICs9IGR4O1xuICB0aGlzLnkxICs9IGR5O1xuICB0aGlzLnkyICs9IGR5O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgeCwgeSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgY3ggPSB4IC0geCpjb3MgKyB5KnNpbixcbiAgICAgIGN5ID0geSAtIHgqc2luIC0geSpjb3MsXG4gICAgICB4MSA9IHRoaXMueDEsIHgyID0gdGhpcy54MixcbiAgICAgIHkxID0gdGhpcy55MSwgeTIgPSB0aGlzLnkyO1xuXG4gIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MSArIGN4LCAgc2luKngxICsgY29zKnkxICsgY3kpXG4gICAgLmFkZChjb3MqeDEgLSBzaW4qeTIgKyBjeCwgIHNpbip4MSArIGNvcyp5MiArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkxICsgY3gsICBzaW4qeDIgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MiAtIHNpbip5MiArIGN4LCAgc2luKngyICsgY29zKnkyICsgY3kpO1xufVxuXG5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihiKSB7XG4gIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmVuY2xvc2VzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAoXG4gICAgdGhpcy54MSA8PSBiLngxICYmXG4gICAgdGhpcy54MiA+PSBiLngyICYmXG4gICAgdGhpcy55MSA8PSBiLnkxICYmXG4gICAgdGhpcy55MiA+PSBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIGIgJiYgIShcbiAgICB0aGlzLngyIDwgYi54MSB8fFxuICAgIHRoaXMueDEgPiBiLngyIHx8XG4gICAgdGhpcy55MiA8IGIueTEgfHxcbiAgICB0aGlzLnkxID4gYi55MlxuICApO1xufTtcblxucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gIShcbiAgICB4IDwgdGhpcy54MSB8fFxuICAgIHggPiB0aGlzLngyIHx8XG4gICAgeSA8IHRoaXMueTEgfHxcbiAgICB5ID4gdGhpcy55MlxuICApO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZHM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvaW5kZXgnKSxcbiAgICBzdmcgPSByZXF1aXJlKCcuLi9yZW5kZXIvc3ZnLWhlYWRsZXNzL2luZGV4JyksXG4gICAgVmlldyA9IHJlcXVpcmUoJy4vVmlldycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG52YXIgSGVhZGxlc3NWaWV3ID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgbW9kZWwpIHtcbiAgVmlldy5jYWxsKG51bGwsIHdpZHRoLCBoZWlnaHQsIG1vZGVsKTtcbiAgdGhpcy5fZWwgPSBcImJvZHlcIjtcbiAgdGhpcy5fdHlwZSA9IFwiY2FudmFzXCI7XG4gIHRoaXMuX3JlbmRlcmVycyA9IHtjYW52YXM6IGNhbnZhcywgc3ZnOiBzdmd9O1xuICB0aGlzLl9jYW52YXMgPSBudWxsO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEhlYWRsZXNzVmlldy5wcm90b3R5cGUgPSBuZXcgVmlldygpKTtcblxucHJvdG90eXBlLnJlbmRlcmVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZih0eXBlKSB0aGlzLl90eXBlID0gdHlwZTtcbiAgcmV0dXJuIFZpZXcucHJvdG90eXBlLnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXM7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzQXN5bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgciA9IHRoaXMuX3JlbmRlcmVyLCB2aWV3ID0gdGhpcztcbiAgXG4gIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKHIucGVuZGluZ0ltYWdlcygpID09PSAwKSB7XG4gICAgICB2aWV3LnJlbmRlcigpOyAvLyByZS1yZW5kZXIgd2l0aCBhbGwgaW1hZ2VzXG4gICAgICBjYWxsYmFjayh2aWV3Ll9jYW52YXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHdhaXQsIDEwKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBpbWFnZXMgbG9hZGluZywgcG9sbCB1bnRpbCByZWFkeVxuICAoci5wZW5kaW5nSW1hZ2VzKCkgPiAwKSA/IHdhaXQoKSA6IGNhbGxiYWNrKHRoaXMuX2NhbnZhcyk7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fdHlwZSA9PT0gXCJzdmdcIilcbiAgICA/IHRoaXMuX3JlbmRlcmVyLnN2ZygpXG4gICAgOiBudWxsO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHsgICAgXG4gIHZhciB3ID0gdGhpcy5fd2lkdGgsXG4gICAgICBoID0gdGhpcy5faGVpZ2h0LFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZztcblxuICBpZiAodGhpcy5fdmlld3BvcnQpIHtcbiAgICB3ID0gdGhpcy5fdmlld3BvcnRbMF0gLSAocGFkID8gcGFkLmxlZnQgKyBwYWQucmlnaHQgOiAwKTtcbiAgICBoID0gdGhpcy5fdmlld3BvcnRbMV0gLSAocGFkID8gcGFkLnRvcCArIHBhZC5ib3R0b20gOiAwKTtcbiAgfVxuXG4gIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgfHwgbmV3IHRoaXMuX2lvLlJlbmRlcmVyKCk7XG4gIFxuICBpZiAodGhpcy5fdHlwZSA9PT0gXCJzdmdcIikge1xuICAgIHRoaXMuaW5pdFNWRyh3LCBoLCBwYWQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaW5pdENhbnZhcyh3LCBoLCBwYWQpO1xuICB9XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5pbml0Q2FudmFzID0gZnVuY3Rpb24odywgaCwgcGFkKSB7XG4gIHZhciBDYW52YXMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5jYW52YXMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmNhbnZhcyA6IG51bGwpLFxuICAgICAgdHcgPSB3ICsgcGFkLmxlZnQgKyBwYWQucmlnaHQsXG4gICAgICB0aCA9IGggKyBwYWQudG9wICsgcGFkLmJvdHRvbSxcbiAgICAgIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyA9IGRsLmlzTm9kZSA/IG5ldyBDYW52YXModHcsIHRoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICBpZighZGwuaXNOb2RlKSB7ICAvLyBNYW51YWxseSBzZXQgd2lkdGgvaGVpZ2h0IG9uIERPTSBlbGVtZW50c1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0dyk7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aCk7XG4gIH1cbiAgXG4gIC8vIHNldHVwIGNhbnZhcyBjb250ZXh0XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgcGFkLmxlZnQsIHBhZC50b3ApO1xuXG4gIC8vIGNvbmZpZ3VyZSByZW5kZXJlclxuICB0aGlzLl9yZW5kZXJlci5jb250ZXh0KGN0eCk7XG4gIHRoaXMuX3JlbmRlcmVyLnJlc2l6ZSh3LCBoLCBwYWQpO1xufTtcblxucHJvdG90eXBlLmluaXRTVkcgPSBmdW5jdGlvbih3LCBoLCBwYWQpIHtcbiAgLy8gY29uZmlndXJlIHJlbmRlcmVyXG4gIHRoaXMuX3JlbmRlcmVyLmluaXRpYWxpemUodGhpcy5fZWwsIHcsIGgsIHBhZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRsZXNzVmlldztcbiIsInZhciBHcmFwaCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0dyYXBoJyksIFxuICAgIE5vZGUgID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEdyb3VwQnVpbGRlciA9IHJlcXVpcmUoJy4uL3NjZW5lL0dyb3VwQnVpbGRlcicpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLCBcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxuZnVuY3Rpb24gTW9kZWwoKSB7XG4gIHRoaXMuX2RlZnMgPSB7fTtcbiAgdGhpcy5fcHJlZGljYXRlcyA9IHt9O1xuICB0aGlzLl9zY2VuZSA9IG51bGw7XG5cbiAgdGhpcy5fbm9kZSA9IG51bGw7XG4gIHRoaXMuX2J1aWxkZXIgPSBudWxsOyAvLyBUb3AtbGV2ZWwgc2NlbmVncmFwaCBidWlsZGVyXG5cbiAgR3JhcGgucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbn07XG5cbnZhciBwcm90byA9IChNb2RlbC5wcm90b3R5cGUgPSBuZXcgR3JhcGgoKSk7XG5cbnByb3RvLmRlZnMgPSBmdW5jdGlvbihkZWZzKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RlZnM7XG4gIHRoaXMuX2RlZnMgPSBkZWZzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGUgfHwgKHRoaXMuX25vZGUgPSBuZXcgTm9kZSh0aGlzKSk7XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gR3JhcGgucHJvdG90eXBlLmRhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsgIC8vIG5ldyBEYXRhc291cmNlXG4gICAgdGhpcy5ub2RlKCkuYWRkTGlzdGVuZXIoZGF0YS5waXBlbGluZSgpWzBdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuZnVuY3Rpb24gcHJlZGljYXRlcyhuYW1lKSB7XG4gIHZhciBtID0gdGhpcywgcHJlZGljYXRlcyA9IHt9O1xuICBpZighZGwuaXNBcnJheShuYW1lKSkgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZXNbbmFtZV07XG4gIG5hbWUuZm9yRWFjaChmdW5jdGlvbihuKSB7IHByZWRpY2F0ZXNbbl0gPSBtLl9wcmVkaWNhdGVzW25dIH0pO1xuICByZXR1cm4gcHJlZGljYXRlcztcbn1cblxucHJvdG8ucHJlZGljYXRlID0gZnVuY3Rpb24obmFtZSwgcHJlZGljYXRlKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwcmVkaWNhdGVzLmNhbGwodGhpcywgbmFtZSk7XG4gIHJldHVybiAodGhpcy5fcHJlZGljYXRlc1tuYW1lXSA9IHByZWRpY2F0ZSk7XG59O1xuXG5wcm90by5wcmVkaWNhdGVzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcmVkaWNhdGVzOyB9O1xuXG5wcm90by5zY2VuZSA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2NlbmU7XG4gIGlmKHRoaXMuX2J1aWxkZXIpIHRoaXMubm9kZSgpLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2J1aWxkZXIuZGlzY29ubmVjdCgpKTtcbiAgdGhpcy5fYnVpbGRlciA9IG5ldyBHcm91cEJ1aWxkZXIodGhpcywgdGhpcy5fZGVmcy5tYXJrcywgdGhpcy5fc2NlbmU9e30pO1xuICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcih0aGlzLl9idWlsZGVyLmNvbm5lY3QoKSk7XG4gIHZhciBwID0gdGhpcy5fYnVpbGRlci5waXBlbGluZSgpO1xuICBwW3AubGVuZ3RoLTFdLmFkZExpc3RlbmVyKHJlbmRlcmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHsgdGhpcy5ub2RlKCkuYWRkTGlzdGVuZXIobCk7IH07XG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHsgdGhpcy5ub2RlKCkucmVtb3ZlTGlzdGVuZXIobCk7IH07XG5cbnByb3RvLmZpcmUgPSBmdW5jdGlvbihjcykge1xuICBpZighY3MpIGNzID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuICB0aGlzLnByb3BhZ2F0ZShjcywgdGhpcy5ub2RlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIHBhcnNlU3RyZWFtcyA9IHJlcXVpcmUoJy4uL3BhcnNlL3N0cmVhbXMnKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvY2FudmFzL2luZGV4JyksXG4gICAgc3ZnID0gcmVxdWlyZSgnLi4vcmVuZGVyL3N2Zy9pbmRleCcpLFxuICAgIEVuY29kZXIgPSByZXF1aXJlKCcuLi9zY2VuZS9FbmNvZGVyJyksXG4gICAgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL3NjZW5lL1RyYW5zaXRpb24nKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpO1xuXG52YXIgVmlldyA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBtb2RlbCkge1xuICB0aGlzLl9lbCAgICA9IG51bGw7XG4gIHRoaXMuX21vZGVsID0gbnVsbDtcbiAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aCB8fCA1MDA7XG4gIHRoaXMuX2hlaWdodCAgPSB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0IHx8IDMwMDtcbiAgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIHRoaXMuX3BhZGRpbmcgPSB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlciAgPSBudWxsO1xuICB0aGlzLl9zdHJlYW1lciA9IG51bGw7IC8vIFRhcmdldGVkIHVwZGF0ZSBmb3Igc3RyZWFtaW5nIGNoYW5nZXNcbiAgdGhpcy5fY2hhbmdlc2V0ID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZXJzID0ge2NhbnZhczogY2FudmFzLCBzdmc6IHN2Z307XG4gIHRoaXMuX2lvICA9IGNhbnZhcztcbiAgdGhpcy5fYXBpID0ge307IC8vIFN0YXNoIHN0cmVhbWluZyBkYXRhIEFQSSBzYW5kYm94ZXMuXG59O1xuXG52YXIgcHJvdG90eXBlID0gVmlldy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICBpZiAodGhpcy5fbW9kZWwgIT09IG1vZGVsKSB7XG4gICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLl9zdHJlYW1lciA9IG5ldyBOb2RlKG1vZGVsKTtcbiAgICB0aGlzLl9jaGFuZ2VzZXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIubW9kZWwobW9kZWwpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU2FuZGJveGVkIHN0cmVhbWluZyBkYXRhIEFQSVxuZnVuY3Rpb24gc3RyZWFtaW5nKHNyYykge1xuICB2YXIgdmlldyA9IHRoaXMsXG4gICAgICBkcyA9IHRoaXMuX21vZGVsLmRhdGEoc3JjKSxcbiAgICAgIGxpc3RlbmVyID0gZHMucGlwZWxpbmUoKVswXSxcbiAgICAgIHN0cmVhbWVyID0gdGhpcy5fc3RyZWFtZXIsXG4gICAgICBjcyAgPSB0aGlzLl9jaGFuZ2VzZXQsXG4gICAgICBhcGkgPSB7fTtcblxuICBpZihkbC5rZXlzKGNzLnNpZ25hbHMpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBcIk5ldyBzaWduYWwgdmFsdWVzIGFyZSBub3QgcmVmbGVjdGVkIGluIHRoZSB2aXN1YWxpemF0aW9uLlwiICtcbiAgICAgIFwiIFBsZWFzZSBjYWxsIHZpZXcudXBkYXRlKCkgYmVmb3JlIHVwZGF0aW5nIGRhdGEgdmFsdWVzLlwiXG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGl0IHN0YXNoZWQsIGRvbid0IGNyZWF0ZSBhIG5ldyBjbG9zdXJlLiBcbiAgaWYodGhpcy5fYXBpW3NyY10pIHJldHVybiB0aGlzLl9hcGlbc3JjXTtcblxuICBhcGkuaW5zZXJ0ID0gZnVuY3Rpb24odmFscykge1xuICAgIGRzLmluc2VydChkbC5kdXBsaWNhdGUodmFscykpOyAgLy8gRG9uJ3QgcG9sbHV0ZSB0aGUgZW52aXJvbm1lbnRcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY3MuZGF0YVtkcy5uYW1lKCldID0gMTtcbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIGFwaS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY3MuZGF0YVtkcy5uYW1lKCldID0gMTtcbiAgICByZXR1cm4gKGRzLnVwZGF0ZS5hcHBseShkcywgYXJndW1lbnRzKSwgYXBpKTtcbiAgfTtcblxuICBhcGkucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNzLmRhdGFbZHMubmFtZSgpXSA9IDE7XG4gICAgcmV0dXJuIChkcy5yZW1vdmUuYXBwbHkoZHMsIGFyZ3VtZW50cyksIGFwaSk7XG4gIH07XG5cbiAgYXBpLnZhbHVlcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZHMudmFsdWVzKCkgfTsgICAgXG5cbiAgcmV0dXJuICh0aGlzLl9hcGlbc3JjXSA9IGFwaSk7XG59O1xuXG5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHYgPSB0aGlzO1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHYuX21vZGVsLmRhdGFWYWx1ZXMoKTtcbiAgZWxzZSBpZihkbC5pc1N0cmluZyhkYXRhKSkgcmV0dXJuIHN0cmVhbWluZy5jYWxsKHYsIGRhdGEpO1xuICBlbHNlIGlmKGRsLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgZGwua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBhcGkgPSBzdHJlYW1pbmcuY2FsbCh2LCBrKTtcbiAgICAgIGRhdGFba10oYXBpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbSAgPSB0aGlzLl9tb2RlbCxcbiAgICAgIGNzID0gdGhpcy5fY2hhbmdlc2V0LFxuICAgICAgc3RyZWFtZXIgPSB0aGlzLl9zdHJlYW1lcixcbiAgICAgIHNldHRlciA9IG5hbWU7IFxuXG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbS5zaWduYWxWYWx1ZXMoKTtcbiAgZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZGwuaXNTdHJpbmcobmFtZSkpIHJldHVybiBtLnNpZ25hbFZhbHVlcyhuYW1lKTtcblxuICBpZihkbC5rZXlzKGNzLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBcIk5ldyBkYXRhIHZhbHVlcyBhcmUgbm90IHJlZmxlY3RlZCBpbiB0aGUgdmlzdWFsaXphdGlvbi5cIiArXG4gICAgICBcIiBQbGVhc2UgY2FsbCB2aWV3LnVwZGF0ZSgpIGJlZm9yZSB1cGRhdGluZyBzaWduYWwgdmFsdWVzLlwiXG4gIH1cblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICBzZXR0ZXIgPSB7fTtcbiAgICBzZXR0ZXJbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGRsLmtleXMoc2V0dGVyKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihtLnNpZ25hbChrKS52YWx1ZShzZXR0ZXJba10pKTtcbiAgICBjcy5zaWduYWxzW2tdID0gMTtcbiAgICBjcy5yZWZsb3cgPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX193aWR0aDtcbiAgaWYgKHRoaXMuX193aWR0aCAhPT0gd2lkdGgpIHtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX193aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLl9zdHJpY3QpIHRoaXMuX2F1dG9wYWQgPSAxO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9faGVpZ2h0O1xuICBpZiAodGhpcy5fX2hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fc3RyaWN0KSB0aGlzLl9hdXRvcGFkID0gMTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWQpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcocGFkKSkge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDE7XG4gICAgICB0aGlzLl9wYWRkaW5nID0ge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgICAgIHRoaXMuX3N0cmljdCA9IChwYWQgPT09IFwic3RyaWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvcGFkID0gMDtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgICB0aGlzLl9zdHJpY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VsKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5yZXNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgcGFkKTtcbiAgICAgIGlmKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIucGFkZGluZyhwYWQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5hdXRvcGFkID0gZnVuY3Rpb24ob3B0KSB7XG4gIGlmICh0aGlzLl9hdXRvcGFkIDwgMSkgcmV0dXJuIHRoaXM7XG4gIGVsc2UgdGhpcy5fYXV0b3BhZCA9IDA7XG5cbiAgdmFyIHBhZCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICBiID0gdGhpcy5tb2RlbCgpLnNjZW5lKCkuYm91bmRzLFxuICAgICAgaW5zZXQgPSBjb25maWcuYXV0b3BhZEluc2V0LFxuICAgICAgbCA9IGIueDEgPCAwID8gTWF0aC5jZWlsKC1iLngxKSArIGluc2V0IDogMCxcbiAgICAgIHQgPSBiLnkxIDwgMCA/IE1hdGguY2VpbCgtYi55MSkgKyBpbnNldCA6IDAsXG4gICAgICByID0gYi54MiA+IHRoaXMuX3dpZHRoICA/IE1hdGguY2VpbCgrYi54MiAtIHRoaXMuX3dpZHRoKSArIGluc2V0IDogMCxcbiAgICAgIGIgPSBiLnkyID4gdGhpcy5faGVpZ2h0ID8gTWF0aC5jZWlsKCtiLnkyIC0gdGhpcy5faGVpZ2h0KSArIGluc2V0IDogMDtcbiAgcGFkID0ge2xlZnQ6bCwgdG9wOnQsIHJpZ2h0OnIsIGJvdHRvbTpifTtcblxuICBpZiAodGhpcy5fc3RyaWN0KSB7XG4gICAgdGhpcy5fYXV0b3BhZCA9IDA7XG4gICAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgICB0aGlzLl93aWR0aCA9IE1hdGgubWF4KDAsIHRoaXMuX193aWR0aCAtIChsK3IpKTtcbiAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLm1heCgwLCB0aGlzLl9faGVpZ2h0IC0gKHQrYikpO1xuICAgIHRoaXMuX21vZGVsLndpZHRoKHRoaXMuX3dpZHRoKTtcbiAgICB0aGlzLl9tb2RlbC5oZWlnaHQodGhpcy5faGVpZ2h0KTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucGFkZGluZyhwYWQpLnVwZGF0ZShvcHQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnZpZXdwb3J0ID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl92aWV3cG9ydDtcbiAgaWYgKHRoaXMuX3ZpZXdwb3J0ICE9PSBzaXplKSB7XG4gICAgdGhpcy5fdmlld3BvcnQgPSBzaXplO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbmRlcmVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZW5kZXJlcjtcbiAgaWYgKHRoaXMuX3JlbmRlcmVyc1t0eXBlXSkgdHlwZSA9IHRoaXMuX3JlbmRlcmVyc1t0eXBlXTtcbiAgZWxzZSBpZiAoZGwuaXNTdHJpbmcodHlwZSkpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcmVuZGVyZXI6IFwiICsgdHlwZSk7XG4gIGVsc2UgaWYgKCF0eXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyByZW5kZXJlciBzcGVjaWZpZWRcIik7XG5cbiAgaWYgKHRoaXMuX2lvICE9PSB0eXBlKSB7XG4gICAgdGhpcy5faW8gPSB0eXBlO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fYnVpbGQpIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsKSB7XG4gIHZhciB2ID0gdGhpcywgcHJldkhhbmRsZXIsXG4gICAgICB3ID0gdi5fd2lkdGgsIGggPSB2Ll9oZWlnaHQsIHBhZCA9IHYuX3BhZGRpbmc7XG5cbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IGVsID09PSBudWxsKSB7XG4gICAgZWwgPSB0aGlzLl9lbCA/IHRoaXMuX2VsLnBhcmVudE5vZGUgOiBudWxsO1xuICAgIGlmKCFlbCkgcmV0dXJuIHRoaXM7ICAvLyBUaGlzIFZpZXcgY2Fubm90IGluaXQgdy9vIGFuXG4gIH1cbiAgXG4gIC8vIGNsZWFyIHByZS1leGlzdGluZyBjb250YWluZXJcbiAgZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJkaXYudmVnYVwiKS5yZW1vdmUoKTtcbiAgXG4gIC8vIGFkZCBkaXYgY29udGFpbmVyXG4gIHRoaXMuX2VsID0gZWwgPSBkMy5zZWxlY3QoZWwpXG4gICAgLmFwcGVuZChcImRpdlwiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ2ZWdhXCIpXG4gICAgLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxuICAgIC5ub2RlKCk7XG4gIGlmICh2Ll92aWV3cG9ydCkge1xuICAgIGQzLnNlbGVjdChlbClcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsICAodi5fdmlld3BvcnRbMF0gfHwgdykrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsICh2Ll92aWV3cG9ydFsxXSB8fCBoKStcInB4XCIpXG4gICAgICAuc3R5bGUoXCJvdmVyZmxvd1wiLCBcImF1dG9cIik7XG4gIH1cblxuICAvLyByZW5kZXJlclxuICB2Ll9yZW5kZXJlciA9ICh2Ll9yZW5kZXJlciB8fCBuZXcgdGhpcy5faW8uUmVuZGVyZXIoKSlcbiAgICAuaW5pdGlhbGl6ZShlbCwgdywgaCwgcGFkKTtcbiAgXG4gIC8vIGlucHV0IGhhbmRsZXJcbiAgcHJldkhhbmRsZXIgPSB2Ll9oYW5kbGVyO1xuICB2Ll9oYW5kbGVyID0gbmV3IHRoaXMuX2lvLkhhbmRsZXIoKVxuICAgIC5pbml0aWFsaXplKGVsLCBwYWQsIHYpXG4gICAgLm1vZGVsKHYuX21vZGVsKTtcblxuICBpZiAocHJldkhhbmRsZXIpIHtcbiAgICBwcmV2SGFuZGxlci5oYW5kbGVycygpLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgdi5faGFuZGxlci5vbihoLnR5cGUsIGguaGFuZGxlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGZvciBzaWduYWwgc3RyZWFtIGRlZmluaXRpb25zLlxuICAgIHBhcnNlU3RyZWFtcyh0aGlzKTtcbiAgfVxuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBidWlsZCgpIHtcbiAgdmFyIHYgPSB0aGlzO1xuICB2Ll9yZW5kZXJOb2RlID0gbmV3IE5vZGUodi5fbW9kZWwpXG4gICAgLnJvdXRlcih0cnVlKTtcblxuICB2Ll9yZW5kZXJOb2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZWJ1ZyhpbnB1dCwgW1wicmVuZGVyaW5nXCJdKTtcblxuICAgIHZhciBzID0gdi5fbW9kZWwuc2NlbmUoKTtcbiAgICBpZihpbnB1dC50cmFucykge1xuICAgICAgaW5wdXQudHJhbnMuc3RhcnQoZnVuY3Rpb24oaXRlbXMpIHsgdi5fcmVuZGVyZXIucmVuZGVyKHMsIGl0ZW1zKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYuX3JlbmRlcmVyLnJlbmRlcihzKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYWxsIHVwZGF0ZWQgZGF0YXNvdXJjZXMsIGZpbmFsaXplIHRoZWlyIGNoYW5nZXNldHMuXG4gICAgdmFyIGQsIGRzO1xuICAgIGZvcihkIGluIGlucHV0LmRhdGEpIHtcbiAgICAgIGRzID0gdi5fbW9kZWwuZGF0YShkKTtcbiAgICAgIGlmKCFkcy5yZXZpc2VzKCkpIGNvbnRpbnVlO1xuICAgICAgY2hhbmdlc2V0LmZpbmFsaXplKGRzLmxhc3QoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIHJldHVybiAodi5fbW9kZWwuc2NlbmUodi5fcmVuZGVyTm9kZSksIHRydWUpOyAgXG59XG5cbnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvcHQpIHsgICAgXG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHYgPSB0aGlzLFxuICAgICAgdHJhbnMgPSBvcHQuZHVyYXRpb25cbiAgICAgICAgPyBuZXcgVHJhbnNpdGlvbihvcHQuZHVyYXRpb24sIG9wdC5lYXNlKVxuICAgICAgICA6IG51bGw7XG5cbiAgdmFyIGNzID0gdi5fY2hhbmdlc2V0O1xuICBpZih0cmFucykgY3MudHJhbnMgPSB0cmFucztcbiAgaWYob3B0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZihkbC5rZXlzKGNzLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IFwiTmV3IGRhdGEgdmFsdWVzIGFyZSBub3QgcmVmbGVjdGVkIGluIHRoZSB2aXN1YWxpemF0aW9uLlwiICtcbiAgICAgICAgXCIgUGxlYXNlIGNhbGwgdmlldy51cGRhdGUoKSBiZWZvcmUgdXBkYXRpbmcgYSBzcGVjaWZpZWQgcHJvcGVydHkgc2V0LlwiXG4gICAgfVxuXG4gICAgY3MucmVmbG93ICA9IHRydWU7XG4gICAgY3MucmVxdWVzdCA9IG9wdC5wcm9wcztcbiAgfVxuXG4gIHYuX2J1aWxkID0gdi5fYnVpbGQgfHwgYnVpbGQuY2FsbCh0aGlzKTtcblxuICAvLyBJZiBzcGVjaWZpYyBpdGVtcyBhcmUgc3BlY2lmaWVkLCBzaG9ydC1jaXJjdWl0IGRhdGFmbG93IGdyYXBoLlxuICAvLyBFbHNlLUlmIHRoZXJlIGFyZSBzdHJlYW1pbmcgdXBkYXRlcywgcGVyZm9ybSBhIHRhcmdldGVkIHByb3BhZ2F0aW9uLlxuICAvLyBPdGhlcndpc2UsIHJlZXZhbHVhdGUgdGhlIGVudGlyZSBtb2RlbCAoZGF0YXNvdXJjZXMgKyBzY2VuZSkuXG4gIGlmKG9wdC5pdGVtcykgeyBcbiAgICBFbmNvZGVyLnVwZGF0ZSh0aGlzLl9tb2RlbCwgb3B0LnRyYW5zLCBvcHQucHJvcHMsIG9wdC5pdGVtcyk7XG4gICAgdi5fcmVuZGVyTm9kZS5ldmFsdWF0ZShjcyk7XG4gIH0gZWxzZSBpZih2Ll9zdHJlYW1lci5saXN0ZW5lcnMoKS5sZW5ndGgpIHtcbiAgICB2Ll9tb2RlbC5wcm9wYWdhdGUoY3MsIHYuX3N0cmVhbWVyKTtcbiAgICB2Ll9zdHJlYW1lci5kaXNjb25uZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgdi5fbW9kZWwuZmlyZShjcyk7XG4gIH1cblxuICB2Ll9jaGFuZ2VzZXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG5cbiAgcmV0dXJuIHYuYXV0b3BhZChvcHQpO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9tb2RlbC5zY2VuZSgpLCBpdGVtcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2hhbmRsZXIub24uYXBwbHkodGhpcy5faGFuZGxlciwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub25TaWduYWwgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuX21vZGVsLnNpZ25hbChuYW1lKS5vbihoYW5kbGVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2hhbmRsZXIub2ZmLmFwcGx5KHRoaXMuX2hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9mZlNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5fbW9kZWwuc2lnbmFsKG5hbWUpLm9mZihoYW5kbGVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WaWV3LmZhY3RvcnkgPSBmdW5jdGlvbihtb2RlbCkge1xuICB2YXIgSGVhZGxlc3NWaWV3ID0gcmVxdWlyZSgnLi9IZWFkbGVzc1ZpZXcnKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB2YXIgZGVmcyA9IG1vZGVsLmRlZnMoKTtcbiAgICB2YXIgdiA9IChvcHQuZWwgPyBuZXcgVmlldygpIDogbmV3IEhlYWRsZXNzVmlldygpKVxuICAgICAgLm1vZGVsKG1vZGVsKVxuICAgICAgLnJlbmRlcmVyKG9wdC5yZW5kZXJlciB8fCBcImNhbnZhc1wiKVxuICAgICAgLndpZHRoKGRlZnMud2lkdGgpXG4gICAgICAuaGVpZ2h0KGRlZnMuaGVpZ2h0KVxuICAgICAgLnBhZGRpbmcoZGVmcy5wYWRkaW5nKTtcblxuICAgIGlmKG9wdC5lbCB8fCAoIW9wdC5lbCAmJiB2IGluc3RhbmNlb2YgSGVhZGxlc3NWaWV3KSkgdi5pbml0aWFsaXplKG9wdC5lbCk7XG4gICAgaWYob3B0LmRhdGEpIHYuZGF0YShvcHQuZGF0YSk7XG4gIFxuICAgIHJldHVybiB2O1xuICB9OyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldztcbiIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gQ29sbGVjdG9yKGdyYXBoKSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX2RhdGEgPSBbXTtcbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKENvbGxlY3Rvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uZGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJjb2xsZWN0aW5nXCJdKTtcblxuICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgaW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcbiAgICBpbnB1dC5tb2QgPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgaWYgKGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICB2YXIgaWRzID0gaW5wdXQucmVtLnJlZHVjZShmdW5jdGlvbihtLHgpIHsgcmV0dXJuIChtW3guX2lkXT0xLCBtKTsgfSwge30pO1xuICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBpZHNbeC5faWRdICE9PSAxOyB9KTtcbiAgfVxuXG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoKSB7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEubGVuZ3RoID8gdGhpcy5fZGF0YS5jb25jYXQoaW5wdXQuYWRkKSA6IGlucHV0LmFkZDtcbiAgfVxuXG4gIGlmIChpbnB1dC5zb3J0KSB7XG4gICAgdGhpcy5fZGF0YS5zb3J0KGlucHV0LnNvcnQpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0JyksIFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi90dXBsZScpLCBcbiAgICBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRGF0YXNvdXJjZShncmFwaCwgbmFtZSwgZmFjZXQpIHtcbiAgdGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2RhdGEgPSBbXTtcbiAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgdGhpcy5fZmFjZXQgPSBmYWNldDtcbiAgdGhpcy5faW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gIHRoaXMuX291dHB1dCA9IG51bGw7ICAgIC8vIE91dHB1dCBjaGFuZ2VzZXRcblxuICB0aGlzLl9waXBlbGluZSAgPSBudWxsOyAvLyBQaXBlbGluZSBvZiB0cmFuc2Zvcm1hdGlvbnMuXG4gIHRoaXMuX2NvbGxlY3RvciA9IG51bGw7IC8vIENvbGxlY3RvciB0byBtYXRlcmlhbGl6ZSBvdXRwdXQgb2YgcGlwZWxpbmVcbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAvLyBEb2VzIGFueSBwaXBlbGluZSBvcGVyYXRvciBuZWVkIHRvIHRyYWNrIHByZXY/XG59O1xuXG52YXIgcHJvdG8gPSBEYXRhc291cmNlLnByb3RvdHlwZTtcblxucHJvdG8ubmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9uYW1lO1xuICByZXR1cm4gKHRoaXMuX25hbWUgPSBuYW1lLCB0aGlzKTtcbn07XG5cbnByb3RvLnNvdXJjZSA9IGZ1bmN0aW9uKHNyYykge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgcmV0dXJuICh0aGlzLl9zb3VyY2UgPSB0aGlzLl9ncmFwaC5kYXRhKHNyYykpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oZCkge1xuICB2YXIgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX2lucHV0LmFkZCA9IHRoaXMuX2lucHV0LmFkZFxuICAgIC5jb25jYXQoZGwuYXJyYXkoZCkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHR1cGxlLmluZ2VzdChkLCBwcmV2KTsgfSkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gIHZhciBkID0gdGhpcy5fZGF0YS5maWx0ZXIod2hlcmUpO1xuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9pbnB1dC5yZW0uY29uY2F0KGQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKHdoZXJlLCBmaWVsZCwgZnVuYykge1xuICB2YXIgbW9kID0gdGhpcy5faW5wdXQubW9kLFxuICAgICAgaWRzID0gdHVwbGUuaWRNYXAobW9kKSxcbiAgICAgIHByZXYgPSB0aGlzLl9yZXZpc2VzID8gbnVsbCA6IHVuZGVmaW5lZDsgXG5cbiAgdGhpcy5faW5wdXQuZmllbGRzW2ZpZWxkXSA9IDE7XG4gIHRoaXMuX2RhdGEuZmlsdGVyKHdoZXJlKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcHJldiA9IHhbZmllbGRdLFxuICAgICAgICBuZXh0ID0gZnVuYyh4KTtcbiAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgdHVwbGUuc2V0KHgsIGZpZWxkLCBuZXh0KTtcbiAgICAgIGlmKGlkc1t4Ll9pZF0gIT09IDEpIHtcbiAgICAgICAgbW9kLnB1c2goeCk7XG4gICAgICAgIGlkc1t4Ll9pZF0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udmFsdWVzID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdG9yID8gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSA6IHRoaXMuX2RhdGE7XG5cbiAgLy8gUmVwbGFjZSBiYWNraW5nIGRhdGFcbiAgdGhpcy5faW5wdXQucmVtID0gdGhpcy5fZGF0YS5zbGljZSgpO1xuICBpZiAoZGF0YSkgeyB0aGlzLmluc2VydChkYXRhKTsgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHNldF9wcmV2KGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfVxuXG5wcm90by5yZXZpc2VzID0gZnVuY3Rpb24ocCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JldmlzZXM7XG5cbiAgLy8gSWYgd2UndmUgbm90IG5lZWRlZCBwcmV2IGluIHRoZSBwYXN0LCBidXQgYSBuZXcgZGF0YWZsb3cgbm9kZSBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIHR1cGxlcyBoYXZlIHByZXYgc2V0LlxuICBpZighdGhpcy5fcmV2aXNlcyAmJiBwKSB7XG4gICAgdGhpcy5fZGF0YS5mb3JFYWNoKHNldF9wcmV2KTtcbiAgICB0aGlzLl9pbnB1dC5hZGQuZm9yRWFjaChzZXRfcHJldik7IC8vIE5ldyB0dXBsZXMgdGhhdCBoYXZlbid0IHlldCBiZWVuIG1lcmdlZCBpbnRvIF9kYXRhXG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX291dHB1dDsgfTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmKGlucHV0KSB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUodGhpcy5faW5wdXQsIHRoaXMuX3BpcGVsaW5lWzBdKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gIHZhciBkcyA9IHRoaXMsIG4sIGM7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG5cbiAgaWYocGlwZWxpbmUubGVuZ3RoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBpcGVsaW5lLCBhZGQgYSBjb2xsZWN0b3IgdG8gdGhlIGVuZCB0byBtYXRlcmlhbGl6ZVxuICAgIC8vIHRoZSBvdXRwdXQuXG4gICAgZHMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IodGhpcy5fZ3JhcGgpO1xuICAgIHBpcGVsaW5lLnB1c2goZHMuX2NvbGxlY3Rvcik7XG4gICAgZHMuX3JldmlzZXMgPSBwaXBlbGluZS5zb21lKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAucmV2aXNlcygpOyB9KTtcbiAgfVxuXG4gIC8vIElucHV0IG5vZGUgYXBwbGllcyB0aGUgZGF0YXNvdXJjZSdzIGRlbHRhLCBhbmQgcHJvcGFnYXRlcyBpdCB0byBcbiAgLy8gdGhlIHJlc3Qgb2YgdGhlIHBpcGVsaW5lLiBJdCByZWNlaXZlcyB0b3VjaGVzIHRvIHJlZmxvdyBkYXRhLlxuICB2YXIgaW5wdXQgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBpbnB1dC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcImlucHV0XCIsIGRzLl9uYW1lXSk7XG5cbiAgICB2YXIgZGVsdGEgPSBkcy5faW5wdXQsIFxuICAgICAgICBvdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgICAgcmVtO1xuXG4gICAgLy8gRGVsdGEgbWlnaHQgY29udGFpbiBmaWVsZHMgdXBkYXRlZCB0aHJvdWdoIEFQSVxuICAgIGRsLmtleXMoZGVsdGEuZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHsgb3V0LmZpZWxkc1tmXSA9IDEgfSk7XG5cbiAgICBpZihpbnB1dC5yZWZsb3cpIHtcbiAgICAgIG91dC5tb2QgPSBkcy5fZGF0YS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgZGF0YVxuICAgICAgaWYoZGVsdGEucmVtLmxlbmd0aCkge1xuICAgICAgICByZW0gPSB0dXBsZS5pZE1hcChkZWx0YS5yZW0pO1xuICAgICAgICBkcy5fZGF0YSA9IGRzLl9kYXRhXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW1beC5faWRdICE9PSAxIH0pO1xuICAgICAgfVxuXG4gICAgICBpZihkZWx0YS5hZGQubGVuZ3RoKSBkcy5fZGF0YSA9IGRzLl9kYXRhLmNvbmNhdChkZWx0YS5hZGQpO1xuXG4gICAgICAvLyByZXNldCBjaGFuZ2UgbGlzdFxuICAgICAgZHMuX2lucHV0ID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuXG4gICAgICBvdXQuYWRkID0gZGVsdGEuYWRkOyBcbiAgICAgIG91dC5tb2QgPSBkZWx0YS5tb2Q7XG4gICAgICBvdXQucmVtID0gZGVsdGEucmVtO1xuICAgIH1cblxuICAgIHJldHVybiAob3V0LmZhY2V0ID0gZHMuX2ZhY2V0LCBvdXQpO1xuICB9O1xuXG4gIHBpcGVsaW5lLnVuc2hpZnQoaW5wdXQpO1xuXG4gIC8vIE91dHB1dCBub2RlIGNhcHR1cmVzIHRoZSBsYXN0IGNoYW5nZXNldCBzZWVuIGJ5IHRoaXMgZGF0YXNvdXJjZVxuICAvLyAobmVlZGVkIGZvciBqb2lucyBhbmQgYnVpbGRzKSBhbmQgbWF0ZXJpYWxpemVzIGFueSBuZXN0ZWQgZGF0YS5cbiAgLy8gSWYgdGhpcyBkYXRhc291cmNlIGlzIGZhY2V0ZWQsIG1hdGVyaWFsaXplcyB0aGUgdmFsdWVzIGluIHRoZSBmYWNldC5cbiAgdmFyIG91dHB1dCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIG91dHB1dC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcIm91dHB1dFwiLCBkcy5fbmFtZV0pO1xuICAgIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0LCB0cnVlKTtcblxuICAgIGlmKGRzLl9mYWNldCkge1xuICAgICAgZHMuX2ZhY2V0LnZhbHVlcyA9IGRzLnZhbHVlcygpO1xuICAgICAgaW5wdXQuZmFjZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGRzLl9vdXRwdXQgPSBpbnB1dDtcbiAgICBvdXRwdXQuZGF0YVtkcy5fbmFtZV0gPSAxO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgcGlwZWxpbmUucHVzaChvdXRwdXQpO1xuXG4gIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QoZHMuX3BpcGVsaW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5saXN0ZW5lciA9IGZ1bmN0aW9uKCkgeyBcbiAgdmFyIGwgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCkucm91dGVyKHRydWUpLFxuICAgICAgZGVzdCA9IHRoaXMsXG4gICAgICBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQ7XG5cbiAgbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVzdC5fc3JjTWFwID0gZGVzdC5fc3JjTWFwIHx8IHt9OyAgLy8gdG8gcHJvcGFnYXRlIHR1cGxlcyBjb3JyZWN0bHlcbiAgICB2YXIgbWFwID0gZGVzdC5fc3JjTWFwLFxuICAgICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgICBvdXRwdXQuYWRkID0gaW5wdXQuYWRkLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gKG1hcFt0Ll9pZF0gPSB0dXBsZS5kZXJpdmUodCwgdC5fcHJldiAhPT0gdW5kZWZpbmVkID8gdC5fcHJldiA6IHByZXYpKTtcbiAgICB9KTtcbiAgICBvdXRwdXQubW9kID0gaW5wdXQubW9kLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBtYXBbdC5faWRdOyB9KTtcbiAgICBvdXRwdXQucmVtID0gaW5wdXQucmVtLm1hcChmdW5jdGlvbih0KSB7IFxuICAgICAgdmFyIG8gPSBtYXBbdC5faWRdO1xuICAgICAgbWFwW3QuX2lkXSA9IG51bGw7XG4gICAgICByZXR1cm4gbztcbiAgICB9KTtcblxuICAgIHJldHVybiAoZGVzdC5faW5wdXQgPSBvdXRwdXQpO1xuICB9O1xuXG4gIGwuYWRkTGlzdGVuZXIodGhpcy5fcGlwZWxpbmVbMF0pO1xuICByZXR1cm4gbDtcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZihsIGluc3RhbmNlb2YgRGF0YXNvdXJjZSkge1xuICAgIGlmKHRoaXMuX2NvbGxlY3RvcikgdGhpcy5fY29sbGVjdG9yLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gICAgZWxzZSB0aGlzLl9waXBlbGluZVswXS5hZGRMaXN0ZW5lcihsLmxpc3RlbmVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5hZGRMaXN0ZW5lcihsKTsgICAgICBcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5yZW1vdmVMaXN0ZW5lcihsKTtcbn07XG5cbnByb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGRzKSB7XG4gIHJldHVybiBkcyBcbiAgICA/IHRoaXMuX2NvbGxlY3RvciA/IHRoaXMuX2NvbGxlY3Rvci5saXN0ZW5lcnMoKSA6IHRoaXMuX3BpcGVsaW5lWzBdLmxpc3RlbmVycygpXG4gICAgOiB0aGlzLl9waXBlbGluZVt0aGlzLl9waXBlbGluZS5sZW5ndGgtMV0ubGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFzb3VyY2U7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEhlYXAgPSByZXF1aXJlKCdoZWFwJyksXG4gICAgRGF0YXNvdXJjZSA9IHJlcXVpcmUoJy4vRGF0YXNvdXJjZScpLFxuICAgIFNpZ25hbCA9IHJlcXVpcmUoJy4vU2lnbmFsJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gR3JhcGgoKSB7XG59XG5cbnZhciBwcm90byA9IEdyYXBoLnByb3RvdHlwZTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFtcCA9IDA7XG4gIHRoaXMuX3JhbmsgID0gMDtcblxuICB0aGlzLl9kYXRhID0ge307XG4gIHRoaXMuX3NpZ25hbHMgPSB7fTtcblxuICB0aGlzLmRvTm90UHJvcGFnYXRlID0ge307XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24obmFtZSwgcGlwZWxpbmUsIGZhY2V0KSB7XG4gIHZhciBkYiA9IHRoaXMuX2RhdGE7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGwua2V5cyhkYikubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRiW2RdOyB9KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGRiW25hbWVdO1xuICByZXR1cm4gKGRiW25hbWVdID0gbmV3IERhdGFzb3VyY2UodGhpcywgbmFtZSwgZmFjZXQpLnBpcGVsaW5lKHBpcGVsaW5lKSk7XG59O1xuXG5wcm90by5kYXRhVmFsdWVzID0gZnVuY3Rpb24obmFtZXMpIHtcbiAgdmFyIGdyYXBoID0gdGhpcztcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBuYW1lcyA9IGRsLmtleXModGhpcy5fZGF0YSk7XG4gIGlmICghZGwuaXNBcnJheShuYW1lcykpIHJldHVybiB0aGlzLl9kYXRhW25hbWVzXS52YWx1ZXMoKTtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihkYiwgbikge1xuICAgIHJldHVybiAoZGJbbl0gPSBncmFwaC5fZGF0YVtuXS52YWx1ZXMoKSwgZGIpO1xuICB9LCB7fSk7XG59O1xuXG5mdW5jdGlvbiBzaWduYWwobmFtZSkge1xuICB2YXIgbSA9IHRoaXMsIGksIGxlbjtcbiAgaWYoIWRsLmlzQXJyYXkobmFtZSkpIHJldHVybiB0aGlzLl9zaWduYWxzW25hbWVdO1xuICByZXR1cm4gbmFtZS5tYXAoZnVuY3Rpb24obikgeyBtLl9zaWduYWxzW25dOyB9KTtcbn1cblxucHJvdG8uc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaW5pdCkge1xuICB2YXIgbSA9IHRoaXM7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBzaWduYWwuY2FsbCh0aGlzLCBuYW1lKTtcbiAgcmV0dXJuICh0aGlzLl9zaWduYWxzW25hbWVdID0gbmV3IFNpZ25hbCh0aGlzLCBuYW1lLCBpbml0KSk7XG59O1xuXG5wcm90by5zaWduYWxWYWx1ZXMgPSBmdW5jdGlvbihuYW1lcykge1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgbmFtZXMgPSBkbC5rZXlzKHRoaXMuX3NpZ25hbHMpO1xuICBpZighZGwuaXNBcnJheShuYW1lcykpIHJldHVybiB0aGlzLl9zaWduYWxzW25hbWVzXS52YWx1ZSgpO1xuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKHNnLCBuKSB7XG4gICAgcmV0dXJuIChzZ1tuXSA9IGdyYXBoLl9zaWduYWxzW25dLnZhbHVlKCksIHNnKTtcbiAgfSwge30pO1xufTtcblxucHJvdG8uc2lnbmFsUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmKCFkbC5pc0FycmF5KHJlZikpIHJlZiA9IGRsLmZpZWxkKHJlZik7XG4gIHZhciB2YWx1ZSA9IHRoaXMuc2lnbmFsKHJlZi5zaGlmdCgpKS52YWx1ZSgpO1xuICBpZihyZWYubGVuZ3RoID4gMCkge1xuICAgIHZhciBmbiA9IEZ1bmN0aW9uKFwic1wiLCBcInJldHVybiBzW1wiK3JlZi5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCIpO1xuICAgIHZhbHVlID0gZm4uY2FsbChudWxsLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgc2NoZWR1bGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIC8vIElmIHRoZSBub2RlcyBhcmUgZXF1YWwsIHByb3BhZ2F0ZSB0aGUgbm9uLXJlZmxvdyBwdWxzZSBmaXJzdCxcbiAgLy8gc28gdGhhdCB3ZSBjYW4gaWdub3JlIHN1YnNlcXVlbnQgcmVmbG93IHB1bHNlcy4gXG4gIGlmKGEucmFuayA9PSBiLnJhbmspIHJldHVybiBhLnB1bHNlLnJlZmxvdyA/IDEgOiAtMTtcbiAgZWxzZSByZXR1cm4gYS5yYW5rIC0gYi5yYW5rOyBcbn07XG5cbnByb3RvLnByb3BhZ2F0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciB2LCBsLCBuLCBwLCByLCBpLCBsZW4sIHJlZmxvd2VkO1xuXG4gIC8vIG5ldyBQUSB3aXRoIGVhY2ggcHJvcGFnYXRpb24gY3ljbGUgc28gdGhhdCB3ZSBjYW4gcHVsc2UgYnJhbmNoZXNcbiAgLy8gb2YgdGhlIGRhdGFmbG93IGdyYXBoIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuLCB3aGVuIGNyZWF0aW5nXG4gIC8vIGEgbmV3IGlubGluZSBkYXRhc291cmNlKS5cbiAgdmFyIHBxID0gbmV3IEhlYXAoc2NoZWR1bGUpOyBcblxuICBpZihwdWxzZS5zdGFtcCkgdGhyb3cgXCJQdWxzZSBhbHJlYWR5IGhhcyBhIG5vbi16ZXJvIHN0YW1wXCJcblxuICBwdWxzZS5zdGFtcCA9ICsrdGhpcy5fc3RhbXA7XG4gIHBxLnB1c2goeyBub2RlOiBub2RlLCBwdWxzZTogcHVsc2UsIHJhbms6IG5vZGUucmFuaygpIH0pO1xuXG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnBvcCgpLCBuID0gdi5ub2RlLCBwID0gdi5wdWxzZSwgciA9IHYucmFuaywgbCA9IG4uX2xpc3RlbmVycztcbiAgICByZWZsb3dlZCA9IHAucmVmbG93ICYmIG4ubGFzdCgpID49IHAuc3RhbXA7XG5cbiAgICBpZihyZWZsb3dlZCkgY29udGludWU7IC8vIERvbid0IG5lZWRsZXNzbHkgcmVmbG93IG9wcy5cblxuICAgIC8vIEEgbm9kZSdzIHJhbmsgbWlnaHQgY2hhbmdlIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuIGluc3RhbnRpYXRpbmdcbiAgICAvLyBhIGdyb3VwJ3MgZGF0YWZsb3cgYnJhbmNoKS4gUmUtcXVldWUgaWYgaXQgaGFzLiBUXG4gICAgLy8gVE9ETzogdXNlIHBxLnJlcGxhY2Ugb3IgcHEucG9wcHVzaD9cbiAgICBpZihyICE9IG4ucmFuaygpKSB7XG4gICAgICBkZWJ1ZyhwLCBbJ1JhbmsgbWlzbWF0Y2gnLCByLCBuLnJhbmsoKV0pO1xuICAgICAgcHEucHVzaCh7IG5vZGU6IG4sIHB1bHNlOiBwLCByYW5rOiBuLnJhbmsoKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHAgPSB0aGlzLmV2YWx1YXRlKHAsIG4pO1xuXG4gICAgLy8gRXZlbiBpZiB3ZSBkaWRuJ3QgcnVuIHRoZSBub2RlLCB3ZSBzdGlsbCB3YW50IHRvIHByb3BhZ2F0ZSBcbiAgICAvLyB0aGUgcHVsc2UuIFxuICAgIGlmIChwICE9PSB0aGlzLmRvTm90UHJvcGFnYXRlKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBxLnB1c2goeyBub2RlOiBsW2ldLCBwdWxzZTogcCwgcmFuazogbFtpXS5fcmFuayB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENvbm5lY3QgYSBicmFuY2ggb2YgZGF0YWZsb3cgbm9kZXMuIFxuLy8gRGVwZW5kZW5jaWVzIGdldCB3aXJlZCB0byB0aGUgbmVhcmVzdCBjb2xsZWN0b3IuIFxuZnVuY3Rpb24gZm9yRWFjaE5vZGUoYnJhbmNoLCBmbikge1xuICB2YXIgbm9kZSwgY29sbGVjdG9yLCBpLCBsZW47XG4gIGZvcihpPTAsIGxlbj1icmFuY2gubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbm9kZSA9IGJyYW5jaFtpXTtcbiAgICBpZihub2RlLmNvbGxlY3RvcigpKSBjb2xsZWN0b3IgPSBub2RlO1xuICAgIGZuKG5vZGUsIGNvbGxlY3RvciwgaSk7XG4gIH1cbn1cblxucHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uKGJyYW5jaCkge1xuICBkZWJ1Zyh7fSwgWydjb25uZWN0aW5nJ10pO1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBmb3JFYWNoTm9kZShicmFuY2gsIGZ1bmN0aW9uKG4sIGMsIGkpIHtcbiAgICB2YXIgZGF0YSA9IG4uZGVwZW5kZW5jeShDLkRBVEEpLFxuICAgICAgICBzaWduYWxzID0gbi5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG5cbiAgICBpZihkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IFxuICAgICAgICBncmFwaC5kYXRhKGQpXG4gICAgICAgICAgLnJldmlzZXMobi5yZXZpc2VzKCkpXG4gICAgICAgICAgLmFkZExpc3RlbmVyKGMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoc2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBncmFwaC5zaWduYWwocykuYWRkTGlzdGVuZXIoYyk7IH0pO1xuICAgIH1cblxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBicmFuY2hbaS0xXS5hZGRMaXN0ZW5lcihicmFuY2hbaV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgZGVidWcoe30sIFsnZGlzY29ubmVjdGluZyddKTtcbiAgdmFyIGdyYXBoID0gdGhpcztcblxuICBmb3JFYWNoTm9kZShicmFuY2gsIGZ1bmN0aW9uKG4sIGMsIGkpIHtcbiAgICB2YXIgZGF0YSA9IG4uZGVwZW5kZW5jeShDLkRBVEEpLFxuICAgICAgICBzaWduYWxzID0gbi5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG5cbiAgICBpZihkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IGdyYXBoLmRhdGEoZCkucmVtb3ZlTGlzdGVuZXIoYyk7IH0pO1xuICAgIH1cblxuICAgIGlmKHNpZ25hbHMubGVuZ3RoID4gMCkge1xuICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgZ3JhcGguc2lnbmFsKHMpLnJlbW92ZUxpc3RlbmVyKGMpIH0pO1xuICAgIH1cblxuICAgIG4uZGlzY29ubmVjdCgpOyAgXG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90by5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgdmFyIHJlZmxvd2VkID0gIXB1bHNlLnJlZmxvdyB8fCAocHVsc2UucmVmbG93ICYmIG5vZGUubGFzdCgpID49IHB1bHNlLnN0YW1wKSxcbiAgICAgIHJ1biA9ICEhcHVsc2UuYWRkLmxlbmd0aCB8fCAhIXB1bHNlLnJlbS5sZW5ndGggfHwgbm9kZS5yb3V0ZXIoKTtcbiAgcnVuID0gcnVuIHx8ICFyZWZsb3dlZDtcbiAgcmV0dXJuIHJ1biB8fCBub2RlLnJlZXZhbHVhdGUocHVsc2UpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICBpZighdGhpcy5yZWV2YWx1YXRlKHB1bHNlLCBub2RlKSkgcmV0dXJuIHB1bHNlO1xuICBwdWxzZSA9IG5vZGUuZXZhbHVhdGUocHVsc2UpO1xuICBub2RlLmxhc3QocHVsc2Uuc3RhbXApO1xuICByZXR1cm4gcHVsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIFJFRVZBTCA9IFtDLkRBVEEsIEMuRklFTERTLCBDLlNDQUxFUywgQy5TSUdOQUxTXTtcblxudmFyIG5vZGVfaWQgPSAxO1xuXG5mdW5jdGlvbiBOb2RlKGdyYXBoKSB7XG4gIGlmKGdyYXBoKSB0aGlzLmluaXQoZ3JhcGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gTm9kZS5wcm90b3R5cGU7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLl9pZCA9IG5vZGVfaWQrKztcbiAgdGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5fcmFuayA9ICsrZ3JhcGguX3Jhbms7IC8vIEZvciB0b3BvbG9naWFsIHNvcnRcbiAgdGhpcy5fc3RhbXAgPSAwOyAgLy8gTGFzdCBzdGFtcCBzZWVuXG5cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX3JlZ2lzdGVyZWQgPSB7fTsgLy8gVG8gcHJldmVudCBkdXBsaWNhdGUgbGlzdGVuZXJzXG5cbiAgdGhpcy5fZGVwcyA9IHtcbiAgICBkYXRhOiAgICBbXSxcbiAgICBmaWVsZHM6ICBbXSxcbiAgICBzY2FsZXM6ICBbXSxcbiAgICBzaWduYWxzOiBbXSxcbiAgfTtcblxuICB0aGlzLl9pc1JvdXRlciA9IGZhbHNlOyAvLyBSZXNwb25zaWJsZSBmb3IgcHJvcGFnYXRpbmcgdHVwbGVzLCBjYW5ub3QgZXZlciBiZSBza2lwcGVkXG4gIHRoaXMuX2lzQ29sbGVjdG9yID0gZmFsc2U7ICAvLyBIb2xkcyBhIG1hdGVyaWFsaXplZCBkYXRhc2V0LCBwdWxzZSB0byByZWZsb3dcbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAvLyBEb2VzIHRoZSBvcGVyYXRvciByZXF1aXJlIHR1cGxlcycgcHJldmlvdXMgdmFsdWVzPyBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKTtcbiAgbi5ldmFsdWF0ZSA9IHRoaXMuZXZhbHVhdGU7XG4gIG4uX2RlcHMgPSB0aGlzLl9kZXBzO1xuICBuLl9pc1JvdXRlciA9IHRoaXMuX2lzUm91dGVyO1xuICBuLl9pc0NvbGxlY3RvciA9IHRoaXMuX2lzQ29sbGVjdG9yO1xuICByZXR1cm4gbjtcbn07XG5cbnByb3RvLnJhbmsgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3Jhbms7IH07XG5cbnByb3RvLmxhc3QgPSBmdW5jdGlvbihzdGFtcCkgeyBcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zdGFtcDtcbiAgdGhpcy5fc3RhbXAgPSBzdGFtcDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICB2YXIgZCA9IHRoaXMuX2RlcHNbdHlwZV07XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBkO1xuICBpZihkZXBzID09PSBudWxsKSB7IC8vIENsZWFyIGRlcGVuZGVuY2llcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgIHdoaWxlKGQubGVuZ3RoID4gMCkgZC5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBpZighZGwuaXNBcnJheShkZXBzKSAmJiBkLmluZGV4T2YoZGVwcykgPCAwKSBkLnB1c2goZGVwcyk7XG4gICAgZWxzZSBkLnB1c2guYXBwbHkoZCwgZGwuYXJyYXkoZGVwcykpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucm91dGVyID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2lzUm91dGVyO1xuICB0aGlzLl9pc1JvdXRlciA9ICEhYm9vbFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmNvbGxlY3RvciA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pc0NvbGxlY3RvcjtcbiAgdGhpcy5faXNDb2xsZWN0b3IgPSAhIWJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuICB0aGlzLl9yZXZpc2VzID0gISFib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIGlmKCEobCBpbnN0YW5jZW9mIE5vZGUpKSB0aHJvdyBcIkxpc3RlbmVyIGlzIG5vdCBhIE5vZGVcIjtcbiAgaWYodGhpcy5fcmVnaXN0ZXJlZFtsLl9pZF0pIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX2xpc3RlbmVycy5wdXNoKGwpO1xuICB0aGlzLl9yZWdpc3RlcmVkW2wuX2lkXSA9IDE7XG4gIGlmKHRoaXMuX3JhbmsgPiBsLl9yYW5rKSB7XG4gICAgdmFyIHEgPSBbbF07XG4gICAgd2hpbGUocS5sZW5ndGgpIHtcbiAgICAgIHZhciBjdXIgPSBxLnNwbGljZSgwLDEpWzBdO1xuICAgICAgY3VyLl9yYW5rID0gKyt0aGlzLl9ncmFwaC5fcmFuaztcbiAgICAgIHEucHVzaC5hcHBseShxLCBjdXIuX2xpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsKSB7XG4gIHZhciBmb3VuZFNlbmRpbmcgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW4gJiYgIWZvdW5kU2VuZGluZzsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tpXSA9PT0gbCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRbbC5faWRdID0gbnVsbDtcbiAgICAgIGZvdW5kU2VuZGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZm91bmRTZW5kaW5nO1xufTtcblxucHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5fcmVnaXN0ZXJlZCA9IHt9O1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkgeyByZXR1cm4gcHVsc2U7IH1cblxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHZhciBub2RlID0gdGhpcywgcmVldmFsID0gZmFsc2U7XG4gIHJldHVybiBSRUVWQUwuc29tZShmdW5jdGlvbihwcm9wKSB7XG4gICAgcmVldmFsID0gcmVldmFsIHx8IG5vZGUuX2RlcHNbcHJvcF0uc29tZShmdW5jdGlvbihrKSB7IHJldHVybiAhIXB1bHNlW3Byb3BdW2tdIH0pO1xuICAgIHJldHVybiByZWV2YWw7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlOyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gU2lnbmFsKGdyYXBoLCBuYW1lLCBpbml0KSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX25hbWUgID0gbmFtZTtcbiAgdGhpcy5fdmFsdWUgPSBpbml0O1xuICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBwcm90byA9IChTaWduYWwucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLm5hbWUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH07XG5cbnByb3RvLnZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIHRoaXMuX3ZhbHVlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmZpcmUgPSBmdW5jdGlvbihjcykge1xuICBpZighY3MpIGNzID0gY2hhbmdlc2V0LmNyZWF0ZShudWxsLCB0cnVlKTtcbiAgY3Muc2lnbmFsc1t0aGlzLl9uYW1lXSA9IDE7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShjcywgdGhpcyk7XG59O1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIHNnID0gdGhpcyxcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCk7XG5cbiAgbm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIChoYW5kbGVyKHNnLm5hbWUoKSwgc2cudmFsdWUoKSksIGlucHV0KTtcbiAgfTtcblxuICB0aGlzLl9oYW5kbGVycy5wdXNoKHsgaGFuZGxlcjogaGFuZGxlciwgbm9kZTogbm9kZSB9KTtcbiAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIobm9kZSk7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHZhciBzZyA9IHRoaXMsIGggPSB0aGlzLl9oYW5kbGVycztcbiAgZm9yKHZhciBpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBzZy5yZW1vdmVMaXN0ZW5lcihoLnNwbGljZShpLCAxKVswXS5ub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbDsiLCJ2YXIgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG52YXIgUkVFVkFMID0gW0MuREFUQSwgQy5GSUVMRFMsIEMuU0NBTEVTLCBDLlNJR05BTFNdO1xuXG5mdW5jdGlvbiBjcmVhdGUoY3MsIHJlZmxvdykge1xuICB2YXIgb3V0ID0ge307XG4gIGNvcHkoY3MsIG91dCk7XG5cbiAgb3V0LmFkZCA9IFtdO1xuICBvdXQubW9kID0gW107XG4gIG91dC5yZW0gPSBbXTtcblxuICBvdXQucmVmbG93ID0gcmVmbG93O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHJlc2V0X3ByZXYoeCkge1xuICB4Ll9wcmV2ID0gKHguX3ByZXYgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiBDLlNFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShjcykge1xuICBmb3IoaT0wLCBsZW49Y3MuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkgcmVzZXRfcHJldihjcy5hZGRbaV0pO1xuICBmb3IoaT0wLCBsZW49Y3MubW9kLmxlbmd0aDsgaTxsZW47ICsraSkgcmVzZXRfcHJldihjcy5tb2RbaV0pO1xufVxuXG5mdW5jdGlvbiBjb3B5KGEsIGIpIHtcbiAgYi5zdGFtcCA9IGEgPyBhLnN0YW1wIDogMDtcbiAgYi5zb3J0ICA9IGEgPyBhLnNvcnQgIDogbnVsbDtcbiAgYi5mYWNldCA9IGEgPyBhLmZhY2V0IDogbnVsbDtcbiAgYi50cmFucyA9IGEgPyBhLnRyYW5zIDogbnVsbDtcbiAgYi5yZXF1ZXN0ID0gYSA/IGEucmVxdWVzdCA6IG51bGw7XG4gIFJFRVZBTC5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgYltkXSA9IGEgPyBhW2RdIDoge307IH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNvcHk6IGNvcHksXG4gIGZpbmFsaXplOiBmaW5hbGl6ZSxcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIHR1cGxlX2lkID0gMTtcblxuLy8gT2JqZWN0LmNyZWF0ZSBpcyBleHBlbnNpdmUuIFNvLCB3aGVuIGluZ2VzdGluZywgdHJ1c3QgdGhhdCB0aGVcbi8vIGRhdHVtIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBiZWVuIGFwcHJvcHJpYXRlbHkgc2FuZGJveGVkIGZyb20gXG4vLyB0aGUgb3V0c2lkZSBlbnZpcm9ubWVudC4gXG5mdW5jdGlvbiBpbmdlc3QoZGF0dW0sIHByZXYpIHtcbiAgZGF0dW0gPSBkbC5pc09iamVjdChkYXR1bSkgPyBkYXR1bSA6IHtkYXRhOiBkYXR1bX07XG4gIGRhdHVtLl9pZCA9IHR1cGxlX2lkKys7XG4gIGRhdHVtLl9wcmV2ID0gKHByZXYgIT09IHVuZGVmaW5lZCkgPyAocHJldiB8fCBDLlNFTlRJTkVMKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGRhdHVtO1xufVxuXG5mdW5jdGlvbiBkZXJpdmUoZGF0dW0sIHByZXYpIHtcbiAgcmV0dXJuIGluZ2VzdChPYmplY3QuY3JlYXRlKGRhdHVtKSwgcHJldik7XG59XG5cbi8vIFdBUk5JTkc6IG9wZXJhdG9ycyBzaG91bGQgb25seSBjYWxsIHRoaXMgb25jZSBwZXIgdGltZXN0YW1wIVxuZnVuY3Rpb24gc2V0KHQsIGssIHYpIHtcbiAgdmFyIHByZXYgPSB0W2tdO1xuICBpZihwcmV2ID09PSB2KSByZXR1cm47XG4gIHNldF9wcmV2KHQsIGspO1xuICB0W2tdID0gdjtcbn1cblxuZnVuY3Rpb24gc2V0X3ByZXYodCwgaykge1xuICBpZih0Ll9wcmV2ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgdC5fcHJldiA9ICh0Ll9wcmV2ID09PSBDLlNFTlRJTkVMKSA/IHt9IDogdC5fcHJldjtcbiAgdC5fcHJldltrXSA9IHRba107XG59XG5cbi8vIFNwb29mIHRoZSBwcmV2aW91cyB0dXBsZVxuZnVuY3Rpb24gcHJldih0KSB7XG4gIHJldHVybiBkbC5leHRlbmQoZGwuZHVwbGljYXRlKHQpLCB0Ll9wcmV2KTtcbn1cblxuZnVuY3Rpb24gaGFzX3ByZXYodCkge1xuICByZXR1cm4gdC5fcHJldiAmJiB0Ll9wcmV2ICE9PSBDLlNFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHsgdHVwbGVfaWQgPSAxOyB9XG5cbmZ1bmN0aW9uIGlkTWFwKGEpIHtcbiAgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uKG0seCkge1xuICAgIHJldHVybiAobVt4Ll9pZF0gPSAxLCBtKTtcbiAgfSwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluZ2VzdDogaW5nZXN0LFxuICBkZXJpdmU6IGRlcml2ZSxcbiAgc2V0OiAgICBzZXQsXG4gIHByZXY6ICAgcHJldixcbiAgc2V0X3ByZXY6IHNldF9wcmV2LFxuICBoYXNfcHJldjogaGFzX3ByZXYsXG4gIHJlc2V0OiAgcmVzZXQsXG4gIGlkTWFwOiAgaWRNYXBcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBjb25zdGFudHMgPSBvcHQuY29uc3RhbnRzIHx8IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG4gIHZhciBmdW5jdGlvbnMgPSAob3B0LmZ1bmN0aW9ucyB8fCByZXF1aXJlKCcuL2Z1bmN0aW9ucycpKShjb2RlZ2VuKTtcbiAgdmFyIGlkV2hpdGVMaXN0ID0gb3B0LmlkV2hpdGVMaXN0ID8gZGwudG9NYXAob3B0LmlkV2hpdGVMaXN0KSA6IG51bGw7XG4gIHZhciBpZEJsYWNrTGlzdCA9IG9wdC5pZEJsYWNrTGlzdCA/IGRsLnRvTWFwKG9wdC5pZEJsYWNrTGlzdCkgOiBudWxsO1xuICB2YXIgbWVtYmVyRGVwdGggPSAwO1xuXG4gIC8vIFRPRE8gZ2VuZXJhbGl6ZT9cbiAgdmFyIERBVFVNID0gJ2QnO1xuICB2YXIgU0lHTkFMX1BSRUZJWCA9ICdzZy4nO1xuICB2YXIgc2lnbmFscyA9IHt9O1xuICB2YXIgZmllbGRzID0ge307XG5cbiAgZnVuY3Rpb24gY29kZWdlbl93cmFwKGFzdCkgeyAgICBcbiAgICB2YXIgcmV0dmFsID0ge1xuICAgICAgZm46IGNvZGVnZW4oYXN0KSxcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoc2lnbmFscyksXG4gICAgICBmaWVsZHM6IGRsLmtleXMoZmllbGRzKVxuICAgIH07XG4gICAgc2lnbmFscyA9IHt9O1xuICAgIGZpZWxkcyA9IHt9O1xuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBjb2RlZ2VuKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiBhc3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IENPREVHRU5fVFlQRVNbYXN0LnR5cGVdO1xuICAgIGlmIChnZW5lcmF0b3IgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZTogXCIgKyBhc3QudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0b3IoYXN0KTtcbiAgfVxuXG4gIHZhciBDT0RFR0VOX1RZUEVTID0ge1xuICAgIFwiTGl0ZXJhbFwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLnJhdztcbiAgICAgIH0sXG4gICAgXCJJZGVudGlmaWVyXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGlkID0gbi5uYW1lO1xuICAgICAgICBpZiAobWVtYmVyRGVwdGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0YW50c1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkV2hpdGVMaXN0KSB7XG4gICAgICAgICAgaWYgKGlkV2hpdGVMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWduYWxzW2lkXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gU0lHTkFMX1BSRUZJWCArIGlkOyAvLyBIQUNLaXNoLi4uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZEJsYWNrTGlzdCAmJiBpZEJsYWNrTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGlkZW50aWZpZXI6IFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0sXG4gICAgXCJQcm9ncmFtXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4uYm9keS5tYXAoY29kZWdlbikuam9pbihcIlxcblwiKTtcbiAgICAgIH0sXG4gICAgXCJNZW1iZXJFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGQgPSAhbi5jb21wdXRlZDtcbiAgICAgICAgdmFyIG8gPSBjb2RlZ2VuKG4ub2JqZWN0KTtcbiAgICAgICAgaWYgKGQpIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBwID0gY29kZWdlbihuLnByb3BlcnR5KTtcbiAgICAgICAgaWYgKG8gPT09IERBVFVNKSB7IGZpZWxkc1twXSA9IDE7IH0gLy8gSEFDS2lzaC4uLlxuICAgICAgICBpZiAoZCkgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgICAgcmV0dXJuIG8gKyAoZCA/IFwiLlwiK3AgOiBcIltcIitwK1wiXVwiKTtcbiAgICAgIH0sXG4gICAgXCJDYWxsRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmIChuLmNhbGxlZS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgY2FsbGVlIHR5cGU6IFwiICsgbi5jYWxsZWUudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxlZSA9IG4uY2FsbGVlLm5hbWU7XG4gICAgICAgIHZhciBhcmdzID0gbi5hcmd1bWVudHM7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShjYWxsZWUpICYmIGZ1bmN0aW9uc1tjYWxsZWVdO1xuICAgICAgICBpZiAoIWZuKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZnVuY3Rpb246IFwiICsgY2FsbGVlKTtcbiAgICAgICAgcmV0dXJuIGZuIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICA/IGZuKGFyZ3MpXG4gICAgICAgICAgOiBmbiArIFwiKFwiICsgYXJncy5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJBcnJheUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyBuLmVsZW1lbnRzLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgfSxcbiAgICBcIkJpbmFyeUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBjb2RlZ2VuKG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLnJpZ2h0KSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIlVuYXJ5RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4uYXJndW1lbnQpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiVXBkYXRlRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIChwcmVmaXhcbiAgICAgICAgICA/IG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4uYXJndW1lbnQpXG4gICAgICAgICAgOiBjb2RlZ2VuKG4uYXJndW1lbnQpICsgbi5vcGVyYXRvclxuICAgICAgICApICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgY29kZWdlbihuLnRlc3QpXG4gICAgICAgICAgKyBcIj9cIiArIGNvZGVnZW4obi5jb25zZXF1ZW50KVxuICAgICAgICAgICsgXCI6XCIgKyBjb2RlZ2VuKG4uYWx0ZXJuYXRlKVxuICAgICAgICAgICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiTG9naWNhbEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBjb2RlZ2VuKG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLnJpZ2h0KSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIk9iamVjdEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBuLnByb3BlcnRpZXMubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICB9LFxuICAgIFwiUHJvcGVydHlcIjogZnVuY3Rpb24obikge1xuICAgICAgICBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgICB2YXIgayA9IGNvZGVnZW4obi5rZXkpO1xuICAgICAgICBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgICByZXR1cm4gayArIFwiOlwiICsgY29kZWdlbihuLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW4obi5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiBjb2RlZ2VuX3dyYXA7XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIk5hTlwiOiAgICAgXCJOYU5cIixcbiAgXCJFXCI6ICAgICAgIFwiTWF0aC5FXCIsXG4gIFwiTE4yXCI6ICAgICBcIk1hdGguTE4yXCIsXG4gIFwiTE4xMFwiOiAgICBcIk1hdGguTE4xMFwiLFxuICBcIkxPRzJFXCI6ICAgXCJNYXRoLkxPRzJFXCIsXG4gIFwiTE9HMTBFXCI6ICBcIk1hdGguTE9HMTBFXCIsXG4gIFwiUElcIjogICAgICBcIk1hdGguUElcIixcbiAgXCJTUVJUMV8yXCI6IFwiTWF0aC5TUVJUMV8yXCIsXG4gIFwiU1FSVDJcIjogICBcIk1hdGguU1FSVDJcIlxufTsiLCJ2YXIgZGF0YWxpYiA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2RlZ2VuKSB7XG5cbiAgZnVuY3Rpb24gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpIHtcbiAgICB2YXIgb2JqID0gY29kZWdlbihhcmdzWzBdKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgb2JqID0gY2FzdCArIFwiKFwiICsgb2JqICsgXCIpXCI7XG4gICAgICBpZiAoZGwuc3RhcnRzV2l0aChjYXN0LCBcIm5ldyBcIikpIG9iaiA9IFwiKFwiICsgb2JqICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBvYmogKyBcIi5cIiArIG5hbWUgKyAodHlwZSA8IDAgPyBcIlwiIDogdHlwZSA9PT0gMFxuICAgICAgPyBcIigpXCJcbiAgICAgIDogXCIoXCIgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgfVxuICBcbiAgdmFyIERBVEUgPSBcIm5ldyBEYXRlXCI7XG4gIHZhciBTVFJJTkcgPSBcIlN0cmluZ1wiO1xuICB2YXIgUkVHRVhQID0gXCJSZWdFeHBcIjtcblxuICByZXR1cm4ge1xuICAgIC8vIE1BVEggZnVuY3Rpb25zXG4gICAgXCJpc05hTlwiOiAgICBcImlzTmFOXCIsXG4gICAgXCJpc0Zpbml0ZVwiOiBcImlzRmluaXRlXCIsXG4gICAgXCJhYnNcIjogICAgICBcIk1hdGguYWJzXCIsXG4gICAgXCJhY29zXCI6ICAgICBcIk1hdGguYWNvc1wiLFxuICAgIFwiYXNpblwiOiAgICAgXCJNYXRoLmFzaW5cIixcbiAgICBcImF0YW5cIjogICAgIFwiTWF0aC5hdGFuXCIsXG4gICAgXCJhdGFuMlwiOiAgICBcIk1hdGguYXRhbjJcIixcbiAgICBcImNlaWxcIjogICAgIFwiTWF0aC5jZWlsXCIsXG4gICAgXCJjb3NcIjogICAgICBcIk1hdGguY29zXCIsXG4gICAgXCJleHBcIjogICAgICBcIk1hdGguZXhwXCIsXG4gICAgXCJmbG9vclwiOiAgICBcIk1hdGguZmxvb3JcIixcbiAgICBcImxvZ1wiOiAgICAgIFwiTWF0aC5sb2dcIixcbiAgICBcIm1heFwiOiAgICAgIFwiTWF0aC5tYXhcIixcbiAgICBcIm1pblwiOiAgICAgIFwiTWF0aC5taW5cIixcbiAgICBcInBvd1wiOiAgICAgIFwiTWF0aC5wb3dcIixcbiAgICBcInJhbmRvbVwiOiAgIFwiTWF0aC5yYW5kb21cIixcbiAgICBcInJvdW5kXCI6ICAgIFwiTWF0aC5yb3VuZFwiLFxuICAgIFwic2luXCI6ICAgICAgXCJNYXRoLnNpblwiLFxuICAgIFwic3FydFwiOiAgICAgXCJNYXRoLnNxcnRcIixcbiAgICBcInRhblwiOiAgICAgIFwiTWF0aC50YW5cIixcblxuICAgIC8vIERBVEUgZnVuY3Rpb25zXG4gICAgXCJub3dcIjogICAgICBcIkRhdGUubm93XCIsXG4gICAgXCJkYXRldGltZVwiOiBcIm5ldyBEYXRlXCIsXG4gICAgXCJkYXRlXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldERhdGVcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwiZGF5XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldERheVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ5ZWFyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldEZ1bGxZZWFyXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcIm1vbnRoXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldE1vbnRoXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcImhvdXJzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldEhvdXJzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcIm1pbnV0ZXNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0TWludXRlc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFNlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwibWlsbGlzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldE1pbGxpc2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ0aW1lXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFRpbWVcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidGltZXpvbmVvZmZzZXRcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VGltZXpvbmVPZmZzZXRcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjZGF0ZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENEYXRlXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y2RheVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENEYXlcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjeWVhclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENGdWxsWWVhclwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNtb250aFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENNb250aFwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNob3Vyc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENIb3Vyc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNtaW51dGVzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ01pbnV0ZXNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjc2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENTZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y21pbGxpc2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENNaWxsaXNlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuXG4gICAgLy8gc2hhcmVkIHNlcXVlbmNlIGZ1bmN0aW9uc1xuICAgIFwibGVuZ3RoXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImxlbmd0aFwiLCBhcmdzLCBudWxsLCAtMSk7XG4gICAgICB9LFxuICAgIFwiaW5kZXhvZlwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJpbmRleE9mXCIsIGFyZ3MsIG51bGwpO1xuICAgICAgfSxcbiAgICBcImxhc3RpbmRleG9mXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImxhc3RJbmRleE9mXCIsIGFyZ3MsIG51bGwpO1xuICAgICAgfSxcblxuICAgIC8vIFNUUklORyBmdW5jdGlvbnNcbiAgICBcInBhcnNlRmxvYXRcIjogXCJwYXJzZUZsb2F0XCIsXG4gICAgXCJwYXJzZUludFwiOiBcInBhcnNlSW50XCIsXG4gICAgXCJ1cHBlclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJ0b1VwcGVyQ2FzZVwiLCBhcmdzLCBTVFJJTkcsIDApO1xuICAgICAgfSxcbiAgICBcImxvd2VyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInRvTG93ZXJDYXNlXCIsIGFyZ3MsIFNUUklORywgMCk7XG4gICAgICB9LFxuICAgIFwic2xpY2VcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwic2xpY2VcIiwgYXJncywgU1RSSU5HKTtcbiAgICAgIH0sXG4gICAgXCJzdWJzdHJpbmdcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwic3Vic3RyaW5nXCIsIGFyZ3MsIFNUUklORyk7XG4gICAgICB9LFxuXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgIFwidGVzdFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJ0ZXN0XCIsIGFyZ3MsIFJFR0VYUCk7XG4gICAgICB9LFxuICAgIFxuICAgIC8vIENvbnRyb2wgRmxvdyBmdW5jdGlvbnNcbiAgICBcImlmXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi5cIik7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBtYW55IGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi5cIik7XG4gICAgICAgIHZhciBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICAgIHJldHVybiBhWzBdK1wiP1wiK2FbMV0rXCI6XCIrYVsyXTtcbiAgICAgIH1cbiAgfTtcbn07IiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyksXG4gICAgY29kZWdlbiA9IHJlcXVpcmUoJy4vY29kZWdlbicpO1xuICAgIFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgb3B0KSB7IHJldHVybiBwYXJzZXIucGFyc2UoXCIoXCIraW5wdXQrXCIpXCIsIG9wdCk7IH0sXG4gIGNvZGU6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gY29kZWdlbihvcHQpOyB9XG59O1xuIiwiLypcbiAgVGhlIGZvbGxvd2luZyBleHByZXNzaW9uIHBhcnNlciBpcyBiYXNlZCBvbiBFc3ByaW1hIChodHRwOi8vZXNwcmltYS5vcmcvKS5cbiAgT3JpZ2luYWwgaGVhZGVyIGNvbW1lbnQgYW5kIGxpY2Vuc2UgZm9yIEVzcHJpbWEgaXMgaW5jbHVkZWQgaGVyZTpcblxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBUb2tlbixcbiAgICAgIFRva2VuTmFtZSxcbiAgICAgIFN5bnRheCxcbiAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgIE1lc3NhZ2VzLFxuICAgICAgUmVnZXgsXG4gICAgICBzb3VyY2UsXG4gICAgICBzdHJpY3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxpbmVOdW1iZXIsXG4gICAgICBsaW5lU3RhcnQsXG4gICAgICBsZW5ndGgsXG4gICAgICBsb29rYWhlYWQsXG4gICAgICBzdGF0ZSxcbiAgICAgIGV4dHJhO1xuXG4gIFRva2VuID0ge1xuICAgICAgQm9vbGVhbkxpdGVyYWw6IDEsXG4gICAgICBFT0Y6IDIsXG4gICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgS2V5d29yZDogNCxcbiAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICBQdW5jdHVhdG9yOiA3LFxuICAgICAgU3RyaW5nTGl0ZXJhbDogOCxcbiAgICAgIFJlZ3VsYXJFeHByZXNzaW9uOiA5XG4gIH07XG5cbiAgVG9rZW5OYW1lID0ge307XG4gIFRva2VuTmFtZVtUb2tlbi5Cb29sZWFuTGl0ZXJhbF0gPSAnQm9vbGVhbic7XG4gIFRva2VuTmFtZVtUb2tlbi5FT0ZdID0gJzxlbmQ+JztcbiAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICBUb2tlbk5hbWVbVG9rZW4uS2V5d29yZF0gPSAnS2V5d29yZCc7XG4gIFRva2VuTmFtZVtUb2tlbi5OdWxsTGl0ZXJhbF0gPSAnTnVsbCc7XG4gIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gIFRva2VuTmFtZVtUb2tlbi5QdW5jdHVhdG9yXSA9ICdQdW5jdHVhdG9yJztcbiAgVG9rZW5OYW1lW1Rva2VuLlN0cmluZ0xpdGVyYWxdID0gJ1N0cmluZyc7XG4gIFRva2VuTmFtZVtUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbl0gPSAnUmVndWxhckV4cHJlc3Npb24nO1xuXG4gIFN5bnRheCA9IHtcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nXG4gIH07XG5cbiAgUHJvcGVydHlLaW5kID0ge1xuICAgICAgRGF0YTogMSxcbiAgICAgIEdldDogMixcbiAgICAgIFNldDogNFxuICB9O1xuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gIE1lc3NhZ2VzID0ge1xuICAgICAgVW5leHBlY3RlZFRva2VuOiAgJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgVW5leHBlY3RlZE51bWJlcjogICdVbmV4cGVjdGVkIG51bWJlcicsXG4gICAgICBVbmV4cGVjdGVkU3RyaW5nOiAgJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcbiAgICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAgJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcbiAgICAgIFVuZXhwZWN0ZWRFT1M6ICAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgTmV3bGluZUFmdGVyVGhyb3c6ICAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG4gICAgICBJbnZhbGlkTEhTSW5Gb3JJbjogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxuICAgICAgTm9DYXRjaE9yRmluYWxseTogICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXG4gICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXG4gICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdE1vZGVXaXRoOiAgJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxuICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFZhck5hbWU6ICAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFBhcmFtTmFtZTogICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdERlbGV0ZTogICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgU3RyaWN0RHVwbGljYXRlUHJvcGVydHk6ICAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIGRhdGEgYW5kIGFjY2Vzc29yIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBBY2Nlc3NvckdldFNldDogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgbXVsdGlwbGUgZ2V0L3NldCBhY2Nlc3NvcnMgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RMSFNQb3N0Zml4OiAgJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RMSFNQcmVmaXg6ICAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAgJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZSdcbiAgfTtcblxuICAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuICBSZWdleCA9IHtcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpLFxuICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gIC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXG5cbiAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KTsgICAvLyAwLi45XG4gIH1cblxuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gIH1cblxuICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XG4gIH1cblxuICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgfVxuXG4gIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSkgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gIGZ1bmN0aW9uIGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICBjYXNlICdlbnVtJzpcbiAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICBjYXNlICdleHRlbmRzJzpcbiAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICBjYXNlICdzdXBlcic6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIDcuNi4xLjEgS2V5d29yZHNcblxuICBmdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcbiAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAvLyAneWllbGQnIGFuZCAnbGV0JyBhcmUgZm9yIGNvbXBhdGlibGl0eSB3aXRoIFNwaWRlck1vbmtleSBhbmQgRVMubmV4dC5cbiAgICAgIC8vIFNvbWUgb3RoZXJzIGFyZSBmcm9tIGZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cblxuICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgIHZhciBjaCwgc3RhcnQ7XG5cbiAgICAgIHN0YXJ0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKSB7XG4gICAgICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBjb2RlID0gMDtcblxuICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVURi0xNiBFbmNvZGluZ1xuICAgICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICB9XG4gICAgICBjdTEgPSAoKGNvZGUgLSAweDEwMDAwKSA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICBjdTIgPSAoKGNvZGUgLSAweDEwMDAwKSAmIDEwMjMpICsgMHhEQzAwO1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3UxLCBjdTIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgY2gsIGlkO1xuXG4gICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KyspO1xuICAgICAgaWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkID0gY2g7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzdGFydCwgY2g7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICBpbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzdGFydCwgaWQsIHR5cGU7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICBpZCA9IChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUMpID8gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSA6IGdldElkZW50aWZpZXIoKTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLktleXdvcmQ7XG4gICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICB9IGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICAvLyA3LjcgUHVuY3R1YXRvcnNcblxuICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgIHZhciBzdGFydCA9IGluZGV4LFxuICAgICAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgICAgICAgY29kZTIsXG4gICAgICAgICAgY2gxID0gc291cmNlW2luZGV4XSxcbiAgICAgICAgICBjaDIsXG4gICAgICAgICAgY2gzLFxuICAgICAgICAgIGNoNDtcblxuICAgICAgc3dpdGNoIChjb2RlKSB7XG5cbiAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgY2FzZSAweDJFOiAgLy8gLiBkb3RcbiAgICAgIGNhc2UgMHgyODogIC8vICggb3BlbiBicmFja2V0XG4gICAgICBjYXNlIDB4Mjk6ICAvLyApIGNsb3NlIGJyYWNrZXRcbiAgICAgIGNhc2UgMHgzQjogIC8vIDsgc2VtaWNvbG9uXG4gICAgICBjYXNlIDB4MkM6ICAvLyAsIGNvbW1hXG4gICAgICBjYXNlIDB4N0I6ICAvLyB7IG9wZW4gY3VybHkgYnJhY2VcbiAgICAgIGNhc2UgMHg3RDogIC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcbiAgICAgIGNhc2UgMHg1QjogIC8vIFtcbiAgICAgIGNhc2UgMHg1RDogIC8vIF1cbiAgICAgIGNhc2UgMHgzQTogIC8vIDpcbiAgICAgIGNhc2UgMHgzRjogIC8vID9cbiAgICAgIGNhc2UgMHg3RTogIC8vIH5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4N0IpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29kZTIgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgICAgICAgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICAgICAgICBpZiAoY29kZTIgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMHgyQjogIC8vICtcbiAgICAgICAgICAgICAgY2FzZSAweDJEOiAgLy8gLVxuICAgICAgICAgICAgICBjYXNlIDB4MkY6ICAvLyAvXG4gICAgICAgICAgICAgIGNhc2UgMHgzQzogIC8vIDxcbiAgICAgICAgICAgICAgY2FzZSAweDNFOiAgLy8gPlxuICAgICAgICAgICAgICBjYXNlIDB4NUU6ICAvLyBeXG4gICAgICAgICAgICAgIGNhc2UgMHg3QzogIC8vIHxcbiAgICAgICAgICAgICAgY2FzZSAweDI1OiAgLy8gJVxuICAgICAgICAgICAgICBjYXNlIDB4MjY6ICAvLyAmXG4gICAgICAgICAgICAgIGNhc2UgMHgyQTogIC8vICpcbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUyKSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNhc2UgMHgyMTogLy8gIVxuICAgICAgICAgICAgICBjYXNlIDB4M0Q6IC8vID1cbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgICAgICAgICAgICAgIC8vICE9PSBhbmQgPT09XG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG4gICAgICBjaDQgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcblxuICAgICAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2g0LFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuICAgICAgY2gzID0gY2g0LnN1YnN0cigwLCAzKTtcblxuICAgICAgaWYgKGNoMyA9PT0gJz4+PicgfHwgY2gzID09PSAnPDw9JyB8fCBjaDMgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gzLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXIgMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ICsrIC0tIDw8ID4+ICYmIHx8XG4gICAgICBjaDIgPSBjaDMuc3Vic3RyKDAsIDIpO1xuXG4gICAgICBpZiAoKGNoMSA9PT0gY2gyWzFdICYmICgnKy08PiZ8Jy5pbmRleE9mKGNoMSkgPj0gMCkpIHx8IGNoMiA9PT0gJz0+Jykge1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xuXG4gICAgICBpZiAoJzw+PSErLSolJnxeLycuaW5kZXhPZihjaDEpID49IDApIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gIH1cblxuICAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnJztcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW1iZXIsIDE2KSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCkge1xuICAgICAgdmFyIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSB8fCBpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgIG9jdGFsOiB0cnVlLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksXG4gICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgbnVtYmVyID0gJyc7XG4gICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSGV4TGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgICAgICAgICAgaWYgKGNoICYmIGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICAvLyA3LjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0TGluZVN0YXJ0O1xuICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksXG4gICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgKytpbmRleDtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAgJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5TdHJpbmdMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXJ0TGluZVN0YXJ0OiBzdGFydExpbmVTdGFydCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgICAgdmFyIHRtcCA9IHBhdHRlcm4sXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBBU0NJSSBzeW1ib2wgdG8gYXZvaWQgdGhyb3dpbmcgb25cbiAgICAgICAgICAvLyByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGVcbiAgICAgICAgICAvLyBgL3VgIGZsYWcuXG4gICAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggdGhlIEFTQ0lJIHN5bWJvbCBgeGAgbWlnaHQgY2F1c2UgZmFsc2VcbiAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdFxuICAgICAgICAgIC8vIHdvdWxkIGJlIHJlcGxhY2VkIGJ5IGBbeC1iXWAgd2hpY2ggdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoJDEsIDE2KSA8PSAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgJ3gnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cCh0bXApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxuICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAgICAgLy8gdXNlcy5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBjbGFzc01hcmtlciwgdGVybWluYXRlZCwgYm9keTtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICAgICAgc3RyID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgdGVybWluYXRlZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIGJvZHkgPSBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEZsYWdzKCkge1xuICAgICAgdmFyIGNoLCBzdHIsIGZsYWdzLCByZXN0b3JlO1xuXG4gICAgICBzdHIgPSAnJztcbiAgICAgIGZsYWdzID0gJyc7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNvdXJjZVtyZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBmbGFncyxcbiAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgdmFsdWU7XG5cbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gICAgICBmbGFncyA9IHNjYW5SZWdFeHBGbGFncygpO1xuICAgICAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RSZWdleCgpIHtcbiAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxvYyA9IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1JlZ3VsYXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHJlZ2V4LmxpdGVyYWwsXG4gICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2V4O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkdmFuY2VTbGFzaCgpIHtcbiAgICAgIHZhciBwcmV2VG9rZW4sXG4gICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgIC8vIFVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cbiAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIXByZXZUb2tlbikge1xuICAgICAgICAgIC8vIE5vdGhpbmcgYmVmb3JlIHRoYXQ6IGl0IGNhbm5vdCBiZSBhIGRpdmlzaW9uLlxuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcbiAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuUGFyZW5Ub2tlbiAtIDFdO1xuICAgICAgICAgICAgICBpZiAoY2hlY2tUb2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGNoZWNrVG9rZW4udmFsdWUgPT09ICdpZicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3doaWxlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnZm9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2l0aCcpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXG4gICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDVdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmIHByZXZUb2tlbi52YWx1ZSAhPT0gJ3RoaXMnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgdmFyIGNoO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcbiAgICAgIGlmIChjaCA9PT0gMHgyOCB8fCBjaCA9PT0gMHgyOSB8fCBjaCA9PT0gMHgzQikge1xuICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICBpZiAoY2ggPT09IDB4MkUpIHtcbiAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2xhc2ggKC8pIFUrMDAyRiBjYW4gYWxzbyBzdGFydCBhIHJlZ2V4LlxuICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNoID09PSAweDJGKSB7XG4gICAgICAgICAgcmV0dXJuIGFkdmFuY2VTbGFzaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgIHZhciBsb2MsIHRva2VuLCB2YWx1ZSwgZW50cnk7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRva2VuID0gYWR2YW5jZSgpO1xuICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgIH07XG5cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJhbmdlOiBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB0b2tlbi5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IHRva2VuLnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgdmFyIHRva2VuO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcblxuICAgICAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0O1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG4gIH1cblxuICBmdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgICAgIHRoaXMubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICB0aGlzLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gU291cmNlTG9jYXRpb24oKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChzdGFydFRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFRva2VuLnN0YXJ0IC0gc3RhcnRUb2tlbi5zdGFydExpbmVTdGFydFxuICAgICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFRva2VuLnN0YXJ0IC0gc3RhcnRUb2tlbi5saW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICAgIC8vIFNraXAgY29tbWVudC5cbiAgICAgIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbG9va2FoZWFkLnN0YXJ0TGluZVN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLmxpbmVOdW1iZXI7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbG9va2FoZWFkLmxpbmVTdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbaW5kZXgsIDBdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikge1xuICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9jLmVuZCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgICAgICAgICBpZiAoZXh0cmEuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvYy5zb3VyY2UgPSBleHRyYS5zb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpID8gU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDogU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DYWxsRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaElkZW50aWZpZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoTGl0ZXJhbDogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIHRoaXMucmF3ID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5yYXcgPT0gJy8vJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3ID0gJy8oPzopLyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5yZWdleCA9IHRva2VuLnJlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb2dyYW07XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoUHJvcGVydHk6IGZ1bmN0aW9uIChraW5kLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb3BlcnR5O1xuICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICcrKycgfHwgb3BlcmF0b3IgPT09ICctLScpID8gU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24gOiBTeW50YXguVW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSBsaW5lIHRlcm1pbmF0b3IgYmVmb3JlIHRoZSBuZXh0IHRva2VuLlxuXG4gIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0LCBmb3VuZDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICAgICAgdmFyIGVycm9yLFxuICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgLyUoXFxkKS9nLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBhc3NlcnQoaW5kZXggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgdG9rZW4ubGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgIGVycm9yLmluZGV4ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgICAgZXJyb3IuY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgZXJyb3IuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgfVxuXG4gICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IG1zZztcbiAgICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhyb3dFcnJvclRvbGVyYW50KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvd0Vycm9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG5cbiAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxuXG4gIGZ1bmN0aW9uIHRocm93VW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgaWYgKGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb29sZWFuTGl0ZXJhbCwgTnVsbExpdGVyYWwsIG9yIFB1bmN0dWF0b3IuXG4gICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG4gIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGV4cGVjdFRvbGVyYW50XG4gICAqIEBkZXNjcmlwdGlvbiBRdWlldGx5IGV4cGVjdCB0aGUgZ2l2ZW4gdG9rZW4gdmFsdWUgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAqIHRvIDxjb2RlPmV4cGVjdCh2YWx1ZSk8L2NvZGU+XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgd2UgYXJlIGV4cGVjdGluZyB0aGUgbG9va2FoZWFkIHRva2VuIHRvIGhhdmVcbiAgICogQHNpbmNlIDIuMFxuICAgKi9cbiAgZnVuY3Rpb24gZXhwZWN0VG9sZXJhbnQodmFsdWUpIHtcbiAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBlY3QodmFsdWUpO1xuICAgICAgfVxuICB9XG5cbiAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgZnVuY3Rpb24gZXhwZWN0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cbiAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lU2VtaWNvbG9uKCkge1xuICAgICAgdmFyIGxpbmU7XG5cbiAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IGxpbmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GICYmICFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiBwcm92aWRlZCBleHByZXNzaW9uIGlzIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cblxuICBmdW5jdGlvbiBpc0xlZnRIYW5kU2lkZShleHByKSB7XG4gICAgICByZXR1cm4gZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciB8fCBleHByLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICB9XG5cbiAgLy8gMTEuMS40IEFycmF5IEluaXRpYWxpc2VyXG5cbiAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgdmFyIGVsZW1lbnRzID0gW10sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuXG4gICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxleCgpO1xuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xuICB9XG5cbiAgLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAgICAgLy8gRU9GIGFuZCBQdW5jdHVhdG9yIHRva2VucyBhcmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQuXG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoKSB7XG4gICAgICB2YXIgdG9rZW4sIGtleSwgaWQsIHZhbHVlLCBwYXJhbSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0JywgaWQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIHRva2VuLCBwcm9wZXJ0eSwgbmFtZSwga2V5LCBraW5kLCBtYXAgPSB7fSwgdG9TdHJpbmcgPSBTdHJpbmcsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2luZCA9IChwcm9wZXJ0eS5raW5kID09PSAnaW5pdCcpID8gUHJvcGVydHlLaW5kLkRhdGEgOiAocHJvcGVydHkua2luZCA9PT0gJ2dldCcpID8gUHJvcGVydHlLaW5kLkdldCA6IFByb3BlcnR5S2luZC5TZXQ7XG5cbiAgICAgICAgICBrZXkgPSAnJCcgKyBuYW1lO1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXBba2V5XSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYga2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBba2V5XSAmIGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXBba2V5XSB8PSBraW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0ga2luZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgKytzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG5cbiAgLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgdmFyIGxlZ2FsS2V5d29yZHMgPSB7XCJpZlwiOjEsIFwidGhpc1wiOjF9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIG5vZGU7XG5cbiAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fCBsZWdhbEtleXdvcmRzW2xvb2thaGVhZC52YWx1ZV0pIHtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChsb29rYWhlYWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSAodG9rZW4udmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChjb2xsZWN0UmVnZXgoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChzY2FuUmVnRXhwKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWVrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJyknKTtcblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgZXhwZWN0KCcuJyk7XG5cbiAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCddJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgcHJvcGVydHksIHN0YXJ0VG9rZW47XG4gICAgICBhc3NlcnQoc3RhdGUuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHRva2VuLCBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCk7XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIGlmICgobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpICYmICFwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjQgVW5hcnkgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VVbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykgfHwgbWF0Y2goJ34nKSB8fCBtYXRjaCgnIScpKSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBhbGxvd0luKSB7XG4gICAgICB2YXIgcHJlYyA9IDA7XG5cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgIHByZWMgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcmJic6XG4gICAgICAgICAgcHJlYyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgIHByZWMgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgICBwcmVjID0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgcHJlYyA9IDU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz09JzpcbiAgICAgIGNhc2UgJyE9JzpcbiAgICAgIGNhc2UgJz09PSc6XG4gICAgICBjYXNlICchPT0nOlxuICAgICAgICAgIHByZWMgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc8JzpcbiAgICAgIGNhc2UgJz4nOlxuICAgICAgY2FzZSAnPD0nOlxuICAgICAgY2FzZSAnPj0nOlxuICAgICAgY2FzZSAnaW5zdGFuY2VvZic6XG4gICAgICAgICAgcHJlYyA9IDc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICBwcmVjID0gYWxsb3dJbiA/IDcgOiAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc8PCc6XG4gICAgICBjYXNlICc+Pic6XG4gICAgICBjYXNlICc+Pj4nOlxuICAgICAgICAgIHByZWMgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHByZWMgPSA5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcqJzpcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgcHJlYyA9IDExO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlYztcbiAgfVxuXG4gIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4gIC8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXG4gIC8vIDExLjcgQml0d2lzZSBTaGlmdCBPcGVyYXRvcnNcbiAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuICAvLyAxMS45IEVxdWFsaXR5IE9wZXJhdG9yc1xuICAvLyAxMS4xMCBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcbiAgLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIG1hcmtlciwgbWFya2VycywgZXhwciwgdG9rZW4sIHByZWMsIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGk7XG5cbiAgICAgIG1hcmtlciA9IGxvb2thaGVhZDtcbiAgICAgIGxlZnQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBzdGF0ZS5hbGxvd0luKTtcbiAgICAgIGlmIChwcmVjID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9XG4gICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgIGxleCgpO1xuXG4gICAgICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgICAgIHJpZ2h0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgc3RhY2sgPSBbbGVmdCwgdG9rZW4sIHJpZ2h0XTtcblxuICAgICAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQsIHN0YXRlLmFsbG93SW4pKSA+IDApIHtcblxuICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2hpZnQuXG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgICBtYXJrZXJzLnB1c2gobG9va2FoZWFkKTtcbiAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxuICAgICAgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICBleHByID0gc3RhY2tbaV07XG4gICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgd2hpbGUgKGkgPiAxKSB7XG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vycy5wb3AoKSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgICAgICAgaSAtPSAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgcHJldmlvdXNBbGxvd0luLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIHN0YXJ0VG9rZW47XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xMyBBc3NpZ25tZW50IE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgb2xkUGFyZW50aGVzaXNDb3VudCwgdG9rZW4sIGV4cHIsIHJpZ2h0LCBsaXN0LCBzdGFydFRva2VuO1xuXG4gICAgICBvbGRQYXJlbnRoZXNpc0NvdW50ID0gc3RhdGUucGFyZW50aGVzaXNDb3VudDtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBzdGFydFRva2VuID0gbG9va2FoZWFkLCBleHByZXNzaW9ucztcblxuICAgICAgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIG5vIHNlcXVlbmNlIGV4cHJlc3Npb25zXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDEyIFN0YXRlbWVudHNcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgIHZhciB0eXBlID0gbG9va2FoZWFkLnR5cGUsXG4gICAgICAgICAgZXhwcixcbiAgICAgICAgICBsYWJlbGVkQm9keSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbm9kZTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gYmxvY2sgc3RhdGVtZW50XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gZW1wdHkgc3RhdGVtZW50XG4gICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBrZXl3b3JkXG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gIH1cblxuICAvLyAxNCBQcm9ncmFtXG5cbiAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50KCkge1xuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgc291cmNlRWxlbWVudCwgc291cmNlRWxlbWVudHMgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvdXJjZUVsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgdmFyIGJvZHksIG5vZGU7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBwZWVrKCk7XG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgIHN0cmljdCA9IHRydWU7IC8vIGFzc3VtZSBzdHJpY3RcblxuICAgICAgYm9keSA9IHBhcnNlU291cmNlRWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb2dyYW0oYm9keSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgdmFyIGksIGVudHJ5LCB0b2tlbiwgdG9rZW5zID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS50b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZW50cnkucmVnZXgpIHtcbiAgICAgICAgICAgICAgdG9rZW4ucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBlbnRyeS5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IGVudHJ5LnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBleHRyYS50b2tlbnMgPSB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdG9TdHJpbmcsXG4gICAgICAgICAgdG9rZW5zO1xuXG4gICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gY29kZTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxuICAgICAgfTtcblxuICAgICAgZXh0cmEgPSB7fTtcblxuICAgICAgLy8gT3B0aW9ucyBtYXRjaGluZy5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBPZiBjb3Vyc2Ugd2UgY29sbGVjdCB0b2tlbnMgaGVyZS5cbiAgICAgIG9wdGlvbnMudG9rZW5zID0gdHJ1ZTtcbiAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgZXh0cmEudG9rZW5pemUgPSB0cnVlO1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyB0d28gZmllbGRzIGFyZSBuZWNlc3NhcnkgdG8gY29tcHV0ZSB0aGUgUmVnZXggdG9rZW5zLlxuICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gLTE7XG5cbiAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcGVlaygpO1xuICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHRyYS50b2tlbnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgd2hpbGUgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChsZXhFcnJvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGJyZWFrIG9uIHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBsZXhFcnJvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICB0b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gY29kZTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICBwYXJlbnRoZXNpc0NvdW50OiAwLFxuICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICB9O1xuXG4gICAgICBleHRyYSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcblxuICAgICAgICAgIGlmIChleHRyYS5sb2MgJiYgb3B0aW9ucy5zb3VyY2UgIT09IG51bGwgJiYgb3B0aW9ucy5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleHRyYS5zb3VyY2UgPSB0b1N0cmluZyhvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICAgICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgcHJvZ3JhbS50b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBwcm9ncmFtLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRva2VuaXplOiB0b2tlbml6ZSxcbiAgICBwYXJzZTogcGFyc2VcbiAgfTtcblxufSkoKTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgYXhzID0gcmVxdWlyZSgnLi4vc2NlbmUvYXhpcycpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyk7XG5cbnZhciBPUklFTlQgPSB7XG4gIFwieFwiOiAgICAgIFwiYm90dG9tXCIsXG4gIFwieVwiOiAgICAgIFwibGVmdFwiLFxuICBcInRvcFwiOiAgICBcInRvcFwiLFxuICBcImJvdHRvbVwiOiBcImJvdHRvbVwiLFxuICBcImxlZnRcIjogICBcImxlZnRcIixcbiAgXCJyaWdodFwiOiAgXCJyaWdodFwiXG59O1xuXG5mdW5jdGlvbiBheGVzKG1vZGVsLCBzcGVjLCBheGVzLCBncm91cCkge1xuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgYXhlc1tpbmRleF0gPSBheGVzW2luZGV4XSB8fCBheHMobW9kZWwpO1xuICAgIGF4aXMoZGVmLCBpbmRleCwgYXhlc1tpbmRleF0sIGdyb3VwKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBheGlzKGRlZiwgaW5kZXgsIGF4aXMsIGdyb3VwKSB7XG4gIC8vIGF4aXMgc2NhbGVcbiAgaWYgKGRlZi5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXhpcy5zY2FsZShncm91cC5zY2FsZShkZWYuc2NhbGUpKTtcbiAgfVxuXG4gIC8vIGF4aXMgb3JpZW50YXRpb25cbiAgYXhpcy5vcmllbnQoZGVmLm9yaWVudCB8fCBPUklFTlRbZGVmLnR5cGVdKTtcbiAgLy8gYXhpcyBvZmZzZXRcbiAgYXhpcy5vZmZzZXQoZGVmLm9mZnNldCB8fCAwKTtcbiAgLy8gYXhpcyBsYXllclxuICBheGlzLmxheWVyKGRlZi5sYXllciB8fCBcImZyb250XCIpO1xuICAvLyBheGlzIGdyaWQgbGluZXNcbiAgYXhpcy5ncmlkKGRlZi5ncmlkIHx8IGZhbHNlKTtcbiAgLy8gYXhpcyB0aXRsZVxuICBheGlzLnRpdGxlKGRlZi50aXRsZSB8fCBudWxsKTtcbiAgLy8gYXhpcyB0aXRsZSBvZmZzZXRcbiAgYXhpcy50aXRsZU9mZnNldChkZWYudGl0bGVPZmZzZXQgIT0gbnVsbFxuICAgID8gZGVmLnRpdGxlT2Zmc2V0IDogY29uZmlnLmF4aXMudGl0bGVPZmZzZXQpO1xuICAvLyBheGlzIHZhbHVlc1xuICBheGlzLnRpY2tWYWx1ZXMoZGVmLnZhbHVlcyB8fCBudWxsKTtcbiAgLy8gYXhpcyBsYWJlbCBmb3JtYXR0aW5nXG4gIGF4aXMudGlja0Zvcm1hdChkZWYuZm9ybWF0IHx8IG51bGwpO1xuICAvLyBheGlzIHRpY2sgc3ViZGl2aXNpb25cbiAgYXhpcy50aWNrU3ViZGl2aWRlKGRlZi5zdWJkaXZpZGUgfHwgMCk7XG4gIC8vIGF4aXMgdGljayBwYWRkaW5nXG4gIGF4aXMudGlja1BhZGRpbmcoZGVmLnRpY2tQYWRkaW5nIHx8IGNvbmZpZy5heGlzLnBhZGRpbmcpO1xuXG4gIC8vIGF4aXMgdGljayBzaXplKHMpXG4gIHZhciBzaXplID0gW107XG4gIGlmIChkZWYudGlja1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGk9MDsgaTwzOyArK2kpIHNpemUucHVzaChkZWYudGlja1NpemUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0cyA9IGNvbmZpZy5heGlzLnRpY2tTaXplO1xuICAgIHNpemUgPSBbdHMsIHRzLCB0c107XG4gIH1cbiAgaWYgKGRlZi50aWNrU2l6ZU1ham9yICE9IG51bGwpIHNpemVbMF0gPSBkZWYudGlja1NpemVNYWpvcjtcbiAgaWYgKGRlZi50aWNrU2l6ZU1pbm9yICE9IG51bGwpIHNpemVbMV0gPSBkZWYudGlja1NpemVNaW5vcjtcbiAgaWYgKGRlZi50aWNrU2l6ZUVuZCAgICE9IG51bGwpIHNpemVbMl0gPSBkZWYudGlja1NpemVFbmQ7XG4gIGlmIChzaXplLmxlbmd0aCkge1xuICAgIGF4aXMudGlja1NpemUuYXBwbHkoYXhpcywgc2l6ZSk7XG4gIH1cblxuICAvLyB0aWNrIGFyZ3VtZW50c1xuICBpZiAoZGVmLnRpY2tzICE9IG51bGwpIHtcbiAgICB2YXIgdGlja3MgPSBkbC5pc0FycmF5KGRlZi50aWNrcykgPyBkZWYudGlja3MgOiBbZGVmLnRpY2tzXTtcbiAgICBheGlzLnRpY2tzLmFwcGx5KGF4aXMsIHRpY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBheGlzLnRpY2tzKGNvbmZpZy5heGlzLnRpY2tzKTtcbiAgfVxuXG4gIC8vIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHAgPSBkZWYucHJvcGVydGllcztcbiAgaWYgKHAgJiYgcC50aWNrcykge1xuICAgIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyhwLm1ham9yVGlja3NcbiAgICAgID8gZGwuZXh0ZW5kKHt9LCBwLnRpY2tzLCBwLm1ham9yVGlja3MpIDogcC50aWNrcyk7XG4gICAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzKHAubWlub3JUaWNrc1xuICAgICAgPyBkbC5leHRlbmQoe30sIHAudGlja3MsIHAubWlub3JUaWNrcykgOiBwLnRpY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMocCAmJiBwLm1ham9yVGlja3MgfHwge30pO1xuICAgIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyhwICYmIHAubWlub3JUaWNrcyB8fCB7fSk7XG4gIH1cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzKHAgJiYgcC5sYWJlbHMgfHwge30pO1xuICBheGlzLnRpdGxlUHJvcGVydGllcyhwICYmIHAudGl0bGUgfHwge30pO1xuICBheGlzLmdyaWRMaW5lUHJvcGVydGllcyhwICYmIHAuZ3JpZCB8fCB7fSk7XG4gIGF4aXMuZG9tYWluUHJvcGVydGllcyhwICYmIHAuYXhpcyB8fCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhlczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBwYXJzZVRyYW5zZm9ybXMgPSByZXF1aXJlKCcuL3RyYW5zZm9ybXMnKSxcbiAgICBwYXJzZU1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5cbnZhciBwYXJzZURhdGEgPSBmdW5jdGlvbihtb2RlbCwgc3BlYywgY2FsbGJhY2spIHtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBsb2FkZWQoZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGRsLmVycm9yKFwiTE9BRElORyBGQUlMRUQ6IFwiICsgZC51cmwgKyBcIiBcIiArIGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsLmRhdGEoZC5uYW1lKS52YWx1ZXMoZGwucmVhZChkYXRhLCBkLmZvcm1hdCkpO1xuICAgICAgfVxuICAgICAgaWYgKC0tY291bnQgPT09IDApIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJvY2VzcyBlYWNoIGRhdGEgc2V0IGRlZmluaXRpb25cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGlmIChkLnVybCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IGQudXJsfSwgY29uZmlnLmxvYWQpLCBsb2FkZWQoZCkpO1xuICAgIH1cbiAgICBwYXJzZURhdGEuZGF0YXNvdXJjZShtb2RlbCwgZCk7XG4gIH0pO1xuXG4gIGlmIChjb3VudCA9PT0gMCkgc2V0VGltZW91dChjYWxsYmFjaywgMSk7XG4gIHJldHVybiBzcGVjO1xufTtcblxucGFyc2VEYXRhLmRhdGFzb3VyY2UgPSBmdW5jdGlvbihtb2RlbCwgZCkge1xuICB2YXIgdHJhbnNmb3JtID0gKGQudHJhbnNmb3JtfHxbXSkubWFwKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHBhcnNlVHJhbnNmb3Jtcyhtb2RlbCwgdCkgfSksXG4gICAgICBtb2QgPSAoZC5tb2RpZnl8fFtdKS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNb2RpZnkobW9kZWwsIG0sIGQpIH0pLFxuICAgICAgZHMgPSBtb2RlbC5kYXRhKGQubmFtZSwgbW9kLmNvbmNhdCh0cmFuc2Zvcm0pKTtcblxuICBpZiAoZC52YWx1ZXMpIHtcbiAgICBkcy52YWx1ZXMoZGwucmVhZChkLnZhbHVlcywgZC5mb3JtYXQpKTtcbiAgfSBlbHNlIGlmIChkLnNvdXJjZSkge1xuICAgIGRzLnNvdXJjZShkLnNvdXJjZSlcbiAgICAgIC5yZXZpc2VzKGRzLnJldmlzZXMoKSkgLy8gSWYgbmV3IGRzIHJldmlzZXMsIHRoZW4gaXQncyBvcmlnaW4gbXVzdCByZXZpc2UgdG9vLlxuICAgICAgLmFkZExpc3RlbmVyKGRzKTsgIC8vIERlcml2ZWQgZHMgd2lsbCBiZSBwdWxzZWQgYnkgaXRzIHNyYyByYXRoZXIgdGhhbiB0aGUgbW9kZWwuXG4gICAgbW9kZWwucmVtb3ZlTGlzdGVuZXIoZHMucGlwZWxpbmUoKVswXSk7IFxuICB9XG5cbiAgcmV0dXJuIGRzOyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VEYXRhO1xuIiwiLypcbiAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICovXG5cbmZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG59XG5cbmZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcblxuICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xufVxuXG5wZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXG4gICAgICBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHN0YXJ0OiBwZWckcGFyc2VzdGFydCB9LFxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXN0YXJ0LFxuXG4gICAgICBwZWckYzAgPSBwZWckRkFJTEVELFxuICAgICAgcGVnJGMxID0gXCIsXCIsXG4gICAgICBwZWckYzIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICBwZWckYzMgPSBmdW5jdGlvbihvLCBtKSB7IHJldHVybiBbb10uY29uY2F0KG0pIH0sXG4gICAgICBwZWckYzQgPSBmdW5jdGlvbihvKSB7IHJldHVybiBbb10gfSxcbiAgICAgIHBlZyRjNSA9IFwiW1wiLFxuICAgICAgcGVnJGM2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiW1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiW1xcXCJcIiB9LFxuICAgICAgcGVnJGM3ID0gXCJdXCIsXG4gICAgICBwZWckYzggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJdXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJdXFxcIlwiIH0sXG4gICAgICBwZWckYzkgPSBcIj5cIixcbiAgICAgIHBlZyRjMTAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICBwZWckYzExID0gZnVuY3Rpb24oZjEsIGYyLCBvKSB7IHJldHVybiB7c3RhcnQ6IGYxLCBlbmQ6IGYyLCBtaWRkbGU6IG99fSxcbiAgICAgIHBlZyRjMTIgPSBbXSxcbiAgICAgIHBlZyRjMTMgPSBmdW5jdGlvbihzLCBmKSB7IHJldHVybiAocy5maWx0ZXJzID0gZiksIHMgfSxcbiAgICAgIHBlZyRjMTQgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzIH0sXG4gICAgICBwZWckYzE1ID0gbnVsbCxcbiAgICAgIHBlZyRjMTYgPSBmdW5jdGlvbih0LCBlKSB7IHJldHVybiB7IGV2ZW50OiBlLCB0YXJnZXQ6IHQgfSB9LFxuICAgICAgcGVnJGMxNyA9IC9eWzphLXpBLXowLTlfXFwtXS8sXG4gICAgICBwZWckYzE4ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIls6YS16QS16MC05X1xcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbOmEtekEtejAtOV9cXFxcLV1cIiB9LFxuICAgICAgcGVnJGMxOSA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHsgc2lnbmFsOiBzLmpvaW4oXCJcIikgfX0sXG4gICAgICBwZWckYzIwID0gXCIoXCIsXG4gICAgICBwZWckYzIxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKFxcXCJcIiB9LFxuICAgICAgcGVnJGMyMiA9IFwiKVwiLFxuICAgICAgcGVnJGMyMyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgIHBlZyRjMjQgPSBmdW5jdGlvbihtKSB7IHJldHVybiB7IHN0cmVhbTogbSB9fSxcbiAgICAgIHBlZyRjMjUgPSBcIi5cIixcbiAgICAgIHBlZyRjMjYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIuXFxcIlwiIH0sXG4gICAgICBwZWckYzI3ID0gXCI6XCIsXG4gICAgICBwZWckYzI4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOlxcXCJcIiB9LFxuICAgICAgcGVnJGMyOSA9IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHsgdHlwZTonY2xhc3MnLCB2YWx1ZTogYyB9IH0sXG4gICAgICBwZWckYzMwID0gXCIjXCIsXG4gICAgICBwZWckYzMxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiI1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiI1xcXCJcIiB9LFxuICAgICAgcGVnJGMzMiA9IGZ1bmN0aW9uKGlkKSB7IHJldHVybiB7IHR5cGU6J2lkJywgdmFsdWU6IGlkIH0gfSxcbiAgICAgIHBlZyRjMzMgPSBcIm1vdXNlZG93blwiLFxuICAgICAgcGVnJGMzNCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlZG93blwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2Vkb3duXFxcIlwiIH0sXG4gICAgICBwZWckYzM1ID0gXCJtb3VzZXVwXCIsXG4gICAgICBwZWckYzM2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2V1cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2V1cFxcXCJcIiB9LFxuICAgICAgcGVnJGMzNyA9IFwiY2xpY2tcIixcbiAgICAgIHBlZyRjMzggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJjbGlja1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiY2xpY2tcXFwiXCIgfSxcbiAgICAgIHBlZyRjMzkgPSBcImRibGNsaWNrXCIsXG4gICAgICBwZWckYzQwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZGJsY2xpY2tcIiwgZGVzY3JpcHRpb246IFwiXFxcImRibGNsaWNrXFxcIlwiIH0sXG4gICAgICBwZWckYzQxID0gXCJ3aGVlbFwiLFxuICAgICAgcGVnJGM0MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIndoZWVsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ3aGVlbFxcXCJcIiB9LFxuICAgICAgcGVnJGM0MyA9IFwia2V5ZG93blwiLFxuICAgICAgcGVnJGM0NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleWRvd25cIiwgZGVzY3JpcHRpb246IFwiXFxcImtleWRvd25cXFwiXCIgfSxcbiAgICAgIHBlZyRjNDUgPSBcImtleXByZXNzXCIsXG4gICAgICBwZWckYzQ2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5cHJlc3NcIiwgZGVzY3JpcHRpb246IFwiXFxcImtleXByZXNzXFxcIlwiIH0sXG4gICAgICBwZWckYzQ3ID0gXCJrZXl1cFwiLFxuICAgICAgcGVnJGM0OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXl1cFxcXCJcIiB9LFxuICAgICAgcGVnJGM0OSA9IFwibW91c2V3aGVlbFwiLFxuICAgICAgcGVnJGM1MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNld2hlZWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNld2hlZWxcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTEgPSBcIm1vdXNlbW92ZVwiLFxuICAgICAgcGVnJGM1MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlbW92ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2Vtb3ZlXFxcIlwiIH0sXG4gICAgICBwZWckYzUzID0gXCJtb3VzZW91dFwiLFxuICAgICAgcGVnJGM1NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlb3V0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW91dFxcXCJcIiB9LFxuICAgICAgcGVnJGM1NSA9IFwibW91c2VvdmVyXCIsXG4gICAgICBwZWckYzU2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VvdmVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW92ZXJcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTcgPSBcIm1vdXNlZW50ZXJcIixcbiAgICAgIHBlZyRjNTggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZWVudGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZWVudGVyXFxcIlwiIH0sXG4gICAgICBwZWckYzU5ID0gXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICBwZWckYzYwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2hzdGFydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidG91Y2hzdGFydFxcXCJcIiB9LFxuICAgICAgcGVnJGM2MSA9IFwidG91Y2htb3ZlXCIsXG4gICAgICBwZWckYzYyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2htb3ZlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaG1vdmVcXFwiXCIgfSxcbiAgICAgIHBlZyRjNjMgPSBcInRvdWNoZW5kXCIsXG4gICAgICBwZWckYzY0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2hlbmRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNoZW5kXFxcIlwiIH0sXG4gICAgICBwZWckYzY1ID0gZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkICB9LFxuICAgICAgcGVnJGM2NiA9IC9eWydcImEtekEtWjAtOV8uPjw9ISBcXHRcXC1dLyxcbiAgICAgIHBlZyRjNjcgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWydcXFwiYS16QS1aMC05Xy4+PD0hIFxcXFx0XFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIlsnXFxcImEtekEtWjAtOV8uPjw9ISBcXFxcdFxcXFwtXVwiIH0sXG4gICAgICBwZWckYzY4ID0gZnVuY3Rpb24odikgeyByZXR1cm4gdi5qb2luKFwiXCIpIH0sXG4gICAgICBwZWckYzY5ID0gL15bIFxcdFxcclxcbl0vLFxuICAgICAgcGVnJGM3MCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIFxcXFx0XFxcXHJcXFxcbl1cIiwgZGVzY3JpcHRpb246IFwiWyBcXFxcdFxcXFxyXFxcXG5dXCIgfSxcblxuICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLFxuICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LFxuICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgcGVnJHJlc3VsdDtcblxuICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICB9XG5cbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckcmVwb3J0ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICByZXR1cm4gcGVnJHJlcG9ydGVkUG9zO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykubGluZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykuY29sdW1uO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICBudWxsLFxuICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICBwZWckcmVwb3J0ZWRQb3NcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBudWxsLCBwZWckcmVwb3J0ZWRQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgIGZ1bmN0aW9uIGFkdmFuY2UoZGV0YWlscywgc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICBmb3IgKHAgPSBzdGFydFBvczsgcCA8IGVuZFBvczsgcCsrKSB7XG4gICAgICAgIGNoID0gaW5wdXQuY2hhckF0KHApO1xuICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICBpZiAoIWRldGFpbHMuc2VlbkNSKSB7IGRldGFpbHMubGluZSsrOyB9XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBlZyRjYWNoZWRQb3MgIT09IHBvcykge1xuICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IDA7XG4gICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGFkdmFuY2UocGVnJGNhY2hlZFBvc0RldGFpbHMsIHBlZyRjYWNoZWRQb3MsIHBvcyk7XG4gICAgICBwZWckY2FjaGVkUG9zID0gcG9zO1xuICAgIH1cblxuICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlscztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIGV4cGVjdGVkLCBwb3MpIHtcbiAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBpID0gMTtcblxuICAgICAgZXhwZWN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmRlc2NyaXB0aW9uID4gYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICBleHBlY3RlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpXG4gICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywgICAnXFxcXGYnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDgwLVxceEZGXS9nLCAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDE4MC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHBlY3RlZERlc2NzID0gbmV3IEFycmF5KGV4cGVjdGVkLmxlbmd0aCksXG4gICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdGVkRGVzYyA9IGV4cGVjdGVkLmxlbmd0aCA+IDFcbiAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXVxuICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XG5cbiAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkRGVzYyArIFwiIGJ1dCBcIiArIGZvdW5kRGVzYyArIFwiIGZvdW5kLlwiO1xuICAgIH1cblxuICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgIGZvdW5kICAgICAgPSBwb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocG9zKSA6IG51bGw7XG5cbiAgICBpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihcbiAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICBleHBlY3RlZCxcbiAgICAgIGZvdW5kLFxuICAgICAgcG9zLFxuICAgICAgcG9zRGV0YWlscy5saW5lLFxuICAgICAgcG9zRGV0YWlscy5jb2x1bW5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3RhcnQoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgczAgPSBwZWckcGFyc2VtZXJnZWQoKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW1lcmdlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VtZXJnZWQoKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzMoczEsIHM1KTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW9yZGVyZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTAsIHMxMSwgczEyLCBzMTM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJGMxO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRjNztcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRjOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTMgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTEoczMsIHM3LCBzMTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmaWx0ZXJlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlc3RyZWFtKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXIoKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzEzKHMxLCBzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXN0cmVhbSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzdHJlYW0oKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWNsYXNzKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRwYXJzZWlkKCk7XG4gICAgfVxuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckYzE1O1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlZXZlbnRUeXBlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNihzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTgpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxOShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIxKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMyMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMjQoczIpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWNsYXNzKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nikge1xuICAgICAgczEgPSBwZWckYzI1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMjkoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VpZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzUpIHtcbiAgICAgIHMxID0gcGVnJGMzMDtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMSk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICAgIHMzID0gcGVnJGMyNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzMyKHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZXZlbnRUeXBlKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzMzKSB7XG4gICAgICBzMCA9IHBlZyRjMzM7XG4gICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzQpOyB9XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjMzUpIHtcbiAgICAgICAgczAgPSBwZWckYzM1O1xuICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjMzcpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjMzc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzM5KSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMzk7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDApOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNDEpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzQxO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDIpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjNDMpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDM7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ0KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzQ1KSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDU7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDYpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ3O1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ5O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTApOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM1Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1NCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzU3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM1OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYyKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzYzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjQpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZmlsdGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgczEgPSBwZWckYzU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgIHMzID0gcGVnJGM3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM2NShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXZhbHVlKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIGlmIChwZWckYzY2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Nyk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIGlmIChwZWckYzY2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY3KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzY4KHMxKTtcbiAgICB9XG4gICAgczAgPSBzMTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXNlcCgpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgczAgPSBbXTtcbiAgICBpZiAocGVnJGM2OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBpZiAocGVnJGM2OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcwKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHsgdHlwZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiZW5kIG9mIGlucHV0XCIgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICBwYXJzZTogICAgICAgcGFyc2Vcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9leHByZXNzaW9uJyk7XG5cbnZhciBleHByID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyc2UgPSBleHByZXNzaW9uLnBhcnNlO1xuICB2YXIgY29kZWdlbiA9IGV4cHJlc3Npb24uY29kZSh7XG4gICAgaWRXaGl0ZUxpc3Q6IFsnZCcsICdlJywgJ2knLCAncCcsICdzZyddXG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbihleHByKSB7ICAgIFxuICAgIHZhciB2YWx1ZSA9IGNvZGVnZW4ocGFyc2UoZXhwcikpO1xuICAgIHZhbHVlLmZuID0gRnVuY3Rpb24oJ2QnLCAnZScsICdpJywgJ3AnLCAnc2cnLFxuICAgICAgJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyB2YWx1ZS5mbiArICcpOycpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0pKCk7XG5cbmV4cHIuZXZhbCA9IGZ1bmN0aW9uKGdyYXBoLCBmbiwgZCwgZSwgaSwgcCwgc2cpIHtcbiAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoZGwuYXJyYXkoc2cpKTtcbiAgcmV0dXJuIGZuLmNhbGwobnVsbCwgZCwgZSwgaSwgcCwgc2cpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHByOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSW50ZXJhY3RvcnMobW9kZWwsIHNwZWMsIGRlZkZhY3RvcnkpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIHNnID0ge30sIHBkID0ge30sIG1rID0ge30sXG4gICAgICBzaWduYWxzID0gW10sIHByZWRpY2F0ZXMgPSBbXTtcblxuICBmdW5jdGlvbiBsb2FkZWQoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGRsLmVycm9yKFwiTE9BRElORyBGQUlMRUQ6IFwiICsgaS51cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlZiA9IGRsLmlzT2JqZWN0KGRhdGEpID8gZGF0YSA6IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIGludGVyYWN0b3IoaS5uYW1lLCBkZWYpO1xuICAgICAgfVxuICAgICAgaWYgKC0tY291bnQgPT0gMCkgaW5qZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJhY3RvcihuYW1lLCBkZWYpIHtcbiAgICBzZyA9IHt9LCBwZCA9IHt9O1xuICAgIGlmIChkZWYuc2lnbmFscykgICAgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIG5zU2lnbmFscyhuYW1lLCBkZWYuc2lnbmFscykpO1xuICAgIGlmIChkZWYucHJlZGljYXRlcykgcHJlZGljYXRlcy5wdXNoLmFwcGx5KHByZWRpY2F0ZXMsIG5zUHJlZGljYXRlcyhuYW1lLCBkZWYucHJlZGljYXRlcykpO1xuICAgIG5zTWFya3MobmFtZSwgZGVmLm1hcmtzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICBpZiAoZGwua2V5cyhtaykubGVuZ3RoID4gMCkgaW5qZWN0TWFya3Moc3BlYy5tYXJrcyk7XG4gICAgc3BlYy5zaWduYWxzID0gZGwuYXJyYXkoc3BlYy5zaWduYWxzKTtcbiAgICBzcGVjLnByZWRpY2F0ZXMgPSBkbC5hcnJheShzcGVjLnByZWRpY2F0ZXMpO1xuICAgIHNwZWMuc2lnbmFscy51bnNoaWZ0LmFwcGx5KHNwZWMuc2lnbmFscywgc2lnbmFscyk7XG4gICAgc3BlYy5wcmVkaWNhdGVzLnVuc2hpZnQuYXBwbHkoc3BlYy5wcmVkaWNhdGVzLCBwcmVkaWNhdGVzKTtcbiAgICBkZWZGYWN0b3J5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RNYXJrcyhtYXJrcykge1xuICAgIHZhciBtLCByLCBpLCBsZW47XG4gICAgbWFya3MgPSBkbC5hcnJheShtYXJrcyk7XG5cbiAgICBmb3IoaSA9IDAsIGxlbiA9IG1hcmtzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtID0gbWFya3NbaV07XG4gICAgICBpZiAociA9IG1rW20udHlwZV0pIHtcbiAgICAgICAgbWFya3NbaV0gPSBkbC5kdXBsaWNhdGUocik7XG4gICAgICAgIGlmIChtLmZyb20pIG1hcmtzW2ldLmZyb20gPSBtLmZyb207XG4gICAgICAgIGlmIChtLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICBbQy5FTlRFUiwgQy5VUERBVEUsIEMuRVhJVF0uZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBtYXJrc1tpXS5wcm9wZXJ0aWVzW3BdID0gZGwuZXh0ZW5kKHIucHJvcGVydGllc1twXSwgbS5wcm9wZXJ0aWVzW3BdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtLm1hcmtzKSB7ICAvLyBUT0RPIGhvdyB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIG5lc3RlZCBtYXJrcz9cbiAgICAgICAgaW5qZWN0TWFya3MobS5tYXJrcyk7XG4gICAgICB9XG4gICAgfSAgICBcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zKG4sIHMpIHsgXG4gICAgaWYgKGRsLmlzU3RyaW5nKHMpKSB7XG4gICAgICByZXR1cm4gcyArIFwiX1wiICsgbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGwua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgXG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxiJyt4KydcXFxcYicsIFwiZ1wiKTtcbiAgICAgICAgbiA9IG4ucmVwbGFjZShyZWdleCwgc1t4XSkgXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5zU2lnbmFscyhuYW1lLCBzaWduYWxzKSB7XG4gICAgc2lnbmFscyA9IGRsLmFycmF5KHNpZ25hbHMpO1xuICAgIC8vIFR3byBwYXNzZXMgdG8gbnMgYWxsIHNpZ25hbHMsIGFuZCB0aGVuIG92ZXJ3cml0ZSB0aGVpciBkZWZpbml0aW9uc1xuICAgIC8vIGluIGNhc2Ugc2lnbmFsIG9yZGVyIGlzIGltcG9ydGFudC5cbiAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBzLm5hbWUgPSBzZ1tzLm5hbWVdID0gbnMocy5uYW1lLCBuYW1lKTsgfSk7XG4gICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIChzLnN0cmVhbXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICB0LnR5cGUgPSBucyh0LnR5cGUsIHNnKTtcbiAgICAgICAgdC5leHByID0gbnModC5leHByLCBzZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbmFscztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zUHJlZGljYXRlcyhuYW1lLCBwcmVkaWNhdGVzKSB7XG4gICAgcHJlZGljYXRlcyA9IGRsLmFycmF5KHByZWRpY2F0ZXMpO1xuICAgIHByZWRpY2F0ZXMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBwLm5hbWUgPSBwZFtwLm5hbWVdID0gbnMocC5uYW1lLCBuYW1lKTtcblxuICAgICAgW3Aub3BlcmFuZHMsIHAucmFuZ2VdLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICAoeCB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKG8uc2lnbmFsKSBvLnNpZ25hbCA9IG5zKG8uc2lnbmFsLCBzZyk7XG4gICAgICAgICAgZWxzZSBpZiAoby5wcmVkaWNhdGUpIG5zT3BlcmFuZChvKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgfSk7ICBcbiAgICByZXR1cm4gcHJlZGljYXRlczsgXG4gIH1cblxuICBmdW5jdGlvbiBuc09wZXJhbmQobykge1xuICAgIG8ucHJlZGljYXRlID0gcGRbby5wcmVkaWNhdGVdO1xuICAgIGRsLmtleXMoby5pbnB1dCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgaSA9IG8uaW5wdXRba107XG4gICAgICBpZiAoaS5zaWduYWwpIGkuc2lnbmFsID0gbnMoaS5zaWduYWwsIHNnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zTWFya3MobmFtZSwgbWFya3MpIHtcbiAgICAobWFya3MgfHwgW10pLmZvckVhY2goZnVuY3Rpb24obSkgeyBcbiAgICAgIG5zUHJvcGVydGllcyhtLnByb3BlcnRpZXMuZW50ZXIpO1xuICAgICAgbnNQcm9wZXJ0aWVzKG0ucHJvcGVydGllcy51cGRhdGUpO1xuICAgICAgbnNQcm9wZXJ0aWVzKG0ucHJvcGVydGllcy5leGl0KTtcbiAgICAgIG1rW25zKG0ubmFtZSwgbmFtZSldID0gbTsgXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuc1Byb3BlcnRpZXMocHJvcHNldCkge1xuICAgIGRsLmtleXMocHJvcHNldCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgcCA9IHByb3BzZXRba107XG4gICAgICBpZiAocC5zaWduYWwpIHAuc2lnbmFsID0gbnMocC5zaWduYWwsIHNnKTtcbiAgICAgIGVsc2UgaWYgKHAucnVsZSkge1xuICAgICAgICBwLnJ1bGUuZm9yRWFjaChmdW5jdGlvbihyKSB7IFxuICAgICAgICAgIGlmIChyLnNpZ25hbCkgci5zaWduYWwgPSBucyhyLnNpZ25hbCwgc2cpO1xuICAgICAgICAgIGlmIChyLnByZWRpY2F0ZSkgbnNPcGVyYW5kKHIpOyBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAoc3BlYy5pbnRlcmFjdG9ycyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgaWYgKGkudXJsKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgZGwubG9hZChkbC5leHRlbmQoe3VybDogaS51cmx9LCBjb25maWcubG9hZCksIGxvYWRlZChpKSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoY291bnQgPT09IDApIHNldFRpbWVvdXQoaW5qZWN0LCAxKTtcbiAgcmV0dXJuIHNwZWM7XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHBhcnNlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTWFyayhtb2RlbCwgbWFyaykge1xuICB2YXIgcHJvcHMgPSBtYXJrLnByb3BlcnRpZXMsXG4gICAgICBncm91cCA9IG1hcmsubWFya3M7XG5cbiAgLy8gcGFyc2UgbWFyayBwcm9wZXJ0eSBkZWZpbml0aW9uc1xuICBkbC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBwcm9wc1trXSA9IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgbWFyay50eXBlLCBwcm9wc1trXSk7XG4gIH0pO1xuXG4gIC8vIHBhcnNlIGRlbGF5IGZ1bmN0aW9uXG4gIGlmIChtYXJrLmRlbGF5KSB7XG4gICAgbWFyay5kZWxheSA9IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgbWFyay50eXBlLCB7ZGVsYXk6IG1hcmsuZGVsYXl9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2UgaWYgZ3JvdXAgdHlwZVxuICBpZiAoZ3JvdXApIHtcbiAgICBtYXJrLm1hcmtzID0gZ3JvdXAubWFwKGZ1bmN0aW9uKGcpIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgZyk7IH0pO1xuICB9XG4gICAgXG4gIHJldHVybiBtYXJrO1xufTsiLCJ2YXIgcGFyc2VNYXJrID0gcmVxdWlyZSgnLi9tYXJrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kZWwsIHNwZWMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHNjYWxlczogc3BlYy5zY2FsZXMgfHwgW10sXG4gICAgYXhlczogc3BlYy5heGVzIHx8IFtdLFxuICAgIC8vIGxlZ2VuZHM6IHNwZWMubGVnZW5kcyB8fCBbXSxcbiAgICBtYXJrczogKHNwZWMubWFya3MgfHwgW10pLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KVxuICB9O1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbnZhciBmaWx0ZXIgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIHNyYywgZGVzdCkge1xuICBmb3IodmFyIGkgPSBzcmMubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYoc3JjW2ldW2ZpZWxkXSA9PSB2YWx1ZSlcbiAgICAgIGRlc3QucHVzaC5hcHBseShkZXN0LCBzcmMuc3BsaWNlKGksIDEpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZU1vZGlmeShtb2RlbCwgZGVmLCBkcykge1xuICB2YXIgc2lnbmFsID0gZGVmLnNpZ25hbCA/IGRsLmZpZWxkKGRlZi5zaWduYWwpIDogbnVsbCwgXG4gICAgICBzaWduYWxOYW1lID0gc2lnbmFsID8gc2lnbmFsWzBdIDogbnVsbCxcbiAgICAgIHByZWRpY2F0ZSA9IGRlZi5wcmVkaWNhdGUgPyBtb2RlbC5wcmVkaWNhdGUoZGVmLnByZWRpY2F0ZSkgOiBudWxsLFxuICAgICAgcmVldmFsID0gKHByZWRpY2F0ZSA9PT0gbnVsbCksXG4gICAgICBub2RlID0gbmV3IE5vZGUobW9kZWwpO1xuXG4gIG5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmKHByZWRpY2F0ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRiID0ge307XG4gICAgICAocHJlZGljYXRlLmRhdGF8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZGJbZF0gPSBtb2RlbC5kYXRhKGQpLnZhbHVlcygpOyB9KTtcblxuICAgICAgLy8gVE9ETzogaW5wdXRcbiAgICAgIHJlZXZhbCA9IHByZWRpY2F0ZS5jYWxsKHByZWRpY2F0ZSwge30sIGRiLCBtb2RlbC5zaWduYWxWYWx1ZXMocHJlZGljYXRlLnNpZ25hbHN8fFtdKSwgbW9kZWwuX3ByZWRpY2F0ZXMpO1xuICAgIH1cblxuICAgIGRlYnVnKGlucHV0LCBbZGVmLnR5cGUrXCJpbmdcIiwgcmVldmFsXSk7XG4gICAgaWYoIXJlZXZhbCkgcmV0dXJuIGlucHV0O1xuXG4gICAgdmFyIGRhdHVtID0ge30sIFxuICAgICAgICB2YWx1ZSA9IHNpZ25hbCA/IG1vZGVsLnNpZ25hbFJlZihkZWYuc2lnbmFsKSA6IG51bGwsXG4gICAgICAgIGQgPSBtb2RlbC5kYXRhKGRzLm5hbWUpLFxuICAgICAgICBwcmV2ID0gZC5yZXZpc2VzKCkgPyBudWxsIDogdW5kZWZpbmVkLFxuICAgICAgICB0ID0gbnVsbDtcblxuICAgIGRhdHVtW2RlZi5maWVsZF0gPSB2YWx1ZTtcblxuICAgIC8vIFdlIGhhdmUgdG8gbW9kaWZ5IGRzLl9kYXRhIHNvIHRoYXQgc3Vic2VxdWVudCBwdWxzZXMgY29udGFpblxuICAgIC8vIG91ciBkeW5hbWljIGRhdGEuIFcvbyBtb2RpZnlpbmcgZHMuX2RhdGEsIG9ubHkgdGhlIG91dHB1dFxuICAgIC8vIGNvbGxlY3RvciB3aWxsIGNvbnRhaW4gZHluYW1pYyB0dXBsZXMuIFxuICAgIGlmKGRlZi50eXBlID09IEMuQUREKSB7XG4gICAgICB0ID0gdHVwbGUuaW5nZXN0KGRhdHVtLCBwcmV2KTtcbiAgICAgIGlucHV0LmFkZC5wdXNoKHQpO1xuICAgICAgZC5fZGF0YS5wdXNoKHQpO1xuICAgIH0gZWxzZSBpZihkZWYudHlwZSA9PSBDLlJFTU9WRSkge1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LmFkZCwgaW5wdXQucmVtKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5tb2QsIGlucHV0LnJlbSk7XG4gICAgICBkLl9kYXRhID0gZC5fZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4geFtkZWYuZmllbGRdICE9PSB2YWx1ZSB9KTtcbiAgICB9IGVsc2UgaWYoZGVmLnR5cGUgPT0gQy5UT0dHTEUpIHtcbiAgICAgIHZhciBhZGQgPSBbXSwgcmVtID0gW107XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQucmVtLCBhZGQpO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LmFkZCwgcmVtKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5tb2QsIHJlbSk7XG4gICAgICBpZihhZGQubGVuZ3RoID09IDAgJiYgcmVtLmxlbmd0aCA9PSAwKSBhZGQucHVzaCh0dXBsZS5pbmdlc3QoZGF0dW0pKTtcblxuICAgICAgaW5wdXQuYWRkLnB1c2guYXBwbHkoaW5wdXQuYWRkLCBhZGQpO1xuICAgICAgZC5fZGF0YS5wdXNoLmFwcGx5KGQuX2RhdGEsIGFkZCk7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIHJlbSk7XG4gICAgICBkLl9kYXRhID0gZC5fZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gcmVtLmluZGV4T2YoeCkgPT09IC0xIH0pO1xuICAgIH0gZWxzZSBpZihkZWYudHlwZSA9PSBDLkNMRUFSKSB7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIGlucHV0LmFkZCk7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIGlucHV0Lm1vZCk7XG4gICAgICBpbnB1dC5hZGQgPSBbXTtcbiAgICAgIGlucHV0Lm1vZCA9IFtdO1xuICAgICAgZC5fZGF0YSAgPSBbXTtcbiAgICB9IFxuXG4gICAgaW5wdXQuZmllbGRzW2RlZi5maWVsZF0gPSAxO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICBpZihzaWduYWxOYW1lKSBub2RlLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzaWduYWxOYW1lKTtcbiAgaWYocHJlZGljYXRlKSAgbm9kZS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgcHJlZGljYXRlLnNpZ25hbHMpO1xuICBcbiAgcmV0dXJuIG5vZGU7XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWQpIHtcbiAgaWYgKHBhZCA9PSBudWxsKSByZXR1cm4gXCJhdXRvXCI7XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHBhZCkpIHJldHVybiBwYWQ9PT1cInN0cmljdFwiID8gXCJzdHJpY3RcIiA6IFwiYXV0b1wiO1xuICBlbHNlIGlmIChkbC5pc09iamVjdChwYWQpKSByZXR1cm4gcGFkO1xuICB2YXIgcCA9IGRsLmlzTnVtYmVyKHBhZCkgPyBwYWQgOiAyMDtcbiAgcmV0dXJuIHt0b3A6cCwgbGVmdDpwLCByaWdodDpwLCBib3R0b206cH07XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUHJlZGljYXRlKG1vZGVsLCBzcGVjKSB7XG4gIHZhciB0eXBlcyA9IHtcbiAgICAnPSc6ICBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJz09JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICchPSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPic6ICBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJz49JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICc8JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPD0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJ2FuZCc6IHBhcnNlTG9naWNhbCxcbiAgICAnJiYnOiAgcGFyc2VMb2dpY2FsLFxuICAgICdvcic6ICBwYXJzZUxvZ2ljYWwsXG4gICAgJ3x8JzogIHBhcnNlTG9naWNhbCxcbiAgICAnaW4nOiBwYXJzZUluXG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VTaWduYWwoc2lnbmFsLCBzaWduYWxzKSB7XG4gICAgdmFyIHMgPSBkbC5maWVsZChzaWduYWwpLFxuICAgICAgICBjb2RlID0gXCJzaWduYWxzW1wiK3MubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiO1xuICAgIHNpZ25hbHNbcy5zaGlmdCgpXSA9IDE7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VPcGVyYW5kcyhvcGVyYW5kcykge1xuICAgIHZhciBkZWNsID0gW10sIGRlZnMgPSBbXSxcbiAgICAgICAgc2lnbmFscyA9IHt9LCBkYiA9IHt9O1xuXG4gICAgZGwuYXJyYXkob3BlcmFuZHMpLmZvckVhY2goZnVuY3Rpb24obywgaSkge1xuICAgICAgdmFyIHNpZ25hbCwgbmFtZSA9IFwib1wiK2ksIGRlZiA9IFwiXCI7XG4gICAgICBcbiAgICAgIGlmKG8udmFsdWUgIT09IHVuZGVmaW5lZCkgZGVmID0gZGwuc3RyKG8udmFsdWUpO1xuICAgICAgZWxzZSBpZihvLmFyZykgICAgZGVmID0gXCJhcmdzW1wiK2RsLnN0cihvLmFyZykrXCJdXCI7XG4gICAgICBlbHNlIGlmKG8uc2lnbmFsKSBkZWYgPSBwYXJzZVNpZ25hbChvLnNpZ25hbCwgc2lnbmFscyk7XG4gICAgICBlbHNlIGlmKG8ucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBwcmVkID0gbW9kZWwucHJlZGljYXRlKG8ucHJlZGljYXRlKSxcbiAgICAgICAgICAgIHAgPSBcInByZWRpY2F0ZXNbXCIrZGwuc3RyKG8ucHJlZGljYXRlKStcIl1cIjtcblxuICAgICAgICBwcmVkLnNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IHNpZ25hbHNbc10gPSAxOyB9KTtcbiAgICAgICAgcHJlZC5kYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkYltkXSA9IDEgfSk7XG5cbiAgICAgICAgZGwua2V5cyhvLmlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICB2YXIgaSA9IG8uaW5wdXRba10sIHNpZ25hbDtcbiAgICAgICAgICBkZWYgKz0gXCJhcmdzW1wiK2RsLnN0cihrKStcIl0gPSBcIjtcbiAgICAgICAgICBpZihpLnNpZ25hbCkgICBkZWYgKz0gcGFyc2VTaWduYWwoaS5zaWduYWwsIHNpZ25hbHMpO1xuICAgICAgICAgIGVsc2UgaWYoaS5hcmcpIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGkuYXJnKStcIl1cIjtcbiAgICAgICAgICBkZWYrPVwiLCBcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmKz0gcCtcIi5jYWxsKFwiK3ArXCIsIGFyZ3MsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKVwiO1xuICAgICAgfVxuXG4gICAgICBkZWNsLnB1c2gobmFtZSk7XG4gICAgICBkZWZzLnB1c2gobmFtZStcIj0oXCIrZGVmK1wiKVwiKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBcInZhciBcIiArIGRlY2wuam9pbihcIiwgXCIpICsgXCI7XFxuXCIgKyBkZWZzLmpvaW4oXCI7XFxuXCIpICsgXCI7XFxuXCIsXG4gICAgICBzaWduYWxzOiBkbC5rZXlzKHNpZ25hbHMpLFxuICAgICAgZGF0YTogZGwua2V5cyhkYilcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKHNwZWMpIHtcbiAgICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhzcGVjLm9wZXJhbmRzKTtcbiAgICBpZihzcGVjLnR5cGUgPT0gJz0nKSBzcGVjLnR5cGUgPSAnPT0nO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG9wcy5jb2RlICsgXCJyZXR1cm4gXCIgKyBbXCJvMFwiLCBcIm8xXCJdLmpvaW4oc3BlYy50eXBlKSArIFwiO1wiLFxuICAgICAgc2lnbmFsczogb3BzLnNpZ25hbHMsXG4gICAgICBkYXRhOiBvcHMuZGF0YVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsKHNwZWMpIHtcbiAgICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhzcGVjLm9wZXJhbmRzKSxcbiAgICAgICAgbyA9IFtdLCBpID0gMCwgbGVuID0gc3BlYy5vcGVyYW5kcy5sZW5ndGg7XG5cbiAgICB3aGlsZShvLnB1c2goXCJvXCIraSsrKTxsZW4pO1xuICAgIGlmKHNwZWMudHlwZSA9PSAnYW5kJykgc3BlYy50eXBlID0gJyYmJztcbiAgICBlbHNlIGlmKHNwZWMudHlwZSA9PSAnb3InKSBzcGVjLnR5cGUgPSAnfHwnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG9wcy5jb2RlICsgXCJyZXR1cm4gXCIgKyBvLmpvaW4oc3BlYy50eXBlKSArIFwiO1wiLFxuICAgICAgc2lnbmFsczogb3BzLnNpZ25hbHMsXG4gICAgICBkYXRhOiBvcHMuZGF0YVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VJbihzcGVjKSB7XG4gICAgdmFyIG8gPSBbc3BlYy5pdGVtXSwgY29kZSA9IFwiXCI7XG4gICAgaWYoc3BlYy5yYW5nZSkgby5wdXNoLmFwcGx5KG8sIHNwZWMucmFuZ2UpO1xuICAgIGlmKHNwZWMuc2NhbGUpIHtcbiAgICAgIGNvZGUgPSBwYXJzZVNjYWxlKHNwZWMuc2NhbGUsIG8pO1xuICAgIH1cblxuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKG8pO1xuICAgIGNvZGUgPSBvcHMuY29kZSArIGNvZGU7XG5cbiAgICBpZihzcGVjLmRhdGEpIHtcbiAgICAgIHZhciBmaWVsZCA9IGRsLmZpZWxkKHNwZWMuZmllbGQpLm1hcChkbC5zdHIpO1xuICAgICAgY29kZSArPSBcInZhciB3aGVyZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbXCIrZmllbGQuam9pbihcIl1bXCIpK1wiXSA9PSBvMCB9O1xcblwiO1xuICAgICAgY29kZSArPSBcInJldHVybiBkYltcIitkbC5zdHIoc3BlYy5kYXRhKStcIl0uZmlsdGVyKHdoZXJlKS5sZW5ndGggPiAwO1wiO1xuICAgIH0gZWxzZSBpZihzcGVjLnJhbmdlKSB7XG4gICAgICAvLyBUT0RPOiBpbmNsdXNpdmUvZXhjbHVzaXZlIHJhbmdlP1xuICAgICAgLy8gVE9ETzogaW52ZXJ0aW5nIG9yZGluYWwgc2NhbGVzXG4gICAgICBpZihzcGVjLnNjYWxlKSBjb2RlICs9IFwibzEgPSBzY2FsZShvMSk7XFxubzIgPSBzY2FsZShvMik7XFxuXCI7XG4gICAgICBjb2RlICs9IFwicmV0dXJuIG8xIDwgbzIgPyBvMSA8PSBvMCAmJiBvMCA8PSBvMiA6IG8yIDw9IG8wICYmIG8wIDw9IG8xXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IGNvZGUsIFxuICAgICAgc2lnbmFsczogb3BzLnNpZ25hbHMsIFxuICAgICAgZGF0YTogb3BzLmRhdGEuY29uY2F0KHNwZWMuZGF0YSA/IFtzcGVjLmRhdGFdIDogW10pXG4gICAgfTtcbiAgfTtcblxuICAvLyBQb3B1bGF0ZSBvcHMgc3VjaCB0aGF0IHVsdGltYXRlIHNjYWxlL2ludmVyc2lvbiBmdW5jdGlvbiB3aWxsIGJlIGluIGBzY2FsZWAgdmFyLiBcbiAgZnVuY3Rpb24gcGFyc2VTY2FsZShzcGVjLCBvcHMpIHtcbiAgICB2YXIgY29kZSA9IFwidmFyIHNjYWxlID0gXCIsIFxuICAgICAgICBpZHggID0gb3BzLmxlbmd0aDtcblxuICAgIGlmKGRsLmlzU3RyaW5nKHNwZWMpKSB7XG4gICAgICBvcHMucHVzaCh7IHZhbHVlOiBzcGVjIH0pO1xuICAgICAgY29kZSArPSBcInRoaXMucm9vdCgpLnNjYWxlKG9cIitpZHgrXCIpXCI7XG4gICAgfSBlbHNlIGlmKHNwZWMuYXJnKSB7ICAvLyBTY2FsZSBmdW5jdGlvbiBpcyBiZWluZyBwYXNzZWQgYXMgYW4gYXJnXG4gICAgICBvcHMucHVzaChzcGVjKTtcbiAgICAgIGNvZGUgKz0gXCJvXCIraWR4O1xuICAgIH0gZWxzZSBpZihzcGVjLm5hbWUpIHsgLy8gRnVsbCBzY2FsZSBwYXJhbWV0ZXIge25hbWU6IC4ufVxuICAgICAgb3BzLnB1c2goZGwuaXNTdHJpbmcoc3BlYy5uYW1lKSA/IHt2YWx1ZTogc3BlYy5uYW1lfSA6IHNwZWMubmFtZSk7XG4gICAgICBjb2RlICs9IFwiKHRoaXMuaXNGdW5jdGlvbihvXCIraWR4K1wiKSA/IG9cIitpZHgrXCIgOiBcIjtcbiAgICAgIGlmKHNwZWMuc2NvcGUpIHtcbiAgICAgICAgb3BzLnB1c2goc3BlYy5zY29wZSk7XG4gICAgICAgIGNvZGUgKz0gXCIob1wiKyhpZHgrMSkrXCIuc2NhbGUgfHwgdGhpcy5yb290KCkuc2NhbGUpKG9cIitpZHgrXCIpXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlICs9IFwidGhpcy5yb290KCkuc2NhbGUob1wiK2lkeCtcIilcIjtcbiAgICAgIH1cbiAgICAgIGNvZGUgKz0gXCIpXCJcbiAgICB9XG5cbiAgICBpZihzcGVjLmludmVydCA9PT0gdHJ1ZSkgeyAgLy8gQWxsb3cgc3BlYy5pbnZlcnQuYXJnP1xuICAgICAgY29kZSArPSBcIi5pbnZlcnRcIlxuICAgIH1cblxuICAgIHJldHVybiBjb2RlK1wiO1xcblwiO1xuICB9XG5cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBwYXJzZSA9IHR5cGVzW3MudHlwZV0ocyksXG4gICAgICAgIHByZWQgID0gRnVuY3Rpb24oXCJhcmdzXCIsIFwiZGJcIiwgXCJzaWduYWxzXCIsIFwicHJlZGljYXRlc1wiLCBwYXJzZS5jb2RlKTtcbiAgICBwcmVkLnJvb3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZGVsLnNjZW5lKCkuaXRlbXNbMF0gfTsgLy8gRm9yIGdsb2JhbCBzY2FsZXNcbiAgICBwcmVkLmlzRnVuY3Rpb24gPSBkbC5pc0Z1bmN0aW9uO1xuICAgIHByZWQuc2lnbmFscyA9IHBhcnNlLnNpZ25hbHM7XG4gICAgcHJlZC5kYXRhID0gcGFyc2UuZGF0YTtcbiAgICBtb2RlbC5wcmVkaWNhdGUocy5uYW1lLCBwcmVkKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyk7XG5cbnZhciBERVBTID0gW1wic2lnbmFsc1wiLCBcInNjYWxlc1wiLCBcImRhdGFcIiwgXCJmaWVsZHNcIl07XG5cbmZ1bmN0aW9uIGNvbXBpbGUobW9kZWwsIG1hcmssIHNwZWMpIHtcbiAgdmFyIGNvZGUgPSBcIlwiLFxuICAgICAgbmFtZXMgPSBkbC5rZXlzKHNwZWMpLFxuICAgICAgaSwgbGVuLCBuYW1lLCByZWYsIHZhcnMgPSB7fSwgXG4gICAgICBkZXBzID0ge1xuICAgICAgICBzaWduYWxzOiB7fSxcbiAgICAgICAgc2NhbGVzOiAge30sXG4gICAgICAgIGRhdGE6ICAgIHt9LFxuICAgICAgICBmaWVsZHM6ICB7fSxcbiAgICAgICAgcmVmbG93OiAgZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgY29kZSArPSBcInZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW07XFxuXCJcbiAgXG4gIGZvciAoaT0wLCBsZW49bmFtZXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgcmVmID0gc3BlY1tuYW1lID0gbmFtZXNbaV1dO1xuICAgIGNvZGUgKz0gKGkgPiAwKSA/IFwiXFxuICBcIiA6IFwiICBcIjtcbiAgICBpZihyZWYucnVsZSkge1xuICAgICAgcmVmID0gcnVsZShtb2RlbCwgbmFtZSwgcmVmLnJ1bGUpO1xuICAgICAgY29kZSArPSBcIlxcbiAgXCIgKyByZWYuY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB2YWx1ZVJlZihuYW1lLCByZWYpO1xuICAgICAgY29kZSArPSBcInRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1wiO1xuICAgIH1cblxuICAgIHZhcnNbbmFtZV0gPSB0cnVlO1xuICAgIERFUFMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBpZihyZWZbcF0gIT0gbnVsbCkgZGwuYXJyYXkocmVmW3BdKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHsgZGVwc1twXVtrXSA9IDEgfSk7XG4gICAgfSk7XG4gICAgZGVwcy5yZWZsb3cgPSBkZXBzLnJlZmxvdyB8fCByZWYucmVmbG93O1xuICB9XG5cbiAgaWYgKHZhcnMueDIpIHtcbiAgICBpZiAodmFycy54KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby54ID4gby54MikgeyBcIlxuICAgICAgICAgICAgKyBcInZhciB0ID0gby54O1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd4Jywgby54Mik7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3gyJywgdCk7IFwiXG4gICAgICAgICAgICArIFwifTtcIjtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAnd2lkdGgnLCAoby54MiAtIG8ueCkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy53aWR0aCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd4JywgKG8ueDIgLSBvLndpZHRoKSk7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneCcsIG8ueDIpO1wiXG4gICAgfVxuICB9XG5cbiAgaWYgKHZhcnMueTIpIHtcbiAgICBpZiAodmFycy55KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby55ID4gby55MikgeyBcIlxuICAgICAgICAgICAgKyBcInZhciB0ID0gby55O1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd5Jywgby55Mik7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3kyJywgdCk7XCJcbiAgICAgICAgICAgICsgXCJ9O1wiO1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICdoZWlnaHQnLCAoby55MiAtIG8ueSkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy5oZWlnaHQpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneScsIChvLnkyIC0gby5oZWlnaHQpKTtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd5Jywgby55Mik7XCJcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChoYXNQYXRoKG1hcmssIHZhcnMpKSBjb2RlICs9IFwiXFxuICBpdGVtLnRvdWNoKCk7XCI7XG4gIGNvZGUgKz0gXCJcXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XCI7XG5cbiAgdHJ5IHtcbiAgICB2YXIgZW5jb2RlciA9IEZ1bmN0aW9uKFwiaXRlbVwiLCBcImdyb3VwXCIsIFwidHJhbnNcIiwgXCJkYlwiLCBcbiAgICAgIFwic2lnbmFsc1wiLCBcInByZWRpY2F0ZXNcIiwgY29kZSk7XG4gICAgZW5jb2Rlci50cGwgID0gdHVwbGU7XG4gICAgZW5jb2Rlci51dGlsID0gZGw7XG4gICAgZW5jb2Rlci5kMyAgID0gZDM7IC8vIEZvciBjb2xvciBzcGFjZXNcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiAgZW5jb2RlcixcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoZGVwcy5zaWduYWxzKSxcbiAgICAgIHNjYWxlczogIGRsLmtleXMoZGVwcy5zY2FsZXMpLFxuICAgICAgZGF0YTogICAgZGwua2V5cyhkZXBzLmRhdGEpLFxuICAgICAgZmllbGRzOiAgZGwua2V5cyhkZXBzLmZpZWxkcyksXG4gICAgICByZWZsb3c6ICBkZXBzLnJlZmxvd1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRsLmVycm9yKGUpO1xuICAgIGRsLmxvZyhjb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXRoKG1hcmssIHZhcnMpIHtcbiAgcmV0dXJuIHZhcnMucGF0aCB8fFxuICAgICgobWFyaz09PVwiYXJlYVwiIHx8IG1hcms9PT1cImxpbmVcIikgJiZcbiAgICAgICh2YXJzLnggfHwgdmFycy54MiB8fCB2YXJzLndpZHRoIHx8XG4gICAgICAgdmFycy55IHx8IHZhcnMueTIgfHwgdmFycy5oZWlnaHQgfHxcbiAgICAgICB2YXJzLnRlbnNpb24gfHwgdmFycy5pbnRlcnBvbGF0ZSkpO1xufVxuXG5mdW5jdGlvbiBydWxlKG1vZGVsLCBuYW1lLCBydWxlcykge1xuICB2YXIgc2lnbmFscyA9IFtdLCBzY2FsZXMgPSBbXSwgZGIgPSBbXSxcbiAgICAgIGlucHV0cyA9IFtdLCBjb2RlID0gXCJcIjtcblxuICAocnVsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICB2YXIgcHJlZE5hbWUgPSByLnByZWRpY2F0ZSxcbiAgICAgICAgcHJlZCA9IG1vZGVsLnByZWRpY2F0ZShwcmVkTmFtZSksXG4gICAgICAgIHAgPSBcInByZWRpY2F0ZXNbXCIrZGwuc3RyKHByZWROYW1lKStcIl1cIixcbiAgICAgICAgaW5wdXQgPSBbXSwgYXJncyA9IG5hbWUrXCJfYXJnXCIraSxcbiAgICAgICAgcmVmO1xuXG4gICAgZGwua2V5cyhyLmlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZVJlZihpLCByLmlucHV0W2tdKTtcbiAgICAgIGlucHV0LnB1c2goZGwuc3RyKGspK1wiOiBcIityZWYudmFsKTtcbiAgICAgIGlmKHJlZi5zaWduYWxzKSBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgZGwuYXJyYXkocmVmLnNpZ25hbHMpKTtcbiAgICAgIGlmKHJlZi5zY2FsZXMpICBzY2FsZXMucHVzaC5hcHBseShzY2FsZXMsIGRsLmFycmF5KHJlZi5zY2FsZXMpKTtcbiAgICB9KTtcblxuICAgIHJlZiA9IHZhbHVlUmVmKG5hbWUsIHIpO1xuICAgIGlmKHJlZi5zaWduYWxzKSBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgZGwuYXJyYXkocmVmLnNpZ25hbHMpKTtcbiAgICBpZihyZWYuc2NhbGVzKSAgc2NhbGVzLnB1c2guYXBwbHkoc2NhbGVzLCBkbC5hcnJheShyZWYuc2NhbGVzKSk7XG5cbiAgICBpZihwcmVkTmFtZSkge1xuICAgICAgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIHByZWQuc2lnbmFscyk7XG4gICAgICBkYi5wdXNoLmFwcGx5KGRiLCBwcmVkLmRhdGEpO1xuICAgICAgaW5wdXRzLnB1c2goYXJncytcIiA9IHtcIitpbnB1dC5qb2luKCcsICcpK1wifVwiKTtcbiAgICAgIGNvZGUgKz0gXCJpZihcIitwK1wiLmNhbGwoXCIrcCtcIixcIithcmdzK1wiLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykpIHtcXG5cIiArXG4gICAgICAgIFwiICAgIHRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1xcblwiO1xuICAgICAgY29kZSArPSBydWxlc1tpKzFdID8gXCIgIH0gZWxzZSBcIiA6IFwiICB9XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJ7XFxuXCIgKyBcbiAgICAgICAgXCIgICAgdGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XFxuXCIrXG4gICAgICAgIFwiICB9XCI7XG4gICAgfVxuICB9KTtcblxuICBjb2RlID0gXCJ2YXIgXCIgKyBpbnB1dHMuam9pbihcIixcXG4gICAgICBcIikgKyBcIjtcXG4gIFwiICsgY29kZTtcbiAgcmV0dXJuIHtjb2RlOiBjb2RlLCBzaWduYWxzOiBzaWduYWxzLCBzY2FsZXM6IHNjYWxlcywgZGF0YTogZGJ9O1xufVxuXG5mdW5jdGlvbiB2YWx1ZVJlZihuYW1lLCByZWYpIHtcbiAgaWYgKHJlZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICBpZiAobmFtZT09PVwiZmlsbFwiIHx8IG5hbWU9PT1cInN0cm9rZVwiKSB7XG4gICAgaWYgKHJlZi5jKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJoY2xcIiwgcmVmLmgsIHJlZi5jLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYuaCB8fCByZWYucykge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwiaHNsXCIsIHJlZi5oLCByZWYucywgcmVmLmwpO1xuICAgIH0gZWxzZSBpZiAocmVmLmwgfHwgcmVmLmEpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcImxhYlwiLCByZWYubCwgcmVmLmEsIHJlZi5iKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5yIHx8IHJlZi5nIHx8IHJlZi5iKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJyZ2JcIiwgcmVmLnIsIHJlZi5nLCByZWYuYik7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB2YWx1ZVxuICB2YXIgdmFsID0gbnVsbCwgc2NhbGUgPSBudWxsLCBcbiAgICAgIHNnUmVmID0ge30sIGZSZWYgPSB7fSwgc1JlZiA9IHt9LFxuICAgICAgc2lnbmFscyA9IFtdLCBmaWVsZHMgPSBbXSwgcmVmbG93ID0gZmFsc2U7XG5cbiAgaWYgKHJlZi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gZGwuc3RyKHJlZi52YWx1ZSk7XG4gIH1cblxuICBpZiAocmVmLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2dSZWYgPSBkbC5maWVsZChyZWYuc2lnbmFsKTtcbiAgICB2YWwgPSBcInNpZ25hbHNbXCIrc2dSZWYubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiOyBcbiAgICBzaWduYWxzLnB1c2goc2dSZWYuc2hpZnQoKSk7XG4gIH1cblxuICBpZihyZWYuZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJlZi5maWVsZCA9IGRsLmlzU3RyaW5nKHJlZi5maWVsZCkgPyB7ZGF0dW06IHJlZi5maWVsZH0gOiByZWYuZmllbGQ7XG4gICAgZlJlZiAgPSBmaWVsZFJlZihyZWYuZmllbGQpO1xuICAgIHZhbCA9IGZSZWYudmFsO1xuICB9XG5cbiAgaWYgKHJlZi5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc1JlZiA9IHNjYWxlUmVmKHJlZi5zY2FsZSk7XG4gICAgc2NhbGUgPSBzUmVmLnZhbDtcblxuICAgIC8vIHJ1biB0aHJvdWdoIHNjYWxlIGZ1bmN0aW9uIGlmIHZhbCBzcGVjaWZpZWQuXG4gICAgLy8gaWYgbm8gdmFsLCBzY2FsZSBmdW5jdGlvbiBpcyBwcmVkaWNhdGUgYXJnLlxuICAgIGlmKHZhbCAhPT0gbnVsbCB8fCByZWYuYmFuZCB8fCByZWYubXVsdCB8fCByZWYub2Zmc2V0KSB7XG4gICAgICB2YWwgPSBzY2FsZSArIChyZWYuYmFuZCA/IFwiLnJhbmdlQmFuZCgpXCIgOiBcbiAgICAgICAgXCIoXCIrKHZhbCAhPT0gbnVsbCA/IHZhbCA6IFwiaXRlbS5kYXR1bS5kYXRhXCIpK1wiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gc2NhbGU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBtdWx0aXBseSwgb2Zmc2V0LCByZXR1cm4gdmFsdWVcbiAgdmFsID0gXCIoXCIgKyAocmVmLm11bHQ/KGRsLm51bWJlcihyZWYubXVsdCkrXCIgKiBcIik6XCJcIikgKyB2YWwgKyBcIilcIlxuICAgICsgKHJlZi5vZmZzZXQgPyBcIiArIFwiICsgZGwubnVtYmVyKHJlZi5vZmZzZXQpIDogXCJcIik7XG5cbiAgLy8gQ29sbGF0ZSBkZXBlbmRlbmNpZXNcbiAgcmV0dXJuIHtcbiAgICB2YWw6IHZhbCxcbiAgICBzaWduYWxzOiBzaWduYWxzLmNvbmNhdChkbC5hcnJheShmUmVmLnNpZ25hbHMpKS5jb25jYXQoZGwuYXJyYXkoc1JlZi5zaWduYWxzKSksXG4gICAgZmllbGRzOiAgZmllbGRzLmNvbmNhdChkbC5hcnJheShmUmVmLmZpZWxkcykpLmNvbmNhdChkbC5hcnJheShzUmVmLmZpZWxkcykpLFxuICAgIHNjYWxlczogIHJlZi5zY2FsZSA/IChyZWYuc2NhbGUubmFtZSB8fCByZWYuc2NhbGUpIDogbnVsbCwgLy8gVE9ETzogY29ubmVjdCBzUmVmJ2Qgc2NhbGU/XG4gICAgcmVmbG93OiAgcmVmbG93IHx8IGZSZWYucmVmbG93IHx8IHNSZWYucmVmbG93XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbG9yUmVmKHR5cGUsIHgsIHksIHopIHtcbiAgdmFyIHh4ID0geCA/IHZhbHVlUmVmKFwiXCIsIHgpIDogY29uZmlnLmNvbG9yW3R5cGVdWzBdLFxuICAgICAgeXkgPSB5ID8gdmFsdWVSZWYoXCJcIiwgeSkgOiBjb25maWcuY29sb3JbdHlwZV1bMV0sXG4gICAgICB6eiA9IHogPyB2YWx1ZVJlZihcIlwiLCB6KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsyXVxuICAgICAgc2lnbmFscyA9IFtdLCBzY2FsZXMgPSBbXTtcblxuICBbeHgsIHl5LCB6el0uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgaWYodi5zaWduYWxzKSBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgdi5zaWduYWxzKTtcbiAgICBpZih2LnNjYWxlcykgIHNjYWxlcy5wdXNoKHYuc2NhbGVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWw6IFwiKHRoaXMuZDMuXCIgKyB0eXBlICsgXCIoXCIgKyBbeHgudmFsLCB5eS52YWwsIHp6LnZhbF0uam9pbihcIixcIikgKyAnKSArIFwiXCIpJyxcbiAgICBzaWduYWxzOiBzaWduYWxzLFxuICAgIHNjYWxlczogc2NhbGVzXG4gIH07XG59XG5cbi8vIHtmaWVsZDoge2RhdHVtOiBcImZvb1wifSB9ICAtPiBpdGVtLmRhdHVtLmZvb1xuLy8ge2ZpZWxkOiB7Z3JvdXA6IFwiZm9vXCJ9IH0gIC0+IGdyb3VwLmZvb1xuLy8ge2ZpZWxkOiB7cGFyZW50OiBcImZvb1wifSB9IC0+IGdyb3VwLmRhdHVtLmZvb1xuZnVuY3Rpb24gZmllbGRSZWYocmVmKSB7XG4gIGlmKGRsLmlzU3RyaW5nKHJlZikpIHtcbiAgICByZXR1cm4ge3ZhbDogZGwuZmllbGQocmVmKS5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIil9O1xuICB9IFxuXG4gIC8vIFJlc29sdmUgbmVzdGluZy9wYXJlbnQgbG9va3Vwc1xuICB2YXIgbCA9IHJlZi5sZXZlbCxcbiAgICAgIG5lc3RlZCA9IChyZWYuZ3JvdXAgfHwgcmVmLnBhcmVudCkgJiYgbCxcbiAgICAgIHNjb3BlID0gbmVzdGVkID8gQXJyYXkobCkuam9pbihcImdyb3VwLm1hcmsuXCIpIDogXCJcIixcbiAgICAgIHIgPSBmaWVsZFJlZihyZWYuZGF0dW0gfHwgcmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQgfHwgcmVmLnNpZ25hbCksXG4gICAgICB2YWwgPSByLnZhbCxcbiAgICAgIGZpZWxkcyAgPSByLmZpZWxkcyAgfHwgW10sXG4gICAgICBzaWduYWxzID0gci5zaWduYWxzIHx8IFtdLFxuICAgICAgcmVmbG93ICA9IHIucmVmbG93ICB8fCBmYWxzZTsgLy8gTmVzdGVkIGZpZWxkcmVmcyB0cmlnZ2VyIGZ1bGwgcmVldmFsIG9mIEVuY29kZXIuXG5cbiAgaWYocmVmLmRhdHVtKSB7XG4gICAgdmFsID0gXCJpdGVtLmRhdHVtW1wiK3ZhbCtcIl1cIjtcbiAgICBmaWVsZHMucHVzaChyZWYuZGF0dW0pO1xuICB9IGVsc2UgaWYocmVmLmdyb3VwKSB7XG4gICAgdmFsID0gc2NvcGUrXCJncm91cFtcIit2YWwrXCJdXCI7XG4gICAgcmVmbG93ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHJlZi5wYXJlbnQpIHtcbiAgICB2YWwgPSBzY29wZStcImdyb3VwLmRhdHVtW1wiK3ZhbCtcIl1cIjtcbiAgICByZWZsb3cgPSB0cnVlO1xuICB9IGVsc2UgaWYocmVmLnNpZ25hbCkge1xuICAgIHZhbCA9IFwic2lnbmFsc1tcIit2YWwrXCJdXCI7XG4gICAgc2lnbmFscy5wdXNoKGRsLmZpZWxkKHJlZi5zaWduYWwpWzBdKTtcbiAgICByZWZsb3cgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHt2YWw6IHZhbCwgZmllbGRzOiBmaWVsZHMsIHNpZ25hbHM6IHNpZ25hbHMsIHJlZmxvdzogcmVmbG93fTtcbn1cblxuLy8ge3NjYWxlOiBcInhcIn1cbi8vIHtzY2FsZToge25hbWU6IFwieFwifX0sXG4vLyB7c2NhbGU6IGZpZWxkUmVmfVxuZnVuY3Rpb24gc2NhbGVSZWYocmVmKSB7XG4gIHZhciBzY2FsZSA9IG51bGwsXG4gICAgICBmciA9IG51bGw7XG5cbiAgaWYoZGwuaXNTdHJpbmcocmVmKSkge1xuICAgIHNjYWxlID0gZGwuc3RyKHJlZik7XG4gIH0gZWxzZSBpZihyZWYubmFtZSkge1xuICAgIHNjYWxlID0gZGwuaXNTdHJpbmcocmVmLm5hbWUpID8gZGwuc3RyKHJlZi5uYW1lKSA6IChmciA9IGZpZWxkUmVmKHJlZi5uYW1lKSkudmFsO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlID0gKGZyID0gZmllbGRSZWYocmVmKSkudmFsO1xuICB9XG5cbiAgc2NhbGUgPSBcImdyb3VwLnNjYWxlKFwiK3NjYWxlK1wiKVwiO1xuICBpZihyZWYuaW52ZXJ0KSBzY2FsZSArPSBcIi5pbnZlcnRcIjsgIC8vIFRPRE86IG9yZGluYWwgc2NhbGVzXG5cbiAgcmV0dXJuIGZyID8gKGZyLnZhbCA9IHNjYWxlLCBmcikgOiB7dmFsOiBzY2FsZX07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTsiLCJ2YXIgZXhwciA9IHJlcXVpcmUoJy4vZXhwcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlU2lnbmFscyhtb2RlbCwgc3BlYykge1xuICAvLyBwcm9jZXNzIGVhY2ggc2lnbmFsIGRlZmluaXRpb25cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBzaWduYWwgPSBtb2RlbC5zaWduYWwocy5uYW1lLCBzLmluaXQpLFxuICAgICAgICBleHA7XG5cbiAgICBpZihzLmV4cHIpIHtcbiAgICAgIGV4cCA9IGV4cHIocy5leHByKTtcbiAgICAgIHNpZ25hbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHIuZXZhbChtb2RlbCwgZXhwLmZuLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBleHAuc2lnbmFscyk7XG4gICAgICAgIGlmKHNwZWMuc2NhbGUpIHZhbHVlID0gbW9kZWwuc2NhbGUoc3BlYywgdmFsdWUpO1xuICAgICAgICBzaWduYWwudmFsdWUodmFsdWUpO1xuICAgICAgICBpbnB1dC5zaWduYWxzW3MubmFtZV0gPSAxO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBleHAuc2lnbmFscyk7XG4gICAgICBleHAuc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKGRlcCkgeyBtb2RlbC5zaWduYWwoZGVwKS5hZGRMaXN0ZW5lcihzaWduYWwpOyB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzcGVjO1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuLi9jb3JlL01vZGVsJyksIFxuICAgIFZpZXcgPSByZXF1aXJlKCcuLi9jb3JlL1ZpZXcnKSwgXG4gICAgcGFyc2VQYWRkaW5nID0gcmVxdWlyZSgnLi4vcGFyc2UvcGFkZGluZycpLFxuICAgIHBhcnNlTWFya3MgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrcycpLFxuICAgIHBhcnNlU2lnbmFscyA9IHJlcXVpcmUoJy4uL3BhcnNlL3NpZ25hbHMnKSxcbiAgICBwYXJzZVByZWRpY2F0ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9wcmVkaWNhdGVzJyksXG4gICAgcGFyc2VEYXRhID0gcmVxdWlyZSgnLi4vcGFyc2UvZGF0YScpLFxuICAgIHBhcnNlSW50ZXJhY3RvcnMgPSByZXF1aXJlKCcuLi9wYXJzZS9pbnRlcmFjdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlU3BlYyhzcGVjLCBjYWxsYmFjaywgdmlld0ZhY3RvcnkpIHtcbiAgLy8gcHJvdGVjdCBhZ2FpbnN0IHN1YnNlcXVlbnQgc3BlYyBtb2RpZmljYXRpb25cbiAgc3BlYyA9IGRsLmR1cGxpY2F0ZShzcGVjKTtcblxuICB2aWV3RmFjdG9yeSA9IHZpZXdGYWN0b3J5IHx8IFZpZXcuZmFjdG9yeTtcblxuICB2YXIgd2lkdGggPSBzcGVjLndpZHRoIHx8IDUwMCxcbiAgICAgIGhlaWdodCA9IHNwZWMuaGVpZ2h0IHx8IDUwMCxcbiAgICAgIHZpZXdwb3J0ID0gc3BlYy52aWV3cG9ydCB8fCBudWxsLFxuICAgICAgbW9kZWwgPSBuZXcgTW9kZWwoKTtcblxuICBwYXJzZUludGVyYWN0b3JzKG1vZGVsLCBzcGVjLCBmdW5jdGlvbigpIHtcbiAgICBtb2RlbC5kZWZzKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgcGFkZGluZzogcGFyc2VQYWRkaW5nKHNwZWMucGFkZGluZyksXG4gICAgICBzaWduYWxzOiBwYXJzZVNpZ25hbHMobW9kZWwsIHNwZWMuc2lnbmFscyksXG4gICAgICBwcmVkaWNhdGVzOiBwYXJzZVByZWRpY2F0ZXMobW9kZWwsIHNwZWMucHJlZGljYXRlcyksXG4gICAgICBtYXJrczogcGFyc2VNYXJrcyhtb2RlbCwgc3BlYywgd2lkdGgsIGhlaWdodCksXG4gICAgICBkYXRhOiBwYXJzZURhdGEobW9kZWwsIHNwZWMuZGF0YSwgZnVuY3Rpb24oKSB7IGNhbGxiYWNrKHZpZXdGYWN0b3J5KG1vZGVsKSk7IH0pXG4gICAgfSk7XG4gIH0pO1xufVxuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBjaGFuZ3NldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIHNlbGVjdG9yID0gcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi9leHByJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbnZhciBTVEFSVCA9IFwic3RhcnRcIiwgTUlERExFID0gXCJtaWRkbGVcIiwgRU5EID0gXCJlbmRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciBtb2RlbCA9IHZpZXcubW9kZWwoKSxcbiAgICAgIHNwZWMgID0gbW9kZWwuZGVmcygpLnNpZ25hbHMsXG4gICAgICByZWdpc3RlciA9IHt9LCBub2RlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHNwZWMsIHZhbHVlKSB7XG4gICAgdmFyIGRlZiA9IHNwZWMuc2NhbGUsXG4gICAgICAgIG5hbWUgID0gZGVmLm5hbWUgfHwgZGVmLnNpZ25hbCB8fCBkZWYsXG4gICAgICAgIHNjb3BlID0gZGVmLnNjb3BlID8gbW9kZWwuc2lnbmFsUmVmKGRlZi5zY29wZS5zaWduYWwpIDogbnVsbDtcblxuICAgIGlmKCFzY29wZSB8fCAhc2NvcGUuc2NhbGUpIHtcbiAgICAgIHNjb3BlID0gKHNjb3BlICYmIHNjb3BlLm1hcmspID8gc2NvcGUubWFyay5ncm91cCA6IG1vZGVsLnNjZW5lKCkuaXRlbXNbMF07XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gc2NvcGUuc2NhbGUobmFtZSk7XG4gICAgaWYoIXNjYWxlKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIGRlZi5pbnZlcnQgPyBzY2FsZS5pbnZlcnQodmFsdWUpIDogc2NhbGUodmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBuID0gbmV3IE5vZGUobW9kZWwpO1xuICAgIG4uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIWlucHV0LnNpZ25hbHNbc2VsZWN0b3Iuc2lnbmFsXSkgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuICAgICAgdmFyIHZhbCA9IGV4cHIuZXZhbChtb2RlbCwgZXhwLmZuLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBleHAuc2lnbmFscyk7XG4gICAgICBpZihzcGVjLnNjYWxlKSB2YWwgPSBzY2FsZShzcGVjLCB2YWwpO1xuICAgICAgc2lnLnZhbHVlKHZhbCk7XG4gICAgICBpbnB1dC5zaWduYWxzW3NpZy5uYW1lKCldID0gMTtcbiAgICAgIGlucHV0LnJlZmxvdyA9IHRydWU7XG4gICAgICByZXR1cm4gaW5wdXQ7ICBcbiAgICB9O1xuICAgIG4uZGVwZW5kZW5jeShDLlNJR05BTFMsIHNlbGVjdG9yLnNpZ25hbCk7XG4gICAgbi5hZGRMaXN0ZW5lcihzaWcpO1xuICAgIG1vZGVsLnNpZ25hbChzZWxlY3Rvci5zaWduYWwpLmFkZExpc3RlbmVyKG4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGV2ZW50KHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBmaWx0ZXJzID0gc2VsZWN0b3IuZmlsdGVycyB8fCBbXSxcbiAgICAgICAgdGFyZ2V0ID0gc2VsZWN0b3IudGFyZ2V0O1xuXG4gICAgaWYodGFyZ2V0KSBmaWx0ZXJzLnB1c2goXCJpLlwiK3RhcmdldC50eXBlK1wiPT1cIitkbC5zdHIodGFyZ2V0LnZhbHVlKSk7XG5cbiAgICByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0gPSByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0gfHwgW107XG4gICAgcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdLnB1c2goe1xuICAgICAgc2lnbmFsOiBzaWcsXG4gICAgICBleHA6IGV4cCxcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGV4cHIoZik7IH0pLFxuICAgICAgc3BlYzogc3BlY1xuICAgIH0pO1xuXG4gICAgbm9kZXNbc2VsZWN0b3IuZXZlbnRdID0gbm9kZXNbc2VsZWN0b3IuZXZlbnRdIHx8IG5ldyBOb2RlKG1vZGVsKTtcbiAgICBub2Rlc1tzZWxlY3Rvci5ldmVudF0uYWRkTGlzdGVuZXIoc2lnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvcmRlcmVkU3RyZWFtKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBuYW1lID0gc2lnLm5hbWUoKSwgXG4gICAgICAgIHRydWVGbiA9IGV4cHIoXCJ0cnVlXCIpLFxuICAgICAgICBzID0ge307XG5cbiAgICBzW1NUQVJUXSAgPSBtb2RlbC5zaWduYWwobmFtZSArIFNUQVJULCAgZmFsc2UpO1xuICAgIHNbTUlERExFXSA9IG1vZGVsLnNpZ25hbChuYW1lICsgTUlERExFLCBmYWxzZSk7XG4gICAgc1tFTkRdICAgID0gbW9kZWwuc2lnbmFsKG5hbWUgKyBFTkQsICAgIGZhbHNlKTtcblxuICAgIHZhciByb3V0ZXIgPSBuZXcgTm9kZShtb2RlbCk7XG4gICAgcm91dGVyLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGlmKHNbU1RBUlRdLnZhbHVlKCkgPT09IHRydWUgJiYgc1tFTkRdLnZhbHVlKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFRPRE86IEV4cGFuZCBzZWxlY3RvciBzeW50YXggdG8gYWxsb3cgc3RhcnQvZW5kIHNpZ25hbHMgaW50byBzdHJlYW0uXG4gICAgICAgIC8vIFVudGlsIHRoZW4sIHByZXZlbnQgb2xkIG1pZGRsZXMgZW50ZXJpbmcgc3RyZWFtIG9uIG5ldyBzdGFydC5cbiAgICAgICAgaWYoaW5wdXQuc2lnbmFsc1tuYW1lK1NUQVJUXSkgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuXG4gICAgICAgIHNpZy52YWx1ZShzW01JRERMRV0udmFsdWUoKSk7XG4gICAgICAgIGlucHV0LnNpZ25hbHNbbmFtZV0gPSAxO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmKHNbRU5EXS52YWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgIHNbU1RBUlRdLnZhbHVlKGZhbHNlKTtcbiAgICAgICAgc1tFTkRdLnZhbHVlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuICAgIH07XG4gICAgcm91dGVyLmFkZExpc3RlbmVyKHNpZyk7XG5cbiAgICBbU1RBUlQsIE1JRERMRSwgRU5EXS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciB2YWwgPSAoeCA9PSBNSURETEUpID8gZXhwIDogdHJ1ZUZuLFxuICAgICAgICAgIHNwID0gKHggPT0gTUlERExFKSA/IHNwZWMgOiB7fTtcblxuICAgICAgaWYoc2VsZWN0b3JbeF0uZXZlbnQpIGV2ZW50KHNbeF0sIHNlbGVjdG9yW3hdLCB2YWwsIHNwKTtcbiAgICAgIGVsc2UgaWYoc2VsZWN0b3JbeF0uc2lnbmFsKSBzaWduYWwoc1t4XSwgc2VsZWN0b3JbeF0sIHZhbCwgc3ApO1xuICAgICAgZWxzZSBpZihzZWxlY3Rvclt4XS5zdHJlYW0pIG1lcmdlZFN0cmVhbShzW3hdLCBzZWxlY3Rvclt4XS5zdHJlYW0sIHZhbCwgc3ApO1xuICAgICAgc1t4XS5hZGRMaXN0ZW5lcihyb3V0ZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICBzZWxlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIGlmKHMuZXZlbnQpICAgICAgIGV2ZW50KHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zaWduYWwpIHNpZ25hbChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc3RhcnQpICBvcmRlcmVkU3RyZWFtKHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zdHJlYW0pIG1lcmdlZFN0cmVhbShzaWcsIHMuc3RyZWFtLCBleHAsIHNwZWMpO1xuICAgIH0pO1xuICB9O1xuXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaWduYWwgPSBtb2RlbC5zaWduYWwoc2lnLm5hbWUpO1xuICAgIGlmKHNpZy5leHByKSByZXR1cm47ICAvLyBDYW5ub3QgaGF2ZSBhbiBleHByIGFuZCBzdHJlYW0gZGVmaW5pdGlvbi5cblxuICAgIChzaWcuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBzZWwgPSBzZWxlY3Rvci5wYXJzZShzdHJlYW0udHlwZSksXG4gICAgICAgICAgZXhwID0gZXhwcihzdHJlYW0uZXhwcik7XG4gICAgICBtZXJnZWRTdHJlYW0oc2lnbmFsLCBzZWwsIGV4cCwgc3RyZWFtKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2UgcmVnaXN0ZXIgdGhlIGV2ZW50IGxpc3RlbmVycyBhbGwgdG9nZXRoZXIgc28gdGhhdCBpZiBtdWx0aXBsZVxuICAvLyBzaWduYWxzIGFyZSByZWdpc3RlcmVkIG9uIHRoZSBzYW1lIGV2ZW50LCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGVcbiAgLy8gbmV3IHZhbHVlIG9uIHRoZSBzYW1lIHB1bHNlLiBcblxuICAvLyBUT0RPOiBGaWx0ZXJzLCB0aW1lIGludGVydmFscywgdGFyZ2V0IHNlbGVjdG9yc1xuICBkbC5rZXlzKHJlZ2lzdGVyKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSByZWdpc3RlcltyXSwgXG4gICAgICAgIG5vZGUgPSBub2Rlc1tyXTtcblxuICAgIHZpZXcub24ociwgZnVuY3Rpb24oZXZ0LCBpdGVtKSB7XG4gICAgICB2YXIgY3MgPSBjaGFuZ3NldC5jcmVhdGUobnVsbCwgdHJ1ZSksXG4gICAgICAgICAgcGFkID0gdmlldy5wYWRkaW5nKCksXG4gICAgICAgICAgZmlsdGVyZWQgPSBmYWxzZSxcbiAgICAgICAgICB2YWwsIGgsIGksIG0sIGQ7XG5cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIHRleHQgc2VsZWN0aW9uXG4gICAgICBtID0gZDMubW91c2UoKGQzLmV2ZW50PWV2dCwgdmlldy5fZWwpKTsgLy8gUmVsYXRpdmUgcG9zaXRpb24gd2l0aGluIGNvbnRhaW5lclxuICAgICAgaXRlbSA9IGl0ZW18fHt9O1xuICAgICAgZCA9IGl0ZW0uZGF0dW18fHt9O1xuICAgICAgdmFyIHAgPSB7eDogbVswXSAtIHBhZC5sZWZ0LCB5OiBtWzFdIC0gcGFkLnRvcH07XG5cbiAgICAgIGZvcihpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGggPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgZmlsdGVyZWQgPSBoLmZpbHRlcnMuc29tZShmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuICFleHByLmV2YWwobW9kZWwsIGYuZm4sIGQsIGV2dCwgaXRlbSwgcCwgZi5zaWduYWxzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGZpbHRlcmVkKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhbCA9IGV4cHIuZXZhbChtb2RlbCwgaC5leHAuZm4sIGQsIGV2dCwgaXRlbSwgcCwgaC5leHAuc2lnbmFscyk7IFxuICAgICAgICBpZihoLnNwZWMuc2NhbGUpIHZhbCA9IHNjYWxlKGguc3BlYywgdmFsLCBpdGVtKTtcbiAgICAgICAgaC5zaWduYWwudmFsdWUodmFsKTtcbiAgICAgICAgY3Muc2lnbmFsc1toLnNpZ25hbC5uYW1lKCldID0gMTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwucHJvcGFnYXRlKGNzLCBub2RlKTtcbiAgICB9KTtcbiAgfSlcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHRyYW5zZm9ybXMgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL2luZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCBkZWYpIHtcbiAgdmFyIHR4ID0gbmV3IHRyYW5zZm9ybXNbZGVmLnR5cGVdKG1vZGVsKTtcbiAgaWYoZGVmLnR5cGUgPT0gJ2ZhY2V0Jykge1xuICAgIHZhciBwaXBlbGluZSA9IChkZWYudHJhbnNmb3JtfHxbXSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCB0KTsgfSk7XG4gICAgdHgucGlwZWxpbmUocGlwZWxpbmUpO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byByZW5hbWUgb3V0cHV0IGZpZWxkcyBiZWZvcmUgc2V0dGluZyBhbnkgb3RoZXIgcHJvcGVydGllcyxcbiAgLy8gYXMgc3Vic2VxdWVudCBwcm9wZXJ0aWVzIG1heSByZXF1aXJlIG91dHB1dCB0byBiZSBzZXQgKGUuZy4gZ3JvdXAgYnkpLlxuICBpZihkZWYub3V0cHV0KSB0eC5vdXRwdXQoZGVmLm91dHB1dCk7XG5cbiAgZGwua2V5cyhkZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmKGsgPT09ICd0eXBlJyB8fCBrID09PSAnb3V0cHV0JykgcmV0dXJuO1xuICAgIGlmKGsgPT09ICd0cmFuc2Zvcm0nICYmIGRlZi50eXBlID09PSAnZmFjZXQnKSByZXR1cm47XG4gICAgKHR4W2tdKS5zZXQodHgsIGRlZltrXSk7XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbnZhciBoYW5kbGVyID0gZnVuY3Rpb24oZWwsIG1vZGVsKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGlmIChlbCkgdGhpcy5pbml0aWFsaXplKGVsKTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsKG1vZGVsKTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSBoYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBkMy5zZWxlY3QoZWwpLm5vZGUoKTtcbiAgdGhpcy5fY2FudmFzID0gZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJjYW52YXMubWFya3NcIikubm9kZSgpO1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcywgdGhhdCA9IHRoaXM7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHByb3RvdHlwZVt0eXBlXS5jYWxsKHRoYXQsIGV2dCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICByZXR1cm4gZGwua2V5cyhoKS5yZWR1Y2UoZnVuY3Rpb24oYSwgaykge1xuICAgIHJldHVybiBoW2tdLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7IHJldHVybiAoYS5wdXNoKHgpLCBhKTsgfSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbi8vIHNldHVwIGV2ZW50c1xudmFyIGV2ZW50cyA9IFtcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZXVwXCIsXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIndoZWVsXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXByZXNzXCIsXG4gIFwia2V5dXBcIixcbiAgXCJtb3VzZXdoZWVsXCIsXG4gIFwidG91Y2hzdGFydFwiXG5dO1xuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICBwcm90b3R5cGVbdHlwZV0gPSBmdW5jdGlvbihldnQpIHtcbiAgICB0aGlzLmZpcmUodHlwZSwgZXZ0KTtcbiAgfTtcbn0pO1xuZXZlbnRzLnB1c2goXCJtb3VzZW1vdmVcIik7XG5ldmVudHMucHVzaChcIm1vdXNlb3V0XCIpO1xuZXZlbnRzLnB1c2goXCJ0b3VjaG1vdmVcIik7XG5ldmVudHMucHVzaChcInRvdWNoZW5kXCIpO1xuXG5mdW5jdGlvbiBldmVudE5hbWUobmFtZSkge1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi5cIik7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59XG5cbnByb3RvdHlwZS50b3VjaG1vdmUgPSBwcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IGV2dC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB4ID0gZXZ0LmNsaWVudFggLSBiLmxlZnQsXG4gICAgICB5ID0gZXZ0LmNsaWVudFkgLSBiLnRvcCxcbiAgICAgIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBwID0gdGhpcy5waWNrKHRoaXMuX21vZGVsLnNjZW5lKCksIHgsIHksIHgtcGFkLmxlZnQsIHktcGFkLnRvcCk7XG5cbiAgaWYgKHAgPT09IGEpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW1vdmVcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNobW92ZVwiKSB0aGlzLmZpcmUoXCJ0b3VjaG1vdmVcIiwgZXZ0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaGVuZFwiKSB0aGlzLmZpcmUoXCJ0b3VjaGVuZFwiLCBldnQpO1xuICB9XG4gIHRoaXMuX2FjdGl2ZSA9IHA7XG4gIGlmIChwKSB7XG4gICAgdGhpcy5maXJlKFwibW91c2VvdmVyXCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaHN0YXJ0XCIpIHRoaXMuZmlyZShcInRvdWNoc3RhcnRcIiwgZXZ0KTtcbiAgfVxufTtcblxucHJvdG90eXBlLnRvdWNoZW5kID0gcHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW91dFwiLCBldnQpO1xuICAgIHRoaXMuZmlyZShcInRvdWNoZW5kXCIsIGV2dCk7XG4gIH1cbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbn07XG5cbi8vIHRvIGtlZXAgZmlyZWZveCBoYXBweVxucHJvdG90eXBlLkRPTU1vdXNlU2Nyb2xsID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuZmlyZShcIm1vdXNld2hlZWxcIiwgZXZ0KTtcbn07XG5cbi8vIGZpcmUgYW4gZXZlbnRcbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZXZ0KSB7XG4gIHZhciBhID0gdGhpcy5fYWN0aXZlLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuICBpZiAoaCkge1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBoW2ldLmhhbmRsZXIuY2FsbCh0aGlzLl9vYmosIGV2dCwgYSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycztcbiAgaCA9IGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSk7XG4gIGgucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSBoLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbn07XG5cbi8vIGZpbmQgdGhlIHNjZW5lZ3JhcGggaXRlbSBhdCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuLy8geCwgeSAtLSB0aGUgYWJzb2x1dGUgeCwgeSBtb3VzZSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzIGVsZW1lbnRcbi8vIGd4LCBneSAtLSB0aGUgcmVsYXRpdmUgY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBjdXJyZW50IGdyb3VwXG5wcm90b3R5cGUucGljayA9IGZ1bmN0aW9uKHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICBwaWNrZXIgPSBtYXJrcy5waWNrW21hcmt0eXBlXTtcbiAgcmV0dXJuIHBpY2tlci5jYWxsKHRoaXMsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N0eCA9IG51bGw7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5faW1nbG9hZCA9IDA7XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgXG4gIGlmICghZWwpIHJldHVybiB0aGlzOyAvLyBlYXJseSBleGl0IGlmIG5vIERPTSBlbGVtZW50XG5cbiAgLy8gc2VsZWN0IGNhbnZhcyBlbGVtZW50XG4gIHZhciBjYW52YXMgPSBkMy5zZWxlY3QoZWwpXG4gICAgLnNlbGVjdEFsbChcImNhbnZhcy5tYXJrc1wiKVxuICAgIC5kYXRhKFsxXSk7XG4gIFxuICAvLyBjcmVhdGUgbmV3IGNhbnZhcyBlbGVtZW50IGlmIG5lZWRlZFxuICBjYW52YXMuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjYW52YXNcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwibWFya3NcIik7XG4gIFxuICAvLyByZW1vdmUgZXh0cmFuZW91cyBjYW52YXMgaWYgbmVlZGVkXG4gIGNhbnZhcy5leGl0KCkucmVtb3ZlKCk7XG4gIFxuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICBcbiAgaWYgKHRoaXMuX2VsKSB7XG4gICAgdmFyIGNhbnZhcyA9IGQzLnNlbGVjdCh0aGlzLl9lbCkuc2VsZWN0KFwiY2FudmFzLm1hcmtzXCIpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjYW52YXMgYXR0cmlidXRlc1xuICAgIGNhbnZhc1xuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0KVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20pO1xuXG4gICAgLy8gZ2V0IHRoZSBjYW52YXMgZ3JhcGhpY3MgY29udGV4dFxuICAgIHZhciBzO1xuICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5ub2RlKCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHRoaXMuX2N0eC5fcmF0aW8gPSAocyA9IHNjYWxlQ2FudmFzKGNhbnZhcy5ub2RlKCksIHRoaXMuX2N0eCkgfHwgMSk7XG4gICAgdGhpcy5fY3R4LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCBzKnBhZC5sZWZ0LCBzKnBhZC50b3ApO1xuICB9XG4gIFxuICBpbml0aWFsaXplTGluZURhc2godGhpcy5fY3R4KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBzY2FsZUNhbnZhcyhjYW52YXMsIGN0eCkge1xuICAvLyBnZXQgY2FudmFzIHBpeGVsIGRhdGFcbiAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSAoXG4gICAgICAgIGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvKSB8fCAxLFxuICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cbiAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IGJhY2tpbmdTdG9yZVJhdGlvKSB7XG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGgsIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIC8vIHNldCBhY3R1YWwgYW5kIHZpc2libGUgY2FudmFzIHNpemVcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyAqIHJhdGlvKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGggKiByYXRpbyk7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICB9XG4gIHJldHVybiByYXRpbztcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUxpbmVEYXNoKGN0eCkge1xuICBpZiAoY3R4LnZnTGluZURhc2gpIHJldHVybjsgLy8gYWxyZWFkeSBzZXRcblxuICB2YXIgTk9EQVNIID0gW107XG4gIGlmIChjdHguc2V0TGluZURhc2gpIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5zZXRMaW5lRGFzaChkYXNoIHx8IE5PREFTSCk7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy5saW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgud2Via2l0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICBcdGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLndlYmtpdExpbmVEYXNoID0gZGFzaCB8fCBOT0RBU0g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgubW96RGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMubW96RGFzaCA9IGRhc2g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgfSBlbHNlIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICB9XG59XG5cbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gIGlmIChjdHgpIHsgdGhpcy5fY3R4ID0gY3R4OyByZXR1cm4gdGhpczsgfVxuICBlbHNlIHJldHVybiB0aGlzLl9jdHg7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUucGVuZGluZ0ltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW1nbG9hZDtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgYm91bmRzKSB7XG4gIHZhciBiID0gbmV3IEJvdW5kcyhib3VuZHMpO1xuICB3aGlsZSAoKGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApICE9IG51bGwpIHtcbiAgICBiLnRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xuICB9XG4gIHJldHVybiBiO1xufVxuICBcbmZ1bmN0aW9uIGdldEJvdW5kcyhpdGVtcykge1xuICByZXR1cm4gIWl0ZW1zID8gbnVsbCA6XG4gICAgZGwuYXJyYXkoaXRlbXMpLnJlZHVjZShmdW5jdGlvbihiLCBpdGVtKSB7XG4gICAgICByZXR1cm4gYi51bmlvbih0cmFuc2xhdGVkQm91bmRzKGl0ZW0sIGl0ZW0uYm91bmRzKSlcbiAgICAgICAgICAgICAgLnVuaW9uKHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgaXRlbVsnYm91bmRzOnByZXYnXSkpO1xuICAgIH0sIG5ldyBCb3VuZHMoKSk7ICBcbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGcsIGJvdW5kcykge1xuICB2YXIgYmJveCA9IG51bGw7XG4gIGlmIChib3VuZHMpIHtcbiAgICBiYm94ID0gKG5ldyBCb3VuZHMoYm91bmRzKSkucm91bmQoKTtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGcucmVjdChiYm94LngxLCBiYm94LnkxLCBiYm94LndpZHRoKCksIGJib3guaGVpZ2h0KCkpO1xuICAgIGcuY2xpcCgpO1xuICB9XG4gIHJldHVybiBiYm94O1xufVxuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIHZhciBnID0gdGhpcy5fY3R4LFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIHcgPSB0aGlzLl93aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgICAgaCA9IHRoaXMuX2hlaWdodCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICAgICAgYmIgPSBudWxsLCBiYjI7XG5cbiAgLy8gc2V0dXBcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgZy5zYXZlKCk7XG4gIGJiID0gc2V0Qm91bmRzKGcsIGdldEJvdW5kcyhpdGVtcykpO1xuICBnLmNsZWFyUmVjdCgtcGFkLmxlZnQsIC1wYWQudG9wLCB3LCBoKTtcblxuICAvLyByZW5kZXJcbiAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYik7XG5cbiAgLy8gcmVuZGVyIGFnYWluIHRvIGhhbmRsZSBwb3NzaWJsZSBib3VuZHMgY2hhbmdlXG4gIGlmIChpdGVtcykge1xuICAgIGcucmVzdG9yZSgpO1xuICAgIGcuc2F2ZSgpO1xuICAgIGJiMiA9IHNldEJvdW5kcyhnLCBnZXRCb3VuZHMoaXRlbXMpKTtcbiAgICBpZiAoIWJiLmVuY2xvc2VzKGJiMikpIHtcbiAgICAgIGcuY2xlYXJSZWN0KC1wYWQubGVmdCwgLXBhZC50b3AsIHcsIGgpO1xuICAgICAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYjIpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gdGFrZWRvd25cbiAgZy5yZXN0b3JlKCk7XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBtYXJrdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgcmVuZGVyZXIgPSBtYXJrcy5kcmF3W21hcmt0eXBlXTtcbiAgcmVuZGVyZXIuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xufTtcblxucHJvdG90eXBlLnJlbmRlckFzeW5jID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgLy8gVE9ETyBtYWtlIHNhZmUgZm9yIG11bHRpcGxlIHNjZW5lIHJlbmRlcmluZz9cbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgaWYgKHJlbmRlcmVyLl9hc3luY19pZCkge1xuICAgIGNsZWFyVGltZW91dChyZW5kZXJlci5fYXN5bmNfaWQpO1xuICB9XG4gIHJlbmRlcmVyLl9hc3luY19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lKTtcbiAgICBkZWxldGUgcmVuZGVyZXIuX2FzeW5jX2lkO1xuICB9LCA1MCk7XG59O1xuXG5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJpKSB7XG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBzY2VuZSA9IHJlbmRlcmVyLl9zY2VuZSxcbiAgICAgIGltYWdlID0gbnVsbCwgdXJsO1xuXG4gIHJlbmRlcmVyLl9pbWdsb2FkICs9IDE7XG4gIGlmIChkbC5pc05vZGUpIHtcbiAgICBpbWFnZSA9IG5ldyAoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuY2FudmFzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5jYW52YXMgOiBudWxsKS5JbWFnZSkoKTtcbiAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiB1cml9LCBjb25maWcubG9hZCksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgeyBkbC5lcnJvcihlcnIpOyByZXR1cm47IH1cbiAgICAgIGltYWdlLnNyYyA9IGRhdGE7XG4gICAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuX2ltZ2xvYWQgLT0gMTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgdXJpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaW1hZ2UubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJlbmRlcmVyLl9pbWdsb2FkIC09IDE7XG4gICAgICByZW5kZXJlci5yZW5kZXJBc3luYyhzY2VuZSk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gIH1cblxuICByZXR1cm4gaW1hZ2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9IYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1JlbmRlcmVyJylcbn07IiwidmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRzJyksXG4gICAgYm91bmRzQ2FsYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYm91bmRzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG5cbnZhciBwYXJzZVBhdGggPSBwYXRoLnBhcnNlLFxuICAgIHJlbmRlclBhdGggPSBwYXRoLnJlbmRlcixcbiAgICBoYWxmcGkgPSBNYXRoLlBJIC8gMixcbiAgICBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCksXG4gICAgdG1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgcmV0dXJuIChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250IHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG59XG5cbi8vIHBhdGggZ2VuZXJhdG9yc1xuXG5mdW5jdGlvbiBhcmNQYXRoKGcsIG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBNYXRoLlBJLzIsXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gTWF0aC5QSS8yO1xuICBnLmJlZ2luUGF0aCgpO1xuICBpZiAoaXIgPT09IDApIGcubW92ZVRvKHgsIHkpO1xuICBlbHNlIGcuYXJjKHgsIHksIGlyLCBzYSwgZWEsIDApO1xuICBnLmFyYyh4LCB5LCBvciwgZWEsIHNhLCAxKTtcbiAgZy5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gYXJlYVBhdGgoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIG0gPSBvLm1hcmssXG4gICAgICBwID0gbS5wYXRoQ2FjaGUgfHwgKG0ucGF0aENhY2hlID0gcGFyc2VQYXRoKHBhdGguYXJlYShpdGVtcykpKTtcbiAgcmVuZGVyUGF0aChnLCBwKTtcbn1cblxuZnVuY3Rpb24gbGluZVBhdGgoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIG0gPSBvLm1hcmssXG4gICAgICBwID0gbS5wYXRoQ2FjaGUgfHwgKG0ucGF0aENhY2hlID0gcGFyc2VQYXRoKHBhdGgubGluZShpdGVtcykpKTtcbiAgcmVuZGVyUGF0aChnLCBwKTtcbn1cblxuZnVuY3Rpb24gcGF0aFBhdGgoZywgbykge1xuICBpZiAoby5wYXRoID09IG51bGwpIHJldHVybjtcbiAgdmFyIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZVBhdGgoby5wYXRoKSk7XG4gIHJldHVybiByZW5kZXJQYXRoKGcsIHAsIG8ueCwgby55KTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sUGF0aChnLCBvKSB7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54LCB5ID0gby55LCByLCB0LCByeCwgcnk7XG5cbiAgaWYgKG8uc2hhcGUgPT0gbnVsbCB8fCBvLnNoYXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgciA9IE1hdGguc3FydChzaXplL01hdGguUEkpO1xuICAgIGcuYXJjKHgsIHksIHIsIDAsIDIqTWF0aC5QSSwgMCk7XG4gICAgZy5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlIFwiY3Jvc3NcIjpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBnLm1vdmVUbyh4LXQsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4LXQsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiB0YW4zMCkpO1xuICAgICAgcnggPSByeSAqIHRhbjMwO1xuICAgICAgZy5tb3ZlVG8oeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5KTtcbiAgICAgIGcubGluZVRvKHgsIHkrcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgIHQgPSBNYXRoLnNxcnQoc2l6ZSk7XG4gICAgICByID0gdCAvIDI7XG4gICAgICBnLnJlY3QoeC1yLCB5LXIsIHQsIHQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGUtZG93blwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBnLm1vdmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeS1yeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS11cFwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBnLm1vdmVUbyh4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHkrcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeStyeSk7XG4gIH1cbiAgZy5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gbGluZVN0cm9rZShnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgbHcgPSBvLnN0cm9rZVdpZHRoLFxuICAgICAgbGMgPSBvLnN0cm9rZUNhcDtcbiAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgZy5saW5lQ2FwICAgPSBsYyAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gIGxpbmVQYXRoKGcsIGl0ZW1zKTtcbn1cblxuZnVuY3Rpb24gcnVsZVN0cm9rZShnLCBvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMCxcbiAgICAgIHgyID0gby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgICAgeTIgPSBvLnkyICE9IG51bGwgPyBvLnkyIDogeTEsXG4gICAgICBsdyA9IG8uc3Ryb2tlV2lkdGgsXG4gICAgICBsYyA9IG8uc3Ryb2tlQ2FwO1xuXG4gIGcubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gIGcubGluZUNhcCAgID0gbGMgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICBnLmJlZ2luUGF0aCgpO1xuICBnLm1vdmVUbyh4MSwgeTEpO1xuICBnLmxpbmVUbyh4MiwgeTIpO1xufVxuXG4vLyBkcmF3aW5nIGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBkcmF3UGF0aE9uZShwYXRoLCBnLCBvLCBpdGVtcykge1xuICB2YXIgZmlsbCA9IG8uZmlsbCwgc3Ryb2tlID0gby5zdHJva2UsIG9wYWMsIGxjLCBsdztcblxuICBwYXRoKGcsIGl0ZW1zKTtcblxuICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICBpZiAob3BhYyA9PSAwIHx8ICFmaWxsICYmICFzdHJva2UpIHJldHVybjtcblxuICBpZiAoZmlsbCkge1xuICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gICAgZy5maWxsU3R5bGUgPSBjb2xvcihnLCBvLCBmaWxsKTtcbiAgICBnLmZpbGwoKTtcbiAgfVxuXG4gIGlmIChzdHJva2UpIHtcbiAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICAgIGlmIChsdyA+IDApIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKGcsIG8sIHN0cm9rZSk7XG4gICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgICBnLnZnTGluZURhc2hPZmZzZXQoby5zdHJva2VEYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgZy5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BhdGhBbGwocGF0aCwgZywgc2NlbmUsIGJvdW5kcykge1xuICB2YXIgaSwgbGVuLCBpdGVtO1xuICBmb3IgKGk9MCwgbGVuPXNjZW5lLml0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBzY2VuZS5pdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG4gICAgZHJhd1BhdGhPbmUocGF0aCwgZywgaXRlbSwgaXRlbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1JlY3QoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGZpbGwsIHN0cm9rZSwgb3BhYywgbGMsIGx3LCB4LCB5LCB3LCBoO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICB4ID0gby54IHx8IDA7XG4gICAgeSA9IG8ueSB8fCAwO1xuICAgIHcgPSBvLndpZHRoIHx8IDA7XG4gICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09IDApIGNvbnRpbnVlO1xuXG4gICAgaWYgKGZpbGwgPSBvLmZpbGwpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gICAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIGZpbGwpO1xuICAgICAgZy5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlID0gby5zdHJva2UpIHtcbiAgICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gICAgICBpZiAobHcgPiAwKSB7XG4gICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgc3Ryb2tlKTtcbiAgICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgICAgICAgZy52Z0xpbmVEYXNoKG8uc3Ryb2tlRGFzaCB8fCBudWxsKTtcbiAgICAgICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgICAgZy5zdHJva2VSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UnVsZShnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgc3Ryb2tlLCBvcGFjLCBsYywgbHcsIHgxLCB5MSwgeDIsIHkyO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICB4MSA9IG8ueCB8fCAwO1xuICAgIHkxID0gby55IHx8IDA7XG4gICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDE7XG4gICAgeTIgPSBvLnkyICE9IG51bGwgPyBvLnkyIDogeTE7XG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09IDApIGNvbnRpbnVlO1xuICAgIFxuICAgIGlmIChzdHJva2UgPSBvLnN0cm9rZSkge1xuICAgICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBzdHJva2UpO1xuICAgICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICAgICAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgICAgICBnLnZnTGluZURhc2hPZmZzZXQoby5zdHJva2VEYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgICBnLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICBnLmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3SW1hZ2UoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcywgbztcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgaWYgKCEoby5pbWFnZSAmJiBvLmltYWdlLnVybCA9PT0gby51cmwpKSB7XG4gICAgICBvLmltYWdlID0gcmVuZGVyZXIubG9hZEltYWdlKG8udXJsKTtcbiAgICAgIG8uaW1hZ2UudXJsID0gby51cmw7XG4gICAgfVxuXG4gICAgdmFyIHgsIHksIHcsIGgsIG9wYWM7XG4gICAgdyA9IG8ud2lkdGggfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS53aWR0aCkgfHwgMDtcbiAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDA7XG4gICAgeCA9IChvLnh8fDApIC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSk7XG4gICAgeSA9IChvLnl8fDApIC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpO1xuXG4gICAgaWYgKG8uaW1hZ2UubG9hZGVkKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gKG9wYWMgPSBvLm9wYWNpdHkpICE9IG51bGwgPyBvcGFjIDogMTtcbiAgICAgIGcuZHJhd0ltYWdlKG8uaW1hZ2UsIHgsIHksIHcsIGgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgZmlsbCwgc3Ryb2tlLCBvcGFjLCBsdywgeCwgeSwgciwgdDtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgZy5mb250ID0gZm9udFN0cmluZyhvKTtcbiAgICBnLnRleHRBbGlnbiA9IG8uYWxpZ24gfHwgXCJsZWZ0XCI7XG4gICAgZy50ZXh0QmFzZWxpbmUgPSBvLmJhc2VsaW5lIHx8IFwiYWxwaGFiZXRpY1wiO1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PSAwKSBjb250aW51ZTtcblxuICAgIHggPSBvLnggfHwgMDtcbiAgICB5ID0gby55IHx8IDA7XG4gICAgaWYgKHIgPSBvLnJhZGl1cykge1xuICAgICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgICB9XG5cbiAgICBpZiAoby5hbmdsZSkge1xuICAgICAgZy5zYXZlKCk7XG4gICAgICBnLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGcucm90YXRlKG8uYW5nbGUgKiBNYXRoLlBJLzE4MCk7XG4gICAgICB4ID0gby5keCB8fCAwO1xuICAgICAgeSA9IG8uZHkgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSAoby5keCB8fCAwKTtcbiAgICAgIHkgKz0gKG8uZHkgfHwgMCk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGwgPSBvLmZpbGwpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gICAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIGZpbGwpO1xuICAgICAgZy5maWxsVGV4dChvLnRleHQsIHgsIHkpO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UgPSBvLnN0cm9rZSkge1xuICAgICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiAxO1xuICAgICAgaWYgKGx3ID4gMCkge1xuICAgICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKG8sIHN0cm9rZSk7XG4gICAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGcuc3Ryb2tlVGV4dChvLnRleHQsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvLmFuZ2xlKSBnLnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QWxsKHBhdGhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgYm91bmRzKSB7XG4gICAgZHJhd1BhdGhBbGwocGF0aEZ1bmMsIGcsIHNjZW5lLCBib3VuZHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdPbmUocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKHNjZW5lLml0ZW1zWzBdLmJvdW5kcykpXG4gICAgICByZXR1cm47IC8vIGJvdW5kcyBjaGVja1xuICAgIGRyYXdQYXRoT25lKHBhdGhGdW5jLCBnLCBzY2VuZS5pdGVtc1swXSwgc2NlbmUuaXRlbXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdHcm91cChnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLCBncm91cCwgYXhlcywgbGVnZW5kcyxcbiAgICAgIHJlbmRlcmVyID0gdGhpcywgZ3gsIGd5LCBnYiwgaSwgbiwgaiwgbTtcblxuICBkcmF3UmVjdChnLCBzY2VuZSwgYm91bmRzKTtcblxuICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZ3JvdXAgPSBpdGVtc1tpXTtcbiAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IFtdO1xuICAgIGxlZ2VuZHMgPSBncm91cC5sZWdlbmRJdGVtcyB8fCBbXTtcbiAgICBneCA9IGdyb3VwLnggfHwgMDtcbiAgICBneSA9IGdyb3VwLnkgfHwgMDtcblxuICAgIC8vIHJlbmRlciBncm91cCBjb250ZW50c1xuICAgIGcuc2F2ZSgpO1xuICAgIGcudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgaWYgKGdyb3VwLmNsaXApIHtcbiAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICBnLnJlY3QoMCwgMCwgZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICAgICAgZy5jbGlwKCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICAgIFxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyID09PSBcImJhY2tcIikge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWdyb3VwLml0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgZ3JvdXAuaXRlbXNbal0sIGJvdW5kcyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyICE9PSBcImJhY2tcIikge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgcmVuZGVyZXIuZHJhdyhnLCBsZWdlbmRzW2pdLCBib3VuZHMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgZy5yZXN0b3JlKCk7XG4gIH0gICAgXG59XG5cbmZ1bmN0aW9uIGNvbG9yKGcsIG8sIHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUuaWQpXG4gICAgPyBncmFkaWVudChnLCB2YWx1ZSwgby5ib3VuZHMpXG4gICAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ3JhZGllbnQoZywgcCwgYikge1xuICB2YXIgdyA9IGIud2lkdGgoKSxcbiAgICAgIGggPSBiLmhlaWdodCgpLFxuICAgICAgeDEgPSBiLngxICsgcC54MSAqIHcsXG4gICAgICB5MSA9IGIueTEgKyBwLnkxICogaCxcbiAgICAgIHgyID0gYi54MSArIHAueDIgKiB3LFxuICAgICAgeTIgPSBiLnkxICsgcC55MiAqIGgsXG4gICAgICBncmFkID0gZy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MiksXG4gICAgICBzdG9wID0gcC5zdG9wcyxcbiAgICAgIGksIG47XG5cbiAgZm9yIChpPTAsIG49c3RvcC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZ3JhZC5hZGRDb2xvclN0b3Aoc3RvcFtpXS5vZmZzZXQsIHN0b3BbaV0uY29sb3IpO1xuICB9XG4gIHJldHVybiBncmFkO1xufVxuXG4vLyBoaXQgdGVzdGluZ1xuXG5mdW5jdGlvbiBwaWNrR3JvdXAoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoc2NlbmUuaXRlbXMubGVuZ3RoID09PSAwIHx8XG4gICAgICBzY2VuZS5ib3VuZHMgJiYgIXNjZW5lLmJvdW5kcy5jb250YWlucyhneCwgZ3kpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLCBzdWJzY2VuZSwgZ3JvdXAsIGhpdCwgZHgsIGR5LFxuICAgICAgaGFuZGxlciA9IHRoaXMsIGksIGo7XG5cbiAgZm9yIChpPWl0ZW1zLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGdyb3VwID0gaXRlbXNbaV07XG4gICAgZHggPSBncm91cC54IHx8IDA7XG4gICAgZHkgPSBncm91cC55IHx8IDA7XG5cbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZShkeCwgZHkpO1xuICAgIGZvciAoaj1ncm91cC5pdGVtcy5sZW5ndGg7IC0taiA+PSAwOykge1xuICAgICAgc3Vic2NlbmUgPSBncm91cC5pdGVtc1tqXTtcbiAgICAgIGlmIChzdWJzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgaGl0ID0gaGFuZGxlci5waWNrKHN1YnNjZW5lLCB4LCB5LCBneC1keCwgZ3ktZHkpO1xuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZy5yZXN0b3JlKCk7XG4gIH1cblxuICByZXR1cm4gc2NlbmUuaW50ZXJhY3RpdmVcbiAgICA/IHBpY2tBbGwoaGl0VGVzdHMuZ3JvdXAsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpXG4gICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGlja0FsbCh0ZXN0LCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBvLCBiLCBpO1xuXG4gIGlmIChnLl9yYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5fcmF0aW87XG4gICAgeSAqPSBnLl9yYXRpbztcbiAgfVxuXG4gIGZvciAoaT1zY2VuZS5pdGVtcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgIG8gPSBzY2VuZS5pdGVtc1tpXTsgYiA9IG8uYm91bmRzO1xuICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgaWYgKChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHx8ICFiKSBjb250aW51ZTtcbiAgICAvLyBpZiBpbiBib3VuZGluZyBib3gsIHBlcmZvcm0gbW9yZSBjYXJlZnVsIHRlc3RcbiAgICBpZiAodGVzdChnLCBvLCB4LCB5LCBneCwgZ3kpKSByZXR1cm4gbztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBpY2tBcmVhKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBiLCBpLCBkaSwgZGQsIG9kLCBkeCwgZHk7XG5cbiAgYiA9IGl0ZW1zWzBdLmJvdW5kcztcbiAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZy5fcmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcuX3JhdGlvO1xuICAgIHkgKj0gZy5fcmF0aW87XG4gIH1cbiAgaWYgKCFoaXRUZXN0cy5hcmVhKGcsIGl0ZW1zLCB4LCB5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlbXNbMF07XG59XG5cbmZ1bmN0aW9uIHBpY2tMaW5lKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBiLCBpLCBkaSwgZGQsIG9kLCBkeCwgZHk7XG5cbiAgYiA9IGl0ZW1zWzBdLmJvdW5kcztcbiAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZy5fcmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcuX3JhdGlvO1xuICAgIHkgKj0gZy5fcmF0aW87XG4gIH1cbiAgaWYgKCFoaXRUZXN0cy5saW5lKGcsIGl0ZW1zLCB4LCB5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlbXNbMF07XG59XG5cbmZ1bmN0aW9uIHBpY2sodGVzdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICByZXR1cm4gcGlja0FsbCh0ZXN0LCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEhpdChnLCBvLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFvLmZvbnRTaXplKSByZXR1cm4gZmFsc2U7XG4gIGlmICghby5hbmdsZSkgcmV0dXJuIHRydWU7IC8vIGJvdW5kcyBzdWZmaWNpZW50IGlmIG5vIHJvdGF0aW9uXG5cbiAgdmFyIGIgPSBib3VuZHNDYWxjLnRleHQobywgdG1wQm91bmRzLCB0cnVlKSxcbiAgICAgIGEgPSAtby5hbmdsZSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBjb3MgPSBNYXRoLmNvcyhhKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGEpLFxuICAgICAgeCA9IG8ueCxcbiAgICAgIHkgPSBvLnksXG4gICAgICBweCA9IGNvcypneCAtIHNpbipneSArICh4IC0geCpjb3MgKyB5KnNpbiksXG4gICAgICBweSA9IHNpbipneCArIGNvcypneSArICh5IC0geCpzaW4gLSB5KmNvcyk7XG5cbiAgcmV0dXJuIGIuY29udGFpbnMocHgsIHB5KTtcbn1cblxudmFyIGhpdFRlc3RzID0ge1xuICB0ZXh0OiAgIHRleHRIaXQsXG4gIHJlY3Q6ICAgZnVuY3Rpb24oZyxvLHgseSkgeyByZXR1cm4gdHJ1ZTsgfSwgLy8gYm91bmRzIHRlc3QgaXMgc3VmZmljaWVudFxuICBpbWFnZTogIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcmV0dXJuIHRydWU7IH0sIC8vIGJvdW5kcyB0ZXN0IGlzIHN1ZmZpY2llbnRcbiAgZ3JvdXA6ICBmdW5jdGlvbihnLG8seCx5KSB7IHJldHVybiBvLmZpbGwgfHwgby5zdHJva2U7IH0sXG4gIHJ1bGU6ICAgZnVuY3Rpb24oZyxvLHgseSkge1xuICAgICAgICAgICAgaWYgKCFnLmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcnVsZVN0cm9rZShnLG8pOyByZXR1cm4gZy5pc1BvaW50SW5TdHJva2UoeCx5KTtcbiAgICAgICAgICB9LFxuICBsaW5lOiAgIGZ1bmN0aW9uKGcscyx4LHkpIHtcbiAgICAgICAgICAgIGlmICghZy5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxpbmVTdHJva2UoZyxzKTsgcmV0dXJuIGcuaXNQb2ludEluU3Ryb2tlKHgseSk7XG4gICAgICAgICAgfSxcbiAgYXJjOiAgICBmdW5jdGlvbihnLG8seCx5KSB7IGFyY1BhdGgoZyxvKTsgIHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfSxcbiAgYXJlYTogICBmdW5jdGlvbihnLHMseCx5KSB7IGFyZWFQYXRoKGcscyk7IHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfSxcbiAgcGF0aDogICBmdW5jdGlvbihnLG8seCx5KSB7IHBhdGhQYXRoKGcsbyk7IHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfSxcbiAgc3ltYm9sOiBmdW5jdGlvbihnLG8seCx5KSB7IHN5bWJvbFBhdGgoZyxvKTsgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzoge1xuICAgIGdyb3VwOiAgIGRyYXdHcm91cCxcbiAgICBhcmVhOiAgICBkcmF3T25lKGFyZWFQYXRoKSxcbiAgICBsaW5lOiAgICBkcmF3T25lKGxpbmVQYXRoKSxcbiAgICBhcmM6ICAgICBkcmF3QWxsKGFyY1BhdGgpLFxuICAgIHBhdGg6ICAgIGRyYXdBbGwocGF0aFBhdGgpLFxuICAgIHN5bWJvbDogIGRyYXdBbGwoc3ltYm9sUGF0aCksXG4gICAgcmVjdDogICAgZHJhd1JlY3QsXG4gICAgcnVsZTogICAgZHJhd1J1bGUsXG4gICAgdGV4dDogICAgZHJhd1RleHQsXG4gICAgaW1hZ2U6ICAgZHJhd0ltYWdlLFxuICAgIGRyYXdPbmU6IGRyYXdPbmUsIC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICAgIGRyYXdBbGw6IGRyYXdBbGwgIC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICB9LFxuICBwaWNrOiB7XG4gICAgZ3JvdXA6ICAgcGlja0dyb3VwLFxuICAgIGFyZWE6ICAgIHBpY2tBcmVhLFxuICAgIGxpbmU6ICAgIHBpY2tMaW5lLFxuICAgIGFyYzogICAgIHBpY2soaGl0VGVzdHMuYXJjKSxcbiAgICBwYXRoOiAgICBwaWNrKGhpdFRlc3RzLnBhdGgpLFxuICAgIHN5bWJvbDogIHBpY2soaGl0VGVzdHMuc3ltYm9sKSxcbiAgICByZWN0OiAgICBwaWNrKGhpdFRlc3RzLnJlY3QpLFxuICAgIHJ1bGU6ICAgIHBpY2soaGl0VGVzdHMucnVsZSksXG4gICAgdGV4dDogICAgcGljayhoaXRUZXN0cy50ZXh0KSxcbiAgICBpbWFnZTogICBwaWNrKGhpdFRlc3RzLmltYWdlKSxcbiAgICBwaWNrQWxsOiBwaWNrQWxsICAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgfVxufTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kcycpO1xuXG4vLyBQYXRoIHBhcnNpbmcgYW5kIHJlbmRlcmluZyBjb2RlIHRha2VuIGZyb20gZmFicmljLmpzIC0tIFRoYW5rcyFcbnZhciBjbWRMZW5ndGggPSB7IG06MiwgbDoyLCBoOjEsIHY6MSwgYzo2LCBzOjQsIHE6NCwgdDoyLCBhOjcgfSxcbiAgICByZSA9IFsvKFtNTEhWQ1NRVEFabWxodmNzcXRhel0pL2csIC8jIyMvLCAvKFxcZCktL2csIC9cXHN8LHwjIyMvXTtcblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBjdXJyZW50UGF0aCxcbiAgICAgIGNodW5rcyxcbiAgICAgIHBhcnNlZDtcblxuICAvLyBGaXJzdCwgYnJlYWsgcGF0aCBpbnRvIGNvbW1hbmQgc2VxdWVuY2VcbiAgcGF0aCA9IHBhdGguc2xpY2UoKS5yZXBsYWNlKHJlWzBdLCAnIyMjJDEnKS5zcGxpdChyZVsxXSkuc2xpY2UoMSk7XG5cbiAgLy8gTmV4dCwgcGFyc2UgZWFjaCBjb21tYW5kIGluIHR1cm5cbiAgZm9yICh2YXIgaT0wLCBqLCBjaHVua3NQYXJzZWQsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgIGN1cnJlbnRQYXRoID0gcGF0aFtpXTtcbiAgICBjaHVua3MgPSBjdXJyZW50UGF0aC5zbGljZSgxKS50cmltKCkucmVwbGFjZShyZVsyXSwnJDEjIyMtJykuc3BsaXQocmVbM10pO1xuICAgIGNodW5rc1BhcnNlZCA9IFtjdXJyZW50UGF0aC5jaGFyQXQoMCldO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBjaHVua3MubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KGNodW5rc1tqXSk7XG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgY2h1bmtzUGFyc2VkLnB1c2gocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tbWFuZCA9IGNodW5rc1BhcnNlZFswXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBjb21tYW5kTGVuZ3RoID0gY21kTGVuZ3RoW2NvbW1hbmRdO1xuXG4gICAgaWYgKGNodW5rc1BhcnNlZC5sZW5ndGggLSAxID4gY29tbWFuZExlbmd0aCkge1xuICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjaHVua3NQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFsgY2h1bmtzUGFyc2VkWzBdIF0uY29uY2F0KGNodW5rc1BhcnNlZC5zbGljZShrLCBrICsgY29tbWFuZExlbmd0aCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChjaHVua3NQYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoZywgeCwgeSwgY29vcmRzLCBib3VuZHMsIGwsIHQpIHtcbiAgdmFyIHJ4ID0gY29vcmRzWzBdO1xuICB2YXIgcnkgPSBjb29yZHNbMV07XG4gIHZhciByb3QgPSBjb29yZHNbMl07XG4gIHZhciBsYXJnZSA9IGNvb3Jkc1szXTtcbiAgdmFyIHN3ZWVwID0gY29vcmRzWzRdO1xuICB2YXIgZXggPSBjb29yZHNbNV07XG4gIHZhciBleSA9IGNvb3Jkc1s2XTtcbiAgdmFyIHNlZ3MgPSBhcmNUb1NlZ21lbnRzKGV4LCBleSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCwgeCwgeSk7XG4gIGZvciAodmFyIGk9MDsgaTxzZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJleiA9IHNlZ21lbnRUb0Jlemllci5hcHBseShudWxsLCBzZWdzW2ldKTtcbiAgICBnLmJlemllckN1cnZlVG8uYXBwbHkoZywgYmV6KTtcbiAgICBib3VuZHMuYWRkKGJlelswXS1sLCBiZXpbMV0tdCk7XG4gICAgYm91bmRzLmFkZChiZXpbMl0tbCwgYmV6WzNdLXQpO1xuICAgIGJvdW5kcy5hZGQoYmV6WzRdLWwsIGJlels1XS10KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZEFyYyh4LCB5LCBjb29yZHMsIGJvdW5kcykge1xuICB2YXIgcnggPSBjb29yZHNbMF07XG4gIHZhciByeSA9IGNvb3Jkc1sxXTtcbiAgdmFyIHJvdCA9IGNvb3Jkc1syXTtcbiAgdmFyIGxhcmdlID0gY29vcmRzWzNdO1xuICB2YXIgc3dlZXAgPSBjb29yZHNbNF07XG4gIHZhciBleCA9IGNvb3Jkc1s1XTtcbiAgdmFyIGV5ID0gY29vcmRzWzZdO1xuICB2YXIgc2VncyA9IGFyY1RvU2VnbWVudHMoZXgsIGV5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90LCB4LCB5KTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmV6ID0gc2VnbWVudFRvQmV6aWVyLmFwcGx5KG51bGwsIHNlZ3NbaV0pO1xuICAgIGJvdW5kcy5hZGQoYmV6WzBdLCBiZXpbMV0pO1xuICAgIGJvdW5kcy5hZGQoYmV6WzJdLCBiZXpbM10pO1xuICAgIGJvdW5kcy5hZGQoYmV6WzRdLCBiZXpbNV0pO1xuICB9XG59XG5cbnZhciBhcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH0sXG4gICAgc2VnbWVudFRvQmV6aWVyQ2FjaGUgPSB7IH0sXG4gICAgam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luLFxuICAgIGFyZ3NTdHI7XG5cbi8vIENvcGllZCBmcm9tIElua3NjYXBlIHN2Z3RvcGRmLCB0aGFua3MhXG5mdW5jdGlvbiBhcmNUb1NlZ21lbnRzKHgsIHksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYLCBveCwgb3kpIHtcbiAgYXJnc1N0ciA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJdKSB7XG4gICAgcmV0dXJuIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyXTtcbiAgfVxuXG4gIHZhciB0aCA9IHJvdGF0ZVggKiAoTWF0aC5QSS8xODApO1xuICB2YXIgc2luX3RoID0gTWF0aC5zaW4odGgpO1xuICB2YXIgY29zX3RoID0gTWF0aC5jb3ModGgpO1xuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIHZhciBweCA9IGNvc190aCAqIChveCAtIHgpICogMC41ICsgc2luX3RoICogKG95IC0geSkgKiAwLjU7XG4gIHZhciBweSA9IGNvc190aCAqIChveSAtIHkpICogMC41IC0gc2luX3RoICogKG94IC0geCkgKiAwLjU7XG4gIHZhciBwbCA9IChweCpweCkgLyAocngqcngpICsgKHB5KnB5KSAvIChyeSpyeSk7XG4gIGlmIChwbCA+IDEpIHtcbiAgICBwbCA9IE1hdGguc3FydChwbCk7XG4gICAgcnggKj0gcGw7XG4gICAgcnkgKj0gcGw7XG4gIH1cblxuICB2YXIgYTAwID0gY29zX3RoIC8gcng7XG4gIHZhciBhMDEgPSBzaW5fdGggLyByeDtcbiAgdmFyIGExMCA9ICgtc2luX3RoKSAvIHJ5O1xuICB2YXIgYTExID0gKGNvc190aCkgLyByeTtcbiAgdmFyIHgwID0gYTAwICogb3ggKyBhMDEgKiBveTtcbiAgdmFyIHkwID0gYTEwICogb3ggKyBhMTEgKiBveTtcbiAgdmFyIHgxID0gYTAwICogeCArIGEwMSAqIHk7XG4gIHZhciB5MSA9IGExMCAqIHggKyBhMTEgKiB5O1xuXG4gIHZhciBkID0gKHgxLXgwKSAqICh4MS14MCkgKyAoeTEteTApICogKHkxLXkwKTtcbiAgdmFyIHNmYWN0b3Jfc3EgPSAxIC8gZCAtIDAuMjU7XG4gIGlmIChzZmFjdG9yX3NxIDwgMCkgc2ZhY3Rvcl9zcSA9IDA7XG4gIHZhciBzZmFjdG9yID0gTWF0aC5zcXJ0KHNmYWN0b3Jfc3EpO1xuICBpZiAoc3dlZXAgPT0gbGFyZ2UpIHNmYWN0b3IgPSAtc2ZhY3RvcjtcbiAgdmFyIHhjID0gMC41ICogKHgwICsgeDEpIC0gc2ZhY3RvciAqICh5MS15MCk7XG4gIHZhciB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEteDApO1xuXG4gIHZhciB0aDAgPSBNYXRoLmF0YW4yKHkwLXljLCB4MC14Yyk7XG4gIHZhciB0aDEgPSBNYXRoLmF0YW4yKHkxLXljLCB4MS14Yyk7XG5cbiAgdmFyIHRoX2FyYyA9IHRoMS10aDA7XG4gIGlmICh0aF9hcmMgPCAwICYmIHN3ZWVwID09IDEpe1xuICAgIHRoX2FyYyArPSAyKk1hdGguUEk7XG4gIH0gZWxzZSBpZiAodGhfYXJjID4gMCAmJiBzd2VlcCA9PSAwKSB7XG4gICAgdGhfYXJjIC09IDIgKiBNYXRoLlBJO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoX2FyYyAvIChNYXRoLlBJICogMC41ICsgMC4wMDEpKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZ21lbnRzOyBpKyspIHtcbiAgICB2YXIgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ21lbnRzO1xuICAgIHZhciB0aDMgPSB0aDAgKyAoaSsxKSAqIHRoX2FyYyAvIHNlZ21lbnRzO1xuICAgIHJlc3VsdFtpXSA9IFt4YywgeWMsIHRoMiwgdGgzLCByeCwgcnksIHNpbl90aCwgY29zX3RoXTtcbiAgfVxuXG4gIHJldHVybiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJdID0gcmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKGN4LCBjeSwgdGgwLCB0aDEsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGgpIHtcbiAgYXJnc1N0ciA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cl0pIHtcbiAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cl07XG4gIH1cblxuICB2YXIgYTAwID0gY29zX3RoICogcng7XG4gIHZhciBhMDEgPSAtc2luX3RoICogcnk7XG4gIHZhciBhMTAgPSBzaW5fdGggKiByeDtcbiAgdmFyIGExMSA9IGNvc190aCAqIHJ5O1xuXG4gIHZhciBjb3NfdGgwID0gTWF0aC5jb3ModGgwKTtcbiAgdmFyIHNpbl90aDAgPSBNYXRoLnNpbih0aDApO1xuICB2YXIgY29zX3RoMSA9IE1hdGguY29zKHRoMSk7XG4gIHZhciBzaW5fdGgxID0gTWF0aC5zaW4odGgxKTtcblxuICB2YXIgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICB2YXIgc2luX3RoX2gyID0gTWF0aC5zaW4odGhfaGFsZiAqIDAuNSk7XG4gIHZhciB0ID0gKDgvMykgKiBzaW5fdGhfaDIgKiBzaW5fdGhfaDIgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgdmFyIHgxID0gY3ggKyBjb3NfdGgwIC0gdCAqIHNpbl90aDA7XG4gIHZhciB5MSA9IGN5ICsgc2luX3RoMCArIHQgKiBjb3NfdGgwO1xuICB2YXIgeDMgPSBjeCArIGNvc190aDE7XG4gIHZhciB5MyA9IGN5ICsgc2luX3RoMTtcbiAgdmFyIHgyID0geDMgKyB0ICogc2luX3RoMTtcbiAgdmFyIHkyID0geTMgLSB0ICogY29zX3RoMTtcblxuICByZXR1cm4gKHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJdID0gW1xuICAgIGEwMCAqIHgxICsgYTAxICogeTEsICBhMTAgKiB4MSArIGExMSAqIHkxLFxuICAgIGEwMCAqIHgyICsgYTAxICogeTIsICBhMTAgKiB4MiArIGExMSAqIHkyLFxuICAgIGEwMCAqIHgzICsgYTAxICogeTMsICBhMTAgKiB4MyArIGExMSAqIHkzXG4gIF0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXIoZywgcGF0aCwgbCwgdCkge1xuICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgY29udHJvbFkgPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICAgICAgdGVtcFgsXG4gICAgICB0ZW1wWSxcbiAgICAgIHRlbXBDb250cm9sWCxcbiAgICAgIHRlbXBDb250cm9sWSxcbiAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgaWYgKGwgPT0gdW5kZWZpbmVkKSBsID0gMDtcbiAgaWYgKHQgPT0gdW5kZWZpbmVkKSB0ID0gMDtcblxuICBnLmJlZ2luUGF0aCgpO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHBhdGhbaV07XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBnLm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBnLm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsIC8vIHgxXG4gICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICAgIGNvbnRyb2xYICsgbCwgLy8geDJcbiAgICAgICAgICBjb250cm9sWSArIHQsIC8vIHkyXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICB5ICsgdFxuICAgICAgICApO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuXG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIqeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIqeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAndCcpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgdFxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSB0ZW1wQ29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIHRlbXBDb250cm9sWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHFcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgeCArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgIF0sIGJvdW5kcywgbCwgdCk7XG4gICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGRyYXdBcmMoZywgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB0XG4gICAgICAgIF0sIGJvdW5kcywgbCwgdCk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcy50cmFuc2xhdGUobCwgdCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kcyhwYXRoLCBib3VuZHMpIHtcbiAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFk7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuXG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIqeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIqeSAtIGNvbnRyb2xZO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBib3VuZEFyYyh4LCB5LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0gKyB4LFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB5XG4gICAgICAgIF0sIGJvdW5kcyk7XG4gICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGJvdW5kQXJjKHgsIHksIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSxcbiAgICAgICAgICBjdXJyZW50WzddXG4gICAgICAgIF0sIGJvdW5kcyk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gYXJlYShpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAueChmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pXG4gICAgLnkxKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueTsgfSlcbiAgICAueTAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55ICsgZC5oZWlnaHQ7IH0pO1xuICBpZiAoby5pbnRlcnBvbGF0ZSkgYXJlYS5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlKTtcbiAgaWYgKG8udGVuc2lvbiAhPSBudWxsKSBhcmVhLnRlbnNpb24oby50ZW5zaW9uKTtcbiAgcmV0dXJuIGFyZWEoaXRlbXMpO1xufVxuXG5mdW5jdGlvbiBsaW5lKGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KVxuICAgLnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55OyB9KTtcbiAgaWYgKG8uaW50ZXJwb2xhdGUpIGxpbmUuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSk7XG4gIGlmIChvLnRlbnNpb24gIT0gbnVsbCkgbGluZS50ZW5zaW9uKG8udGVuc2lvbik7XG4gIHJldHVybiBsaW5lKGl0ZW1zKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiAgcGFyc2UsXG4gIHJlbmRlcjogcmVuZGVyLFxuICBib3VuZHM6IGJvdW5kcyxcbiAgYXJlYTogICBhcmVhLFxuICBsaW5lOiAgIGxpbmVcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBTVkdCdWlsZGVyID0gcmVxdWlyZSgnLi9zdmcnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2J1aWxkZXIgPSBudWxsO1xufTtcblxudmFyIHByb3RvdHlwZSA9IHJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX2J1aWxkZXIgPSBuZXcgU1ZHQnVpbGRlcigpO1xuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn1cblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQgfHwge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgdGhpcy5fYXV0b3BhZCA9IGRsLmlzU3RyaW5nKHRoaXMuX3BhZGRpbmcpID8gMSA6IDA7XG5cbiAgdmFyIHcgPSB0aGlzLl93aWR0aCwgaCA9IHRoaXMuX2hlaWdodCwgcGFkID0gdGhpcy5fcGFkZGluZztcbiAgXG4gIC8vIChyZS0pY29uZmlndXJlIGJ1aWxkZXIgc2l6ZVxuICB0aGlzLl9idWlsZGVyLmluaXRpYWxpemUobnVsbCwgdywgaCwgcGFkKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgLy8gaGVhZGxlc3MgYWx3YXlzIGRyYXdzIHRoZSBlbnRpcmUgc2NlbmUsIGlnbm9yaW5nIGl0ZW1zXG4gIHRoaXMuX2J1aWxkZXIucmVuZGVyKHNjZW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9idWlsZGVyLnN2ZygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBSZW5kZXJlcjogcmVxdWlyZSgnLi9SZW5kZXJlcicpXG59O1xuIiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2dpZCA9IDA7IC8vIGdyb3VwIGlkIGNvdW50ZXIgZm9yIGQzIGRvbSBjb21wYXRcbiAgdGhpcy5fdGV4dCA9IHtcbiAgICBoZWFkOiBcIlwiLFxuICAgIHJvb3Q6IFwiXCIsXG4gICAgZm9vdDogXCJcIixcbiAgICBkZWZzOiBcIlwiLFxuICAgIGJvZHk6IFwiXCJcbiAgfTtcbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBvcGVuKHRhZywgYXR0ciwgcmF3KSB7XG4gIHZhciBzID0gXCI8XCIgKyB0YWc7XG4gIGlmIChhdHRyKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGF0dHIpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyW2tleV07XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgcyArPSBcIiBcIiArIGtleSArICc9XCInICsgdmFsICsgJ1wiJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJhdykgcyArPSBcIiBcIiArIHJhdztcbiAgcmV0dXJuIHMgKyBcIj5cIjtcbn1cblxuZnVuY3Rpb24gY2xvc2UodGFnKSB7XG4gIHJldHVybiBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbn1cblxudmFyIHByb3RvdHlwZSA9IHJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgdywgaCwgcGFkKSB7XG4gIHZhciB0ID0gdGhpcy5fdGV4dDtcblxuICB0LmhlYWQgPSBvcGVuKCdzdmcnLCB7XG4gICAgXCJjbGFzc1wiOiAnbWFya3MnLFxuICAgIHdpZHRoOiB3ICsgcGFkLmxlZnQgKyBwYWQucmlnaHQsXG4gICAgaGVpZ2h0OiBoICsgcGFkLnRvcCArIHBhZC5ib3R0b20sXG4gIH0sIGNvbmZpZy5zdmdOYW1lc3BhY2UpO1xuXG4gIHQucm9vdCA9IG9wZW4oJ2cnLCB7XG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyBwYWQubGVmdCArICcsJyArIHBhZC50b3AgKyAnKSdcbiAgfSk7XG5cbiAgdC5mb290ID0gY2xvc2UoJ2cnKSArIGNsb3NlKCdzdmcnKTtcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLl90ZXh0O1xuICByZXR1cm4gdC5oZWFkICsgdC5kZWZzICsgdC5yb290ICsgdC5ib2R5ICsgdC5mb290O1xufTtcblxucHJvdG90eXBlLmJ1aWxkRGVmcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYWxsID0gdGhpcy5fZGVmcyxcbiAgICAgIGRncmFkID0gZGwua2V5cyhhbGwuZ3JhZGllbnQpLFxuICAgICAgZGNsaXAgPSBkbC5rZXlzKGFsbC5jbGlwcGluZyksXG4gICAgICBkZWZzID0gXCJcIiwgZ3JhZCwgY2xpcCwgaSwgajtcblxuICBmb3IgKGk9MDsgaTxkZ3JhZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IGRncmFkW2ldLFxuICAgICAgICBkZWYgPSBhbGwuZ3JhZGllbnRbaWRdLFxuICAgICAgICBzdG9wcyA9IGRlZi5zdG9wcztcblxuICAgIGRlZnMgKz0gb3BlbihcImxpbmVhckdyYWRpZW50XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHgxOiBkZWYueDEsXG4gICAgICB4MjogZGVmLngyLFxuICAgICAgeTE6IGRlZi55MSxcbiAgICAgIHkyOiBkZWYueTJcbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGo9MDsgajxzdG9wcy5sZW5ndGg7ICsraikge1xuICAgICAgZGVmcyArPSBvcGVuKFwic3RvcFwiLCB7XG4gICAgICAgIG9mZnNldDogc3RvcHNbal0ub2Zmc2V0LFxuICAgICAgICBcInN0b3AtY29sb3JcIjogc3RvcHNbal0uY29sb3JcbiAgICAgIH0pICsgY2xvc2UoXCJzdG9wXCIpO1xuICAgIH1cbiAgICBcbiAgICBkZWZzICs9IGNsb3NlKFwibGluZWFyR3JhZGllbnRcIik7XG4gIH1cbiAgXG4gIGZvciAoaT0wOyBpPGRjbGlwLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGlkID0gZGNsaXBbaV0sXG4gICAgICAgIGRlZiA9IGFsbC5jbGlwcGluZ1tpZF07XG5cbiAgICBkZWZzICs9IG9wZW4oXCJjbGlwUGF0aFwiLCB7aWQ6IGlkfSk7XG5cbiAgICBkZWZzICs9IG9wZW4oXCJyZWN0XCIsIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGRlZi53aWR0aCxcbiAgICAgIGhlaWdodDogZGVmLmhlaWdodFxuICAgIH0pICsgY2xvc2UoXCJyZWN0XCIpO1xuXG4gICAgZGVmcyArPSBjbG9zZShcImNsaXBQYXRoXCIpO1xuICB9XG4gIFxuICBpZiAoZGVmcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG9wZW4oXCJkZWZzXCIpICsgZGVmcyArIGNsb3NlKFwiZGVmc1wiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG4gIHJldHVybiBkZWZzO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHRoaXMuX2dpZCA9IDA7IC8vIHJlc2V0IHRoZSBncm91cCBjb3VudGVyXG4gIHRoaXMuX3RleHQuYm9keSA9IHRoaXMuZHJhdyhzY2VuZSk7XG4gIHRoaXMuX3RleHQuZGVmcyA9IHRoaXMuYnVpbGREZWZzKCk7XG59O1xuXG5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBtZXRhID0gTUFSS1Nbc2NlbmUubWFya3R5cGVdO1xuICBpZiAoIW1ldGEpIHtcbiAgICByZXR1cm47IC8vIG5vIGtub3duIG1hcmt0eXBlIChlLmcuLCBhbiBpbnRlcmFjdG9yKVxuICB9XG4gIHZhciB0YWcgID0gbWV0YVswXSxcbiAgICAgIGF0dHIgPSBtZXRhWzFdLFxuICAgICAgbmVzdCA9IG1ldGFbMl0gfHwgZmFsc2UsXG4gICAgICBkYXRhID0gbmVzdCA/IFtzY2VuZS5pdGVtc10gOiBzY2VuZS5pdGVtcyxcbiAgICAgIGRlZnMgPSB0aGlzLl9kZWZzLFxuICAgICAgc3ZnID0gXCJcIiwgaSwgc3R5O1xuXG4gIHZhciBjbHMgPSBjc3NDbGFzcyhzY2VuZS5kZWYpO1xuXG4gIC8vIHN0eWxlIGxpdGVyYWxzIHRvIGV4YWN0bHkgbWF0Y2ggdGhlIGQzIGRvbVxuICB2YXIgc3R5bCA9IG51bGw7XG4gIGlmIChjbHMgPT09ICd0eXBlLXJ1bGUnIHx8IGNscyA9PT0gJ3R5cGUtcGF0aCcpXG4gICAgc3R5bCA9ICdzdHlsZT1cInBvaW50ZXItZXZlbnRzOiBub25lO1wiJztcbiAgZWxzZSBpZiAoY2xzICE9PSAndHlwZS1ncm91cCcpXG4gICAgc3R5bCA9ICdzdHlsZT1cIlwiJztcblxuICBzdmcgKz0gb3BlbignZycsIHtcbiAgICAnaWQnOiAnZycgKyArK3RoaXMuX2dpZCwgLy8gZDMgZG9tIGNvbXBhdFxuICAgICdjbGFzcyc6IGNzc0NsYXNzKHNjZW5lLmRlZilcbiAgfSwgc3R5bCk7XG5cbiAgZm9yIChpPTA7IGk8ZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzdHkgPSB0YWcgPT09ICdnJyA/IG51bGwgOiBzdHlsZShkYXRhW2ldLCB0YWcsIGRlZnMpO1xuICAgIHN2ZyArPSBvcGVuKHRhZywgYXR0cihkYXRhW2ldLCBkZWZzKSwgc3R5KTtcbiAgICBpZiAodGFnID09PSAndGV4dCcpIHN2ZyArPSBlc2NhcGVfdGV4dChkYXRhW2ldLnRleHQpO1xuICAgIGlmICh0YWcgPT09ICdnJykgc3ZnICs9IHRoaXMuZHJhd0dyb3VwKGRhdGFbaV0pO1xuICAgIHN2ZyArPSBjbG9zZSh0YWcpO1xuICB9XG5cbiAgcmV0dXJuIHN2ZyArIGNsb3NlKCdnJyk7XG59O1xuXG5mdW5jdGlvbiBlc2NhcGVfdGV4dChzKSB7XG4gIHMgPSAocyA9PSBudWxsID8gXCJcIiA6IFN0cmluZyhzKSk7XG4gIHJldHVybiBzLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlX2ZvbnQocykge1xuICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoL1xcXCIvZywgXCInXCIpO1xufVxuXG52YXIgTUFSS1MgPSB7XG4gIGdyb3VwOiAgWydnJywgZ3JvdXBdLFxuICBhcmVhOiAgIFsncGF0aCcsIGFyZWEsIHRydWVdLFxuICBsaW5lOiAgIFsncGF0aCcsIGxpbmUsIHRydWVdLFxuICBhcmM6ICAgIFsncGF0aCcsIGFyY10sXG4gIHBhdGg6ICAgWydwYXRoJywgcGF0aF0sXG4gIHN5bWJvbDogWydwYXRoJywgc3ltYm9sXSxcbiAgcmVjdDogICBbJ3JlY3QnLCByZWN0XSxcbiAgcnVsZTogICBbJ2xpbmUnLCBydWxlXSxcbiAgdGV4dDogICBbJ3RleHQnLCB0ZXh0XSxcbiAgaW1hZ2U6ICBbJ2ltYWdlJywgaW1hZ2VdXG59O1xuXG5wcm90b3R5cGUuZHJhd0dyb3VwID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIHN2ZyA9IFwiXCIsXG4gICAgICBheGVzID0gc2NlbmUuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGxlZ2VuZHMgPSBzY2VuZS5sZWdlbmRJdGVtcyB8fCBbXSxcbiAgICAgIGksIGosIG07XG5cbiAgc3ZnICs9IGdyb3VwX2JnKHNjZW5lKTtcblxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgPT09IFwiYmFja1wiKSB7XG4gICAgICBzdmcgKz0gdGhpcy5kcmF3KGF4ZXNbal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgc3ZnICs9IHRoaXMuZHJhdyhpdGVtc1tqXSk7XG4gIH1cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyICE9PSBcImJhY2tcIikge1xuICAgICAgc3ZnICs9IHRoaXMuZHJhdyhheGVzW2pdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgc3ZnICs9IHRoaXMuZHJhdyhsZWdlbmRzW2pdKTtcbiAgfVxuXG4gIHJldHVybiBzdmc7XG59O1xuXG4vLy9cblxuZnVuY3Rpb24gZ3JvdXBfYmcobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwO1xuXG4gIHZhciBzdHlsID0gby5tYXJrLmludGVyYWN0aXZlID09PSBmYWxzZSA/XG4gICAgJ3N0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCInIDogXG4gICAgJ3N0eWxlPVwiXCInO1xuXG4gIHJldHVybiBvcGVuKCdyZWN0Jywge1xuICAgICdjbGFzcyc6ICdiYWNrZ3JvdW5kJ1xuICB9LCBzdHlsKSArIGNsb3NlKCdyZWN0Jyk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKG8sIGRlZnMpIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGF0dHIgPSB7dHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCJ9O1xuXG4gIGlmIChvLmNsaXApIHtcbiAgICB2YXIgYyA9IHt3aWR0aDogby53aWR0aCB8fCAwLCBoZWlnaHQ6IG8uaGVpZ2h0IHx8IDB9LFxuICAgICAgICBpZCA9IG8uY2xpcF9pZCB8fCAoby5jbGlwX2lkID0gXCJjbGlwXCIgKyBjbGlwX2lkKyspO1xuICAgIGRlZnMuY2xpcHBpbmdbaWRdID0gYztcbiAgICBhdHRyW1wiY2xpcC1wYXRoXCJdID0gXCJ1cmwoI1wiK2lkK1wiKVwiO1xuICB9XG5cbiAgcmV0dXJuIGF0dHI7XG59XG5cbmZ1bmN0aW9uIGFyYyhvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIsXG4gICAgZDogYXJjX3BhdGgobylcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXJlYShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgcGF0aCA9IG8ub3JpZW50ID09PSBcImhvcml6b250YWxcIiA/IGFyZWFfcGF0aF9oIDogYXJlYV9wYXRoX3Y7XG4gIHBhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgcmV0dXJuIHtkOiBwYXRoKGl0ZW1zKX07XG59XG5cbmZ1bmN0aW9uIGxpbmUoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgbGluZV9wYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHJldHVybiB7ZDogbGluZV9wYXRoKGl0ZW1zKX07XG59XG5cbmZ1bmN0aW9uIHBhdGgobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiLFxuICAgIGQ6IG8ucGF0aFxuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0KG8pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBvLnggfHwgMCxcbiAgICB5OiBvLnkgfHwgMCxcbiAgICB3aWR0aDogby53aWR0aCB8fCAwLFxuICAgIGhlaWdodDogby5oZWlnaHQgfHwgMFxuICB9O1xufVxuXG5mdW5jdGlvbiBydWxlKG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSxcbiAgICB5Mjogby55MiAhPSBudWxsID8gby55MiA6IHkxXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIsXG4gICAgZDogc3ltYm9sX3BhdGgobylcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW1hZ2Uobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS53aWR0aCkgfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMCxcbiAgICAgIHggPSBvLnggLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IG8ueSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpLFxuICAgICAgdXJsID0gY29uZmlnLmJhc2VVUkwgKyBvLnVybDtcbiAgXG4gIHJldHVybiB7XG4gICAgXCJ4bGluazpocmVmXCI6IHVybCxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHQobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgZHggPSBvLmR4IHx8IDAsXG4gICAgICBkeSA9IG8uZHkgfHwgMCxcbiAgICAgIGEgPSBvLmFuZ2xlIHx8IDAsXG4gICAgICByID0gby5yYWRpdXMgfHwgMCxcbiAgICAgIGFsaWduID0gdGV4dEFsaWduW28uYWxpZ24gfHwgXCJsZWZ0XCJdLFxuICAgICAgYmFzZSA9IG8uYmFzZWxpbmU9PT1cInRvcFwiID8gXCIuOWVtXCJcbiAgICAgICAgICAgOiBvLmJhc2VsaW5lPT09XCJtaWRkbGVcIiA/IFwiLjM1ZW1cIiA6IDA7XG5cbiAgaWYgKHIpIHtcbiAgICB2YXIgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgZHgsXG4gICAgeTogeSArIGR5LFxuICAgICd0ZXh0LWFuY2hvcic6IGFsaWduLFxuICAgIHRyYW5zZm9ybTogYSA/IFwicm90YXRlKFwiK2ErXCIgXCIreCtcIixcIit5K1wiKVwiIDogbnVsbCxcbiAgICBkeTogYmFzZSA/IGJhc2UgOiBudWxsXG4gIH07XG59XG5cbi8vL1xuXG5mdW5jdGlvbiBjc3NDbGFzcyhkZWYpIHtcbiAgdmFyIGNscyA9IFwidHlwZS1cIiArIGRlZi50eXBlO1xuICBpZiAoZGVmLm5hbWUpIGNscyArPSBcIiBcIiArIGRlZi5uYW1lO1xuICByZXR1cm4gY2xzO1xufVxuXG5mdW5jdGlvbiB4KG8pICAgICB7IHJldHVybiBvLnggfHwgMDsgfVxuZnVuY3Rpb24geShvKSAgICAgeyByZXR1cm4gby55IHx8IDA7IH1cbmZ1bmN0aW9uIHh3KG8pICAgIHsgcmV0dXJuIG8ueCArIG8ud2lkdGggfHwgMDsgfVxuZnVuY3Rpb24geWgobykgICAgeyByZXR1cm4gby55ICsgby5oZWlnaHQgfHwgMDsgfVxuZnVuY3Rpb24ga2V5KG8pICAgeyByZXR1cm4gby5rZXk7IH1cbmZ1bmN0aW9uIHNpemUobykgIHsgcmV0dXJuIG8uc2l6ZT09bnVsbCA/IDEwMCA6IG8uc2l6ZTsgfVxuZnVuY3Rpb24gc2hhcGUobykgeyByZXR1cm4gby5zaGFwZSB8fCBcImNpcmNsZVwiOyB9XG5cbnZhciBhcmNfcGF0aCAgICA9IGQzLnN2Zy5hcmMoKSxcbiAgICBhcmVhX3BhdGhfdiA9IGQzLnN2Zy5hcmVhKCkueCh4KS55MSh5KS55MCh5aCksXG4gICAgYXJlYV9wYXRoX2ggPSBkMy5zdmcuYXJlYSgpLnkoeSkueDAoeHcpLngxKHgpLFxuICAgIGxpbmVfcGF0aCAgID0gZDMuc3ZnLmxpbmUoKS54KHgpLnkoeSksXG4gICAgc3ltYm9sX3BhdGggPSBkMy5zdmcuc3ltYm9sKCkudHlwZShzaGFwZSkuc2l6ZShzaXplKTtcblxudmFyIG1hcmtfaWQgPSAwLFxuICAgIGNsaXBfaWQgPSAwO1xuXG52YXIgdGV4dEFsaWduID0ge1xuICBcImxlZnRcIjogICBcInN0YXJ0XCIsXG4gIFwiY2VudGVyXCI6IFwibWlkZGxlXCIsXG4gIFwicmlnaHRcIjogIFwiZW5kXCJcbn07XG5cbnZhciBzdHlsZXMgPSB7XG4gIFwiZmlsbFwiOiAgICAgICAgICAgICBcImZpbGxcIixcbiAgXCJmaWxsT3BhY2l0eVwiOiAgICAgIFwiZmlsbC1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlXCI6ICAgICAgICAgICBcInN0cm9rZVwiLFxuICBcInN0cm9rZVdpZHRoXCI6ICAgICAgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJzdHJva2VPcGFjaXR5XCI6ICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgXCJzdHJva2VDYXBcIjogICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIixcbiAgXCJzdHJva2VEYXNoXCI6ICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiLFxuICBcInN0cm9rZURhc2hPZmZzZXRcIjogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICBcIm9wYWNpdHlcIjogICAgICAgICAgXCJvcGFjaXR5XCJcbn07XG5cbnZhciBzdHlsZVByb3BzID0gZGwua2V5cyhzdHlsZXMpO1xuXG5mdW5jdGlvbiBzdHlsZShkLCB0YWcsIGRlZnMpIHtcbiAgdmFyIGksIG4sIHByb3AsIG5hbWUsIHZhbHVlLFxuICAgICAgbyA9IGQubWFyayA/IGQgOiBkLmxlbmd0aCA/IGRbMF0gOiBudWxsO1xuICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHMgPSBcIlwiO1xuXG4gIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgIHMgKz0gJ2ZvbnQ6ICcgKyBmb250U3RyaW5nKG8pICsgJzsnO1xuICB9XG4gIFxuICBmb3IgKGk9MCwgbj1zdHlsZVByb3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gc3R5bGVQcm9wc1tpXTtcbiAgICBuYW1lID0gc3R5bGVzW3Byb3BdO1xuICAgIHZhbHVlID0gb1twcm9wXTtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJmaWxsXCIpIHMgKz0gJ2ZpbGw6IG5vbmU7JztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgIC8vIGVuc3VyZSBkZWZpbml0aW9uIGlzIGluY2x1ZGVkXG4gICAgICAgIGRlZnMuZ3JhZGllbnRbdmFsdWUuaWRdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gXCJ1cmwoXCIgKyB3aW5kb3cubG9jYXRpb24uaHJlZiArIFwiI1wiICsgdmFsdWUuaWQgKyBcIilcIjtcbiAgICAgIH1cbiAgICAgIHMgKz0gKHMubGVuZ3RoID8gJyAnIDogJycpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICc7J1xuICAgIH1cbiAgfVxuICBcbiAgLy8gbm90IHRoYXQgd2UgZG9uJ3QgZXhjbHVkZSBibGFuayBzdHlsZXMgZm9yIGQzIGRvbSBjb21wYXRcbiAgcmV0dXJuICdzdHlsZT1cIicrcysnXCInO1xufVxuXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgdmFyIGYgPSAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCAmJiBlc2NhcGVfZm9udChvLmZvbnQpIHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG4gIHJldHVybiBmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG52YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGVsLCBtb2RlbCkge1xuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICBpZiAoZWwpIHRoaXMuaW5pdGlhbGl6ZShlbCk7XG4gIGlmIChtb2RlbCkgdGhpcy5tb2RlbChtb2RlbCk7XG59O1xuXG5mdW5jdGlvbiBzdmdIYW5kbGVyKGhhbmRsZXIpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgIGl0ZW0gPSB0YXJnZXQuX19kYXRhX187XG5cbiAgICBpZiAoaXRlbSkgaXRlbSA9IGl0ZW0ubWFyayA/IGl0ZW0gOiBpdGVtWzBdO1xuICAgIGhhbmRsZXIuY2FsbCh0aGF0Ll9vYmosIGV2dCwgaXRlbSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZShuYW1lKSB7XG4gIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLlwiKTtcbiAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCxpKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IGhhbmRsZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCBwYWQsIG9iaikge1xuICB0aGlzLl9lbCA9IGQzLnNlbGVjdChlbCkubm9kZSgpO1xuICB0aGlzLl9zdmcgPSBkMy5zZWxlY3QoZWwpLnNlbGVjdChcInN2Zy5tYXJrc1wiKS5ub2RlKCk7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHRoaXMuX29iaiA9IG9iaiB8fCBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoID0gdGhpcy5faGFuZGxlcnM7XG4gIHJldHVybiBkbC5rZXlzKGgpLnJlZHVjZShmdW5jdGlvbihhLCBrKSB7XG4gICAgcmV0dXJuIGhba10ucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHsgcmV0dXJuIChhLnB1c2goeCksIGEpOyB9LCBhKTtcbiAgfSwgW10pO1xufTtcblxuLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSBldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICBkb20gPSBkMy5zZWxlY3QodGhpcy5fc3ZnKS5ub2RlKCk7XG4gICAgICBcbiAgdmFyIHggPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIHN2Zzogc3ZnSGFuZGxlci5jYWxsKHRoaXMsIGhhbmRsZXIpXG4gIH07XG4gIGggPSBoW25hbWVdIHx8IChoW25hbWVdID0gW10pO1xuICBoLnB1c2goeCk7XG5cbiAgZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgeC5zdmcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXSxcbiAgICAgIGRvbSA9IGQzLnNlbGVjdCh0aGlzLl9zdmcpLm5vZGUoKTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoW2ldLnN2Zyk7XG4gICAgICBoLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZXI7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdmcgPSBudWxsO1xuICB0aGlzLl9jdHggPSBudWxsO1xuICB0aGlzLl9lbCA9IG51bGw7XG4gIHRoaXMuX2RlZnMgPSB7XG4gICAgZ3JhZGllbnQ6IHt9LFxuICAgIGNsaXBwaW5nOiB7fVxuICB9O1xufTtcblxudmFyIHByb3RvdHlwZSA9IHJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX2VsID0gZWw7XG5cbiAgLy8gcmVtb3ZlIGFueSBleGlzdGluZyBzdmcgZWxlbWVudFxuICBkMy5zZWxlY3QoZWwpLnNlbGVjdChcInN2Zy5tYXJrc1wiKS5yZW1vdmUoKTtcblxuICAvLyBjcmVhdGUgc3ZnIGVsZW1lbnQgYW5kIGluaXRpYWxpemUgYXR0cmlidXRlc1xuICB0aGlzLl9zdmcgPSBkMy5zZWxlY3QoZWwpXG4gICAgLmFwcGVuZChcInN2Z1wiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrc1wiKTtcbiAgXG4gIC8vIHNldCB0aGUgc3ZnIHJvb3QgZ3JvdXBcbiAgdGhpcy5fY3R4ID0gdGhpcy5fc3ZnLmFwcGVuZChcImdcIik7XG4gIFxuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICBcbiAgdGhpcy5fc3ZnXG4gICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0KVxuICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIHBhZC50b3AgKyBwYWQuYm90dG9tKTtcbiAgICBcbiAgdGhpcy5fY3R4XG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrcGFkLmxlZnQrXCIsXCIrcGFkLnRvcCtcIilcIik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY3R4O1xufTtcblxucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZURlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgIGFsbCA9IHRoaXMuX2RlZnMsXG4gICAgICBkZ3JhZCA9IGRsLmtleXMoYWxsLmdyYWRpZW50KSxcbiAgICAgIGRjbGlwID0gZGwua2V5cyhhbGwuY2xpcHBpbmcpLFxuICAgICAgZGVmcyA9IHN2Zy5zZWxlY3QoXCJkZWZzXCIpLCBncmFkLCBjbGlwO1xuXG4gIC8vIGdldCBvciBjcmVhdGUgc3ZnIGRlZnMgYmxvY2tcbiAgaWYgKGRncmFkLmxlbmd0aD09PTAgJiYgZGNsaXAubGVuZ3RoPT0wKSB7IGRlZnMucmVtb3ZlKCk7IHJldHVybjsgfVxuICBpZiAoZGVmcy5lbXB0eSgpKSBkZWZzID0gc3ZnLmluc2VydChcImRlZnNcIiwgXCI6Zmlyc3QtY2hpbGRcIik7XG4gIFxuICBncmFkID0gZGVmcy5zZWxlY3RBbGwoXCJsaW5lYXJHcmFkaWVudFwiKS5kYXRhKGRncmFkLCBkbC5pZGVudGl0eSk7XG4gIGdyYWQuZW50ZXIoKS5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKS5hdHRyKFwiaWRcIiwgZGwuaWRlbnRpdHkpO1xuICBncmFkLmV4aXQoKS5yZW1vdmUoKTtcbiAgZ3JhZC5lYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGRlZiA9IGFsbC5ncmFkaWVudFtpZF0sXG4gICAgICAgIGdyZCA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgIC8vIHNldCBncmFkaWVudCBjb29yZGluYXRlc1xuICAgIGdyZC5hdHRyKHt4MTogZGVmLngxLCB4MjogZGVmLngyLCB5MTogZGVmLnkxLCB5MjogZGVmLnkyfSk7XG5cbiAgICAvLyBzZXQgZ3JhZGllbnQgc3RvcHNcbiAgICBzdG9wID0gZ3JkLnNlbGVjdEFsbChcInN0b3BcIikuZGF0YShkZWYuc3RvcHMpO1xuICAgIHN0b3AuZW50ZXIoKS5hcHBlbmQoXCJzdG9wXCIpO1xuICAgIHN0b3AuZXhpdCgpLnJlbW92ZSgpO1xuICAgIHN0b3AuYXR0cihcIm9mZnNldFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcbiAgICAgICAgLmF0dHIoXCJzdG9wLWNvbG9yXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuY29sb3I7IH0pO1xuICB9KTtcbiAgXG4gIGNsaXAgPSBkZWZzLnNlbGVjdEFsbChcImNsaXBQYXRoXCIpLmRhdGEoZGNsaXAsIGRsLmlkZW50aXR5KTtcbiAgY2xpcC5lbnRlcigpLmFwcGVuZChcImNsaXBQYXRoXCIpLmF0dHIoXCJpZFwiLCBkbC5pZGVudGl0eSk7XG4gIGNsaXAuZXhpdCgpLnJlbW92ZSgpO1xuICBjbGlwLmVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZGVmID0gYWxsLmNsaXBwaW5nW2lkXSxcbiAgICAgICAgY3IgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKFwicmVjdFwiKS5kYXRhKFsxXSk7XG4gICAgY3IuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpO1xuICAgIGNyLmF0dHIoXCJ4XCIsIDApXG4gICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgIC5hdHRyKFwid2lkdGhcIiwgZGVmLndpZHRoKVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZGVmLmhlaWdodCk7XG4gIH0pO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lLCBpdGVtcykge1xuICBtYXJrcy5jdXJyZW50ID0gdGhpcztcblxuICBpZiAoaXRlbXMpIHtcbiAgICB0aGlzLnJlbmRlckl0ZW1zKGRsLmFycmF5KGl0ZW1zKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kcmF3KHRoaXMuX2N0eCwgc2NlbmUsIC0xKTtcbiAgfVxuICB0aGlzLnVwZGF0ZURlZnMoKTtcblxuIGRlbGV0ZSBtYXJrcy5jdXJyZW50O1xufTtcblxucHJvdG90eXBlLnJlbmRlckl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdmFyIGl0ZW0sIG5vZGUsIHR5cGUsIG5lc3QsIGksIG47XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBub2RlID0gaXRlbS5fc3ZnO1xuICAgIHR5cGUgPSBpdGVtLm1hcmsubWFya3R5cGU7XG5cbiAgICBpdGVtID0gbWFya3MubmVzdGVkW3R5cGVdID8gaXRlbS5tYXJrLml0ZW1zIDogaXRlbTtcbiAgICBtYXJrcy51cGRhdGVbdHlwZV0uY2FsbChub2RlLCBpdGVtKTtcbiAgICBtYXJrcy5zdHlsZS5jYWxsKG5vZGUsIGl0ZW0pO1xuICB9XG59XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgaW5kZXgpIHtcbiAgdmFyIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICByZW5kZXJlciA9IG1hcmtzLmRyYXdbbWFya3R5cGVdO1xuICByZW5kZXJlci5jYWxsKHRoaXMsIGN0eCwgc2NlbmUsIGluZGV4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpO1xuXG5mdW5jdGlvbiB4KG8pICAgICB7IHJldHVybiBvLnggfHwgMDsgfVxuZnVuY3Rpb24geShvKSAgICAgeyByZXR1cm4gby55IHx8IDA7IH1cbmZ1bmN0aW9uIHloKG8pICAgIHsgcmV0dXJuIG8ueSArIG8uaGVpZ2h0IHx8IDA7IH1cbmZ1bmN0aW9uIGtleShvKSAgIHsgcmV0dXJuIG8ua2V5OyB9XG5mdW5jdGlvbiBzaXplKG8pICB7IHJldHVybiBvLnNpemU9PW51bGwgPyAxMDAgOiBvLnNpemU7IH1cbmZ1bmN0aW9uIHNoYXBlKG8pIHsgcmV0dXJuIG8uc2hhcGUgfHwgXCJjaXJjbGVcIjsgfVxuICAgIFxudmFyIGFyY19wYXRoICAgID0gZDMuc3ZnLmFyYygpLFxuICAgIGFyZWFfcGF0aCAgID0gZDMuc3ZnLmFyZWEoKS54KHgpLnkxKHkpLnkwKHloKSxcbiAgICBsaW5lX3BhdGggICA9IGQzLnN2Zy5saW5lKCkueCh4KS55KHkpLFxuICAgIHN5bWJvbF9wYXRoID0gZDMuc3ZnLnN5bWJvbCgpLnR5cGUoc2hhcGUpLnNpemUoc2l6ZSk7XG5cbnZhciBtYXJrX2lkID0gMCxcbiAgICBjbGlwX2lkID0gMDtcblxudmFyIHRleHRBbGlnbiA9IHtcbiAgXCJsZWZ0XCI6ICAgXCJzdGFydFwiLFxuICBcImNlbnRlclwiOiBcIm1pZGRsZVwiLFxuICBcInJpZ2h0XCI6ICBcImVuZFwiXG59O1xuXG52YXIgc3R5bGVzID0ge1xuICBcImZpbGxcIjogICAgICAgICAgICAgXCJmaWxsXCIsXG4gIFwiZmlsbE9wYWNpdHlcIjogICAgICBcImZpbGwtb3BhY2l0eVwiLFxuICBcInN0cm9rZVwiOiAgICAgICAgICAgXCJzdHJva2VcIixcbiAgXCJzdHJva2VXaWR0aFwiOiAgICAgIFwic3Ryb2tlLXdpZHRoXCIsXG4gIFwic3Ryb2tlT3BhY2l0eVwiOiAgICBcInN0cm9rZS1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlQ2FwXCI6ICAgICAgICBcInN0cm9rZS1saW5lY2FwXCIsXG4gIFwic3Ryb2tlRGFzaFwiOiAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgXCJzdHJva2VEYXNoT2Zmc2V0XCI6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgXCJvcGFjaXR5XCI6ICAgICAgICAgIFwib3BhY2l0eVwiXG59O1xudmFyIHN0eWxlUHJvcHMgPSBkbC5rZXlzKHN0eWxlcyk7XG5cbmZ1bmN0aW9uIHN0eWxlKGQpIHtcbiAgdmFyIGksIG4sIHByb3AsIG5hbWUsIHZhbHVlLFxuICAgICAgbyA9IGQubWFyayA/IGQgOiBkLmxlbmd0aCA/IGRbMF0gOiBudWxsO1xuICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gIGZvciAoaT0wLCBuPXN0eWxlUHJvcHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHByb3AgPSBzdHlsZVByb3BzW2ldO1xuICAgIG5hbWUgPSBzdHlsZXNbcHJvcF07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSBcImZpbGxcIikgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBcIm5vbmVcIiwgbnVsbCk7XG4gICAgICBlbHNlIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5pZCkge1xuICAgICAgICAvLyBlbnN1cmUgZGVmaW5pdGlvbiBpcyBpbmNsdWRlZFxuICAgICAgICBtYXJrcy5jdXJyZW50Ll9kZWZzLmdyYWRpZW50W3ZhbHVlLmlkXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IFwidXJsKCNcIiArIHZhbHVlLmlkICsgXCIpXCI7XG4gICAgICB9XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlK1wiXCIsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcmMobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgYXJjX3BhdGgobykpO1xufVxuXG5mdW5jdGlvbiBhcmVhKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIGFyZWFfcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgYXJlYV9wYXRoKGl0ZW1zKSk7XG59XG5cbmZ1bmN0aW9uIGxpbmUoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgbGluZV9wYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBsaW5lX3BhdGgoaXRlbXMpKTtcbn1cblxuZnVuY3Rpb24gcGF0aChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG4gIGlmIChvLnBhdGggIT0gbnVsbCkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIG8ucGF0aCk7XG59XG5cbmZ1bmN0aW9uIHJlY3Qobykge1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInhcIiwgby54IHx8IDApO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgby55IHx8IDApO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG8ud2lkdGggfHwgMCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG8uaGVpZ2h0IHx8IDApO1xufVxuXG5mdW5jdGlvbiBydWxlKG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIngxXCIsIHgxKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCB5MSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieDJcIiwgby54MiAhPSBudWxsID8gby54MiA6IHgxKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBvLnkyICE9IG51bGwgPyBvLnkyIDogeTEpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgc3ltYm9sX3BhdGgobykpO1xufVxuXG5mdW5jdGlvbiBpbWFnZShvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IChvLmltYWdlICYmIG8uaW1hZ2UuaGVpZ2h0KSB8fCAwLFxuICAgICAgeCA9IG8ueCAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSksXG4gICAgICB5ID0gby55IC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSksXG4gICAgICB1cmwgPSBjb25maWcuYmFzZVVSTCArIG8udXJsO1xuICBcbiAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJocmVmXCIsIHVybCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHcpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoKTtcbn1cbiAgXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgcmV0dXJuIChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250IHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG59XG5cbmZ1bmN0aW9uIHRleHQobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgZHggPSBvLmR4IHx8IDAsXG4gICAgICBkeSA9IG8uZHkgfHwgMCxcbiAgICAgIGEgPSBvLmFuZ2xlIHx8IDAsXG4gICAgICByID0gby5yYWRpdXMgfHwgMCxcbiAgICAgIGFsaWduID0gdGV4dEFsaWduW28uYWxpZ24gfHwgXCJsZWZ0XCJdLFxuICAgICAgYmFzZSA9IG8uYmFzZWxpbmU9PT1cInRvcFwiID8gXCIuOWVtXCJcbiAgICAgICAgICAgOiBvLmJhc2VsaW5lPT09XCJtaWRkbGVcIiA/IFwiLjM1ZW1cIiA6IDA7XG5cbiAgaWYgKHIpIHtcbiAgICB2YXIgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHggKyBkeCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCB5ICsgZHkpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsIGFsaWduKTtcbiAgXG4gIGlmIChhKSB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInJvdGF0ZShcIithK1wiIFwiK3grXCIsXCIreStcIilcIik7XG4gIGVsc2UgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gIFxuICBpZiAoYmFzZSkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBiYXNlKTtcbiAgZWxzZSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcImR5XCIpO1xuICBcbiAgdGhpcy50ZXh0Q29udGVudCA9IG8udGV4dDtcbiAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShcImZvbnRcIiwgZm9udFN0cmluZyhvKSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcblxuICBpZiAoby5jbGlwKSB7XG4gICAgdmFyIGMgPSB7d2lkdGg6IG8ud2lkdGggfHwgMCwgaGVpZ2h0OiBvLmhlaWdodCB8fCAwfSxcbiAgICAgICAgaWQgPSBvLmNsaXBfaWQgfHwgKG8uY2xpcF9pZCA9IFwiY2xpcFwiICsgY2xpcF9pZCsrKTtcbiAgICBtYXJrcy5jdXJyZW50Ll9kZWZzLmNsaXBwaW5nW2lkXSA9IGM7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI1wiK2lkK1wiKVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBncm91cF9iZyhvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3NDbGFzcyhkZWYpIHtcbiAgdmFyIGNscyA9IFwidHlwZS1cIiArIGRlZi50eXBlO1xuICBpZiAoZGVmLm5hbWUpIGNscyArPSBcIiBcIiArIGRlZi5uYW1lO1xuICByZXR1cm4gY2xzO1xufVxuXG5mdW5jdGlvbiBkcmF3KHRhZywgYXR0ciwgbmVzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgc2NlbmUsIGluZGV4KSB7XG4gICAgZHJhd01hcmsoZywgc2NlbmUsIGluZGV4LCBcIm1hcmtfXCIsIHRhZywgYXR0ciwgbmVzdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdNYXJrKGcsIHNjZW5lLCBpbmRleCwgcHJlZml4LCB0YWcsIGF0dHIsIG5lc3QpIHtcbiAgdmFyIGRhdGEgPSBuZXN0ID8gW3NjZW5lLml0ZW1zXSA6IHNjZW5lLml0ZW1zLFxuICAgICAgZXZ0cyA9IHNjZW5lLmludGVyYWN0aXZlPT09ZmFsc2UgPyBcIm5vbmVcIiA6IG51bGwsXG4gICAgICBncnBzID0gZy5ub2RlKCkuY2hpbGROb2RlcyxcbiAgICAgIG5vdEcgPSAodGFnICE9PSBcImdcIiksXG4gICAgICBwID0gKHAgPSBncnBzW2luZGV4KzFdKSAvLyArMSB0byBza2lwIGdyb3VwIGJhY2tncm91bmQgcmVjdFxuICAgICAgICA/IGQzLnNlbGVjdChwKVxuICAgICAgICA6IGcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAuYXR0cihcImlkXCIsIFwiZ1wiKygrK21hcmtfaWQpKVxuICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGNzc0NsYXNzKHNjZW5lLmRlZikpO1xuXG4gIHZhciBpZCA9IHAuYXR0cihcImlkXCIpLFxuICAgICAgcyA9IFwiI1wiICsgaWQgKyBcIiA+IFwiICsgdGFnLFxuICAgICAgbSA9IHAuc2VsZWN0QWxsKHMpLmRhdGEoZGF0YSksXG4gICAgICBlID0gbS5lbnRlcigpLmFwcGVuZCh0YWcpO1xuXG4gIGlmIChub3RHKSB7XG4gICAgcC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIGV2dHMpO1xuICAgIGUuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoZC5tYXJrKSBkLl9zdmcgPSB0aGlzO1xuICAgICAgZWxzZSBpZiAoZC5sZW5ndGgpIGRbMF0uX3N2ZyA9IHRoaXM7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLFwiYmFja2dyb3VuZFwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsZXZ0cyk7XG4gIH1cbiAgXG4gIG0uZXhpdCgpLnJlbW92ZSgpO1xuICBtLmVhY2goYXR0cik7XG4gIGlmIChub3RHKSBtLmVhY2goc3R5bGUpO1xuICBlbHNlIHAuc2VsZWN0QWxsKHMrXCIgPiByZWN0LmJhY2tncm91bmRcIikuZWFjaChncm91cF9iZykuZWFjaChzdHlsZSk7XG4gIFxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZHJhd0dyb3VwKGcsIHNjZW5lLCBpbmRleCwgcHJlZml4KSB7ICAgIFxuICB2YXIgcCA9IGRyYXdNYXJrKGcsIHNjZW5lLCBpbmRleCwgcHJlZml4IHx8IFwiZ3JvdXBfXCIsIFwiZ1wiLCBncm91cCksXG4gICAgICBjID0gcC5ub2RlKCkuY2hpbGROb2RlcywgbiA9IGMubGVuZ3RoLCBpLCBqLCBtO1xuICBcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGl0ZW1zID0gY1tpXS5fX2RhdGFfXy5pdGVtcyxcbiAgICAgICAgbGVnZW5kcyA9IGNbaV0uX19kYXRhX18ubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICAgIGF4ZXMgPSBjW2ldLl9fZGF0YV9fLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgICAgc2VsID0gZDMuc2VsZWN0KGNbaV0pLFxuICAgICAgICBpZHggPSAwO1xuXG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGRyYXdHcm91cC5jYWxsKHRoaXMsIHNlbCwgYXhlc1tqXSwgaWR4KyssIFwiYXhpc19cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHRoaXMuZHJhdyhzZWwsIGl0ZW1zW2pdLCBpZHgrKyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyICE9PSBcImJhY2tcIikge1xuICAgICAgICBkcmF3R3JvdXAuY2FsbCh0aGlzLCBzZWwsIGF4ZXNbal0sIGlkeCsrLCBcImF4aXNfXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGRyYXdHcm91cC5jYWxsKHRoaXMsIHNlbCwgbGVnZW5kc1tqXSwgaWR4KyssIFwibGVnZW5kX1wiKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIG1hcmtzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVwZGF0ZToge1xuICAgIGdyb3VwOiAgIHJlY3QsXG4gICAgYXJlYTogICAgYXJlYSxcbiAgICBsaW5lOiAgICBsaW5lLFxuICAgIGFyYzogICAgIGFyYyxcbiAgICBwYXRoOiAgICBwYXRoLFxuICAgIHN5bWJvbDogIHN5bWJvbCxcbiAgICByZWN0OiAgICByZWN0LFxuICAgIHJ1bGU6ICAgIHJ1bGUsXG4gICAgdGV4dDogICAgdGV4dCxcbiAgICBpbWFnZTogICBpbWFnZVxuICB9LFxuICBuZXN0ZWQ6IHtcbiAgICBcImFyZWFcIjogdHJ1ZSxcbiAgICBcImxpbmVcIjogdHJ1ZVxuICB9LFxuICBzdHlsZTogc3R5bGUsXG4gIGRyYXc6IHtcbiAgICBncm91cDogICBkcmF3R3JvdXAsXG4gICAgYXJlYTogICAgZHJhdyhcInBhdGhcIiwgYXJlYSwgdHJ1ZSksXG4gICAgbGluZTogICAgZHJhdyhcInBhdGhcIiwgbGluZSwgdHJ1ZSksXG4gICAgYXJjOiAgICAgZHJhdyhcInBhdGhcIiwgYXJjKSxcbiAgICBwYXRoOiAgICBkcmF3KFwicGF0aFwiLCBwYXRoKSxcbiAgICBzeW1ib2w6ICBkcmF3KFwicGF0aFwiLCBzeW1ib2wpLFxuICAgIHJlY3Q6ICAgIGRyYXcoXCJyZWN0XCIsIHJlY3QpLFxuICAgIHJ1bGU6ICAgIGRyYXcoXCJsaW5lXCIsIHJ1bGUpLFxuICAgIHRleHQ6ICAgIGRyYXcoXCJ0ZXh0XCIsIHRleHQpLFxuICAgIGltYWdlOiAgIGRyYXcoXCJpbWFnZVwiLCBpbWFnZSksXG4gICAgZHJhdzogICAgZHJhdyAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgfSxcbiAgY3VycmVudDogbnVsbFxufTsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBib3VuZHMgPSByZXF1aXJlKCcuLi91dGlsL2JvdW5kcycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBCb3VuZGVyKGdyYXBoLCBtYXJrKSB7XG4gIHRoaXMuX21hcmsgPSBtYXJrO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKS5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChCb3VuZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJib3VuZHNcIiwgdGhpcy5fbWFyay5tYXJrdHlwZV0pO1xuXG4gIGJvdW5kcy5tYXJrKHRoaXMuX21hcmspO1xuICBpZiAodGhpcy5fbWFyay5tYXJrdHlwZSA9PT0gQy5HUk9VUCkgXG4gICAgYm91bmRzLm1hcmsodGhpcy5fbWFyaywgbnVsbCwgZmFsc2UpO1xuXG4gIGlucHV0LnJlZmxvdyA9IHRydWU7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBFbmNvZGVyICA9IHJlcXVpcmUoJy4vRW5jb2RlcicpLFxuICAgIEJvdW5kZXIgID0gcmVxdWlyZSgnLi9Cb3VuZGVyJyksXG4gICAgSXRlbSAgPSByZXF1aXJlKCcuL0l0ZW0nKSxcbiAgICBwYXJzZURhdGEgPSByZXF1aXJlKCcuLi9wYXJzZS9kYXRhJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBCdWlsZGVyKCkgeyAgICBcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBwcm90byA9IChCdWlsZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgsIGRlZiwgbWFyaywgcGFyZW50LCBwYXJlbnRfaWQsIGluaGVyaXRGcm9tKSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICB0aGlzLl9kZWYgICA9IGRlZjtcbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuICB0aGlzLl9mcm9tICA9IChkZWYuZnJvbSA/IGRlZi5mcm9tLmRhdGEgOiBudWxsKSB8fCBpbmhlcml0RnJvbTtcbiAgdGhpcy5fZHMgICAgPSBkbC5pc1N0cmluZyh0aGlzLl9mcm9tKSA/IGdyYXBoLmRhdGEodGhpcy5fZnJvbSkgOiBudWxsO1xuICB0aGlzLl9tYXAgICA9IHt9O1xuXG4gIHRoaXMuX3JldmlzZXMgPSBmYWxzZTsgIC8vIFNob3VsZCBzY2VuZWdyYXBoIGl0ZW1zIHRyYWNrIF9wcmV2P1xuXG4gIG1hcmsuZGVmID0gZGVmO1xuICBtYXJrLm1hcmt0eXBlID0gZGVmLnR5cGU7XG4gIG1hcmsuaW50ZXJhY3RpdmUgPSAhKGRlZi5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpO1xuICBtYXJrLml0ZW1zID0gW107XG5cbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9wYXJlbnRfaWQgPSBwYXJlbnRfaWQ7XG5cbiAgaWYoZGVmLmZyb20gJiYgKGRlZi5mcm9tLm1hcmsgfHwgZGVmLmZyb20udHJhbnNmb3JtIHx8IGRlZi5mcm9tLm1vZGlmeSkpIHtcbiAgICBpbmxpbmVEcy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTm9uLWdyb3VwIG1hcmsgYnVpbGRlcnMgYXJlIHN1cGVyIG5vZGVzLiBFbmNvZGVyIGFuZCBCb3VuZGVyIHJlbWFpbiBcbiAgLy8gc2VwYXJhdGUgb3BlcmF0b3JzIGJ1dCBhcmUgZW1iZWRkZWQgYW5kIGNhbGxlZCBieSBCdWlsZGVyLmV2YWx1YXRlLlxuICB0aGlzLl9pc1N1cGVyID0gKHRoaXMuX2RlZi50eXBlICE9PSBDLkdST1VQKTsgXG4gIHRoaXMuX2VuY29kZXIgPSBuZXcgRW5jb2Rlcih0aGlzLl9ncmFwaCwgdGhpcy5fbWFyayk7XG4gIHRoaXMuX2JvdW5kZXIgPSBuZXcgQm91bmRlcih0aGlzLl9ncmFwaCwgdGhpcy5fbWFyayk7XG5cbiAgaWYodGhpcy5fZHMpIHsgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuREFUQSwgdGhpcy5fZnJvbSk7IH1cblxuICAvLyBTaW5jZSBCdWlsZGVycyBhcmUgc3VwZXIgbm9kZXMsIGNvcHkgb3ZlciBlbmNvZGVyIGRlcGVuZGVuY2llc1xuICAvLyAoYm91bmRlciBoYXMgbm8gcmVnaXN0ZXJlZCBkZXBlbmRlbmNpZXMpLlxuICB0aGlzLmRlcGVuZGVuY3koQy5EQVRBLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5EQVRBKSk7XG4gIHRoaXMuZGVwZW5kZW5jeShDLlNDQUxFUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0NBTEVTKSk7XG4gIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNJR05BTFMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJldmlzZXMgPSBmdW5jdGlvbihwKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmV2aXNlcztcblxuICAvLyBJZiB3ZSd2ZSBub3QgbmVlZGVkIHByZXYgaW4gdGhlIHBhc3QsIGJ1dCBhIG5ldyBpbmxpbmUgZHMgbmVlZHMgaXQgbm93XG4gIC8vIGVuc3VyZSBleGlzdGluZyBpdGVtcyBoYXZlIHByZXYgc2V0LlxuICBpZighdGhpcy5fcmV2aXNlcyAmJiBwKSB7XG4gICAgdGhpcy5faXRlbXMuZm9yRWFjaChmdW5jdGlvbihkKSB7IGlmKGQuX3ByZXYgPT09IHVuZGVmaW5lZCkgZC5fcHJldiA9IEMuU0VOVElORUw7IH0pO1xuICB9XG5cbiAgdGhpcy5fcmV2aXNlcyA9IHRoaXMuX3JldmlzZXMgfHwgcDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBSZWFjdGl2ZSBnZW9tZXRyeSBhbmQgbWFyay1sZXZlbCB0cmFuc2Zvcm1hdGlvbnMgYXJlIGhhbmRsZWQgaGVyZSBcbi8vIGJlY2F1c2UgdGhleSBuZWVkIHRoZWlyIGdyb3VwJ3MgZGF0YS1qb2luZWQgY29udGV4dC4gXG5mdW5jdGlvbiBpbmxpbmVEcygpIHtcbiAgdmFyIGZyb20gPSB0aGlzLl9kZWYuZnJvbSxcbiAgICAgIGdlb20gPSBmcm9tLm1hcmssXG4gICAgICBzcmMsIG5hbWUsIHNwZWMsIHNpYmxpbmcsIG91dHB1dDtcblxuICBpZihnZW9tKSB7XG4gICAgbmFtZSA9IFtcInZnXCIsIHRoaXMuX3BhcmVudF9pZCwgZ2VvbV0uam9pbihcIl9cIik7XG4gICAgc3BlYyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0cmFuc2Zvcm06IGZyb20udHJhbnNmb3JtLCBcbiAgICAgIG1vZGlmeTogZnJvbS5tb2RpZnlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNyYyA9IHRoaXMuX2dyYXBoLmRhdGEodGhpcy5fZnJvbSk7XG4gICAgbmFtZSA9IFtcInZnXCIsIHRoaXMuX2Zyb20sIHRoaXMuX2RlZi50eXBlLCBzcmMubGlzdGVuZXJzKHRydWUpLmxlbmd0aF0uam9pbihcIl9cIik7XG4gICAgc3BlYyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzb3VyY2U6IHRoaXMuX2Zyb20sXG4gICAgICB0cmFuc2Zvcm06IGZyb20udHJhbnNmb3JtLFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH1cblxuICB0aGlzLl9mcm9tID0gbmFtZTtcbiAgdGhpcy5fZHMgPSBwYXJzZURhdGEuZGF0YXNvdXJjZSh0aGlzLl9ncmFwaCwgc3BlYyk7XG4gIHZhciByZXZpc2VzID0gdGhpcy5fZHMucmV2aXNlcygpO1xuXG4gIGlmKGdlb20pIHtcbiAgICBzaWJsaW5nID0gdGhpcy5zaWJsaW5nKGdlb20pLnJldmlzZXMocmV2aXNlcyk7XG4gICAgaWYoc2libGluZy5faXNTdXBlcikgc2libGluZy5hZGRMaXN0ZW5lcih0aGlzLl9kcy5saXN0ZW5lcigpKTtcbiAgICBlbHNlIHNpYmxpbmcuX2JvdW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSBhIG5ldyBkYXRhc291cmNlIGJ1dCBpdCBpcyBlbXB0eSBhc1xuICAgIC8vIHRoZSBwcm9wYWdhdGlvbiBjeWNsZSBoYXMgYWxyZWFkeSBjcm9zc2VkIHRoZSBkYXRhc291cmNlcy4gXG4gICAgLy8gU28sIHdlIHJlcHVsc2UganVzdCB0aGlzIGRhdGFzb3VyY2UuIFRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAvLyBhcyB0aGUgZHMgaXNuJ3QgY29ubmVjdGVkIHRvIHRoZSBzY2VuZWdyYXBoIHlldC5cbiAgICBcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fZHMuc291cmNlKCkucmV2aXNlcyhyZXZpc2VzKS5sYXN0KCk7XG4gICAgICAgIGlucHV0ICA9IGNoYW5nZXNldC5jcmVhdGUob3V0cHV0KTtcblxuICAgIGlucHV0LmFkZCA9IG91dHB1dC5hZGQ7XG4gICAgaW5wdXQubW9kID0gb3V0cHV0Lm1vZDtcbiAgICBpbnB1dC5yZW0gPSBvdXRwdXQucmVtO1xuICAgIGlucHV0LnN0YW1wID0gbnVsbDtcbiAgICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUoaW5wdXQsIHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICB9XG59XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpc107XG59O1xuXG5wcm90by5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcblxuICB0aGlzLl9ncmFwaC5jb25uZWN0KHRoaXMucGlwZWxpbmUoKSk7XG4gIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNDQUxFUykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgYnVpbGRlci5fcGFyZW50LnNjYWxlKHMpLmFkZExpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcblxuICBpZih0aGlzLl9wYXJlbnQpIHtcbiAgICBpZih0aGlzLl9pc1N1cGVyKSB0aGlzLmFkZExpc3RlbmVyKHRoaXMuX3BhcmVudC5fY29sbGVjdG9yKTtcbiAgICBlbHNlIHRoaXMuX2JvdW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcbiAgaWYoIXRoaXMuX2xpc3RlbmVycy5sZW5ndGgpIHJldHVybiB0aGlzO1xuXG4gIE5vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbiAgdGhpcy5fZ3JhcGguZGlzY29ubmVjdCh0aGlzLnBpcGVsaW5lKCkpO1xuICB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5TQ0FMRVMpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIGJ1aWxkZXIuX3BhcmVudC5zY2FsZShzKS5yZW1vdmVMaXN0ZW5lcihidWlsZGVyKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uc2libGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3BhcmVudC5jaGlsZChuYW1lLCB0aGlzLl9wYXJlbnRfaWQpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiYnVpbGRpbmdcIiwgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGVdKTtcblxuICB2YXIgb3V0cHV0LCBmdWxsVXBkYXRlLCBmY3MsIGRhdGE7XG5cbiAgaWYodGhpcy5fZHMpIHtcbiAgICBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICAgIC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGFueSBlbmNvZGVyIGRlcGVuZGVuY2llcyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAvLyBIb3dldmVyLCB0aGUgZW5jb2RlcidzIGRhdGEgc291cmNlIHdpbGwgbGlrZWx5IGJlIHVwZGF0ZWQsIGFuZCBzaG91bGRuJ3RcbiAgICAvLyB0cmlnZ2VyIGFsbCBpdGVtcyB0byBtb2QuXG4gICAgZGF0YSA9IGRsLmR1cGxpY2F0ZShvdXRwdXQuZGF0YSk7XG4gICAgZGVsZXRlIG91dHB1dC5kYXRhW3RoaXMuX2RzLm5hbWUoKV07XG4gICAgZnVsbFVwZGF0ZSA9IHRoaXMuX2VuY29kZXIucmVldmFsdWF0ZShvdXRwdXQpO1xuICAgIG91dHB1dC5kYXRhID0gZGF0YTtcblxuICAgIC8vIElmIGEgc2NhbGUgb3Igc2lnbmFsIGluIHRoZSB1cGRhdGUgcHJvcHNldCBoYXMgYmVlbiB1cGRhdGVkLCBcbiAgICAvLyBzZW5kIGZvcndhcmQgYWxsIGl0ZW1zIGZvciByZWVuY29kaW5nIGlmIHdlIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICBpZihmdWxsVXBkYXRlKSBvdXRwdXQubW9kID0gdGhpcy5fbWFyay5pdGVtcy5zbGljZSgpO1xuXG4gICAgZmNzID0gdGhpcy5fZHMubGFzdCgpO1xuICAgIGlmKCFmY3MpIHtcbiAgICAgIG91dHB1dC5yZWZsb3cgPSB0cnVlXG4gICAgfSBlbHNlIGlmKGZjcy5zdGFtcCA+IHRoaXMuX3N0YW1wKSB7XG4gICAgICBvdXRwdXQgPSBqb2luRGF0YXNvdXJjZS5jYWxsKHRoaXMsIGZjcywgdGhpcy5fZHMudmFsdWVzKCksIGZ1bGxVcGRhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKGlucHV0KTtcbiAgICBkYXRhID0gZGwuaXNGdW5jdGlvbih0aGlzLl9kZWYuZnJvbSkgPyB0aGlzLl9kZWYuZnJvbSgpIDogW0MuU0VOVElORUxdO1xuICAgIG91dHB1dCA9IGpvaW5WYWx1ZXMuY2FsbCh0aGlzLCBpbnB1dCwgZGF0YSwgZnVsbFVwZGF0ZSk7XG4gIH1cblxuICBvdXRwdXQgPSB0aGlzLl9ncmFwaC5ldmFsdWF0ZShvdXRwdXQsIHRoaXMuX2VuY29kZXIpO1xuICByZXR1cm4gdGhpcy5faXNTdXBlciA/IHRoaXMuX2dyYXBoLmV2YWx1YXRlKG91dHB1dCwgdGhpcy5fYm91bmRlcikgOiBvdXRwdXQ7XG59O1xuXG5mdW5jdGlvbiBuZXdJdGVtKCkge1xuICB2YXIgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkLFxuICAgICAgaXRlbSA9IHR1cGxlLmluZ2VzdChuZXcgSXRlbSh0aGlzLl9tYXJrKSwgcHJldik7XG5cbiAgLy8gRm9yIHRoZSByb290IG5vZGUncyBpdGVtXG4gIGlmKHRoaXMuX2RlZi53aWR0aCkgIHR1cGxlLnNldChpdGVtLCBcIndpZHRoXCIsICB0aGlzLl9kZWYud2lkdGgpO1xuICBpZih0aGlzLl9kZWYuaGVpZ2h0KSB0dXBsZS5zZXQoaXRlbSwgXCJoZWlnaHRcIiwgdGhpcy5fZGVmLmhlaWdodCk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuZnVuY3Rpb24gam9pbihkYXRhLCBrZXlmLCBuZXh0LCBvdXRwdXQsIHByZXYsIG1vZCkge1xuICB2YXIgaSwga2V5LCBsZW4sIGl0ZW0sIGRhdHVtLCBlbnRlcjtcblxuICBmb3IoaT0wLCBsZW49ZGF0YS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBkYXR1bSA9IGRhdGFbaV07XG4gICAgaXRlbSAgPSBrZXlmID8gdGhpcy5fbWFwW2tleSA9IGtleWYoZGF0dW0pXSA6IHByZXZbaV07XG4gICAgZW50ZXIgPSBpdGVtID8gZmFsc2UgOiAoaXRlbSA9IG5ld0l0ZW0uY2FsbCh0aGlzKSwgdHJ1ZSk7XG4gICAgaXRlbS5zdGF0dXMgPSBlbnRlciA/IEMuRU5URVIgOiBDLlVQREFURTtcbiAgICBpdGVtLmRhdHVtID0gZGF0dW07XG4gICAgdHVwbGUuc2V0KGl0ZW0sIFwia2V5XCIsIGtleSk7XG4gICAgdGhpcy5fbWFwW2tleV0gPSBpdGVtO1xuICAgIG5leHQucHVzaChpdGVtKTtcbiAgICBpZihlbnRlcikgb3V0cHV0LmFkZC5wdXNoKGl0ZW0pO1xuICAgIGVsc2UgaWYoIW1vZCB8fCAobW9kICYmIG1vZFtkYXR1bS5faWRdKSkgb3V0cHV0Lm1vZC5wdXNoKGl0ZW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGpvaW5EYXRhc291cmNlKGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKSB7XG4gIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIGtleWYgPSBrZXlGdW5jdGlvbih0aGlzLl9kZWYua2V5IHx8IFwiX2lkXCIpLFxuICAgICAgYWRkID0gaW5wdXQuYWRkLCBcbiAgICAgIG1vZCA9IGlucHV0Lm1vZCwgXG4gICAgICByZW0gPSBpbnB1dC5yZW0sXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIC8vIEJ1aWxkIHJlbXMgZmlyc3QsIGFuZCBwdXQgdGhlbSBhdCB0aGUgaGVhZCBvZiB0aGUgbmV4dCBpdGVtc1xuICAvLyBUaGVuIGJ1aWxkIHRoZSByZXN0IG9mIHRoZSBkYXRhIHZhbHVlcyAod2hpY2ggd29uJ3QgY29udGFpbiByZW0pLlxuICAvLyBUaGlzIHdpbGwgcHJlc2VydmUgdGhlIHNvcnQgb3JkZXIgd2l0aG91dCBuZWVkaW5nIGFueXRoaW5nIGV4dHJhLlxuXG4gIGZvcihpPTAsIGxlbj1yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHRoaXMuX21hcFtrZXkgPSBrZXlmKHJlbVtpXSldO1xuICAgIGl0ZW0uc3RhdHVzID0gQy5FWElUO1xuICAgIG5leHQucHVzaChpdGVtKTtcbiAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fbWFwW2tleV0gPSBudWxsO1xuICB9XG5cbiAgam9pbi5jYWxsKHRoaXMsIGRhdGEsIGtleWYsIG5leHQsIG91dHB1dCwgbnVsbCwgdHVwbGUuaWRNYXAoZnVsbFVwZGF0ZSA/IGRhdGEgOiBtb2QpKTtcblxuICByZXR1cm4gKHRoaXMuX21hcmsuaXRlbXMgPSBuZXh0LCBvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBqb2luVmFsdWVzKGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKSB7XG4gIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIGtleWYgPSBrZXlGdW5jdGlvbih0aGlzLl9kZWYua2V5KSxcbiAgICAgIHByZXYgPSB0aGlzLl9tYXJrLml0ZW1zIHx8IFtdLFxuICAgICAgbmV4dCA9IFtdLFxuICAgICAgaSwga2V5LCBsZW4sIGl0ZW0sIGRhdHVtLCBlbnRlcjtcblxuICBmb3IgKGk9MCwgbGVuPXByZXYubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHByZXZbaV07XG4gICAgaXRlbS5zdGF0dXMgPSBDLkVYSVQ7XG4gICAgaWYgKGtleWYpIHRoaXMuX21hcFtpdGVtLmtleV0gPSBpdGVtO1xuICB9XG4gIFxuICBqb2luLmNhbGwodGhpcywgZGF0YSwga2V5ZiwgbmV4dCwgb3V0cHV0LCBwcmV2LCBmdWxsVXBkYXRlID8gdHVwbGUuaWRNYXAoZGF0YSkgOiBudWxsKTtcblxuICBmb3IgKGk9MCwgbGVuPXByZXYubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHByZXZbaV07XG4gICAgaWYgKGl0ZW0uc3RhdHVzID09PSBDLkVYSVQpIHtcbiAgICAgIHR1cGxlLnNldChpdGVtLCBcImtleVwiLCBrZXlmID8gaXRlbS5rZXkgOiB0aGlzLl9pdGVtcy5sZW5ndGgpO1xuICAgICAgbmV4dC5zcGxpY2UoMCwgMCwgaXRlbSk7ICAvLyBLZWVwIGl0ZW0gYXJvdW5kIGZvciBcImV4aXRcIiB0cmFuc2l0aW9uLlxuICAgICAgb3V0cHV0LnJlbS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuICh0aGlzLl9tYXJrLml0ZW1zID0gbmV4dCwgb3V0cHV0KTtcbn07XG5cbmZ1bmN0aW9uIGtleUZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ID09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgZiA9IGRsLmFycmF5KGtleSkubWFwKGRsLmFjY2Vzc29yKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICBmb3IgKHZhciBzPVwiXCIsIGk9MCwgbj1mLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmIChpPjApIHMgKz0gXCJ8XCI7XG4gICAgICBzICs9IFN0cmluZyhmW2ldKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVpbGRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBib3VuZHMgPSByZXF1aXJlKCcuLi91dGlsL2JvdW5kcycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEVNUFRZID0ge307XG5cbmZ1bmN0aW9uIEVuY29kZXIoZ3JhcGgsIG1hcmspIHtcbiAgdmFyIHByb3BzID0gbWFyay5kZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIHVwZGF0ZSA9IHByb3BzLnVwZGF0ZTtcblxuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpXG5cbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuXG4gIGlmKHVwZGF0ZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHVwZGF0ZS5kYXRhKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHVwZGF0ZS5zY2FsZXMpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIHVwZGF0ZS5zaWduYWxzKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5GSUVMRFMsIHVwZGF0ZS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChFbmNvZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJlbmNvZGluZ1wiLCB0aGlzLl9tYXJrLmRlZi50eXBlXSk7XG4gIHZhciBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgaXRlbXMgPSB0aGlzLl9tYXJrLml0ZW1zLFxuICAgICAgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgZW50ZXIgID0gcHJvcHMuZW50ZXIsXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUsXG4gICAgICBleGl0ICAgPSBwcm9wcy5leGl0LFxuICAgICAgcHJlZHMgID0gdGhpcy5fZ3JhcGgucHJlZGljYXRlcygpLFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSwgIC8vIEZvciBleHBlZGllbmN5LCBnZXQgYWxsIHNpZ25hbCB2YWx1ZXNcbiAgICAgIGRiID0gZ3JhcGguZGF0YVZhbHVlcygpLCBcbiAgICAgIHJlcSA9IGlucHV0LnJlcXVlc3QsXG4gICAgICBpLCBsZW4sIGl0ZW0sIHByb3A7XG5cbiAgaWYocmVxKSB7XG4gICAgaWYocHJvcCA9IHByb3BzW3JlcV0pIHtcbiAgICAgIGZvcihpPTAsIGxlbj1pbnB1dC5tb2QubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICAgIGVuY29kZS5jYWxsKHRoaXMsIHByb3AsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7IC8vIGV4aXQgZWFybHkgaWYgZ2l2ZW4gcmVxdWVzdFxuICB9XG5cbiAgLy8gSXRlbXMgbWFya2VkIGZvciByZW1vdmFsIGFyZSBhdCB0aGUgaGVhZCBvZiBpdGVtcy4gUHJvY2VzcyB0aGVtIGZpcnN0LlxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5yZW1baV07XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpZihleGl0KSAgIGVuY29kZS5jYWxsKHRoaXMsIGV4aXQsICAgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpOyBcbiAgICBpZihpbnB1dC50cmFucyAmJiAhZXhpdCkgaW5wdXQudHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgRU1QVFkpO1xuICAgIGVsc2UgaWYoIWlucHV0LnRyYW5zKSBpdGVtLnJlbW92ZSgpO1xuICB9XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmKGVudGVyKSAgZW5jb2RlLmNhbGwodGhpcywgZW50ZXIsICBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcyk7XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuVVBEQVRFO1xuICB9XG5cbiAgaWYodXBkYXRlKSB7XG4gICAgZm9yKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGUocHJvcCwgaXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMpIHtcbiAgdmFyIGVuYyA9IHByb3AuZW5jb2RlO1xuICBlbmMuY2FsbChlbmMsIGl0ZW0sIGl0ZW0ubWFyay5ncm91cHx8aXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMpO1xufVxuXG4vLyBJZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBzZXQgY2FsbGVkLCBvciB1cGRhdGUgcHJvcGVydHkgc2V0IFxuLy8gdXNlcyBuZXN0ZWQgZmllbGRyZWZzLCByZWV2YWx1YXRlIGFsbCBpdGVtcy5cbnByb3RvLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlO1xuXG4gIHJldHVybiBwdWxzZS5yZXF1ZXN0IHx8IFxuICAgIE5vZGUucHJvdG90eXBlLnJlZXZhbHVhdGUuY2FsbCh0aGlzLCBwdWxzZSkgfHwgXG4gICAgKHVwZGF0ZSA/IHVwZGF0ZS5yZWZsb3cgOiBmYWxzZSk7XG59O1xuXG4vLyBTaG9ydC1jaXJjdWl0IGVuY29kZXIgaWYgdXNlciBzcGVjaWZpZXMgaXRlbXNcbkVuY29kZXIudXBkYXRlID0gZnVuY3Rpb24oZ3JhcGgsIHRyYW5zLCByZXF1ZXN0LCBpdGVtcykge1xuICBpdGVtcyA9IGRsLmFycmF5KGl0ZW1zKTtcbiAgdmFyIHByZWRzID0gZ3JhcGgucHJlZGljYXRlcygpLCBcbiAgICAgIGRiID0gZ3JhcGguZGF0YVZhbHVlcygpLFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSxcbiAgICAgIGksIGxlbiwgaXRlbSwgcHJvcHMsIHByb3A7XG5cbiAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgcHJvcHMgPSBpdGVtLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gICAgcHJvcCA9IHByb3BzICYmIHByb3BzW3JlcXVlc3RdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBlbmNvZGUuY2FsbChudWxsLCBwcm9wLCBpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcyk7XG4gICAgICBib3VuZHMuaXRlbShpdGVtKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKSxcbiAgICBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBwYXJzZUF4ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9heGVzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnVpbGRlcigpIHtcbiAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgdGhpcy5fc2NhbGVyID0gbnVsbDtcbiAgdGhpcy5fcmVjdXJzb3IgPSBudWxsO1xuXG4gIHRoaXMuX3NjYWxlcyA9IHt9O1xuICB0aGlzLnNjYWxlID0gc2NhbGUuYmluZCh0aGlzKTtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHcm91cEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IEJ1aWxkZXIoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX3NjYWxlciA9IG5ldyBOb2RlKGdyYXBoKTtcblxuICAoZGVmLnNjYWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ocykgeyBcbiAgICBzID0gYnVpbGRlci5zY2FsZShzLm5hbWUsIG5ldyBTY2FsZShncmFwaCwgcywgYnVpbGRlcikpO1xuICAgIGJ1aWxkZXIuX3NjYWxlci5hZGRMaXN0ZW5lcihzKTsgIC8vIFNjYWxlcyBzaG91bGQgYmUgY29tcHV0ZWQgYWZ0ZXIgZ3JvdXAgaXMgZW5jb2RlZFxuICB9KTtcblxuICB0aGlzLl9yZWN1cnNvciA9IG5ldyBOb2RlKGdyYXBoKTtcbiAgdGhpcy5fcmVjdXJzb3IuZXZhbHVhdGUgPSByZWN1cnNlLmJpbmQodGhpcyk7XG5cbiAgdmFyIHNjYWxlcyA9IChkZWYuYXhlc3x8W10pLnJlZHVjZShmdW5jdGlvbihhY2MsIHgpIHtcbiAgICByZXR1cm4gKGFjY1t4LnNjYWxlXSA9IDEsIGFjYyk7XG4gIH0sIHt9KTtcbiAgdGhpcy5fcmVjdXJzb3IuZGVwZW5kZW5jeShDLlNDQUxFUywgZGwua2V5cyhzY2FsZXMpKTtcblxuICAvLyBXZSBvbmx5IG5lZWQgYSBjb2xsZWN0b3IgZm9yIHVwLXByb3BhZ2F0aW9uIG9mIGJvdW5kcyBjYWxjdWxhdGlvbixcbiAgLy8gc28gb25seSBHcm91cEJ1aWxkZXJzLCBhbmQgbm90IHJlZ3VsYXIgQnVpbGRlcnMsIGhhdmUgY29sbGVjdG9ycy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG5cbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IEJ1aWxkZXIucHJvdG90eXBlLmV2YWx1YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgYnVpbGRHcm91cC5jYWxsKGJ1aWxkZXIsIG91dHB1dCwgZ3JvdXApOyB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcywgdGhpcy5fc2NhbGVyLCB0aGlzLl9yZWN1cnNvciwgdGhpcy5fY29sbGVjdG9yLCB0aGlzLl9ib3VuZGVyXTtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBkbC5rZXlzKGJ1aWxkZXIuX2NoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwX2lkKSB7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXBfaWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7XG4gICAgfSlcbiAgfSk7XG5cbiAgYnVpbGRlci5fY2hpbGRyZW4gPSB7fTtcbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLmNoaWxkID0gZnVuY3Rpb24obmFtZSwgZ3JvdXBfaWQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bZ3JvdXBfaWRdLFxuICAgICAgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGNoaWxkO1xuXG4gIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmKGNoaWxkLnR5cGUgPT0gQy5NQVJLICYmIGNoaWxkLmJ1aWxkZXIuX2RlZi5uYW1lID09IG5hbWUpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkLmJ1aWxkZXI7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNlKGlucHV0KSB7XG4gIHZhciBidWlsZGVyID0gdGhpcyxcbiAgICAgIGhhc01hcmtzID0gdGhpcy5fZGVmLm1hcmtzICYmIHRoaXMuX2RlZi5tYXJrcy5sZW5ndGggPiAwLFxuICAgICAgaGFzQXhlcyA9IHRoaXMuX2RlZi5heGVzICYmIHRoaXMuX2RlZi5heGVzLmxlbmd0aCA+IDAsXG4gICAgICBpLCBsZW4sIGdyb3VwLCBwaXBlbGluZSwgZGVmLCBpbmxpbmUgPSBmYWxzZTtcblxuICBmb3IoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmKGhhc01hcmtzKSBidWlsZE1hcmtzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgICBpZihoYXNBeGVzKSAgYnVpbGRBeGVzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIFdpcmUgdXAgbmV3IGNoaWxkcmVuIGJ1aWxkZXJzIGluIHJldmVyc2UgdG8gbWluaW1pemUgZ3JhcGggcmV3cml0ZXMuXG4gIGZvciAoaT1pbnB1dC5hZGQubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGZvciAoaj10aGlzLl9jaGlsZHJlbltncm91cC5faWRdLmxlbmd0aC0xOyBqPj0wOyAtLWopIHtcbiAgICAgIGMgPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdW2pdO1xuICAgICAgYy5idWlsZGVyLmNvbm5lY3QoKTtcbiAgICAgIHBpcGVsaW5lID0gYy5idWlsZGVyLnBpcGVsaW5lKCk7XG4gICAgICBkZWYgPSBjLmJ1aWxkZXIuX2RlZjtcblxuICAgICAgLy8gVGhpcyBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYnVpbHQgZHVyaW5nIHRoaXMgcHJvcGFnYXRpb24gY3ljbGUuXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgaXRzIGJ1aWxkZXIgYXMgYSBsaXN0ZW5lciBvZmYgdGhlIF9yZWN1cnNvciBub2RlLCBcbiAgICAgIC8vIGJ1dCB0cnkgdG8gaW5saW5lIGl0IGlmIHdlIGNhbiB0byBtaW5pbWl6ZSBncmFwaCBkaXNwYXRjaGVzLlxuICAgICAgaW5saW5lID0gKGRlZi50eXBlICE9PSBDLkdST1VQKTtcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAodGhpcy5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQpOyBcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAocGlwZWxpbmVbcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpLmxlbmd0aCA9PSAxKTsgLy8gUmVhY3RpdmUgZ2VvbVxuICAgICAgYy5pbmxpbmUgPSBpbmxpbmU7XG5cbiAgICAgIGlmKGlubGluZSkgYy5idWlsZGVyLmV2YWx1YXRlKGlucHV0KTtcbiAgICAgIGVsc2UgdGhpcy5fcmVjdXJzb3IuYWRkTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQubW9kW2ldO1xuICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY29ubmVjdGlvbiBmb3IgbWFya3MgdGhhdCBkcmF3IGZyb20gYSBzb3VyY2VcbiAgICBpZihoYXNNYXJrcykge1xuICAgICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYoYy50eXBlID09IEMuTUFSSyAmJiAhYy5pbmxpbmUgJiYgYnVpbGRlci5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGF4ZXMgZGF0YSBkZWZzXG4gICAgaWYoaGFzQXhlcykge1xuICAgICAgcGFyc2VBeGVzKGJ1aWxkZXIuX2dyYXBoLCBidWlsZGVyLl9kZWYuYXhlcywgZ3JvdXAuYXhlcywgZ3JvdXApO1xuICAgICAgZ3JvdXAuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHsgYS5kZWYoKSB9KTtcbiAgICB9ICAgICAgXG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQucmVtW2ldO1xuICAgIC8vIEZvciBkZWxldGVkIGdyb3VwcywgZGlzY29ubmVjdCB0aGVpciBjaGlsZHJlblxuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0uZm9yRWFjaChmdW5jdGlvbihjKSB7IFxuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7IFxuICAgIH0pO1xuICAgIGRlbGV0ZSBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuZnVuY3Rpb24gc2NhbGUobmFtZSwgc2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gdGhpcztcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIChncm91cC5fc2NhbGVzW25hbWVdID0gc2NhbGUsIHNjYWxlKTtcbiAgd2hpbGUoc2NhbGUgPT0gbnVsbCkge1xuICAgIHNjYWxlID0gZ3JvdXAuX3NjYWxlc1tuYW1lXTtcbiAgICBncm91cCA9IGdyb3VwLm1hcmsgPyBncm91cC5tYXJrLmdyb3VwIDogZ3JvdXAuX3BhcmVudDtcbiAgICBpZighZ3JvdXApIGJyZWFrO1xuICB9XG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRHcm91cChpbnB1dCwgZ3JvdXApIHtcbiAgZGVidWcoaW5wdXQsIFtcImJ1aWxkaW5nIGdyb3VwXCIsIGdyb3VwLl9pZF0pO1xuXG4gIGdyb3VwLl9zY2FsZXMgPSBncm91cC5fc2NhbGVzIHx8IHt9OyAgICBcbiAgZ3JvdXAuc2NhbGUgID0gc2NhbGUuYmluZChncm91cCk7XG5cbiAgZ3JvdXAuaXRlbXMgPSBncm91cC5pdGVtcyB8fCBbXTtcbiAgdGhpcy5fY2hpbGRyZW5bZ3JvdXAuX2lkXSA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gfHwgW107XG5cbiAgZ3JvdXAuYXhlcyA9IGdyb3VwLmF4ZXMgfHwgW107XG4gIGdyb3VwLmF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNYXJrcyhpbnB1dCwgZ3JvdXApIHtcbiAgZGVidWcoaW5wdXQsIFtcImJ1aWxkaW5nIG1hcmtzXCIsIGdyb3VwLl9pZF0pO1xuICB2YXIgbWFya3MgPSB0aGlzLl9kZWYubWFya3MsXG4gICAgICBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgIG1hcmssIGZyb20sIGluaGVyaXQsIGksIGxlbiwgbSwgYjtcblxuICBmb3IoaT0wLCBsZW49bWFya3MubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbWFyayA9IG1hcmtzW2ldO1xuICAgIGZyb20gPSBtYXJrLmZyb20gfHwge307XG4gICAgaW5oZXJpdCA9IFwidmdfXCIrZ3JvdXAuZGF0dW0uX2lkO1xuICAgIGdyb3VwLml0ZW1zW2ldID0ge2dyb3VwOiBncm91cH07XG4gICAgYiA9IChtYXJrLnR5cGUgPT09IEMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQodGhpcy5fZ3JhcGgsIG1hcmssIGdyb3VwLml0ZW1zW2ldLCB0aGlzLCBncm91cC5faWQsIGluaGVyaXQpO1xuICAgIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IFxuICAgICAgYnVpbGRlcjogYiwgXG4gICAgICBmcm9tOiBmcm9tLmRhdGEgfHwgKGZyb20ubWFyayA/IChcInZnX1wiICsgZ3JvdXAuX2lkICsgXCJfXCIgKyBmcm9tLm1hcmspIDogaW5oZXJpdCksIFxuICAgICAgdHlwZTogQy5NQVJLIFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQXhlcyhpbnB1dCwgZ3JvdXApIHtcbiAgdmFyIGF4ZXMgPSBncm91cC5heGVzLFxuICAgICAgYXhpc0l0ZW1zID0gZ3JvdXAuYXhpc0l0ZW1zLFxuICAgICAgYnVpbGRlciA9IHRoaXM7XG5cbiAgcGFyc2VBeGVzKHRoaXMuX2dyYXBoLCB0aGlzLl9kZWYuYXhlcywgYXhlcywgZ3JvdXApO1xuICBheGVzLmZvckVhY2goZnVuY3Rpb24oYSwgaSkge1xuICAgIHZhciBzY2FsZSA9IGJ1aWxkZXIuX2RlZi5heGVzW2ldLnNjYWxlLFxuICAgICAgICBkZWYgPSBhLmRlZigpLFxuICAgICAgICBiID0gbnVsbDtcblxuICAgIGF4aXNJdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIGF4aXNEZWY6IGRlZn07XG4gICAgYiA9IChkZWYudHlwZSA9PT0gQy5HUk9VUCkgPyBuZXcgR3JvdXBCdWlsZGVyKCkgOiBuZXcgQnVpbGRlcigpO1xuICAgIGIuaW5pdChidWlsZGVyLl9ncmFwaCwgZGVmLCBheGlzSXRlbXNbaV0sIGJ1aWxkZXIpXG4gICAgICAuZGVwZW5kZW5jeShDLlNDQUxFUywgc2NhbGUpO1xuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IGJ1aWxkZXI6IGIsIHR5cGU6IEMuQVhJUywgc2NhbGU6IHNjYWxlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ1aWxkZXI7IiwiZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG59XG5cbnZhciBwcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmhhc1Byb3BlcnR5U2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gIHJldHVybiBwcm9wcyAmJiBwcm9wc1tuYW1lXSAhPSBudWxsO1xufTtcblxucHJvdG90eXBlLmNvdXNpbiA9IGZ1bmN0aW9uKG9mZnNldCwgaW5kZXgpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBncm91cCA9IG1hcmsuZ3JvdXAsXG4gICAgICBpaWR4ID0gaW5kZXg9PW51bGwgPyBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgOiBpbmRleCxcbiAgICAgIG1pZHggPSBncm91cC5pdGVtcy5pbmRleE9mKG1hcmspICsgb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXAuaXRlbXNbbWlkeF0uaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGlpZHggPSBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgKyBvZmZzZXQ7XG4gIHJldHVybiBtYXJrLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IHRoaXMsXG4gICAgICBsaXN0ID0gaXRlbS5tYXJrLml0ZW1zLFxuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGkgPj0gMCkgKGk9PT1saXN0Lmxlbmd0aC0xKSA/IGxpc3QucG9wKCkgOiBsaXN0LnNwbGljZShpLCAxKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGF0aENhY2hlKSB0aGlzLnBhdGhDYWNoZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hcmsucGF0aENhY2hlKSB0aGlzLm1hcmsucGF0aENhY2hlID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvQWdncmVnYXRlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIEdST1VQX1BST1BFUlRZID0ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9O1xuXG5mdW5jdGlvbiBTY2FsZShncmFwaCwgZGVmLCBwYXJlbnQpIHtcbiAgdGhpcy5fZGVmICAgICA9IGRlZjtcbiAgdGhpcy5fcGFyZW50ICA9IHBhcmVudDtcbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbn1cblxudmFyIHByb3RvID0gKFNjYWxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZuID0gZnVuY3Rpb24oZ3JvdXApIHsgc2NhbGUuY2FsbChzZWxmLCBncm91cCk7IH07XG5cbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICBpbnB1dC5hZGQuZm9yRWFjaChmbik7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZuKTtcblxuICAvLyBTY2FsZXMgYXJlIGF0IHRoZSBlbmQgb2YgYW4gZW5jb2RpbmcgcGlwZWxpbmUsIHNvIHRoZXkgc2hvdWxkIGZvcndhcmQgYVxuICAvLyByZWZsb3cgcHVsc2UuIFRodXMsIGlmIG11bHRpcGxlIHNjYWxlcyB1cGRhdGUgaW4gdGhlIHBhcmVudCBncm91cCwgd2UgZG9uJ3RcbiAgLy8gcmVldmFsdWF0ZSBjaGlsZCBtYXJrcyBtdWx0aXBsZSB0aW1lcy4gXG4gIGlmICh0aGlzLl91cGRhdGVkKSBpbnB1dC5zY2FsZXNbdGhpcy5fZGVmLm5hbWVdID0gMTtcbiAgcmV0dXJuIGNoYW5nZXNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xufTtcblxuLy8gQWxsIG9mIGEgc2NhbGUncyBkZXBlbmRlbmNpZXMgYXJlIHJlZ2lzdGVyZWQgZHVyaW5nIHByb3BhZ2F0aW9uIGFzIHdlIHBhcnNlXG4vLyBkYXRhUmVmcy4gU28gYSBzY2FsZSBtdXN0IGJlIHJlc3BvbnNpYmxlIGZvciBjb25uZWN0aW5nIGl0c2VsZiB0byBkZXBlbmRlbnRzLlxucHJvdG8uZGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHR5cGUsIGRlcHMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgIGRlcHMgPSBkbC5hcnJheShkZXBzKTtcbiAgICBmb3IodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9ncmFwaFt0eXBlID09IEMuREFUQSA/IEMuREFUQSA6IEMuU0lHTkFMXShkZXBzW2ldKVxuICAgICAgICAuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuZGVwZW5kZW5jeS5jYWxsKHRoaXMsIHR5cGUsIGRlcHMpO1xufTtcblxuZnVuY3Rpb24gc2NhbGUoZ3JvdXApIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9kZWYubmFtZSxcbiAgICAgIHByZXYgPSBuYW1lICsgXCI6cHJldlwiLFxuICAgICAgcyA9IGluc3RhbmNlLmNhbGwodGhpcywgZ3JvdXAuc2NhbGUobmFtZSkpLFxuICAgICAgbSA9IHMudHlwZT09PUMuT1JESU5BTCA/IG9yZGluYWwgOiBxdWFudGl0YXRpdmUsXG4gICAgICBybmcgPSByYW5nZS5jYWxsKHRoaXMsIGdyb3VwKTtcblxuICBtLmNhbGwodGhpcywgcywgcm5nLCBncm91cCk7XG5cbiAgZ3JvdXAuc2NhbGUobmFtZSwgcyk7XG4gIGdyb3VwLnNjYWxlKHByZXYsIGdyb3VwLnNjYWxlKHByZXYpIHx8IHMpO1xuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZShzY2FsZSkge1xuICB2YXIgdHlwZSA9IHRoaXMuX2RlZi50eXBlIHx8IEMuTElORUFSO1xuICBpZiAoIXNjYWxlIHx8IHR5cGUgIT09IHNjYWxlLnR5cGUpIHtcbiAgICB2YXIgY3RvciA9IGNvbmZpZy5zY2FsZVt0eXBlXSB8fCBkMy5zY2FsZVt0eXBlXTtcbiAgICBpZiAoIWN0b3IpIGRsLmVycm9yKFwiVW5yZWNvZ25pemVkIHNjYWxlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgKHNjYWxlID0gY3RvcigpKS50eXBlID0gc2NhbGUudHlwZSB8fCB0eXBlO1xuICAgIHNjYWxlLnNjYWxlTmFtZSA9IHRoaXMuX2RlZi5uYW1lO1xuICAgIHNjYWxlLl9wcmV2ID0ge307XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkb21haW4sIHNvcnQsIHN0ciwgcmVmcywgZGF0YURyaXZlblJhbmdlID0gZmFsc2U7XG4gIFxuICAvLyByYW5nZSBwcmUtcHJvY2Vzc2luZyBmb3IgZGF0YS1kcml2ZW4gcmFuZ2VzXG4gIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpICYmICFkbC5pc0FycmF5KGRlZi5yYW5nZSkpIHtcbiAgICBkYXRhRHJpdmVuUmFuZ2UgPSB0cnVlO1xuICAgIHJuZyA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLlJBTkdFLCBkZWYucmFuZ2UsIHNjYWxlLCBncm91cCk7XG4gIH1cbiAgXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcblxuICBzdHIgPSB0eXBlb2Ygcm5nWzBdID09PSAnc3RyaW5nJztcbiAgaWYgKHN0ciB8fCBybmcubGVuZ3RoID4gMiB8fCBybmcubGVuZ3RoPT09MSB8fCBkYXRhRHJpdmVuUmFuZ2UpIHtcbiAgICBzY2FsZS5yYW5nZShybmcpOyAvLyBjb2xvciBvciBzaGFwZSB2YWx1ZXNcbiAgfSBlbHNlIGlmIChkZWYucG9pbnRzKSB7XG4gICAgc2NhbGUucmFuZ2VQb2ludHMocm5nLCBkZWYucGFkZGluZ3x8MCk7XG4gIH0gZWxzZSBpZiAoZGVmLnJvdW5kIHx8IGRlZi5yb3VuZD09PXVuZGVmaW5lZCkge1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyhybmcsIGRlZi5wYWRkaW5nfHwwKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZS5yYW5nZUJhbmRzKHJuZywgZGVmLnBhZGRpbmd8fDApO1xuICB9XG5cbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXRhdGl2ZShzY2FsZSwgcm5nLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgcHJldiA9IHNjYWxlLl9wcmV2LFxuICAgICAgZG9tYWluLCBpbnRlcnZhbDtcblxuICAvLyBkb21haW5cbiAgZG9tYWluID0gKGRlZi50eXBlID09PSBDLlFVQU5USUxFKVxuICAgID8gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOLCBkZWYuZG9tYWluLCBzY2FsZSwgZ3JvdXApXG4gICAgOiBkb21haW5NaW5NYXguY2FsbCh0aGlzLCBzY2FsZSwgZ3JvdXApO1xuICBpZiAoZG9tYWluICYmICFkbC5lcXVhbChwcmV2LmRvbWFpbiwgZG9tYWluKSkge1xuICAgIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgIHByZXYuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICB9IFxuXG4gIC8vIHJhbmdlXG4gIC8vIHZlcnRpY2FsIHNjYWxlcyBzaG91bGQgZmxpcCBieSBkZWZhdWx0LCBzbyB1c2UgWE9SIGhlcmVcbiAgaWYgKGRlZi5yYW5nZSA9PT0gXCJoZWlnaHRcIikgcm5nID0gcm5nLnJldmVyc2UoKTtcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcbiAgc2NhbGVbZGVmLnJvdW5kICYmIHNjYWxlLnJhbmdlUm91bmQgPyBcInJhbmdlUm91bmRcIiA6IFwicmFuZ2VcIl0ocm5nKTtcbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG5cbiAgLy8gVE9ETzogU3VwcG9ydCBzaWduYWxzIGZvciB0aGVzZSBwcm9wZXJ0aWVzLiBVbnRpbCB0aGVuLCBvbmx5IGV2YWxcbiAgLy8gdGhlbSBvbmNlLlxuICBpZiAodGhpcy5fc3RhbXAgPiAwKSByZXR1cm47XG4gIGlmIChkZWYuZXhwb25lbnQgJiYgZGVmLnR5cGU9PT1DLlBPV0VSKSBzY2FsZS5leHBvbmVudChkZWYuZXhwb25lbnQpO1xuICBpZiAoZGVmLmNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGRlZi5uaWNlKSB7XG4gICAgaWYgKGRlZi50eXBlID09PSBDLlRJTUUpIHtcbiAgICAgIGludGVydmFsID0gZDMudGltZVtkZWYubmljZV07XG4gICAgICBpZiAoIWludGVydmFsKSBkbC5lcnJvcihcIlVucmVjb2duaXplZCBpbnRlcnZhbDogXCIgKyBpbnRlcnZhbCk7XG4gICAgICBzY2FsZS5uaWNlKGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUubmljZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhUmVmKHdoaWNoLCBkZWYsIHNjYWxlLCBncm91cCkge1xuICBpZiAoZGVmID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG4gIGlmIChkbC5pc0FycmF5KGRlZikpIHJldHVybiBkZWYubWFwKHNpZ25hbC5iaW5kKHRoaXMpKTtcblxuICB2YXIgc2VsZiA9IHRoaXMsIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICByZWZzID0gZGVmLmZpZWxkcyB8fCBkbC5hcnJheShkZWYpLFxuICAgICAgdW5pcXVlcyA9IHNjYWxlLnR5cGUgPT09IEMuT1JESU5BTCB8fCBzY2FsZS50eXBlID09PSBDLlFVQU5USUxFLFxuICAgICAgY2sgPSBcIl9cIit3aGljaCxcbiAgICAgIGNhY2hlID0gc2NhbGVbY2tdLFxuICAgICAgYWdnciA9IGNhY2hlID8gY2FjaGUuYWdncigpIDogbnVsbCwgIC8vIGRsLkFnZ3JlZ2F0b3JcbiAgICAgIGNhY2hlRmllbGQgPSB7b3BzOiBbXX0sICAvLyB0aGUgZmllbGQgYW5kIG1lYXN1cmVzIGluIHRoZSBhZ2dyZWdhdG9yXG4gICAgICBzb3J0ID0gZGVmLnNvcnQsXG4gICAgICBpLCBybGVuLCBqLCBmbGVuLCByLCBmaWVsZHMsIGZyb20sIGRhdGEsIGtleXM7XG5cbiAgaWYgKCFjYWNoZSkge1xuICAgIGNhY2hlID0gc2NhbGVbY2tdID0gbmV3IEFnZ3JlZ2F0ZShncmFwaClcbiAgICBjYWNoZS5ncm91cGJ5LnNldChjYWNoZSwgW10pXG4gICAgICAuc3VtbWFyaXplLnNldChjYWNoZSwge30pO1xuXG4gICAgYWdnciA9IGNhY2hlLmFnZ3IoKTtcbiAgICBpZih1bmlxdWVzICYmIHNvcnQpIHtcbiAgICAgIGFnZ3Iuc3VtbWFyaXplKHsgXCJkYXRhcmVmXCI6IFtzb3J0LnN0YXRdIH0pXG4gICAgfSBlbHNlIGlmKCF1bmlxdWVzKSB7XG4gICAgICBhZ2dyLnN1bW1hcml6ZSh7IFwiZGF0YXJlZlwiOiBbQy5NSU4sIEMuTUFYXSB9KVxuICAgIH1cbiAgfVxuXG4gIGZvcihpPTAsIHJsZW49cmVmcy5sZW5ndGg7IGk8cmxlbjsgKytpKSB7XG4gICAgciA9IHJlZnNbaV07XG4gICAgZnJvbSA9IHIuZGF0YSB8fCBcInZnX1wiK2dyb3VwLmRhdHVtLl9pZDtcbiAgICBkYXRhID0gZ3JhcGguZGF0YShmcm9tKVxuICAgICAgLnJldmlzZXModHJ1ZSlcbiAgICAgIC5sYXN0KCk7XG5cbiAgICBpZiAoZGF0YS5zdGFtcCA8PSB0aGlzLl9zdGFtcCkgY29udGludWU7XG5cbiAgICBmaWVsZHMgPSBkbC5hcnJheShyLmZpZWxkKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgaWYgKGYucGFyZW50KSByZXR1cm4gZGwuYWNjZXNzb3IoZi5wYXJlbnQpKGdyb3VwLmRhdHVtKVxuICAgICAgcmV0dXJuIGY7IC8vIFN0cmluZyBvciB7XCJzaWduYWxcIn1cbiAgICB9KTtcblxuICAgIGlmICh1bmlxdWVzKSB7XG4gICAgICBhZ2dyLmFjY2Vzc29ycyh7IFwiZGF0YXJlZlwiOiBzb3J0ID8gKHIuc29ydCB8fCBzb3J0LmZpZWxkKSA6IFwiX2lkXCIgfSk7XG4gICAgICBmb3IgKGo9MCwgZmxlbj1maWVsZHMubGVuZ3RoOyBqPGZsZW47ICsraikge1xuICAgICAgICBhZ2dyLmdyb3VwYnkoeyBuYW1lOiBcImtleVwiLCBnZXQ6IGRsLmFjY2Vzc29yKGZpZWxkc1tqXSkgfSk7XG4gICAgICAgIGNhY2hlLmV2YWx1YXRlKGRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGo9MCwgZmxlbj1maWVsZHMubGVuZ3RoOyBqPGZsZW47ICsraikge1xuICAgICAgICBhZ2dyLmFjY2Vzc29ycyh7IFwiZGF0YXJlZlwiOiBmaWVsZHNbal0gfSk7XG4gICAgICAgIGNhY2hlLmV2YWx1YXRlKGRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIGZyb20pO1xuICAgIGNhY2hlLmRlcGVuZGVuY3koQy5TSUdOQUxTKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgc2VsZi5kZXBlbmRlbmN5KEMuU0lHTkFMUywgcykgfSk7XG4gIH1cblxuICBkYXRhID0gYWdnci5yZXN1bHQoKTtcbiAgaWYgKHVuaXF1ZXMpIHtcbiAgICBpZiAoc29ydCkge1xuICAgICAgc29ydCA9IHNvcnQub3JkZXIuc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKHNvcnQub3JkZXIuc2lnbmFsKSA6IHNvcnQub3JkZXI7XG4gICAgICBzb3J0ID0gKHNvcnQgPT0gQy5ERVNDID8gXCItXCIgOiBcIitcIikgKyBzb3J0LnN0YXQgKyBcIl9kYXRhcmVmXCI7XG4gICAgICBzb3J0ID0gZGwuY29tcGFyYXRvcihzb3J0KTtcbiAgICAgIGRhdGEgPSBkYXRhLnNvcnQoc29ydCk7XG4gICAgLy8gfSBlbHNlIHsgIC8vIFwiRmlyc3Qgc2VlblwiIG9yZGVyXG4gICAgLy8gICBzb3J0ID0gZGwuY29tcGFyYXRvcihcInRwbC5faWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQua2V5OyB9KTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gZGF0YVswXTtcbiAgICByZXR1cm4gKGRhdGEgPT09IG51bGwpID8gW10gOiBbZGF0YS5taW5fZGF0YXJlZiwgZGF0YS5tYXhfZGF0YXJlZl07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lnbmFsKHYpIHtcbiAgdmFyIHMgPSB2LnNpZ25hbCwgcmVmO1xuICBpZiAoIXMpIHJldHVybiB2O1xuICB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTLCAocmVmID0gZGwuZmllbGQocykpWzBdKTtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoLnNpZ25hbFJlZihyZWYpO1xufVxuXG5mdW5jdGlvbiBkb21haW5NaW5NYXgoc2NhbGUsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBkb21haW4gPSBbbnVsbCwgbnVsbF0sIHJlZnMsIHo7XG5cbiAgaWYgKGRlZi5kb21haW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGRvbWFpbiA9ICghZGwuaXNPYmplY3QoZGVmLmRvbWFpbikpID8gZG9tYWluIDpcbiAgICAgIGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuXG4gIHogPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgaWYgKGRlZi5kb21haW5NaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5pc09iamVjdChkZWYuZG9tYWluTWluKSkge1xuICAgICAgaWYgKGRlZi5kb21haW5NaW4uc2lnbmFsKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5kb21haW5NaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluWzBdID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOK0MuTUlOLCBkZWYuZG9tYWluTWluLCBzY2FsZSwgZ3JvdXApWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW5bMF0gPSBkZWYuZG9tYWluTWluO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLmRvbWFpbk1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NYXgpKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1heC5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluW3pdID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1heCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bel0gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4rQy5NQVgsIGRlZi5kb21haW5NYXgsIHNjYWxlLCBncm91cClbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblt6XSA9IGRlZi5kb21haW5NYXg7XG4gICAgfVxuICB9XG4gIGlmIChkZWYudHlwZSAhPT0gQy5MT0cgJiYgZGVmLnR5cGUgIT09IEMuVElNRSAmJiAoZGVmLnplcm8gfHwgZGVmLnplcm89PT11bmRlZmluZWQpKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oMCwgZG9tYWluWzBdKTtcbiAgICBkb21haW5bel0gPSBNYXRoLm1heCgwLCBkb21haW5bel0pO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHJhbmdlKGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBybmcgPSBbbnVsbCwgbnVsbF07XG5cbiAgaWYgKGRlZi5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYucmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoR1JPVVBfUFJPUEVSVFlbZGVmLnJhbmdlXSkge1xuICAgICAgICBybmcgPSBbMCwgZ3JvdXBbZGVmLnJhbmdlXV07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdKSB7XG4gICAgICAgIHJuZyA9IGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGwuZXJyb3IoXCJVbnJlY29naXplZCByYW5nZTogXCIrZGVmLnJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgICAgcm5nID0gZGVmLnJhbmdlLm1hcChzaWduYWwuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZWFybHkgZXhpdFxuICAgIH0gZWxzZSB7XG4gICAgICBybmcgPSBbMCwgZGVmLnJhbmdlXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nWzBdID0gZGVmLnJhbmdlTWluLnNpZ25hbCA/IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZU1pbikgOiBkZWYucmFuZ2VNaW47XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nW3JuZy5sZW5ndGgtMV0gPSBkZWYucmFuZ2VNYXguc2lnbmFsID8gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWF4KSA6IGRlZi5yYW5nZU1heDtcbiAgfVxuICBcbiAgaWYgKGRlZi5yZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmV2ID0gZGVmLnJldmVyc2U7XG4gICAgaWYgKGRsLmlzT2JqZWN0KHJldikpIHtcbiAgICAgIHJldiA9IGRsLmFjY2Vzc29yKHJldi5maWVsZCkoZ3JvdXAuZGF0dW0pO1xuICAgIH1cbiAgICBpZiAocmV2KSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICB9XG4gIFxuICByZXR1cm4gcm5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlOyIsInZhciB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2FsY0JvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZHVyYXRpb24sIGVhc2UpIHtcbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDUwMDtcbiAgdGhpcy5lYXNlID0gZWFzZSAmJiBkMy5lYXNlKGVhc2UpIHx8IGQzLmVhc2UoXCJjdWJpYy1pbi1vdXRcIik7XG4gIHRoaXMudXBkYXRlcyA9IHtuZXh0OiBudWxsfTtcbn1cblxudmFyIHByb3RvdHlwZSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG52YXIgc2tpcCA9IHtcbiAgXCJ0ZXh0XCI6IDEsXG4gIFwidXJsXCI6ICAxXG59O1xuXG5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihpdGVtLCB2YWx1ZXMsIHN0YW1wKSB7XG4gIHZhciBrZXksIGN1cnIsIG5leHQsIGludGVycCwgbGlzdCA9IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgY3VyciA9IGl0ZW1ba2V5XTtcbiAgICBuZXh0ID0gdmFsdWVzW2tleV07ICAgICAgXG4gICAgaWYgKGN1cnIgIT09IG5leHQpIHtcbiAgICAgIGlmIChza2lwW2tleV0gfHwgY3VyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNraXAgaW50ZXJwb2xhdGlvbiBmb3Igc3BlY2lmaWMga2V5cyBvciB1bmRlZmluZWQgc3RhcnQgdmFsdWVzXG4gICAgICAgIHR1cGxlLnNldChpdGVtLCBrZXksIG5leHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3VyciA9PT0gXCJudW1iZXJcIiAmJiAhaXNGaW5pdGUoY3VycikpIHtcbiAgICAgICAgLy8gZm9yIE5hTiBvciBpbmZpbml0ZSBudW1lcmljIHZhbHVlcywgc2tpcCB0byBmaW5hbCB2YWx1ZVxuICAgICAgICB0dXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBsb29rdXAgaW50ZXJwb2xhdG9yXG4gICAgICAgIGludGVycCA9IGQzLmludGVycG9sYXRlKGN1cnIsIG5leHQpO1xuICAgICAgICBpbnRlcnAucHJvcGVydHkgPSBrZXk7XG4gICAgICAgIChsaXN0IHx8IChsaXN0PVtdKSkucHVzaChpbnRlcnApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsaXN0ID09PSBudWxsICYmIGl0ZW0uc3RhdHVzID09PSBDLkVYSVQpIHtcbiAgICBsaXN0ID0gW107IC8vIGVuc3VyZSBleGl0aW5nIGl0ZW1zIGFyZSBpbmNsdWRlZFxuICB9XG5cbiAgaWYgKGxpc3QgIT0gbnVsbCkge1xuICAgIGxpc3QuaXRlbSA9IGl0ZW07XG4gICAgbGlzdC5lYXNlID0gaXRlbS5tYXJrLmVhc2UgfHwgdGhpcy5lYXNlO1xuICAgIGxpc3QubmV4dCA9IHRoaXMudXBkYXRlcy5uZXh0O1xuICAgIHRoaXMudXBkYXRlcy5uZXh0ID0gbGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB0ID0gdGhpcywgcHJldiA9IHQudXBkYXRlcywgY3VyciA9IHByZXYubmV4dDtcbiAgZm9yICg7IGN1cnIhPW51bGw7IHByZXY9Y3VyciwgY3Vycj1wcmV2Lm5leHQpIHtcbiAgICBpZiAoY3Vyci5pdGVtLnN0YXR1cyA9PT0gQy5FWElUKSBjdXJyLnJlbW92ZSA9IHRydWU7XG4gIH1cbiAgdC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBkMy50aW1lcihmdW5jdGlvbihlbGFwc2VkKSB7IHJldHVybiBzdGVwLmNhbGwodCwgZWxhcHNlZCk7IH0pO1xufTtcblxuZnVuY3Rpb24gc3RlcChlbGFwc2VkKSB7XG4gIHZhciBsaXN0ID0gdGhpcy51cGRhdGVzLCBwcmV2ID0gbGlzdCwgY3VyciA9IHByZXYubmV4dCxcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbixcbiAgICAgIGl0ZW0sIGRlbGF5LCBmLCBlLCBpLCBuLCBzdG9wID0gdHJ1ZTtcblxuICBmb3IgKDsgY3VyciE9bnVsbDsgcHJldj1jdXJyLCBjdXJyPXByZXYubmV4dCkge1xuICAgIGl0ZW0gPSBjdXJyLml0ZW07XG4gICAgZGVsYXkgPSBpdGVtLmRlbGF5IHx8IDA7XG5cbiAgICBmID0gKGVsYXBzZWQgLSBkZWxheSkgLyBkdXJhdGlvbjtcbiAgICBpZiAoZiA8IDApIHsgc3RvcCA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGlmIChmID4gMSkgZiA9IDE7XG4gICAgZSA9IGN1cnIuZWFzZShmKTtcblxuICAgIGZvciAoaT0wLCBuPWN1cnIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaXRlbVtjdXJyW2ldLnByb3BlcnR5XSA9IGN1cnJbaV0oZSk7XG4gICAgfVxuICAgIGl0ZW0udG91Y2goKTtcbiAgICBjYWxjQm91bmRzLml0ZW0oaXRlbSk7XG5cbiAgICBpZiAoZiA9PT0gMSkge1xuICAgICAgaWYgKGN1cnIucmVtb3ZlKSBpdGVtLnJlbW92ZSgpO1xuICAgICAgcHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuICAgICAgY3VyciA9IHByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhbGxiYWNrKCk7XG4gIHJldHVybiBzdG9wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgdHBsID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBwYXJzZU1hcmsgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrJyk7XG5cbmZ1bmN0aW9uIGF4cyhtb2RlbCkge1xuICB2YXIgc2NhbGUsXG4gICAgICBvcmllbnQgPSBjb25maWcuYXhpcy5vcmllbnQsXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgdGl0bGVPZmZzZXQgPSBjb25maWcuYXhpcy50aXRsZU9mZnNldCxcbiAgICAgIGF4aXNEZWYgPSB7fSxcbiAgICAgIGxheWVyID0gXCJmcm9udFwiLFxuICAgICAgZ3JpZCA9IGZhbHNlLFxuICAgICAgdGl0bGUgPSBudWxsLFxuICAgICAgdGlja01ham9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja01pbm9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja0VuZFNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tQYWRkaW5nID0gY29uZmlnLmF4aXMucGFkZGluZyxcbiAgICAgIHRpY2tWYWx1ZXMgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdFN0cmluZyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTdWJkaXZpZGUgPSAwLFxuICAgICAgdGlja0FyZ3VtZW50cyA9IFtjb25maWcuYXhpcy50aWNrc10sXG4gICAgICBncmlkTGluZVN0eWxlID0ge30sXG4gICAgICB0aWNrTGFiZWxTdHlsZSA9IHt9LFxuICAgICAgbWFqb3JUaWNrU3R5bGUgPSB7fSxcbiAgICAgIG1pbm9yVGlja1N0eWxlID0ge30sXG4gICAgICB0aXRsZVN0eWxlID0ge30sXG4gICAgICBkb21haW5TdHlsZSA9IHt9LFxuICAgICAgbSA9IHsgLy8gQXhpcyBtYXJrcyBhcyByZWZlcmVuY2VzIGZvciB1cGRhdGVzXG4gICAgICAgIGdyaWRMaW5lczogbnVsbCxcbiAgICAgICAgbWFqb3JUaWNrczogbnVsbCxcbiAgICAgICAgbWlub3JUaWNrczogbnVsbCxcbiAgICAgICAgdGlja0xhYmVsczogbnVsbCxcbiAgICAgICAgZG9tYWluOiBudWxsLFxuICAgICAgICB0aXRsZTogbnVsbFxuICAgICAgfTtcblxuICB2YXIgYXhpcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGF4aXNEZWYudHlwZSA9IG51bGw7XG4gIH07XG5cbiAgYXhpcy5kZWYgPSBmdW5jdGlvbigpIHtcbiAgICBpZighYXhpc0RlZi50eXBlKSBheGlzX2RlZihzY2FsZSk7XG5cbiAgICAvLyB0aWNrIGZvcm1hdFxuICAgIHRpY2tGb3JtYXQgPSAhdGlja0Zvcm1hdFN0cmluZyA/IG51bGwgOiAoKHNjYWxlLnR5cGUgPT09ICd0aW1lJylcbiAgICAgID8gZDMudGltZS5mb3JtYXQodGlja0Zvcm1hdFN0cmluZylcbiAgICAgIDogZDMuZm9ybWF0KHRpY2tGb3JtYXRTdHJpbmcpKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICAvLyBXZSBkb24ndCBfcmVhbGx5XyBuZWVkIHRvIG1vZGVsIHRoZXNlIGFzIHR1cGxlcyBhcyBubyBmdXJ0aGVyXG4gICAgLy8gZGF0YSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLiBTbyB3ZSBvcHRpbWl6ZSBmb3IgYSBoaWdoIGNodXJuIHJhdGUuIFxuICAgIHZhciBpbmplc3QgPSBmdW5jdGlvbihkKSB7IHJldHVybiB7ZGF0YTogZH07IH07XG4gICAgdmFyIG1ham9yID0gdGlja1ZhbHVlcyA9PSBudWxsXG4gICAgICA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKVxuICAgICAgOiB0aWNrVmFsdWVzO1xuICAgIHZhciBtaW5vciA9IHZnX2F4aXNTdWJkaXZpZGUoc2NhbGUsIG1ham9yLCB0aWNrU3ViZGl2aWRlKS5tYXAoaW5qZXN0KTtcbiAgICBtYWpvciA9IG1ham9yLm1hcChpbmplc3QpO1xuICAgIHZhciBmbXQgPSB0aWNrRm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiB0aWNrRm9ybWF0O1xuICAgIG1ham9yLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkLmxhYmVsID0gZm10KGQuZGF0YSk7IH0pO1xuICAgIHZhciB0ZGF0YSA9IHRpdGxlID8gW3RpdGxlXS5tYXAoaW5qZXN0KSA6IFtdO1xuXG4gICAgYXhpc0RlZi5tYXJrc1swXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBncmlkID8gbWFqb3IgOiBbXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1ham9yOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWlub3I7IH07XG4gICAgYXhpc0RlZi5tYXJrc1szXS5mcm9tID0gYXhpc0RlZi5tYXJrc1sxXS5mcm9tO1xuICAgIGF4aXNEZWYubWFya3NbNF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gWzFdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbNV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgYXhpc0RlZi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgYXhpc0RlZi5vcmllbnQgPSBvcmllbnQ7XG4gICAgYXhpc0RlZi5sYXllciA9IGxheWVyO1xuICAgIHJldHVybiBheGlzRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGF4aXNfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgc2NhbGUgbWFwcGluZ1xuICAgIHZhciBuZXdTY2FsZSwgb2xkU2NhbGUsIHJhbmdlO1xuICAgIGlmIChzY2FsZS50eXBlID09PSBcIm9yZGluYWxcIikge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjUgKyBzY2FsZS5yYW5nZUJhbmQoKS8yfTtcbiAgICAgIG9sZFNjYWxlID0gbmV3U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUsIG9mZnNldDogMC41fTtcbiAgICAgIG9sZFNjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUrXCI6cHJldlwiLCBvZmZzZXQ6IDAuNX07XG4gICAgfVxuICAgIHJhbmdlID0gdmdfYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpO1xuXG4gICAgLy8gc2V0dXAgYXhpcyBtYXJrc1xuICAgIGlmICghbS5ncmlkTGluZXMpICBtLmdyaWRMaW5lcyAgPSB2Z19heGlzVGlja3MoKTtcbiAgICBpZiAoIW0ubWFqb3JUaWNrcykgbS5tYWpvclRpY2tzID0gdmdfYXhpc1RpY2tzKCk7XG4gICAgaWYgKCFtLm1pbm9yVGlja3MpIG0ubWlub3JUaWNrcyA9IHZnX2F4aXNUaWNrcygpO1xuICAgIGlmICghbS50aWNrTGFiZWxzKSBtLnRpY2tMYWJlbHMgPSB2Z19heGlzVGlja0xhYmVscygpO1xuICAgIGlmICghbS5kb21haW4pIG0uZG9tYWluID0gdmdfYXhpc0RvbWFpbigpO1xuICAgIGlmICghbS50aXRsZSkgIG0udGl0bGUgID0gdmdfYXhpc1RpdGxlKCk7XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2UgPSB7dmFsdWU6IGNvbmZpZy5heGlzLmdyaWRDb2xvcn07XG5cbiAgICAvLyBleHRlbmQgYXhpcyBtYXJrcyBiYXNlZCBvbiBheGlzIG9yaWVudGF0aW9uXG4gICAgdmdfYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5ncmlkTGluZXMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgSW5maW5pdHkpO1xuICAgIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWFqb3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplKTtcbiAgICB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1pbm9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01pbm9yU2l6ZSk7XG4gICAgdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbS50aWNrTGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUsIHRpY2tQYWRkaW5nKTtcblxuICAgIHZnX2F4aXNEb21haW5FeHRlbmQob3JpZW50LCBtLmRvbWFpbiwgcmFuZ2UsIHRpY2tFbmRTaXplKTtcbiAgICB2Z19heGlzVGl0bGVFeHRlbmQob3JpZW50LCBtLnRpdGxlLCByYW5nZSwgdGl0bGVPZmZzZXQpOyAvLyBUT0RPIGdldCBvZmZzZXRcbiAgICBcbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JpZExpbmVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWFqb3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWFqb3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1pbm9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1pbm9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aWNrTGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB0aWNrTGFiZWxTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLCBkb21haW5TdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGl0bGUucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuXG4gICAgdmFyIG1hcmtzID0gW20uZ3JpZExpbmVzLCBtLm1ham9yVGlja3MsIG0ubWlub3JUaWNrcywgbS50aWNrTGFiZWxzLCBtLmRvbWFpbiwgbS50aXRsZV07XG4gICAgZGwuZXh0ZW5kKGF4aXNEZWYsIHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHsgXG4gICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19heGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGVuY29kZTogdmdfYXhpc1VwZGF0ZSxcbiAgICAgICAgICBzY2FsZXM6IFtzY2FsZS5zY2FsZU5hbWVdLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBkYXRhOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBheGlzRGVmLm1hcmtzID0gbWFya3MubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pO1xuICB9O1xuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgaWYgKHNjYWxlICE9PSB4KSB7IHNjYWxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSB4KSB7XG4gICAgICBvcmllbnQgPSB4IGluIHZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBjb25maWcuYXhpcy5vcmllbnQ7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIGlmICh0aXRsZSAhPT0geCkgeyB0aXRsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50cztcbiAgICB0aWNrQXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0U3RyaW5nO1xuICAgIGlmICh0aWNrRm9ybWF0U3RyaW5nICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrTWFqb3JTaXplO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgIG1ham9yID0gK3gsXG4gICAgICAgIG1pbm9yID0gbiA+IDEgPyAreSA6IHRpY2tNYWpvclNpemUsXG4gICAgICAgIGVuZCAgID0gbiA+IDAgPyArYXJndW1lbnRzW25dIDogdGlja01ham9yU2l6ZTtcblxuICAgIGlmICh0aWNrTWFqb3JTaXplICE9PSBtYWpvciB8fFxuICAgICAgICB0aWNrTWlub3JTaXplICE9PSBtaW5vciB8fFxuICAgICAgICB0aWNrRW5kU2l6ZSAhPT0gZW5kKSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHRpY2tNYWpvclNpemUgPSBtYWpvcjtcbiAgICB0aWNrTWlub3JTaXplID0gbWlub3I7XG4gICAgdGlja0VuZFNpemUgPSBlbmQ7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tTdWJkaXZpZGU7XG4gICAgdGlja1N1YmRpdmlkZSA9ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGRsLmlzT2JqZWN0KHgpID8geCA6ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgaWYgKHRpY2tQYWRkaW5nICE9PSAreCkgeyB0aWNrUGFkZGluZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZU9mZnNldDtcbiAgICBpZiAodGl0bGVPZmZzZXQgIT09ICt4KSB7IHRpdGxlT2Zmc2V0ID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmxheWVyID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxheWVyO1xuICAgIGlmIChsYXllciAhPT0geCkgeyBsYXllciA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmdyaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZDtcbiAgICBpZiAoZ3JpZCAhPT0geCkgeyBncmlkID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyaWRMaW5lU3R5bGU7XG4gICAgaWYgKGdyaWRMaW5lU3R5bGUgIT09IHgpIHsgZ3JpZExpbmVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFqb3JUaWNrU3R5bGU7XG4gICAgaWYgKG1ham9yVGlja1N0eWxlICE9PSB4KSB7IG1ham9yVGlja1N0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW5vclRpY2tTdHlsZTtcbiAgICBpZiAobWlub3JUaWNrU3R5bGUgIT09IHgpIHsgbWlub3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tMYWJlbFN0eWxlO1xuICAgIGlmICh0aWNrTGFiZWxTdHlsZSAhPT0geCkgeyB0aWNrTGFiZWxTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVN0eWxlO1xuICAgIGlmICh0aXRsZVN0eWxlICE9PSB4KSB7IHRpdGxlU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpblN0eWxlO1xuICAgIGlmIChkb21haW5TdHlsZSAhPT0geCkgeyBkb21haW5TdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgXG4gIGF4aXMucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gYXhpcztcbn07XG5cbnZhciB2Z19heGlzT3JpZW50cyA9IHt0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19heGlzU3ViZGl2aWRlKHNjYWxlLCB0aWNrcywgbSkge1xuICBzdWJ0aWNrcyA9IFtdO1xuICBpZiAobSAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGV4dGVudCA9IHZnX2F4aXNTY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksXG4gICAgICAgIHN1YnRpY2tzLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0aWNrcy5sZW5ndGgsXG4gICAgICAgIGQgPSAodGlja3NbMV0gLSB0aWNrc1swXSkgLyArK20sXG4gICAgICAgIGosXG4gICAgICAgIHY7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGZvciAoaiA9IG07IC0taiA+IDA7KSB7XG4gICAgICAgIGlmICgodiA9ICt0aWNrc1tpXSAtIGogKiBkKSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICBzdWJ0aWNrcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoLS1pLCBqID0gMDsgKytqIDwgbSAmJiAodiA9ICt0aWNrc1tpXSArIGogKiBkKSA8IGV4dGVudFsxXTspIHtcbiAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJ0aWNrcztcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1NjYWxlRXh0ZW50KGRvbWFpbikge1xuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNTY2FsZVJhbmdlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudFxuICAgID8gc2NhbGUucmFuZ2VFeHRlbnQoKVxuICAgIDogdmdfYXhpc1NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xufVxuXG52YXIgdmdfYXhpc0FsaWduID0ge1xuICBib3R0b206IFwiY2VudGVyXCIsXG4gIHRvcDogXCJjZW50ZXJcIixcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCJcbn07XG5cbnZhciB2Z19heGlzQmFzZWxpbmUgPSB7XG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiLFxuICBsZWZ0OiBcIm1pZGRsZVwiLFxuICByaWdodDogXCJtaWRkbGVcIlxufTtcblxuZnVuY3Rpb24gdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUsIHBhZCkge1xuICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCkgKyBwYWQ7XG4gIGlmIChvcmllbnQgPT09IFwibGVmdFwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIHNpemUgKj0gLTE7XG4gIH0gIFxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogb2xkU2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IG5ld1NjYWxlLFxuICAgICAgeToge3ZhbHVlOiBzaXplfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6IFwiY2VudGVyXCJ9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogdmdfYXhpc0Jhc2VsaW5lW29yaWVudF19XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogb2xkU2NhbGUsXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG5ld1NjYWxlLFxuICAgICAgYWxpZ246IHt2YWx1ZTogdmdfYXhpc0FsaWduW29yaWVudF19LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCB0aWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCBzaXplKSB7XG4gIHZhciBzaWduID0gKG9yaWVudCA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSA/IC0xIDogMTtcbiAgaWYgKHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgc2l6ZSA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKVxuICAgICAgPyB7ZmllbGQ6IHtncm91cDogXCJoZWlnaHRcIiwgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn1cbiAgICAgIDoge2ZpZWxkOiB7Z3JvdXA6IFwid2lkdGhcIiwgIGxldmVsOiAyfSwgbXVsdDogLXNpZ259O1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB7dmFsdWU6IHNpZ24gKiBzaXplfTtcbiAgfVxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAgb2xkU2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAgbmV3U2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgIH0pOyAgICAgICAgXG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgb2xkU2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgbmV3U2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5leGl0LCB7XG4gICAgICB5OiAgbmV3U2NhbGUsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlRXh0ZW5kKG9yaWVudCwgdGl0bGUsIHJhbmdlLCBvZmZzZXQpIHtcbiAgdmFyIG1pZCA9IH5+KChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDIpLFxuICAgICAgc2lnbiA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikgPyAtMSA6IDE7XG4gIFxuICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBtaWR9LFxuICAgICAgeToge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICB5OiB7dmFsdWU6IG1pZH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAtOTB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc0RvbWFpbkV4dGVuZChvcmllbnQsIGRvbWFpbiwgcmFuZ2UsIHNpemUpIHtcbiAgdmFyIHBhdGg7XG4gIGlmIChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikge1xuICAgIHNpemUgPSAtMSAqIHNpemU7XG4gIH1cbiAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICBwYXRoID0gXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2l6ZSArIFwiVjBIXCIgKyByYW5nZVsxXSArIFwiVlwiICsgc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gXCJNXCIgKyBzaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2l6ZTtcbiAgfVxuICBkb21haW4ucHJvcGVydGllcy51cGRhdGUucGF0aCA9IHt2YWx1ZTogcGF0aH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNVcGRhdGUoaXRlbSwgZ3JvdXAsIHRyYW5zLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykge1xuICB2YXIgbyA9IHRyYW5zID8ge30gOiBpdGVtLFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHdpZHRoICA9IGdyb3VwLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZ3JvdXAuaGVpZ2h0OyAvLyBUT0RPIGZhbGxiYWNrIHRvIGdsb2JhbCB3LGg/XG5cbiAgaWYgKGRsLmlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSAtZ3JvdXAuc2NhbGUob2Zmc2V0LnNjYWxlKShvZmZzZXQudmFsdWUpO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFwibGVmdFwiOiAgIHsgdHBsLnNldChvLCAneCcsIC1vZmZzZXQpOyB0cGwuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgY2FzZSBcInJpZ2h0XCI6ICB7IHRwbC5zZXQobywgJ3gnLCB3aWR0aCArIG9mZnNldCk7IHRwbC5zZXQobywgJ3knLCAwKTsgYnJlYWs7IH1cbiAgICBjYXNlIFwiYm90dG9tXCI6IHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgaGVpZ2h0ICsgb2Zmc2V0KTsgYnJlYWs7IH1cbiAgICBjYXNlIFwidG9wXCI6ICAgIHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgLW9mZnNldCk7IGJyZWFrOyB9XG4gICAgZGVmYXVsdDogICAgICAgeyB0cGwuc2V0KG8sICd4JywgMCk7IHRwbC5zZXQobywgJ3knLCAwKTsgfVxuICB9XG5cbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpY2tzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicnVsZVwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHN0cm9rZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrV2lkdGh9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja0xhYmVscygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbEZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250U2l6ZX0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJsYWJlbFwifVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250V2VpZ2h0fSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUNvbG9yfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogXCJjZW50ZXJcIn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IFwibWlkZGxlXCJ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwiZGF0YVwifVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNEb21haW4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwYXRoXCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgeToge3ZhbHVlOiAwLjV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc1dpZHRofVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhzO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHBsID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksIFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKS5yZXZpc2VzKHRydWUpO1xuXG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn1cbiAgfSk7XG5cbiAgdGhpcy5fZmllbGRzRGVmID0gbnVsbDtcbiAgdGhpcy5fYWdnciA9IG51bGw7ICAvLyBkbC5BZ2dyZWdhdG9yXG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChBZ2dyZWdhdGUucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8uc3VtbWFyaXplID0ge1xuICBzZXQ6IGZ1bmN0aW9uKHRyYW5zZm9ybSwgc3VtbWFyaXplKSB7XG4gICAgdmFyIGksIGxlbiwgZiwgZmllbGRzLCBuYW1lLCBvcHMsIHNpZ25hbHMgPSB7fTtcbiAgICBpZighZGwuaXNBcnJheShmaWVsZHMgPSBzdW1tYXJpemUpKSB7IC8vIE9iamVjdCBzeW50YXggZnJvbSBkbFxuICAgICAgZmllbGRzID0gW107XG4gICAgICBmb3IgKG5hbWUgaW4gc3VtbWFyaXplKSB7XG4gICAgICAgIG9wcyA9IHV0aWwuYXJyYXkoc3VtbWFyaXplW25hbWVdKTtcbiAgICAgICAgZmllbGRzLnB1c2goe25hbWU6IG5hbWUsIG9wczogb3BzfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKGk9MCwgbGVuPWZpZWxkcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGYgPSBmaWVsZHNbaV07XG4gICAgICBpZihmLm5hbWUuc2lnbmFsKSBzaWduYWxzW2YubmFtZS5zaWduYWxdID0gMTtcbiAgICAgIGRsLmFycmF5KGYub3BzKS5mb3JFYWNoKGZ1bmN0aW9uKG8peyBpZihvLnNpZ25hbCkgc2lnbmFsc1tvLnNpZ25hbF0gPSAxIH0pO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybS5fZmllbGRzRGVmID0gZmllbGRzO1xuICAgIHRyYW5zZm9ybS5fYWdnciA9IG51bGw7XG4gICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBkbC5rZXlzKHNpZ25hbHMpKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG59O1xuXG5mdW5jdGlvbiBpbmdlc3QodCkgeyByZXR1cm4gdHBsLmluZ2VzdCh0LCBudWxsKSB9XG5cbnByb3RvLmFnZ3IgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5fYWdncikgcmV0dXJuIHRoaXMuX2FnZ3I7XG5cbiAgdmFyIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICBncm91cGJ5ID0gdGhpcy5ncm91cGJ5LmdldChncmFwaCkuZmllbGRzO1xuXG4gIHZhciBmaWVsZHMgPSB0aGlzLl9maWVsZHNEZWYubWFwKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgdmFyIGYgPSBkbC5kdXBsaWNhdGUoZmllbGQpO1xuICAgIGYubmFtZSA9IGYubmFtZS5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoZi5uYW1lLnNpZ25hbCkgOiBmLm5hbWU7XG4gICAgZi5vcHMgID0gZi5vcHMuc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKGYub3BzLnNpZ25hbCkgOiBkbC5hcnJheShmLm9wcykubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgIHJldHVybiBvLnNpZ25hbCA/IGdyYXBoLnNpZ25hbFJlZihvLnNpZ25hbCkgOiBvO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGY7XG4gIH0pO1xuXG4gIHZhciBhZ2dyID0gdGhpcy5fYWdnciA9IGRsLmdyb3VwYnkoZ3JvdXBieSlcbiAgICAuc3RyZWFtKHRydWUpXG4gICAgLnN1bW1hcml6ZShmaWVsZHMpO1xuXG4gIGFnZ3IuX2Fzc2lnbiA9IHRwbC5zZXQ7XG4gIGFnZ3IuX2luZ2VzdCA9IGluZ2VzdDtcblxuICByZXR1cm4gYWdncjtcbn07XG5cbnByb3RvLl9yZXNldCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuYWdncigpLnJlc3VsdCgpKTtcbiAgdGhpcy5fYWdnciA9IG51bGw7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImFnZ3JlZ2F0ZVwiXSk7XG5cbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuICBpZihyZXNldCkgdGhpcy5fcmVzZXQoaW5wdXQsIG91dHB1dCk7XG5cbiAgdmFyIGFnZ3IgPSB0aGlzLmFnZ3IoKTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChhZ2dyLmFkZC5iaW5kKGFnZ3IpKTtcblxuICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYocmVzZXQpIHtcbiAgICAgIGFnZ3IuYWRkKHgpOyAgLy8gU2lnbmFsIGNoYW5nZSB0cmlnZ2VyZWQgcmVmbG93XG4gICAgfSBlbHNlIGlmKHRwbC5oYXNfcHJldih4KSkge1xuICAgICAgYWdnci5yZW0odHBsLnByZXYoeCkpO1xuICAgICAgYWdnci5hZGQoeCk7XG4gICAgfVxuICB9KTtcblxuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgYWdnci5yZW0odHBsLmhhc19wcmV2KHgpID8gdHBsLnByZXYoeCkgOiB4KTtcbiAgfSk7XG5cbiAgdmFyIGNoYW5nZXMgPSBhZ2dyLmNoYW5nZXMoKTtcbiAgb3V0cHV0LmFkZC5wdXNoLmFwcGx5KG91dHB1dC5hZGQsIGNoYW5nZXMuYWRkKTtcbiAgb3V0cHV0Lm1vZC5wdXNoLmFwcGx5KG91dHB1dC5tb2QsIGNoYW5nZXMubW9kKTtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIGNoYW5nZXMucmVtKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQmF0Y2hUcmFuc2Zvcm0oKSB7XG59XG5cbnZhciBwcm90byA9IChCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLlxuICAvLyBUT0RPOiBlZmZpY2llbnRseSBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG4gIHZhciBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKTtcbiAgcmV0dXJuIHRoaXMuYmF0Y2hUcmFuc2Zvcm0oaW5wdXQsIGRhdGEpO1xufTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFRyYW5zZm9ybTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gQmluKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBtaW46IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIG1heDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgc3RlcDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgbWF4Ymluczoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMjB9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcImJpblwiOiBcImJpblwifTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChCaW4ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQuYmluO1xuICAgICAgXG4gIHZhciBiID0gZGwuYmlucyh7XG4gICAgbWluOiB0aGlzLm1pbi5nZXQoKSxcbiAgICBtYXg6IHRoaXMubWF4LmdldCgpLFxuICAgIHN0ZXA6IHRoaXMuc3RlcC5nZXQoKSxcbiAgICBtYXhiaW5zOiB0aGlzLm1heGJpbnMuZ2V0KClcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGQpIHtcbiAgICB2YXIgdiA9IHRyYW5zZm9ybS5maWVsZC5nZXQoKS5hY2Nlc3NvcihkKTtcbiAgICB2ID0gdiA9PSBudWxsID8gbnVsbFxuICAgICAgOiBiLnN0YXJ0ICsgYi5zdGVwICogfn4oKHYgLSBiLnN0YXJ0KSAvIGIuc3RlcCk7XG4gICAgdHVwbGUuc2V0KGQsIG91dHB1dCwgdiwgaW5wdXQuc3RhbXApO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW47XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIENyb3NzKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgZGlhZ29uYWw6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwidHJ1ZVwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XCJsZWZ0XCI6IFwiYVwiLCBcInJpZ2h0XCI6IFwiYlwifTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHRoaXMuX2xhc3RSZW0gID0gbnVsbDsgLy8gTW9zdCByZWNlbnQgc3RhbXAgdGhhdCByZW0gb2NjdXJlZC4gXG4gIHRoaXMuX2xhc3RXaXRoID0gbnVsbDsgLy8gTGFzdCB0aW1lIHdlIGNyb3NzZWQgdy93aXRoZHMuXG4gIHRoaXMuX2lkcyAgID0ge307XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQ3Jvc3MucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuLy8gRWFjaCBjYWNoZWQgaW5jb21pbmcgdHVwbGUgYWxzbyBoYXMgYSBzdGFtcCB0byB0cmFjayBpZiB3ZSBuZWVkIHRvIGRvXG4vLyBsYXp5IGZpbHRlcmluZyBvZiByZW1vdmVkIHR1cGxlcy5cbmZ1bmN0aW9uIGNhY2hlKHgsIHQpIHtcbiAgdmFyIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwge2M6IFtdLCBzOiB0aGlzLl9zdGFtcH07XG4gIGMuYy5wdXNoKHQpO1xufVxuXG5mdW5jdGlvbiBhZGQob3V0cHV0LCBsZWZ0LCB3ZGF0YSwgZGlhZywgeCkge1xuICB2YXIgZGF0YSA9IGxlZnQgPyB3ZGF0YSA6IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksIC8vIExlZnQgdHVwbGVzIGNyb3NzIHcvcmlnaHQuXG4gICAgICBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBwcmV2ICA9IHguX3ByZXYgIT09IHVuZGVmaW5lZCA/IG51bGwgOiB1bmRlZmluZWQsIFxuICAgICAgdCwgeSwgaWQ7XG5cbiAgZm9yKDsgaTxsZW47ICsraSkge1xuICAgIHkgPSBkYXRhW2ldO1xuICAgIGlkID0gbGVmdCA/IHguX2lkK1wiX1wiK3kuX2lkIDogeS5faWQrXCJfXCIreC5faWQ7XG4gICAgaWYodGhpcy5faWRzW2lkXSkgY29udGludWU7XG4gICAgaWYoeC5faWQgPT0geS5faWQgJiYgIWRpYWcpIGNvbnRpbnVlO1xuXG4gICAgdCA9IHR1cGxlLmluZ2VzdCh7fSwgcHJldik7XG4gICAgdFt0aGlzLl9vdXRwdXQubGVmdF0gID0gbGVmdCA/IHggOiB5O1xuICAgIHRbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IGxlZnQgPyB5IDogeDtcbiAgICBvdXRwdXQuYWRkLnB1c2godCk7XG4gICAgY2FjaGUuY2FsbCh0aGlzLCB4LCB0KTtcbiAgICBjYWNoZS5jYWxsKHRoaXMsIHksIHQpO1xuICAgIHRoaXMuX2lkc1tpZF0gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vZChvdXRwdXQsIGxlZnQsIHgpIHtcbiAgdmFyIGNyb3NzID0gdGhpcyxcbiAgICAgIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF07XG5cbiAgaWYodGhpcy5fbGFzdFJlbSA+IGMucykgeyAgLy8gUmVtb3ZlZCB0dXBsZXMgaGF2ZW4ndCBiZWVuIGZpbHRlcmVkIHlldFxuICAgIGMuYyA9IGMuYy5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIHQgPSB5W2Nyb3NzLl9vdXRwdXRbbGVmdCA/IFwicmlnaHRcIiA6IFwibGVmdFwiXV07XG4gICAgICByZXR1cm4gY3Jvc3MuX2NhY2hlW3QuX2lkXSAhPT0gbnVsbDtcbiAgICB9KTtcbiAgICBjLnMgPSB0aGlzLl9sYXN0UmVtO1xuICB9XG5cbiAgb3V0cHV0Lm1vZC5wdXNoLmFwcGx5KG91dHB1dC5tb2QsIGMuYyk7XG59XG5cbmZ1bmN0aW9uIHJlbShvdXRwdXQsIHgpIHtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW3guX2lkXS5jKTtcbiAgdGhpcy5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgdGhpcy5fbGFzdFJlbSA9IHRoaXMuX3N0YW1wO1xufVxuXG5mdW5jdGlvbiB1cEZpZWxkcyhpbnB1dCwgb3V0cHV0KSB7XG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmxlZnRdICA9IDE7IFxuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IDE7XG4gIH1cbn1cblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImNyb3NzaW5nXCJdKTtcblxuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLiBUT0RPOiBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG5cbiAgdmFyIHcgPSB0aGlzLndpdGguZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGRpYWcgPSB0aGlzLmRpYWdvbmFsLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBzZWxmQ3Jvc3MgPSAoIXcubmFtZSksXG4gICAgICBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSxcbiAgICAgIHdvdXRwdXQgPSBzZWxmQ3Jvc3MgPyBpbnB1dCA6IHcuc291cmNlLmxhc3QoKSxcbiAgICAgIHdkYXRhICAgPSBzZWxmQ3Jvc3MgPyBkYXRhIDogdy5zb3VyY2UudmFsdWVzKCksXG4gICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICByID0gcmVtLmJpbmQodGhpcywgb3V0cHV0KTsgXG5cbiAgaW5wdXQucmVtLmZvckVhY2gocik7XG4gIGlucHV0LmFkZC5mb3JFYWNoKGFkZC5iaW5kKHRoaXMsIG91dHB1dCwgdHJ1ZSwgd2RhdGEsIGRpYWcpKTtcblxuICBpZighc2VsZkNyb3NzICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0V2l0aCkge1xuICAgIHdvdXRwdXQucmVtLmZvckVhY2gocik7XG4gICAgd291dHB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlLCBkYXRhLCBkaWFnKSk7XG4gICAgd291dHB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlKSk7XG4gICAgdXBGaWVsZHMuY2FsbCh0aGlzLCB3b3V0cHV0LCBvdXRwdXQpO1xuICAgIHRoaXMuX2xhc3RXaXRoID0gd291dHB1dC5zdGFtcDtcbiAgfVxuXG4gIC8vIE1vZHMgbmVlZCB0byBjb21lIGFmdGVyIGFsbCByZW1vdmFscyBoYXZlIGJlZW4gcnVuLlxuICBpbnB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUpKTtcbiAgdXBGaWVsZHMuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcm9zczsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmFjZXQoZ3JhcGgpIHtcbiAgR3JvdXBCeS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge2tleXM6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSB9KTtcblxuICB0aGlzLl9waXBlbGluZSA9IFtdO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZhY2V0LnByb3RvdHlwZSA9IG5ldyBHcm91cEJ5KCkpO1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG4gIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB2YXIgaywgYztcbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoIWMpIGNvbnRpbnVlO1xuICAgIG91dHB1dC5yZW0ucHVzaChjLnRwbCk7XG4gICAgYy5kZWxldGUoKTtcbiAgfVxuICB0aGlzLl9jZWxscyA9IHt9O1xufTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgcmV0dXJuIHR1cGxlLmluZ2VzdChrLCBudWxsKTtcbn07XG5cbnByb3RvLl9uZXdfY2VsbCA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgLy8gUmF0aGVyIHRoYW4gc2hhcmluZyB0aGUgcGlwZWxpbmUgYmV0d2VlbiBhbGwgbm9kZXMsXG4gIC8vIGdpdmUgZWFjaCBjZWxsIGl0cyBpbmRpdmlkdWFsIHBpcGVsaW5lLiBUaGlzIGFsbG93c1xuICAvLyBkeW5hbWljYWxseSBhZGRlZCBjb2xsZWN0b3JzIHRvIGRvIHRoZSByaWdodCB0aGluZ1xuICAvLyB3aGVuIHdpcmluZyB1cCB0aGUgcGlwZWxpbmVzLlxuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9uZXdfY2VsbC5jYWxsKHRoaXMsIHgsIGspLFxuICAgICAgcGlwZWxpbmUgPSB0aGlzLl9waXBlbGluZS5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbi5jbG9uZSgpOyB9KSxcbiAgICAgIGZhY2V0ID0gdGhpcyxcbiAgICAgIHQgPSBjZWxsLnRwbDtcblxuICBjZWxsLmRzID0gdGhpcy5fZ3JhcGguZGF0YShcInZnX1wiK3QuX2lkLCBwaXBlbGluZSwgdCk7XG4gIGNlbGwuZGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoe30sIFtcImRlbGV0aW5nIGNlbGxcIiwgay5rZXldKTtcbiAgICBmYWNldC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gICAgZmFjZXQuX2dyYXBoLmRpc2Nvbm5lY3QocGlwZWxpbmUpO1xuICB9O1xuXG4gIHRoaXMuYWRkTGlzdGVuZXIocGlwZWxpbmVbMF0pO1xuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fYWRkLmNhbGwodGhpcywgeCk7XG4gIGNlbGwuZHMuX2lucHV0LmFkZC5wdXNoKHgpO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9tb2QgPSBmdW5jdGlvbih4LCByZXNldCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9tb2QuY2FsbCh0aGlzLCB4LCByZXNldCk7XG4gIGlmKCEoY2VsbC5mbGcgJiBDLkFERF9DRUxMKSkgY2VsbC5kcy5faW5wdXQubW9kLnB1c2goeCk7IC8vIFByb3BhZ2F0ZSB0dXBsZXNcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9yZW0uY2FsbCh0aGlzLCB4KTtcbiAgY2VsbC5kcy5faW5wdXQucmVtLnB1c2goeCk7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmYWNldGluZ1wiXSk7XG5cbiAgdGhpcy5fZ2IgPSB0aGlzLmtleXMuZ2V0KHRoaXMuX2dyYXBoKTtcblxuICB2YXIgb3V0cHV0ID0gR3JvdXBCeS5wcm90b3R5cGUudHJhbnNmb3JtLmNhbGwodGhpcywgaW5wdXQsIHJlc2V0KSxcbiAgICAgIGssIGM7XG5cbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoYyA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZihjLmNudCA9PT0gMCkge1xuICAgICAgYy5kZWxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvcGFnYXRlIHNvcnQsIHNpZ25hbHMsIGZpZWxkcywgZXRjLlxuICAgICAgY2hhbmdlc2V0LmNvcHkoaW5wdXQsIGMuZHMuX2lucHV0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNldDsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmlsdGVyKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge3Rlc3Q6IHt0eXBlOiBcImV4cHJcIn0gfSk7XG5cbiAgdGhpcy5fc2tpcCA9IHt9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZpbHRlci5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiB0ZXN0KHgpIHtcbiAgcmV0dXJuIGV4cHIuZXZhbCh0aGlzLl9ncmFwaCwgdGhpcy50ZXN0LmdldCh0aGlzLl9ncmFwaCksIFxuICAgIHgsIG51bGwsIG51bGwsIG51bGwsIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMpKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmaWx0ZXJpbmdcIl0pO1xuICB2YXIgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBza2lwID0gdGhpcy5fc2tpcCxcbiAgICAgIGYgPSB0aGlzO1xuXG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoc2tpcFt4Ll9pZF0gIT09IDEpIG91dHB1dC5yZW0ucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMDtcbiAgfSk7XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmICh0ZXN0LmNhbGwoZiwgeCkpIG91dHB1dC5hZGQucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMTtcbiAgfSk7XG5cbiAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciBiID0gdGVzdC5jYWxsKGYsIHgpLFxuICAgICAgICBzID0gKHNraXBbeC5faWRdID09PSAxKTtcbiAgICBpZiAoYiAmJiBzKSB7XG4gICAgICBza2lwW3guX2lkXSA9IDA7XG4gICAgICBvdXRwdXQuYWRkLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmIChiICYmICFzKSB7XG4gICAgICBvdXRwdXQubW9kLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmICghYiAmJiBzKSB7XG4gICAgICAvLyBkbyBub3RoaW5nLCBrZWVwIHNraXAgdHJ1ZVxuICAgIH0gZWxzZSB7IC8vICFiICYmICFzXG4gICAgICBvdXRwdXQucmVtLnB1c2goeCk7XG4gICAgICBza2lwW3guX2lkXSA9IDE7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksIFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIEZvbGQoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGRzOiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0gXG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtrZXk6IFwia2V5XCIsIHZhbHVlOiBcInZhbHVlXCJ9O1xuICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKS5yZXZpc2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoRm9sZC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiByc3QoaW5wdXQsIG91dHB1dCkgeyBcbiAgZm9yKHZhciBpZCBpbiB0aGlzLl9jYWNoZSkgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW2lkXSk7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuXG5mdW5jdGlvbiBnZXRfdHVwbGUoeCwgaSwgbGVuKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5fY2FjaGVbeC5faWRdIHx8ICh0aGlzLl9jYWNoZVt4Ll9pZF0gPSBBcnJheShsZW4pKTtcbiAgcmV0dXJuIGxpc3RbaV0gfHwgKGxpc3RbaV0gPSB0dXBsZS5kZXJpdmUoeCwgeC5fcHJldikpO1xufTtcblxuZnVuY3Rpb24gZm4oZGF0YSwgZmllbGRzLCBhY2Nlc3NvcnMsIG91dCwgc3RhbXApIHtcbiAgdmFyIGkgPSAwLCBkbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBqLCBmbGVuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgIGQsIHQ7XG5cbiAgZm9yKDsgaTxkbGVuOyArK2kpIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBmb3Ioaj0wOyBqPGZsZW47ICsraikge1xuICAgICAgdCA9IGdldF90dXBsZS5jYWxsKHRoaXMsIGQsIGosIGZsZW4pOyAgXG4gICAgICB0dXBsZS5zZXQodCwgdGhpcy5fb3V0cHV0LmtleSwgZmllbGRzW2pdKTtcbiAgICAgIHR1cGxlLnNldCh0LCB0aGlzLl9vdXRwdXQudmFsdWUsIGFjY2Vzc29yc1tqXShkKSk7XG4gICAgICBvdXQucHVzaCh0KTtcbiAgICB9ICAgICAgXG4gIH1cbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiZm9sZGluZ1wiXSk7XG5cbiAgdmFyIGZvbGQgPSB0aGlzLFxuICAgICAgb24gPSB0aGlzLmZpZWxkcy5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgZmllbGRzID0gb24uZmllbGRzLCBhY2Nlc3NvcnMgPSBvbi5hY2Nlc3NvcnMsXG4gICAgICBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICBpZihyZXNldCkgcnN0LmNhbGwodGhpcywgaW5wdXQsIG91dHB1dCk7XG5cbiAgZm4uY2FsbCh0aGlzLCBpbnB1dC5hZGQsIGZpZWxkcywgYWNjZXNzb3JzLCBvdXRwdXQuYWRkLCBpbnB1dC5zdGFtcCk7XG4gIGZuLmNhbGwodGhpcywgaW5wdXQubW9kLCBmaWVsZHMsIGFjY2Vzc29ycywgcmVzZXQgPyBvdXRwdXQuYWRkIDogb3V0cHV0Lm1vZCwgaW5wdXQuc3RhbXApO1xuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIGZvbGQuX2NhY2hlW3guX2lkXSk7XG4gICAgZm9sZC5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgfSk7XG5cbiAgLy8gSWYgd2UncmUgb25seSBwcm9wYWdhdGluZyB2YWx1ZXMsIGRvbid0IG1hcmsga2V5L3ZhbHVlIGFzIHVwZGF0ZWQuXG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCB8fCBcbiAgICBmaWVsZHMuc29tZShmdW5jdGlvbihmKSB7IHJldHVybiAhIWlucHV0LmZpZWxkc1tmXTsgfSkpXG4gICAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5rZXldID0gMSwgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQudmFsdWVdID0gMTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9sZDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gRm9yY2UoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc2l6ZToge3R5cGU6IFwiYXJyYXk8dmFsdWU+XCIsIGRlZmF1bHQ6IFs1MDAsIDUwMF19LFxuICAgIGxpbmtzOiB7dHlwZTogXCJkYXRhXCJ9LFxuICAgIGxpbmtEaXN0YW5jZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMjB9LFxuICAgIGxpbmtTdHJlbmd0aDoge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMX0sXG4gICAgY2hhcmdlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAzMH0sXG4gICAgY2hhcmdlRGlzdGFuY2U6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IEluZmluaXR5fSxcbiAgICBpdGVyYXRpb25zOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiA1MDB9LFxuICAgIGZyaWN0aW9uOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjl9LFxuICAgIHRoZXRhOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjh9LFxuICAgIGdyYXZpdHk6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMX0sXG4gICAgYWxwaGE6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMX1cbiAgfSk7XG5cbiAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgdGhpcy5fbGlua3MgPSBbXTtcbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LmZvcmNlKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiBcImxheW91dDp4XCIsXG4gICAgXCJ5XCI6IFwibGF5b3V0OnlcIixcbiAgICBcInNvdXJjZVwiOiBcIl9zb3VyY2VcIixcbiAgICBcInRhcmdldFwiOiBcIl90YXJnZXRcIlxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRm9yY2UucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gZ2V0KHRyYW5zZm9ybSwgbmFtZSkge1xuICB2YXIgdiA9IHRyYW5zZm9ybVtuYW1lXS5nZXQodHJhbnNmb3JtLl9ncmFwaCk7XG4gIHJldHVybiB2LmFjY2Vzc29yXG4gICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiB2LmFjY2Vzc29yKHgudHVwbGUpOyB9XG4gICAgOiB2LmZpZWxkO1xufVxuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlSW5wdXQpIHtcbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgbGlua0lucHV0ID0gdGhpcy5saW5rcy5nZXQoZykuc291cmNlLmxhc3QoKSxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICBsaW5rcyA9IHRoaXMuX2xpbmtzLFxuICAgICAgaXRlciA9IHRoaXMuaXRlcmF0aW9ucy5nZXQoZyk7XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBub2Rlc1xuICBub2RlSW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIG5vZGVzLnB1c2goe3R1cGxlOiBufSk7XG4gIH0pO1xuXG4gIC8vIHByb2Nlc3MgYWRkZWQgZWRnZXNcbiAgbGlua0lucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgbGluayA9IHtcbiAgICAgIHR1cGxlOiBsLFxuICAgICAgc291cmNlOiBub2Rlc1tsLnNvdXJjZV0sXG4gICAgICB0YXJnZXQ6IG5vZGVzW2wudGFyZ2V0XVxuICAgIH07XG4gICAgdHVwbGUuc2V0KGwsIG91dHB1dC5zb3VyY2UsIGxpbmsuc291cmNlLnR1cGxlKTtcbiAgICB0dXBsZS5zZXQobCwgb3V0cHV0LnRhcmdldCwgbGluay50YXJnZXQudHVwbGUpO1xuICAgIGxpbmtzLnB1c2gobGluayk7XG4gIH0pO1xuXG4gIC8vIFRPRE8gcHJvY2VzcyBcIm1vZFwiIG9mIGVkZ2Ugc291cmNlIG9yIHRhcmdldD9cblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zaXplKHRoaXMuc2l6ZS5nZXQoZykpXG4gICAgLmxpbmtEaXN0YW5jZShnZXQodGhpcywgXCJsaW5rRGlzdGFuY2VcIikpXG4gICAgLmxpbmtTdHJlbmd0aChnZXQodGhpcywgXCJsaW5rU3RyZW5ndGhcIikpXG4gICAgLmNoYXJnZShnZXQodGhpcywgXCJjaGFyZ2VcIikpXG4gICAgLmNoYXJnZURpc3RhbmNlKGdldCh0aGlzLCBcImNoYXJnZURpc3RhbmNlXCIpKVxuICAgIC5mcmljdGlvbih0aGlzLmZyaWN0aW9uLmdldChnKSlcbiAgICAudGhldGEodGhpcy50aGV0YS5nZXQoZykpXG4gICAgLmdyYXZpdHkodGhpcy5ncmF2aXR5LmdldChnKSlcbiAgICAuYWxwaGEodGhpcy5hbHBoYS5nZXQoZykpXG4gICAgLm5vZGVzKG5vZGVzKVxuICAgIC5saW5rcyhsaW5rcyk7XG5cbiAgLy8gcnVuIGxheW91dFxuICBsYXlvdXQuc3RhcnQoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGl0ZXI7ICsraSkge1xuICAgIGxheW91dC50aWNrKCk7XG4gIH1cbiAgbGF5b3V0LnN0b3AoKTtcblxuICAvLyBjb3B5IGxheW91dCB2YWx1ZXMgdG8gbm9kZXNcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdHVwbGUuc2V0KG4udHVwbGUsIG91dHB1dC54LCBuLngpO1xuICAgIHR1cGxlLnNldChuLnR1cGxlLCBvdXRwdXQueSwgbi55KTtcbiAgfSk7XG5cbiAgLy8gcHJvY2VzcyByZW1vdmVkIG5vZGVzXG4gIGlmIChub2RlSW5wdXQucmVtLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbm9kZUlkcyA9IHR1cGxlLmlkTWFwKG5vZGVJbnB1dC5yZW0pO1xuICAgIHRoaXMuX25vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuICFub2RlSWRzW24udHVwbGUuX2lkXTsgfSk7XG4gIH1cblxuICAvLyBwcm9jZXNzIHJlbW92ZWQgZWRnZXNcbiAgaWYgKGxpbmtJbnB1dC5yZW0ubGVuZ3RoID4gMCkge1xuICAgIHZhciBsaW5rSWRzID0gdHVwbGUuaWRNYXAobGlua0lucHV0LnJlbSk7XG4gICAgdGhpcy5fbGlua3MgPSBsaW5rcy5maWx0ZXIoZnVuY3Rpb24obCkgeyByZXR1cm4gIWxpbmtJZHNbbC50dXBsZS5faWRdOyB9KTtcbiAgfVxuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgbm9kZUlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBub2RlSW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBub2RlSW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgZXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRm9ybXVsYShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgZXhwcjogIHt0eXBlOiBcImV4cHJcIn1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGb3JtdWxhLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmb3JtdWxhdGluZ1wiXSk7XG4gIHZhciB0ID0gdGhpcywgXG4gICAgICBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBmaWVsZCA9IHRoaXMuZmllbGQuZ2V0KGcpLFxuICAgICAgZXhwciA9IHRoaXMuZXhwci5nZXQoZyksXG4gICAgICBkZXBzID0gdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG4gIFxuICBmdW5jdGlvbiBzZXQoeCkge1xuICAgIHZhciB2YWwgPSBleHByZXNzaW9uLmV2YWwoZywgZXhwciwgeCwgbnVsbCwgbnVsbCwgbnVsbCwgZGVwcyk7XG4gICAgdHVwbGUuc2V0KHgsIGZpZWxkLCB2YWwpO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgXG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tmaWVsZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm11bGE7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIEdlbyhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGxvbjoge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgbGF0OiB7dHlwZTogXCJmaWVsZFwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6IFwiZ2VvOnhcIixcbiAgICBcInlcIjogXCJnZW86eVwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgTm9uZVxuXG5HZW8uUGFyYW1ldGVycyA9IHtcbiAgcHJvamVjdGlvbjoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJtZXJjYXRvclwifSxcbiAgY2VudGVyOiAgICAge3R5cGU6IFwiYXJyYXlbdmFsdWVdXCJ9LFxuICB0cmFuc2xhdGU6ICB7dHlwZTogXCJhcnJheVt2YWx1ZV1cIn0sXG4gIHJvdGF0ZTogICAgIHt0eXBlOiBcImFycmF5W3ZhbHVlXVwifSxcbiAgc2NhbGU6ICAgICAge3R5cGU6IFwidmFsdWVcIn0sXG4gIHByZWNpc2lvbjogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICBjbGlwQW5nbGU6ICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgY2xpcEV4dGVudDoge3R5cGU6IFwidmFsdWVcIn1cbn07XG5cbkdlby5kM1Byb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIHAgPSB0aGlzLnByb2plY3Rpb24uZ2V0KGcpLFxuICAgICAgcGFyYW0gPSBHZW8uUGFyYW1ldGVycyxcbiAgICAgIHByb2osIG5hbWUsIHZhbHVlO1xuXG4gIGlmIChwICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgdGhpcy5fbW9kZSA9IHA7XG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IGQzLmdlb1twXSgpO1xuICB9XG4gIHByb2ogPSB0aGlzLl9wcm9qZWN0aW9uO1xuXG4gIGZvciAobmFtZSBpbiBwYXJhbSkge1xuICAgIGlmIChuYW1lID09PSBcInByb2plY3Rpb25cIiB8fCAhcHJvaltuYW1lXSkgY29udGludWU7XG4gICAgdmFsdWUgPSB0aGlzW25hbWVdLmdldChnKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCAoZGwuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gcHJvaltuYW1lXSgpKSB7XG4gICAgICBwcm9qW25hbWVdKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvajtcbn07XG5cbnZhciBwcm90byA9IChHZW8ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGxvbiA9IHRoaXMubG9uLmdldChnKS5hY2Nlc3NvcixcbiAgICAgIGxhdCA9IHRoaXMubGF0LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHByb2ogPSBHZW8uZDNQcm9qZWN0aW9uLmNhbGwodGhpcyk7XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgbGwgPSBbbG9uKHQpLCBsYXQodCldO1xuICAgIHZhciB4eSA9IHByb2oobGwpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQueCwgeHlbMF0pO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQueSwgeHlbMV0pO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgR2VvID0gcmVxdWlyZSgnLi9HZW8nKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gR2VvUGF0aChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHZhbHVlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBudWxsfSxcbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwicGF0aFwiOiBcImdlbzpwYXRoXCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHZW9QYXRoLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBnZW9qc29uID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IgfHwgZGwuaWRlbnRpdHksXG4gICAgICBwcm9qID0gR2VvLmQzUHJvamVjdGlvbi5jYWxsKHRoaXMpLFxuICAgICAgcGF0aCA9IGQzLmdlby5wYXRoKCkucHJvamVjdGlvbihwcm9qKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aChnZW9qc29uKHQpKSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQucGF0aF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb1BhdGg7XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnkoZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIHRoaXMuaW5pdChncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoR3JvdXBCeS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5fZ2IgPSBudWxsOyAvLyBmaWVsZHMrYWNjZXNzb3JzIHRvIGdyb3VwYnkgZmllbGRzXG4gIHRoaXMuX2NlbGxzID0ge307XG4gIHJldHVybiBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpLnJldmlzZXModHJ1ZSk7XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jZWxsczsgfTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB2YXIgaywgYztcbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBpZighKGMgPSB0aGlzLl9jZWxsc1trXSkpIGNvbnRpbnVlO1xuICAgIG91dHB1dC5yZW0ucHVzaChjLnRwbCk7XG4gIH1cbiAgdGhpcy5fY2VsbHMgPSB7fTtcbn07XG5cbnByb3RvLl9rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYWNjID0gdGhpcy5fZ2IuYWNjZXNzb3JzIHx8IFt0aGlzLl9nYi5hY2Nlc3Nvcl07XG4gIHZhciBrZXlzID0gYWNjLnJlZHVjZShmdW5jdGlvbihnLCBmKSB7XG4gICAgcmV0dXJuICgodiA9IGYoeCkpICE9PSB1bmRlZmluZWQpID8gKGcucHVzaCh2KSwgZykgOiBnO1xuICB9LCBbXSksIGsgPSBrZXlzLmpvaW4oXCJ8XCIpLCB2O1xuICByZXR1cm4ga2V5cy5sZW5ndGggPiAwID8ge2tleXM6IGtleXMsIGtleToga30gOiB1bmRlZmluZWQ7XG59O1xuXG5wcm90by5fY2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGsgPSB0aGlzLl9rZXlzKHgpO1xuICByZXR1cm4gdGhpcy5fY2VsbHNbay5rZXldIHx8ICh0aGlzLl9jZWxsc1trLmtleV0gPSB0aGlzLl9uZXdfY2VsbCh4LCBrKSk7XG59O1xuXG5wcm90by5fbmV3X2NlbGwgPSBmdW5jdGlvbih4LCBrKSB7XG4gIHJldHVybiB7XG4gICAgY250OiAwLFxuICAgIHRwbDogdGhpcy5fbmV3X3R1cGxlKHgsIGspLFxuICAgIGZsZzogQy5BRERfQ0VMTFxuICB9O1xufTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgdmFyIGdiID0gdGhpcy5fZ2IsXG4gICAgICBmaWVsZHMgPSBnYi5maWVsZHMgfHwgW2diLmZpZWxkXSxcbiAgICAgIGFjYyA9IGdiLmFjY2Vzc29ycyB8fCBbZ2IuYWNjZXNzb3JdLFxuICAgICAgdCA9IHt9LCBpLCBsZW47XG5cbiAgZm9yKGk9MCwgbGVuPWZpZWxkcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB0W2ZpZWxkc1tpXV0gPSBhY2NbaV0oeCk7XG4gIH0gXG5cbiAgcmV0dXJuIHR1cGxlLmluZ2VzdCh0LCBudWxsKTtcbn07XG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KTtcbiAgY2VsbC5jbnQgKz0gMTtcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCk7XG4gIGNlbGwuY250IC09IDE7XG4gIGNlbGwuZmxnIHw9IEMuTU9EX0NFTEw7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX21vZCA9IGZ1bmN0aW9uKHgsIHJlc2V0KSB7XG4gIGlmKHguX3ByZXYgJiYgeC5fcHJldiAhPT0gQy5TRU5USU5FTCAmJiB0aGlzLl9rZXlzKHguX3ByZXYpICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9yZW0oeC5fcHJldik7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh4KTtcbiAgfSBlbHNlIGlmKHJlc2V0KSB7IC8vIFNpZ25hbCBjaGFuZ2UgdHJpZ2dlcmVkIHJlZmxvd1xuICAgIHJldHVybiB0aGlzLl9hZGQoeCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2NlbGwoeCk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgdmFyIGdyb3VwQnkgPSB0aGlzLFxuICAgICAgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBrLCBjLCBmLCB0O1xuXG4gIGlmKHJlc2V0KSB0aGlzLl9yZXNldChpbnB1dCwgb3V0cHV0KTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7IGdyb3VwQnkuX2FkZCh4KTsgfSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgZ3JvdXBCeS5fbW9kKHgsIHJlc2V0KTsgfSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZih4Ll9wcmV2ICYmIHguX3ByZXYgIT09IEMuU0VOVElORUwgJiYgZ3JvdXBCeS5fa2V5cyh4Ll9wcmV2KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBncm91cEJ5Ll9yZW0oeC5fcHJldik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwQnkuX3JlbSh4KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKCFjKSBjb250aW51ZTtcbiAgICBmID0gYy5mbGc7XG4gICAgdCA9IGMudHBsO1xuXG4gICAgaWYoYy5jbnQgPT09IDApIHtcbiAgICAgIGlmKGYgPT09IEMuTU9EX0NFTEwpIG91dHB1dC5yZW0ucHVzaCh0KTtcbiAgICAgIHRoaXMuX2NlbGxzW2tdID0gbnVsbDtcbiAgICB9IGVsc2UgaWYoZiAmIEMuQUREX0NFTEwpIHtcbiAgICAgIG91dHB1dC5hZGQucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYoZiAmIEMuTU9EX0NFTEwpIHtcbiAgICAgIG91dHB1dC5tb2QucHVzaCh0KTtcbiAgICB9XG4gICAgYy5mbGcgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBCeTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIExpbmtQYXRoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHNvdXJjZTogIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiX3NvdXJjZVwifSxcbiAgICB0YXJnZXQ6ICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcIl90YXJnZXRcIn0sXG4gICAgeDogICAgICAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJsYXlvdXQ6eFwifSxcbiAgICB5OiAgICAgICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImxheW91dDp5XCJ9LFxuICAgIHRlbnNpb246IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMn0sXG4gICAgc2hhcGU6ICAge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJsaW5lXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcInBhdGhcIjogXCJsaW5rOnBhdGhcIn07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoTGlua1BhdGgucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gbGluZShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KTtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkxcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxuZnVuY3Rpb24gY3VydmUoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBkeCA9IHR4IC0gc3gsXG4gICAgICBkeSA9IHR5IC0gc3ksXG4gICAgICBpeCA9IHRlbnNpb24gKiAoZHggKyBkeSksXG4gICAgICBpeSA9IHRlbnNpb24gKiAoZHkgLSBkeCk7XG4gIHJldHVybiBcIk1cIiArIHN4ICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCJDXCIgKyAoc3graXgpICsgXCIsXCIgKyAoc3kraXkpXG4gICAgICAgKyBcIiBcIiArICh0eCtpeSkgKyBcIixcIiArICh0eS1peClcbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFgoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBtID0gKHN4ICsgdHgpIC8gMjtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIG0gICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCIgXCIgKyBtICArIFwiLFwiICsgdHlcbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFkoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBtID0gKHN5ICsgdHkpIC8gMjtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIHN4ICsgXCIsXCIgKyBtXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyBtXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxudmFyIHNoYXBlcyA9IHtcbiAgbGluZTogICAgICBsaW5lLFxuICBjdXJ2ZTogICAgIGN1cnZlLFxuICBkaWFnb25hbDogIGRpYWdvbmFsWCxcbiAgZGlhZ29uYWxYOiBkaWFnb25hbFgsXG4gIGRpYWdvbmFsWTogZGlhZ29uYWxZXG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgc2hhcGUgPSBzaGFwZXNbdGhpcy5zaGFwZS5nZXQoZyldIHx8IHNoYXBlcy5saW5lLFxuICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgeCA9IHRoaXMueC5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB5ID0gdGhpcy55LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHRlbnNpb24gPSB0aGlzLnRlbnNpb24uZ2V0KGcpO1xuICBcbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgcGF0aCA9IHNoYXBlKHQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKVxuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aCk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnBhdGhdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rUGF0aDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIGFycmF5VHlwZSA9IC9hcnJheS9pLFxuICAgIGRhdGFUeXBlICA9IC9kYXRhL2ksXG4gICAgZmllbGRUeXBlID0gL2ZpZWxkL2ksXG4gICAgZXhwclR5cGUgID0gL2V4cHIvaTtcblxuZnVuY3Rpb24gUGFyYW1ldGVyKG5hbWUsIHR5cGUpIHtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuXG4gIC8vIElmIHBhcmFtZXRlciBpcyBkZWZpbmVkIHcvc2lnbmFscywgaXQgbXVzdCBiZSByZXNvbHZlZFxuICAvLyBvbiBldmVyeSBwdWxzZS5cbiAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gIHRoaXMuX3Jlc29sdXRpb24gPSBmYWxzZTtcbiAgdGhpcy5fc2lnbmFscyA9IHt9O1xufVxuXG52YXIgcHJvdG8gPSBQYXJhbWV0ZXIucHJvdG90eXBlO1xuXG5wcm90by5fZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc0FycmF5ID0gYXJyYXlUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICBpZiAoaXNEYXRhKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB7IG5hbWVzOiB0aGlzLl92YWx1ZSwgc291cmNlczogdGhpcy5fYWNjZXNzb3JzIH0gOlxuICAgICAgeyBuYW1lOiB0aGlzLl92YWx1ZVswXSwgc291cmNlOiB0aGlzLl9hY2Nlc3NvcnNbMF0gfTtcbiAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB7IGZpZWxkczogdGhpcy5fdmFsdWUsIGFjY2Vzc29yczogdGhpcy5fYWNjZXNzb3JzIH0gOlxuICAgICAgeyBmaWVsZDogdGhpcy5fdmFsdWVbMF0sIGFjY2Vzc29yOiB0aGlzLl9hY2Nlc3NvcnNbMF0gfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHRoaXMuX3ZhbHVlIDogdGhpcy5fdmFsdWVbMF07XG4gIH1cbn07XG5cbnByb3RvLmdldCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIHMsIGlkeCwgdmFsO1xuXG4gIC8vIElmIHdlIGRvbid0IHJlcXVpcmUgcmVzb2x1dGlvbiwgcmV0dXJuIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgaWYgKCF0aGlzLl9yZXNvbHV0aW9uKSByZXR1cm4gdGhpcy5fZ2V0KCk7XG5cbiAgaWYgKGlzRGF0YSkge1xuICAgIHRoaXMuX2FjY2Vzc29ycyA9IHRoaXMuX3ZhbHVlLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBncmFwaC5kYXRhKHYpOyB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCk7IC8vIFRPRE86IHN1cHBvcnQgc2lnbmFsIGFzIGRhdGFUeXBlc1xuICB9XG5cbiAgZm9yKHMgaW4gdGhpcy5fc2lnbmFscykge1xuICAgIGlkeCAgPSB0aGlzLl9zaWduYWxzW3NdO1xuICAgIHZhbCAgPSBncmFwaC5zaWduYWxSZWYocyk7XG5cbiAgICBpZiAoaXNGaWVsZCkge1xuICAgICAgdGhpcy5fYWNjZXNzb3JzW2lkeF0gPSB0aGlzLl92YWx1ZVtpZHhdICE9IHZhbCA/IFxuICAgICAgICBkbC5hY2Nlc3Nvcih2YWwpIDogdGhpcy5fYWNjZXNzb3JzW2lkeF07XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWVbaWR4XSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9nZXQoKTtcbn07XG5cbnByb3RvLnNldCA9IGZ1bmN0aW9uKHRyYW5zZm9ybSwgdmFsdWUpIHtcbiAgdmFyIHBhcmFtID0gdGhpcywgXG4gICAgICBpc0V4cHIgPSBleHByVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSk7XG5cbiAgdGhpcy5fdmFsdWUgPSBkbC5hcnJheSh2YWx1ZSkubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcodikpIHtcbiAgICAgIGlmIChpc0V4cHIpIHtcbiAgICAgICAgdmFyIGUgPSBleHByKHYpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgIGUuZmllbGRzKTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBlLnNpZ25hbHMpO1xuICAgICAgICByZXR1cm4gZS5mbjtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaWVsZCkgeyAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgcGFyYW0uX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgdik7XG4gICAgICB9IGVsc2UgaWYgKGlzRGF0YSkge1xuICAgICAgICBwYXJhbS5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuREFUQSwgdik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9IGVsc2UgaWYgKHYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHYudmFsdWU7XG4gICAgfSBlbHNlIGlmICh2LmZpZWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtLl9hY2Nlc3NvcnNbaV0gPSBkbC5hY2Nlc3Nvcih2LmZpZWxkKTtcbiAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCB2LmZpZWxkKTtcbiAgICAgIHJldHVybiB2LmZpZWxkO1xuICAgIH0gZWxzZSBpZiAodi5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW0uX3Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgcGFyYW0uX3NpZ25hbHNbdi5zaWduYWxdID0gaTtcbiAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdi5zaWduYWwpO1xuICAgICAgcmV0dXJuIHYuc2lnbmFsO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbWV0ZXI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIFBpZShncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHZhbHVlOiAgICAgIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIHN0YXJ0QW5nbGU6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDB9LFxuICAgIGVuZEFuZ2xlOiAgIHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDIgKiBNYXRoLlBJfSxcbiAgICBzb3J0OiAgICAgICB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBmYWxzZX1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwic3RhcnRcIjogXCJsYXlvdXQ6c3RhcnRcIixcbiAgICBcInN0b3BcIjogIFwibGF5b3V0OnN0b3BcIixcbiAgICBcIm1pZFwiOiAgIFwibGF5b3V0Om1pZFwiXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChQaWUucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBvbmVzKCkgeyByZXR1cm4gMTsgfVxuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWUuZ2V0KGcpLmFjY2Vzc29yIHx8IG9uZXMsXG4gICAgICBzdGFydCA9IHRoaXMuc3RhcnRBbmdsZS5nZXQoZyksXG4gICAgICBzdG9wID0gdGhpcy5lbmRBbmdsZS5nZXQoZyksXG4gICAgICBzb3J0ID0gdGhpcy5zb3J0LmdldChnKTtcblxuICB2YXIgdmFsdWVzID0gZGF0YS5tYXAodmFsdWUpLFxuICAgICAgYSA9IHN0YXJ0LFxuICAgICAgayA9IChzdG9wIC0gc3RhcnQpIC8gZDMuc3VtKHZhbHVlcyksXG4gICAgICBpbmRleCA9IGRsLnJhbmdlKGRhdGEubGVuZ3RoKSxcbiAgICAgIGksIHQsIHY7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZXNbYV0gLSB2YWx1ZXNbYl07XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxpbmRleC5sZW5ndGg7ICsraSkge1xuICAgIHQgPSBkYXRhW2luZGV4W2ldXTtcbiAgICB2ID0gdmFsdWVzW2luZGV4W2ldXTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnN0YXJ0LCBhKTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0Lm1pZCwgKGEgKyAwLjUgKiB2ICogaykpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQuc3RvcCwgKGEgKz0gdiAqIGspKTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdG9wXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQubWlkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGllO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxuZnVuY3Rpb24gU29ydChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9IH0pO1xuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChTb3J0LnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJzb3J0aW5nXCJdKTtcblxuICBpZihpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0Lm1vZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIGlucHV0LnNvcnQgPSBkbC5jb21wYXJhdG9yKHRoaXMuYnkuZ2V0KHRoaXMuX2dyYXBoKS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb3J0OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gU3RhY2soZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0sXG4gICAgc29ydGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0sXG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCJ9LFxuICAgIG9mZnNldDoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJ6ZXJvXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInN0YXJ0XCI6IFwibGF5b3V0OnN0YXJ0XCIsXG4gICAgXCJzdG9wXCI6ICBcImxheW91dDpzdG9wXCIsXG4gICAgXCJtaWRcIjogICBcImxheW91dDptaWRcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFN0YWNrLnByb3RvdHlwZSA9IG5ldyBCYXRjaFRyYW5zZm9ybSgpKTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgZ3JvdXBieSA9IHRoaXMuZ3JvdXBieS5nZXQoZykuYWNjZXNzb3JzLFxuICAgICAgc29ydGJ5ID0gZGwuY29tcGFyYXRvcih0aGlzLnNvcnRieS5nZXQoZykuZmllbGRzKSxcbiAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IsXG4gICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldC5nZXQoZyksXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQ7XG5cbiAgLy8gcGFydGl0aW9uLCBzdW0sIGFuZCBzb3J0IHRoZSBzdGFjayBncm91cHNcbiAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBzb3J0YnksIHZhbHVlKTtcblxuICAvLyBjb21wdXRlIHN0YWNrIGxheW91dHMgcGVyIGdyb3VwXG4gIGZvciAodmFyIGk9MCwgbWF4PWdyb3Vwcy5tYXg7IGk8Z3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldLFxuICAgICAgICBzdW0gPSBncm91cC5zdW0sXG4gICAgICAgIG9mZiA9IG9mZnNldD09PVwiY2VudGVyXCIgPyAobWF4IC0gc3VtKS8yIDogMCxcbiAgICAgICAgc2NhbGUgPSBvZmZzZXQ9PT1cIm5vcm1hbGl6ZVwiID8gKDEvc3VtKSA6IDEsXG4gICAgICAgIGksIHgsIGEsIGIgPSBvZmYsIHYgPSAwO1xuXG4gICAgLy8gc2V0IHN0YWNrIGNvb3JkaW5hdGVzIGZvciBlYWNoIGRhdHVtIGluIGdyb3VwXG4gICAgZm9yIChqPTA7IGo8Z3JvdXAubGVuZ3RoOyArK2opIHtcbiAgICAgIHggPSBncm91cFtqXTtcbiAgICAgIGEgPSBiOyAvLyB1c2UgcHJldmlvdXMgdmFsdWUgZm9yIHN0YXJ0IHBvaW50XG4gICAgICB2ICs9IHZhbHVlKHgpO1xuICAgICAgYiA9IHNjYWxlICogdiArIG9mZjsgLy8gY29tcHV0ZSBlbmQgcG9pbnRcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5zdG9wLCBiKTtcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQubWlkLCAwLjUgKiAoYSArIGIpKTtcbiAgICB9XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0YXJ0XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RvcF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0Lm1pZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydGJ5LCB2YWx1ZSkge1xuICB2YXIgZ3JvdXBzID0gW10sXG4gICAgICBtYXAsIGksIHgsIGssIGcsIHMsIG1heDtcblxuICAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBzdGFjayBncm91cHNcbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEuc2xpY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXA9e30sIGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB4ID0gZGF0YVtpXTtcbiAgICAgIGsgPSAoZ3JvdXBieS5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gZih4KTsgfSkpO1xuICAgICAgZyA9IG1hcFtrXSB8fCAoZ3JvdXBzLnB1c2gobWFwW2tdID0gW10pLCBtYXBba10pO1xuICAgICAgZy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbXB1dGUgc3VtcyBvZiBncm91cHMsIHNvcnQgZ3JvdXBzIGFzIG5lZWRlZFxuICBmb3IgKGs9MCwgbWF4PTA7IGs8Z3JvdXBzLmxlbmd0aDsgKytrKSB7XG4gICAgZyA9IGdyb3Vwc1trXTtcbiAgICBmb3IgKGk9MCwgcz0wOyBpPGcubGVuZ3RoOyArK2kpIHtcbiAgICAgIHMgKz0gdmFsdWUoZ1tpXSk7XG4gICAgfVxuICAgIGcuc3VtID0gcztcbiAgICBpZiAocyA+IG1heCkgbWF4ID0gcztcbiAgICBpZiAoc29ydGJ5ICE9IG51bGwpIGcuc29ydChzb3J0YnkpO1xuICB9XG4gIGdyb3Vwcy5tYXggPSBtYXg7XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjazsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBQYXJhbWV0ZXIgPSByZXF1aXJlKCcuL1BhcmFtZXRlcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5UcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHByb3RvLCBwYXJhbXMpIHtcbiAgdmFyIHA7XG4gIGZvciAodmFyIG5hbWUgaW4gcGFyYW1zKSB7XG4gICAgcCA9IHBhcmFtc1tuYW1lXTtcbiAgICBwcm90b1tuYW1lXSA9IG5ldyBQYXJhbWV0ZXIobmFtZSwgcC50eXBlKTtcbiAgICBpZiAocC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSBwcm90b1tuYW1lXS5zZXQocHJvdG8sIHAuZGVmYXVsdCk7XG4gIH1cbiAgcHJvdG8uX3BhcmFtZXRlcnMgPSBwYXJhbXM7XG59O1xuXG52YXIgcHJvdG8gPSAoVHJhbnNmb3JtLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IE5vZGUucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gIG4udHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gIG4uX3BhcmFtZXRlcnMgPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICBmb3IodmFyIGsgaW4gdGhpcykgeyBcbiAgICBpZihuW2tdKSBjb250aW51ZTtcbiAgICBuW2tdID0gdGhpc1trXTsgXG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHsgcmV0dXJuIGlucHV0OyB9O1xucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYW55IHRyYW5zZm9ybXMgc3RvcmUgY2FjaGVzIHRoYXQgbXVzdCBiZSBpbnZhbGlkYXRlZCBpZlxuICAvLyBhIHNpZ25hbCB2YWx1ZSBoYXMgY2hhbmdlZC4gXG4gIHZhciByZXNldCA9IHRoaXMuX3N0YW1wIDwgaW5wdXQuc3RhbXAgJiYgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUykuc29tZShmdW5jdGlvbihzKSB7IFxuICAgIHJldHVybiAhIWlucHV0LnNpZ25hbHNbc10gXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybShpbnB1dCwgcmVzZXQpO1xufTtcblxucHJvdG8ub3V0cHV0ID0gZnVuY3Rpb24obWFwKSB7XG4gIGZvciAodmFyIGtleSBpbiB0aGlzLl9vdXRwdXQpIHtcbiAgICBpZiAobWFwW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fb3V0cHV0W2tleV0gPSBtYXBba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gVHJlZW1hcChncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIC8vIGhpZXJhcmNoeSBwYXJhbWV0ZXJzXG4gICAgc29ydDoge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCIsIGRlZmF1bHQ6IFtcIi12YWx1ZVwiXX0sXG4gICAgY2hpbGRyZW46IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiY2hpbGRyZW5cIn0sXG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwidmFsdWVcIn0sXG4gICAgLy8gdHJlZW1hcCBwYXJhbWV0ZXJzXG4gICAgc2l6ZToge3R5cGU6IFwiYXJyYXk8dmFsdWU+XCIsIGRlZmF1bHQ6IFs1MDAsIDUwMF19LFxuICAgIHJvdW5kOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiB0cnVlfSxcbiAgICBzdGlja3k6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICByYXRpbzoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC41ICogKDEgKyBNYXRoLnNxcnQoNSkpfSxcbiAgICBwYWRkaW5nOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBudWxsfSxcbiAgICBtb2RlOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcInNxdWFyaWZ5XCJ9XG4gIH0pO1xuXG4gIHRoaXMuX2xheW91dCA9IGQzLmxheW91dC50cmVlbWFwKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiAgICAgIFwibGF5b3V0OnhcIixcbiAgICBcInlcIjogICAgICBcImxheW91dDp5XCIsXG4gICAgXCJ3aWR0aFwiOiAgXCJsYXlvdXQ6d2lkdGhcIixcbiAgICBcImhlaWdodFwiOiBcImxheW91dDpoZWlnaHRcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFRyZWVtYXAucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dDtcblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zb3J0KGRsLmNvbXBhcmF0b3IodGhpcy5zb3J0LmdldChnKS5maWVsZHMpKVxuICAgIC5jaGlsZHJlbih0aGlzLmNoaWxkcmVuLmdldChnKS5hY2Nlc3NvcilcbiAgICAudmFsdWUodGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IpXG4gICAgLnNpemUodGhpcy5zaXplLmdldChnKSlcbiAgICAucm91bmQodGhpcy5yb3VuZC5nZXQoZykpXG4gICAgLnN0aWNreSh0aGlzLnN0aWNreS5nZXQoZykpXG4gICAgLnJhdGlvKHRoaXMucmF0aW8uZ2V0KGcpKVxuICAgIC5wYWRkaW5nKHRoaXMucGFkZGluZy5nZXQoZykpXG4gICAgLm1vZGUodGhpcy5tb2RlLmdldChnKSlcbiAgICAubm9kZXMoZGF0YVswXSk7XG5cbiAgLy8gY29weSBsYXlvdXQgdmFsdWVzIHRvIG5vZGVzXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC54LCBuLngpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQueSwgbi55KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LndpZHRoLCBuLmR4KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LmhlaWdodCwgbi5keSk7XG4gIH0pO1xuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgaW5wdXQuZmllbGRzW291dHB1dC54XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueV0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LndpZHRoXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuaGVpZ2h0XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZW1hcDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxuZnVuY3Rpb24gWmlwKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgYXM6ICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBrZXk6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiZGF0YVwifSxcbiAgICB3aXRoS2V5OiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBudWxsfSxcbiAgICBkZWZhdWx0OiB7dHlwZTogXCJ2YWx1ZVwifVxuICB9KTtcblxuICB0aGlzLl9tYXAgPSB7fTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHRoaXMuX2xhc3RKb2luID0gMDtcblxuICByZXR1cm4gdGhpcy5yZXZpc2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoWmlwLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIG1wKGspIHtcbiAgcmV0dXJuIHRoaXMuX21hcFtrXSB8fCAodGhpcy5fbWFwW2tdID0gW10pO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHcgPSB0aGlzLndpdGguZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIHdkcyA9IHcuc291cmNlLFxuICAgICAgd291dHB1dCA9IHdkcy5sYXN0KCksXG4gICAgICB3ZGF0YSA9IHdkcy52YWx1ZXMoKSxcbiAgICAgIGtleSA9IHRoaXMua2V5LmdldCh0aGlzLl9ncmFwaCksXG4gICAgICB3aXRoS2V5ID0gdGhpcy53aXRoS2V5LmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBhcyA9IHRoaXMuYXMuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGRmbHQgPSB0aGlzLmRlZmF1bHQuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIG1hcCA9IG1wLmJpbmQodGhpcyksXG4gICAgICByZW0gPSB7fTtcblxuICBkZWJ1ZyhpbnB1dCwgW1wiemlwcGluZ1wiLCB3Lm5hbWVdKTtcblxuICBpZih3aXRoS2V5LmZpZWxkKSB7XG4gICAgaWYod291dHB1dCAmJiB3b3V0cHV0LnN0YW1wID4gdGhpcy5fbGFzdEpvaW4pIHtcbiAgICAgIHdvdXRwdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgbSA9IG1hcCh3aXRoS2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgaWYobVswXSkgbVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSBkZmx0IH0pO1xuICAgICAgICBtWzFdID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICB3b3V0cHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgXG4gICAgICAgIHZhciBtID0gbWFwKHdpdGhLZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICBpZihtWzBdKSBtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IHggfSk7XG4gICAgICAgIG1bMV0gPSB4O1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE9ubHkgcHJvY2VzcyB3b3V0cHV0Lm1vZCB0dXBsZXMgaWYgdGhlIGpvaW4ga2V5IGhhcyBjaGFuZ2VkLlxuICAgICAgLy8gT3RoZXIgZmllbGQgdXBkYXRlcyB3aWxsIGF1dG8tcHJvcGFnYXRlIHZpYSBwcm90b3R5cGUuXG4gICAgICBpZih3b3V0cHV0LmZpZWxkc1t3aXRoS2V5LmZpZWxkXSkge1xuICAgICAgICB3b3V0cHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgICBpZigheC5fcHJldiB8fCAocHJldiA9IHdpdGhLZXkuYWNjZXNzb3IoeC5fcHJldikpID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICB2YXIgcHJldm0gPSBtYXAocHJldik7XG4gICAgICAgICAgaWYocHJldm1bMF0pIHByZXZtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IGRmbHQgfSk7XG4gICAgICAgICAgcHJldm1bMV0gPSBudWxsO1xuXG4gICAgICAgICAgdmFyIG0gPSBtYXAod2l0aEtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgICAgaWYobVswXSkgbVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSB4IH0pO1xuICAgICAgICAgIG1bMV0gPSB4O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFzdEpvaW4gPSB3b3V0cHV0LnN0YW1wO1xuICAgIH1cbiAgXG4gICAgaW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIG0gPSBtYXAoa2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgIHhbYXNdID0gbVsxXSB8fCBkZmx0O1xuICAgICAgKG1bMF09bVswXXx8W10pLnB1c2goeCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7IFxuICAgICAgdmFyIGsgPSBrZXkuYWNjZXNzb3IoeCk7XG4gICAgICAocmVtW2tdPXJlbVtrXXx8e30pW3guX2lkXSA9IDE7XG4gICAgfSk7XG5cbiAgICBpZihpbnB1dC5maWVsZHNba2V5LmZpZWxkXSkge1xuICAgICAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgaWYoIXguX3ByZXYgfHwgKHByZXYgPSBrZXkuYWNjZXNzb3IoeC5fcHJldikpID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICB2YXIgbSA9IG1hcChrZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICB4W2FzXSA9IG1bMV0gfHwgZGZsdDtcbiAgICAgICAgKG1bMF09bVswXXx8W10pLnB1c2goeCk7XG4gICAgICAgIChyZW1bcHJldl09cmVtW3ByZXZdfHx7fSlbeC5faWRdID0gMTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRsLmtleXMocmVtKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHsgXG4gICAgICB2YXIgbSA9IG1hcChrKTtcbiAgICAgIGlmKCFtWzBdKSByZXR1cm47XG4gICAgICBtWzBdID0gbVswXS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gcmVtW2tdW3guX2lkXSAhPT0gMSB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcnVuIGEgbm9uLWtleS1qb2luIGFnYWluIGlmIHdlJ3ZlIGdvdCBhbnkgYWRkL3JlbVxuICAgIC8vIG9uIGlucHV0IG9yIHdvdXRwdXRcbiAgICBpZihpbnB1dC5hZGQubGVuZ3RoID09IDAgJiYgaW5wdXQucmVtLmxlbmd0aCA9PSAwICYmIFxuICAgICAgICB3b3V0cHV0LmFkZC5sZW5ndGggPT0gMCAmJiB3b3V0cHV0LnJlbS5sZW5ndGggPT0gMCkgcmV0dXJuIGlucHV0O1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGtleS1qb2luLCB0aGVuIHdlIG5lZWQgdG8gbWF0ZXJpYWxpemUgYm90aFxuICAgIC8vIGRhdGEgc291cmNlcyB0byBpdGVyYXRlIHRocm91Z2ggdGhlbS4gXG4gICAgdGhpcy5fY29sbGVjdG9yLmV2YWx1YXRlKGlucHV0KTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSwgXG4gICAgICAgIHdsZW4gPSB3ZGF0YS5sZW5ndGgsIGk7XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7IGRhdGFbaV1bYXNdID0gd2RhdGFbaSV3bGVuXTsgfVxuICB9XG5cbiAgaW5wdXQuZmllbGRzW2FzXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBhZ2dyZWdhdGU6ICByZXF1aXJlKCcuL0FnZ3JlZ2F0ZScpLFxuICBiaW46ICAgICAgICByZXF1aXJlKCcuL0JpbicpLFxuICBjcm9zczogICAgICByZXF1aXJlKCcuL0Nyb3NzJyksXG4gIGxpbmtwYXRoOiAgIHJlcXVpcmUoJy4vTGlua1BhdGgnKSxcbiAgZmFjZXQ6ICAgICAgcmVxdWlyZSgnLi9GYWNldCcpLFxuICBmaWx0ZXI6ICAgICByZXF1aXJlKCcuL0ZpbHRlcicpLFxuICBmb2xkOiAgICAgICByZXF1aXJlKCcuL0ZvbGQnKSxcbiAgZm9yY2U6ICAgICAgcmVxdWlyZSgnLi9Gb3JjZScpLFxuICBmb3JtdWxhOiAgICByZXF1aXJlKCcuL0Zvcm11bGEnKSxcbiAgZ2VvOiAgICAgICAgcmVxdWlyZSgnLi9HZW8nKSxcbiAgZ2VvcGF0aDogICAgcmVxdWlyZSgnLi9HZW9QYXRoJyksXG4gIHBpZTogICAgICAgIHJlcXVpcmUoJy4vUGllJyksXG4gIHNvcnQ6ICAgICAgIHJlcXVpcmUoJy4vU29ydCcpLFxuICBzdGFjazogICAgICByZXF1aXJlKCcuL1N0YWNrJyksXG4gIHRyZWVtYXA6ICAgIHJlcXVpcmUoJy4vVHJlZW1hcCcpLFxuICB6aXA6ICAgICAgICByZXF1aXJlKCcuL1ppcCcpXG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uL2NvcmUvQm91bmRzJyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2NhbnZhcy9wYXRoJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcblxudmFyIHBhcnNlID0gY2FudmFzLnBhcnNlLFxuICAgIGJvdW5kUGF0aCA9IGNhbnZhcy5ib3VuZHMsXG4gICAgYXJlYVBhdGggPSBjYW52YXMuYXJlYSxcbiAgICBsaW5lUGF0aCA9IGNhbnZhcy5saW5lLFxuICAgIGhhbGZwaSA9IE1hdGguUEkgLyAyLFxuICAgIHNxcnQzID0gTWF0aC5zcXJ0KDMpLFxuICAgIHRhbjMwID0gTWF0aC50YW4oMzAgKiBNYXRoLlBJIC8gMTgwKSxcbiAgICBnZnggPSBudWxsO1xuXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgcmV0dXJuIChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250IHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG59XG5cbmZ1bmN0aW9uIGNvbnRleHQoKSB7XG4gIC8vIFRPRE86IGhvdyB0byBjaGVjayBpZiBub2RlSlMgaW4gcmVxdWlyZUpTP1xuICByZXR1cm4gZ2Z4IHx8IChnZnggPSAoLypjb25maWcuaXNOb2RlXG4gICAgPyBuZXcgKHJlcXVpcmUoXCJjYW52YXNcIikpKDEsMSlcbiAgICA6ICovZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJjYW52YXNcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInZlZ2FfaGlkZGVuXCIpXG4gICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMSlcbiAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgMSlcbiAgICAgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICAgICAgLm5vZGUoKSlcbiAgICAuZ2V0Q29udGV4dChcIjJkXCIpKTtcbn1cblxuZnVuY3Rpb24gcGF0aEJvdW5kcyhvLCBwYXRoLCBib3VuZHMpIHtcbiAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgYm91bmRQYXRoKHBhdGgsIGJvdW5kcyk7XG4gICAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gcGF0aChvLCBib3VuZHMpIHtcbiAgdmFyIHAgPSBvLnBhdGhcbiAgICA/IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKG8ucGF0aCkpXG4gICAgOiBudWxsO1xuICByZXR1cm4gcGF0aEJvdW5kcyhvLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBhcmVhKG8sIGJvdW5kcykge1xuICB2YXIgaXRlbXMgPSBvLm1hcmsuaXRlbXMsIG8gPSBpdGVtc1swXTtcbiAgdmFyIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShhcmVhUGF0aChpdGVtcykpKTtcbiAgcmV0dXJuIHBhdGhCb3VuZHMoaXRlbXNbMF0sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIGxpbmUobywgYm91bmRzKSB7XG4gIHZhciBpdGVtcyA9IG8ubWFyay5pdGVtcywgbyA9IGl0ZW1zWzBdO1xuICB2YXIgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGxpbmVQYXRoKGl0ZW1zKSkpO1xuICByZXR1cm4gcGF0aEJvdW5kcyhpdGVtc1swXSwgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gcmVjdChvLCBib3VuZHMpIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIHcgPSAoeCArIG8ud2lkdGgpIHx8IDAsXG4gICAgICBoID0gKHkgKyBvLmhlaWdodCkgfHwgMDtcbiAgYm91bmRzLnNldCh4LCB5LCB3LCBoKTtcbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gaW1hZ2UobywgYm91bmRzKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IDAsXG4gICAgICB4ID0gKG8ueHx8MCkgLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSksXG4gICAgICB5ID0gKG8ueXx8MCkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpO1xuICByZXR1cm4gYm91bmRzLnNldCh4LCB5LCB4K3csIHkraCk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobywgYm91bmRzKSB7XG4gIHZhciB4MSwgeTE7XG4gIGJvdW5kcy5zZXQoXG4gICAgeDEgPSBvLnggfHwgMCxcbiAgICB5MSA9IG8ueSB8fCAwLFxuICAgIG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSxcbiAgICBvLnkyICE9IG51bGwgPyBvLnkyIDogeTFcbiAgKTtcbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gYXJjKG8sIGJvdW5kcykge1xuICB2YXIgY3ggPSBvLnggfHwgMCxcbiAgICAgIGN5ID0gby55IHx8IDAsXG4gICAgICBpciA9IG8uaW5uZXJSYWRpdXMgfHwgMCxcbiAgICAgIG9yID0gby5vdXRlclJhZGl1cyB8fCAwLFxuICAgICAgc2EgPSAoby5zdGFydEFuZ2xlIHx8IDApIC0gaGFsZnBpLFxuICAgICAgZWEgPSAoby5lbmRBbmdsZSB8fCAwKSAtIGhhbGZwaSxcbiAgICAgIHhtaW4gPSBJbmZpbml0eSwgeG1heCA9IC1JbmZpbml0eSxcbiAgICAgIHltaW4gPSBJbmZpbml0eSwgeW1heCA9IC1JbmZpbml0eSxcbiAgICAgIGEsIGksIG4sIHgsIHksIGl4LCBpeSwgb3gsIG95O1xuXG4gIHZhciBhbmdsZXMgPSBbc2EsIGVhXSxcbiAgICAgIHMgPSBzYSAtIChzYSVoYWxmcGkpO1xuICBmb3IgKGk9MDsgaTw0ICYmIHM8ZWE7ICsraSwgcys9aGFsZnBpKSB7XG4gICAgYW5nbGVzLnB1c2gocyk7XG4gIH1cblxuICBmb3IgKGk9MCwgbj1hbmdsZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGEgPSBhbmdsZXNbaV07XG4gICAgeCA9IE1hdGguY29zKGEpOyBpeCA9IGlyKng7IG94ID0gb3IqeDtcbiAgICB5ID0gTWF0aC5zaW4oYSk7IGl5ID0gaXIqeTsgb3kgPSBvcip5O1xuICAgIHhtaW4gPSBNYXRoLm1pbih4bWluLCBpeCwgb3gpO1xuICAgIHhtYXggPSBNYXRoLm1heCh4bWF4LCBpeCwgb3gpO1xuICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBpeSwgb3kpO1xuICAgIHltYXggPSBNYXRoLm1heCh5bWF4LCBpeSwgb3kpO1xuICB9XG5cbiAgYm91bmRzLnNldChjeCt4bWluLCBjeSt5bWluLCBjeCt4bWF4LCBjeSt5bWF4KTtcbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gc3ltYm9sKG8sIGJvdW5kcykge1xuICB2YXIgc2l6ZSA9IG8uc2l6ZSAhPSBudWxsID8gby5zaXplIDogMTAwLFxuICAgICAgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgciwgdCwgcngsIHJ5O1xuXG4gIHN3aXRjaCAoby5zaGFwZSkge1xuICAgIGNhc2UgXCJjcm9zc1wiOlxuICAgICAgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgdCA9IDMqcjtcbiAgICAgIGJvdW5kcy5zZXQoeC10LCB5LXIsIHgrdCwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIHRhbjMwKSk7XG4gICAgICByeCA9IHJ5ICogdGFuMzA7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICB0ID0gTWF0aC5zcXJ0KHNpemUpO1xuICAgICAgciA9IHQgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXIsIHktciwgeCtyLCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGUtZG93blwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGUtdXBcIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZS9NYXRoLlBJKTtcbiAgICAgIGJvdW5kcy5zZXQoeC1yLCB5LXIsIHgrciwgeStyKTtcbiAgfVxuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiB0ZXh0KG8sIGJvdW5kcywgbm9Sb3RhdGUpIHtcbiAgdmFyIHggPSAoby54IHx8IDApICsgKG8uZHggfHwgMCksXG4gICAgICB5ID0gKG8ueSB8fCAwKSArIChvLmR5IHx8IDApLFxuICAgICAgaCA9IG8uZm9udFNpemUgfHwgY29uZmlnLnJlbmRlci5mb250U2l6ZSxcbiAgICAgIGEgPSBvLmFsaWduLFxuICAgICAgYiA9IG8uYmFzZWxpbmUsXG4gICAgICByID0gby5yYWRpdXMgfHwgMCxcbiAgICAgIGcgPSBjb250ZXh0KCksIHcsIHQ7XG5cbiAgZy5mb250ID0gZm9udFN0cmluZyhvKTtcbiAgZy50ZXh0QWxpZ24gPSBhIHx8IFwibGVmdFwiO1xuICBnLnRleHRCYXNlbGluZSA9IGIgfHwgXCJhbHBoYWJldGljXCI7XG4gIHcgPSBnLm1lYXN1cmVUZXh0KG8udGV4dCB8fCBcIlwiKS53aWR0aDtcblxuICBpZiAocikge1xuICAgIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIC8vIGhvcml6b250YWxcbiAgaWYgKGEgPT09IFwiY2VudGVyXCIpIHtcbiAgICB4ID0geCAtICh3IC8gMik7XG4gIH0gZWxzZSBpZiAoYSA9PT0gXCJyaWdodFwiKSB7XG4gICAgeCA9IHggLSB3O1xuICB9IGVsc2Uge1xuICAgIC8vIGxlZnQgYnkgZGVmYXVsdCwgZG8gbm90aGluZ1xuICB9XG5cbiAgLy8vIFRPRE8gZmluZCBhIHJvYnVzdCBzb2x1dGlvbiBmb3IgaGVpZ2h0cy5cbiAgLy8vIFRoZXNlIG9mZnNldHMgd29yayBmb3Igc29tZSBidXQgbm90IGFsbCBmb250cy5cblxuICAvLyB2ZXJ0aWNhbFxuICBpZiAoYiA9PT0gXCJ0b3BcIikge1xuICAgIHkgPSB5ICsgKGgvNSk7XG4gIH0gZWxzZSBpZiAoYiA9PT0gXCJib3R0b21cIikge1xuICAgIHkgPSB5IC0gaDtcbiAgfSBlbHNlIGlmIChiID09PSBcIm1pZGRsZVwiKSB7XG4gICAgeSA9IHkgLSAoaC8yKSArIChoLzEwKTtcbiAgfSBlbHNlIHtcbiAgICB5ID0geSAtIDQqaC81OyAvLyBhbHBoYWJldGljIGJ5IGRlZmF1bHRcbiAgfVxuICBcbiAgYm91bmRzLnNldCh4LCB5LCB4K3csIHkraCk7XG4gIGlmIChvLmFuZ2xlICYmICFub1JvdGF0ZSkge1xuICAgIGJvdW5kcy5yb3RhdGUoby5hbmdsZSpNYXRoLlBJLzE4MCwgby54fHwwLCBvLnl8fDApO1xuICB9XG4gIHJldHVybiBib3VuZHMuZXhwYW5kKG5vUm90YXRlID8gMCA6IDEpO1xufVxuXG5mdW5jdGlvbiBncm91cChnLCBib3VuZHMsIGluY2x1ZGVMZWdlbmRzKSB7XG4gIHZhciBheGVzID0gZy5heGlzSXRlbXMgfHwgW10sXG4gICAgICBsZWdlbmRzID0gZy5sZWdlbmRJdGVtcyB8fCBbXSwgaiwgbTtcblxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBib3VuZHMudW5pb24oYXhlc1tqXS5ib3VuZHMpO1xuICB9XG4gIGZvciAoaj0wLCBtPWcuaXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGJvdW5kcy51bmlvbihnLml0ZW1zW2pdLmJvdW5kcyk7XG4gIH1cbiAgaWYgKGluY2x1ZGVMZWdlbmRzKSB7XG4gICAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBib3VuZHMudW5pb24obGVnZW5kc1tqXS5ib3VuZHMpO1xuICAgIH1cbiAgICBpZiAoZy53aWR0aCAhPSBudWxsICYmIGcuaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIGJvdW5kcy5hZGQoZy53aWR0aCwgZy5oZWlnaHQpO1xuICAgIH1cbiAgICBpZiAoZy54ICE9IG51bGwgJiYgZy55ICE9IG51bGwpIHtcbiAgICAgIGJvdW5kcy5hZGQoMCwgMCk7XG4gICAgfVxuICB9XG4gIGJvdW5kcy50cmFuc2xhdGUoZy54fHwwLCBnLnl8fDApO1xuICByZXR1cm4gYm91bmRzO1xufVxuXG52YXIgbWV0aG9kcyA9IHtcbiAgZ3JvdXA6ICBncm91cCxcbiAgc3ltYm9sOiBzeW1ib2wsXG4gIGltYWdlOiAgaW1hZ2UsXG4gIHJlY3Q6ICAgcmVjdCxcbiAgcnVsZTogICBydWxlLFxuICBhcmM6ICAgIGFyYyxcbiAgdGV4dDogICB0ZXh0LFxuICBwYXRoOiAgIHBhdGgsXG4gIGFyZWE6ICAgYXJlYSxcbiAgbGluZTogICBsaW5lXG59O1xuXG5mdW5jdGlvbiBpdGVtQm91bmRzKGl0ZW0sIGZ1bmMsIG9wdCkge1xuICBmdW5jID0gZnVuYyB8fCBtZXRob2RzW2l0ZW0ubWFyay5tYXJrdHlwZV07XG4gIGlmICghaXRlbS5ib3VuZHNfcHJldikgaXRlbVsnYm91bmRzOnByZXYnXSA9IG5ldyBCb3VuZHMoKTtcbiAgdmFyIGIgPSBpdGVtLmJvdW5kcywgcGIgPSBpdGVtWydib3VuZHM6cHJldiddO1xuICBpZiAoYikgcGIuY2xlYXIoKS51bmlvbihiKTtcbiAgaXRlbS5ib3VuZHMgPSBmdW5jKGl0ZW0sIGIgPyBiLmNsZWFyKCkgOiBuZXcgQm91bmRzKCksIG9wdCk7XG4gIGlmICghYikgcGIuY2xlYXIoKS51bmlvbihpdGVtLmJvdW5kcyk7XG4gIHJldHVybiBpdGVtLmJvdW5kcztcbn1cblxuZnVuY3Rpb24gbWFya0JvdW5kcyhtYXJrLCBib3VuZHMsIG9wdCkge1xuICBib3VuZHMgPSBib3VuZHMgfHwgbWFyay5ib3VuZHMgJiYgbWFyay5ib3VuZHMuY2xlYXIoKSB8fCBuZXcgQm91bmRzKCk7XG4gIHZhciB0eXBlICA9IG1hcmsubWFya3R5cGUsXG4gICAgICBmdW5jICA9IG1ldGhvZHNbdHlwZV0sXG4gICAgICBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICBpdGVtLCBpLCBsZW47XG4gICAgICBcbiAgaWYgKHR5cGU9PT1cImFyZWFcIiB8fCB0eXBlPT09XCJsaW5lXCIpIHtcbiAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICBpdGVtc1swXS5ib3VuZHMgPSBmdW5jKGl0ZW1zWzBdLCBib3VuZHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgYm91bmRzLnVuaW9uKGl0ZW1Cb3VuZHMoaXRlbXNbaV0sIGZ1bmMsIG9wdCkpO1xuICAgIH1cbiAgfVxuICBtYXJrLmJvdW5kcyA9IGJvdW5kcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1hcms6ICBtYXJrQm91bmRzLFxuICBpdGVtOiAgaXRlbUJvdW5kcyxcbiAgdGV4dDogIHRleHQsXG4gIGdyb3VwOiBncm91cFxufTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBjb25maWcgPSB7fTtcblxuY29uZmlnLmRlYnVnID0gZmFsc2U7XG5cbmNvbmZpZy5sb2FkID0ge1xuICAvLyBiYXNlIHVybCBmb3IgbG9hZGluZyBleHRlcm5hbCBkYXRhIGZpbGVzXG4gIC8vIHVzZWQgb25seSBmb3Igc2VydmVyLXNpZGUgb3BlcmF0aW9uXG4gIGJhc2VVUkw6IFwiXCIsXG4gIC8vIEFsbG93cyBkb21haW4gcmVzdHJpY3Rpb24gd2hlbiB1c2luZyBkYXRhIGxvYWRpbmcgdmlhIFhIUi5cbiAgLy8gVG8gZW5hYmxlLCBzZXQgaXQgdG8gYSBsaXN0IG9mIGFsbG93ZWQgZG9tYWluc1xuICAvLyBlLmcuLCBbJ3dpa2lwZWRpYS5vcmcnLCAnZWZmLm9yZyddXG4gIGRvbWFpbldoaXRlTGlzdDogZmFsc2Vcbn07XG5cbi8vIHZlcnNpb24gYW5kIG5hbWVwc2FjZXMgZm9yIGV4cG9ydGVkIHN2Z1xuY29uZmlnLnN2Z05hbWVzcGFjZSA9XG4gICd2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiICcgK1xuICAneG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCInO1xuXG4vLyBpbnNldCBwYWRkaW5nIGZvciBhdXRvbWF0aWMgcGFkZGluZyBjYWxjdWxhdGlvblxuY29uZmlnLmF1dG9wYWRJbnNldCA9IDU7XG5cbi8vIGV4dGVuc2libGUgc2NhbGUgbG9va3VwIHRhYmxlXG4vLyBhbGwgZDMuc2NhbGUuKiBpbnN0YW5jZXMgYWxzbyBzdXBwb3J0ZWRcbmNvbmZpZy5zY2FsZSA9IHtcbiAgdGltZTogZDMudGltZS5zY2FsZSxcbiAgdXRjOiAgZDMudGltZS5zY2FsZS51dGNcbn07XG5cbi8vIGRlZmF1bHQgcmVuZGVyaW5nIHNldHRpbmdzXG5jb25maWcucmVuZGVyID0ge1xuICBsaW5lV2lkdGg6IDEsXG4gIGxpbmVDYXA6ICAgXCJidXR0XCIsXG4gIGZvbnQ6ICAgICAgXCJzYW5zLXNlcmlmXCIsXG4gIGZvbnRTaXplOiAgMTFcbn07XG5cbi8vIGRlZmF1bHQgYXhpcyBwcm9wZXJ0aWVzXG5jb25maWcuYXhpcyA9IHtcbiAgb3JpZW50OiBcImJvdHRvbVwiLFxuICB0aWNrczogMTAsXG4gIHBhZGRpbmc6IDMsXG4gIGF4aXNDb2xvcjogXCIjMDAwXCIsXG4gIGdyaWRDb2xvcjogXCIjZDhkOGQ4XCIsXG4gIHRpY2tDb2xvcjogXCIjMDAwXCIsXG4gIHRpY2tMYWJlbENvbG9yOiBcIiMwMDBcIixcbiAgYXhpc1dpZHRoOiAxLFxuICB0aWNrV2lkdGg6IDEsXG4gIHRpY2tTaXplOiA2LFxuICB0aWNrTGFiZWxGb250U2l6ZTogMTEsXG4gIHRpY2tMYWJlbEZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICB0aXRsZUNvbG9yOiBcIiMwMDBcIixcbiAgdGl0bGVGb250OiBcInNhbnMtc2VyaWZcIixcbiAgdGl0bGVGb250U2l6ZTogMTEsXG4gIHRpdGxlRm9udFdlaWdodDogXCJib2xkXCIsXG4gIHRpdGxlT2Zmc2V0OiAzNVxufTtcblxuLy8gZGVmYXVsdCBsZWdlbmQgcHJvcGVydGllc1xuY29uZmlnLmxlZ2VuZCA9IHtcbiAgb3JpZW50OiBcInJpZ2h0XCIsXG4gIG9mZnNldDogMTAsXG4gIHBhZGRpbmc6IDMsXG4gIGdyYWRpZW50U3Ryb2tlQ29sb3I6IFwiIzg4OFwiLFxuICBncmFkaWVudFN0cm9rZVdpZHRoOiAxLFxuICBncmFkaWVudEhlaWdodDogMTYsXG4gIGdyYWRpZW50V2lkdGg6IDEwMCxcbiAgbGFiZWxDb2xvcjogXCIjMDAwXCIsXG4gIGxhYmVsRm9udFNpemU6IDEwLFxuICBsYWJlbEZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICBsYWJlbEFsaWduOiBcImxlZnRcIixcbiAgbGFiZWxCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgbGFiZWxPZmZzZXQ6IDgsXG4gIHN5bWJvbFNoYXBlOiBcImNpcmNsZVwiLFxuICBzeW1ib2xTaXplOiA1MCxcbiAgc3ltYm9sQ29sb3I6IFwiIzg4OFwiLFxuICBzeW1ib2xTdHJva2VXaWR0aDogMSxcbiAgdGl0bGVDb2xvcjogXCIjMDAwXCIsXG4gIHRpdGxlRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIHRpdGxlRm9udFNpemU6IDExLFxuICB0aXRsZUZvbnRXZWlnaHQ6IFwiYm9sZFwiXG59O1xuXG4vLyBkZWZhdWx0IGNvbG9yIHZhbHVlc1xuY29uZmlnLmNvbG9yID0ge1xuICByZ2I6IFsxMjgsIDEyOCwgMTI4XSxcbiAgbGFiOiBbNTAsIDAsIDBdLFxuICBoY2w6IFswLCAwLCA1MF0sXG4gIGhzbDogWzAsIDAsIDAuNV1cbn07XG5cbi8vIGRlZmF1bHQgc2NhbGUgcmFuZ2VzXG5jb25maWcucmFuZ2UgPSB7XG4gIGNhdGVnb3J5MTA6IFtcbiAgICBcIiMxZjc3YjRcIixcbiAgICBcIiNmZjdmMGVcIixcbiAgICBcIiMyY2EwMmNcIixcbiAgICBcIiNkNjI3MjhcIixcbiAgICBcIiM5NDY3YmRcIixcbiAgICBcIiM4YzU2NGJcIixcbiAgICBcIiNlMzc3YzJcIixcbiAgICBcIiM3ZjdmN2ZcIixcbiAgICBcIiNiY2JkMjJcIixcbiAgICBcIiMxN2JlY2ZcIlxuICBdLFxuICBjYXRlZ29yeTIwOiBbXG4gICAgXCIjMWY3N2I0XCIsXG4gICAgXCIjYWVjN2U4XCIsXG4gICAgXCIjZmY3ZjBlXCIsXG4gICAgXCIjZmZiYjc4XCIsXG4gICAgXCIjMmNhMDJjXCIsXG4gICAgXCIjOThkZjhhXCIsXG4gICAgXCIjZDYyNzI4XCIsXG4gICAgXCIjZmY5ODk2XCIsXG4gICAgXCIjOTQ2N2JkXCIsXG4gICAgXCIjYzViMGQ1XCIsXG4gICAgXCIjOGM1NjRiXCIsXG4gICAgXCIjYzQ5Yzk0XCIsXG4gICAgXCIjZTM3N2MyXCIsXG4gICAgXCIjZjdiNmQyXCIsXG4gICAgXCIjN2Y3ZjdmXCIsXG4gICAgXCIjYzdjN2M3XCIsXG4gICAgXCIjYmNiZDIyXCIsXG4gICAgXCIjZGJkYjhkXCIsXG4gICAgXCIjMTdiZWNmXCIsXG4gICAgXCIjOWVkYWU1XCJcbiAgXSxcbiAgc2hhcGVzOiBbXG4gICAgXCJjaXJjbGVcIixcbiAgICBcImNyb3NzXCIsXG4gICAgXCJkaWFtb25kXCIsXG4gICAgXCJzcXVhcmVcIixcbiAgICBcInRyaWFuZ2xlLWRvd25cIixcbiAgICBcInRyaWFuZ2xlLXVwXCJcbiAgXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWc7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFERF9DRUxMOiAxLFxuICBNT0RfQ0VMTDogMixcblxuICBEQVRBOiBcImRhdGFcIixcbiAgRklFTERTOiAgXCJmaWVsZHNcIixcbiAgU0NBTEVTOiAgXCJzY2FsZXNcIixcbiAgU0lHTkFMOiAgXCJzaWduYWxcIixcbiAgU0lHTkFMUzogXCJzaWduYWxzXCIsXG5cbiAgR1JPVVA6IFwiZ3JvdXBcIixcblxuICBFTlRFUjogXCJlbnRlclwiLFxuICBVUERBVEU6IFwidXBkYXRlXCIsXG4gIEVYSVQ6IFwiZXhpdFwiLFxuXG4gIFNFTlRJTkVMOiB7XCJzZW50aW5lbFwiOiAxfSxcbiAgU0lOR0xFVE9OOiBcIl9zaW5nbGV0b25cIixcblxuICBBREQ6IFwiYWRkXCIsXG4gIFJFTU9WRTogXCJyZW1vdmVcIixcbiAgVE9HR0xFOiBcInRvZ2dsZVwiLFxuICBDTEVBUjogXCJjbGVhclwiLFxuXG4gIExJTkVBUjogXCJsaW5lYXJcIixcbiAgT1JESU5BTDogXCJvcmRpbmFsXCIsXG4gIExPRzogXCJsb2dcIixcbiAgUE9XRVI6IFwicG93XCIsXG4gIFRJTUU6IFwidGltZVwiLFxuICBRVUFOVElMRTogXCJxdWFudGlsZVwiLFxuXG4gIERPTUFJTjogXCJkb21haW5cIixcbiAgUkFOR0U6IFwicmFuZ2VcIixcblxuICBNQVJLOiBcIm1hcmtcIixcbiAgQVhJUzogXCJheGlzXCIsXG5cbiAgQ09VTlQ6IFwiY291bnRcIixcbiAgTUlOOiBcIm1pblwiLFxuICBNQVg6IFwibWF4XCIsXG5cbiAgQVNDOiBcImFzY1wiLFxuICBERVNDOiBcImRlc2NcIlxufTsiLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciB0cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbnB1dCwgYXJncykge1xuICBpZiAoIWNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuICB2YXIgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gIGFyZ3MudW5zaGlmdChpbnB1dC5zdGFtcHx8LTEpO1xuICBhcmdzLnVuc2hpZnQoRGF0ZS5ub3coKSAtIHRzKTtcbiAgaWYoaW5wdXQuYWRkKSBhcmdzLnB1c2goaW5wdXQuYWRkLmxlbmd0aCwgaW5wdXQubW9kLmxlbmd0aCwgaW5wdXQucmVtLmxlbmd0aCwgISFpbnB1dC5yZWZsb3cpO1xuICBsb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIHRzID0gRGF0ZS5ub3coKTtcbn07Il19\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        f.get || util.$(f.name), // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this;\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nproto.accessors = function(fields) {\n  var aggr = this._aggr, i, n, f;\n  for (i=0, n=aggr.length; i<n; ++i) {\n    if ((f = fields[aggr[i].name])) {\n      aggr[i].measures.prototype.get = util.$(f);\n    }\n  }\n  return this;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._keys = function(x) {\n  var d = this._dims,\n      n = d.length,\n      k = Array(n), i;\n  for (i=0; i<n; ++i) { k[i] = d[i].get(x); }\n  return {key: util.keystr(k), keys: k};\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._newcell(x, k));\n};\n\nproto._newcell = function(x, k) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x, k),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector();\n  }\n\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for(i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto.add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (cell.collect) cell.data.add(x);\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name].add(x);\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto.rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (cell.collect) cell.data.rem(x);\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name].rem(x);\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var results = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      results.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  return results;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  for (var i=0; i<input.length; ++i) {\n    this.add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this.rem(input[i]);\n  }\n  return this;\n};\n\nmodule.exports = Aggregator;","var stats = require('../stats');\n\nvar REM = '$!_rem_!#';\n\nfunction Collector() {\n  this._add = [];\n  this._rem = [];\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return this._add;\n  var a = this._add,\n      r = this._rem,\n      x = Array(a.length - r.length),\n      i, j, n;\n\n  for (i=0, n=r.length; i<n; ++i) {\n    r[i][REM] = 1;\n  }\n  for (i=0, j=0, n=a.length; i<n; ++i) {\n    if (!a[i][REM]) { x[j++] = a[i]; }\n  }\n  for (i=0, n=r.length; i<n; ++i) {\n    delete r[i][REM];\n  }\n  \n  this._rem = [];\n  this._f = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._f !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._f = get;    \n  }\n  return this._ext;\n};\nproto.min = function(f) { return this.extent(f)[0]; };\nproto.max = function(f) { return this.extent(f)[1]; };\n\nproto.quartile = function(get) {\n  if (this._f !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._f = get;    \n  }\n  return this._q;\n};\nproto.q1 = function(f) { return this.quartile(f)[0]; };\nproto.q2 = function(f) { return this.quartile(f)[1]; };\nproto.q3 = function(f) { return this.quartile(f)[2]; };\n\nmodule.exports = Collector;","var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = Array.prototype.reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n","var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'this.argmin = null;',\n    set:  'this.argmin || cell.data.min(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'this.argmax = null;',\n    set:  'this.argmax || cell.data.max(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? this.get(cell.data.min(this.get)) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'this.max = null;',\n    set:  'this.max = (isNaN(this.max) ? this.get(cell.data.max(this.get)) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;","var util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f), c = u.counts;\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;","var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;","var util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n","var STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : 0;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); };\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","var bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;","var dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n","var Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n","var Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;","var dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;","var dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;","var Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;","var C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};","var dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\n// Spoof the previous tuple\nfunction prev(t) {\n  return dl.extend(dl.duplicate(t), t._prev);\n}\n\nfunction has_prev(t) {\n  return t._prev && t._prev !== C.SENTINEL;\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   prev,\n  set_prev: set_prev,\n  has_prev: has_prev,\n  reset:  reset,\n  idMap:  idMap\n};","var dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};","module.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};","var datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;","var dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n","/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};","var dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;","var dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};","var parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}","var dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}","var dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;","var expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};","var dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;","module.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};","var Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n","module.exports = {\n  Renderer: require('./Renderer')\n};\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n","var dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};","var Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      aggr = cache ? cache.aggr() : null,  // dl.Aggregator\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph)\n    cache.groupby.set(cache, [])\n      .summarize.set(cache, {});\n\n    aggr = cache.aggr();\n    if(uniques && sort) {\n      aggr.summarize({ \"dataref\": [sort.stat] })\n    } else if(!uniques) {\n      aggr.summarize({ \"dataref\": [C.MIN, C.MAX] })\n    }\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      aggr.accessors({ \"dataref\": sort ? (r.sort || sort.field) : \"_id\" });\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        aggr.groupby({ name: \"key\", get: dl.accessor(fields[j]) });\n        cache.evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        aggr.accessors({ \"dataref\": fields[j] });\n        cache.evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = aggr.result();\n  if (uniques) {\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + sort.stat + \"_dataref\";\n      sort = dl.comparator(sort);\n      data = data.sort(sort);\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return data.map(function(d) { return d.key; });\n  } else {\n    data = data[0];\n    return (data === null) ? [] : [data.min_dataref, data.max_dataref];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;","var tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tpl = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"}\n  });\n\n  this._fieldsDef = null;\n  this._aggr = null;  // dl.Aggregator\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new Transform());\n\nproto.summarize = {\n  set: function(transform, summarize) {\n    var i, len, f, fields, name, ops, signals = {};\n    if(!dl.isArray(fields = summarize)) { // Object syntax from dl\n      fields = [];\n      for (name in summarize) {\n        ops = util.array(summarize[name]);\n        fields.push({name: name, ops: ops});\n      }\n    }\n\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._aggr = null;\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nfunction ingest(t) { return tpl.ingest(t, null) }\n\nproto.aggr = function() {\n  if(this._aggr) return this._aggr;\n\n  var graph = this._graph,\n      groupby = this.groupby.get(graph).fields;\n\n  var fields = this._fieldsDef.map(function(field) {\n    var f = dl.duplicate(field);\n    f.name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    f.ops  = f.ops.signal ? graph.signalRef(f.ops.signal) : dl.array(f.ops).map(function(o) {\n      return o.signal ? graph.signalRef(o.signal) : o;\n    });\n\n    return f;\n  });\n\n  var aggr = this._aggr = dl.groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  aggr._assign = tpl.set;\n  aggr._ingest = ingest;\n\n  return aggr;\n};\n\nproto._reset = function(input, output) {\n  output.rem.push.apply(output.rem, this.aggr().result());\n  this._aggr = null;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  var output = changeset.create(input);\n  if(reset) this._reset(input, output);\n\n  var aggr = this.aggr();\n\n  input.add.forEach(aggr.add.bind(aggr));\n\n  input.mod.forEach(function(x) {\n    if(reset) {\n      aggr.add(x);  // Signal change triggered reflow\n    } else if(tpl.has_prev(x)) {\n      aggr.rem(tpl.prev(x));\n      aggr.add(x);\n    }\n  });\n\n  input.rem.forEach(function(x) {\n    aggr.rem(tpl.has_prev(x) ? tpl.prev(x) : x);\n  });\n\n  var changes = aggr.changes();\n  output.add.push.apply(output.add, changes.add);\n  output.mod.push.apply(output.mod, changes.mod);\n  output.rem.push.apply(output.rem, changes.rem);\n\n  return output;\n}\n\nmodule.exports = Aggregate;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;","var Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;","var Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;","var dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;","var Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;","module.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  zip:        require('./Zip')\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;","module.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};","var config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};"],"sourceRoot":"/source/"}