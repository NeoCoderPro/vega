{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index","vega2.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/aggregate/aggregator.js","node_modules/datalib/src/aggregate/collector.js","node_modules/datalib/src/aggregate/groupby.js","node_modules/datalib/src/aggregate/measures.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/bins/histogram.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/formats/dsv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/import/readers.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/index.js","node_modules/datalib/src/print.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/template.js","node_modules/datalib/src/time-units.js","node_modules/datalib/src/util.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","src/core/HeadlessView.js","src/core/Model.js","src/core/View.js","src/dataflow/Collector.js","src/dataflow/Datasource.js","src/dataflow/Graph.js","src/dataflow/Node.js","src/dataflow/Signal.js","src/dataflow/changeset.js","src/dataflow/tuple.js","src/expression/codegen.js","src/expression/constants.js","src/expression/functions.js","src/expression/index.js","src/expression/parser.js","src/parse/axes.js","src/parse/data.js","src/parse/events.js","src/parse/expr.js","src/parse/interactors.js","src/parse/legends.js","src/parse/mark.js","src/parse/marks.js","src/parse/modify.js","src/parse/padding.js","src/parse/predicates.js","src/parse/properties.js","src/parse/signals.js","src/parse/spec.js","src/parse/streams.js","src/parse/transforms.js","src/render/canvas/Handler.js","src/render/canvas/Renderer.js","src/render/canvas/index.js","src/render/canvas/marks.js","src/render/canvas/path.js","src/render/svg-headless/Renderer.js","src/render/svg-headless/index.js","src/render/svg-headless/svg.js","src/render/svg/Handler.js","src/render/svg/Renderer.js","src/render/svg/marks.js","src/scene/Bounder.js","src/scene/Builder.js","src/scene/Encoder.js","src/scene/GroupBuilder.js","src/scene/Item.js","src/scene/Scale.js","src/scene/Transition.js","src/scene/axis.js","src/scene/legend.js","src/transforms/Aggregate.js","src/transforms/BatchTransform.js","src/transforms/Bin.js","src/transforms/Cross.js","src/transforms/Facet.js","src/transforms/Filter.js","src/transforms/Fold.js","src/transforms/Force.js","src/transforms/Formula.js","src/transforms/Geo.js","src/transforms/GeoPath.js","src/transforms/GroupBy.js","src/transforms/LinkPath.js","src/transforms/Parameter.js","src/transforms/Pie.js","src/transforms/Sort.js","src/transforms/Stack.js","src/transforms/Transform.js","src/transforms/Treemap.js","src/transforms/Unique.js","src/transforms/Zip.js","src/transforms/index.js","src/transforms/measures.js","src/util/Bounds.js","src/util/Gradient.js","src/util/boundscalc.js","src/util/config.js","src/util/constants.js","src/util/debug.js","src/util/quickselect.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vg","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"core","View","dataflow","changeset","Datasource","Graph","Node","parse","spec","scene","Builder","GroupBuilder","transforms","config","util","./src/core/View","./src/dataflow/Datasource","./src/dataflow/Graph","./src/dataflow/Node","./src/dataflow/changeset","./src/parse/spec","./src/scene/Builder","./src/scene/GroupBuilder","./src/transforms/index","./src/util/config","datalib",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"Aggregator","_cells","_aggr","_stream","summarize_args","fields","isArray","ops","array","Measures","Collector","Flags","ADD_CELL","MOD_CELL","proto","prototype","stream","v","key","_key","$","groupby","dims","_dims","map","d","isString","get","isFunction","clear","summarize","_count","m","j","op","as","aggr","identity","measures","create","_assign","count","*","object","value","_cellkey","x","k","String","_cell","_newcell","cell","num","tuple","_newtuple","flag","aggs","collect","data","_ingest","_add","add","_rem","rem","_mod","curr","prev","cell0","cell1","isObject","result","values","set","_rems","changes","mod","execute","input","insert","_consolidate","remove","../util","./collector","./measures",5,"_last","stats","REM","Array","lut","toMap","hasOwnProperty","_f","extent","_ext","index","argmin","argmax","min","Infinity","max","quartile","_q","q1","q2","q3","../stats",6,"args","reduce","arguments","concat","./aggregator",7,"measure","base","out","extend","init","idx","resolve","agg","helper","types","req","forEach","str","vals","sort","b","accessor","mutator","all","ctr","slice","Function","assign","distinct","isValid","v_new","v_old","undefined","missing","valid","sum","mean","average","variance","variancep","stdev","stdevp","median","modeskew",8,"bins","opt","step","level","minstep","precision","eps","maxb","maxbins","logb","Math","log","div","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","lo","hi","mid","cmp","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","raw","../time-units",9,"$bin","options","$func","histogram","numerical","categorical","type","qtype","ext","h","gen","range","isFinite","unique","c","comparator","integer","number","../generate","../import/type","./bins",10,"repeat","val","zeros","random","uniform","samples","normal","next","rds","y","sqrt",11,"dsv","format","header","join","delimiter","d3","delim","fmt","../../util",12,"json","topojson","treejson","csv","tsv","./dsv","./json","./topojson","./treejson",13,"isBuffer","JSON","property",14,"obj","feature","objects","features","mesh",15,"toTable","root","childrenField","visit","node","table","children",16,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","test","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","lastIndexOf","load","callback","error","err","indexOf","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","filename","fs","readFile","readFileSync","body","statusCode","getBody","sync-request",17,"read","formats","cols","parsers","clen","inferAll","duplicate","keys","annotation","./formats","./type",18,"./load","./read",19,"TYPES","isDate","isNumber","isBoolean","typeAll","infer","TESTS","splice","PARSERS","boolean","string","isNaN","Date",20,"dl","print","template","timeunits","./aggregate/groupby","./bins/bins","./bins/histogram","./generate","./import/load","./import/read","./import/readers","./import/type","./print","./stats","./template","./time-units","./util",21,"printQuantitativeProfile","p","printCategoricalProfile","list","top","FMT","POS","separator","minwidth","maxwidth","limit","lens","head","truncate","pad","tmpl","summary","__summary__","field",22,"results","filter","quantile","q","H","delta","M2","avg","med","std","dot","Number","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","L2","abs","R","M","entropy","counts","LN2","mutual","z","px","py","I","info","profile","sd",23,"text","src","source","bind","context","variable","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","stringCast","filters","split","prop","shift","trim","pidx","template_format","time","template_escapes","pattern","format_map","clearFormatCache","'","\\","\r","\n"," "," ",24,"STEPS","entries","UTC","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",25,"util_escape_str","escape_str_re","strrep","truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","Buffer","stderr","FNAME","namedfunc","stringify","equal","keystr","toString","Object","apply","$valid","$length","$year","$month","$date","$day","$hour","$minute","$in","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","searchString","pos","padchar","word","ellipsis","l1","l2","_process","buffer",26,"./lib/heap",27,"Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","item","lastelt","returnitem","pop","_ref","_i","_len","_ref1","_results","_results1","_j","elem","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","pushpop","peek","contains","empty","size","clone","heap","toArray","front","has","copy","factory",28,"canvas","svg","HeadlessView","width","height","model","_el","_type","_renderers","_canvas","renderer","canvasAsync","wait","pendingImages","view","render","_renderer","initialize","_width","_height","_padding","_viewport","left","right","bottom","_io","Renderer","initSVG","initCanvas","Canvas","tw","th","ctx","getContext","setAttribute","setTransform","resize","../render/canvas/index","../render/svg-headless/index","../util/debug","./View",29,"Model","_defs","_predicates","_scene","_node","_builder","predicates","defs","pipeline","predicate","disconnect","marks","connect","fire","cs","propagate","../dataflow/Graph","../dataflow/Node","../dataflow/changeset","../scene/GroupBuilder",30,"streaming","ds","_model","listener","streamer","_streamer","_changeset","api","signals","_api","update","build","_renderNode","router","evaluate","debug","trans","items","revises","finalize","last","parseStreams","Encoder","Transition","el","__width","__height","_autopad","_handler","dataValues","signal","setter","signalValues","reflow","_strict","padding","autopad","bounds","inset","autopadInset","x1","y1","x2","y2","viewport","_build","prevHandler","parentNode","select","append","attr","style","Handler","handlers","handler","duration","ease","props","listeners","onSignal","offSignal","../parse/streams","../render/svg/index","../scene/Encoder","../scene/Transition","../util/config","./HeadlessView",31,"graph","_data","collector","ids","_id","../util/constants","./Node","./changeset",32,"facet","_graph","_name","_source","_facet","_input","_output","_pipeline","_collector","_revises","set_prev","_prev","C","SENTINEL","ingest","where","func","idMap","unshift","output","dest","_srcMap","derive","./Collector","./tuple",33,"_signals","forEachNode","branch","Signal","_stamp","_rank","doNotPropagate","db","names","sg","signalRef","ref","schedule","pulse","reflowed","pq","stamp","_listeners","dependency","DATA","SIGNALS","reevaluate","run","./Datasource","./Signal",34,"REEVAL","FIELDS","SCALES","node_id","_registered","_deps","scales","_isRouter","_isCollector","deps","bool","cur","foundSending","reeval",35,"_value","_handlers",36,"reset_prev",37,"datum","tuple_id","reset",38,"codegen_wrap","ast","retval","codegen","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","DATUM","SIGNAL_PREFIX","Literal","Identifier","id","Program","MemberExpression","computed","CallExpression","callee","ArrayExpression","elements","BinaryExpression","operator","UnaryExpression","argument","UpdateExpression","prefix","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","Property","ExpressionStatement","expression","./constants","./functions",39,"E","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2",40,"fncall","cast","DATE","STRING","REGEXP","acos","asin","atan","atan2","cos","sin","tan","now","datetime","hours","minutes","seconds","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseFloat","parseInt","upper","lower","substring","if",41,"parser","./codegen","./parser",42,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","charCodeAt","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","token","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","EOF","collectToken","entry","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","msg","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","expr","state","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",43,"axes","group","def","axs","axis","scale","orient","ORIENT","layer","grid","titleOffset","tickValues","tickFormat","tickSubdivide","subdivide","tickPadding","tickSize","ts","tickSizeMajor","tickSizeMinor","tickSizeEnd","ticks","majorTickProperties","majorTicks","minorTickProperties","minorTicks","tickLabelProperties","labels","titleProperties","gridLineProperties","domainProperties","../scene/axis",44,"parseTransforms","parseModify","parseData","loaded","datasource","transform","modify","./modify","./transforms",45,"peg$subclass","child","ctor","constructor","SyntaxError","expected","peg$computePosDetails","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","buildMessage","stringEscape","hex","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","peg$parsemerged","s1","s2","s3","s4","s5","peg$parseordered","peg$FAILED","peg$parsesep","peg$c1","peg$silentFails","peg$c2","peg$reportedPos","peg$c3","peg$c0","peg$c4","s6","s7","s8","s9","s10","s11","s12","s13","peg$c5","peg$c6","peg$parsefiltered","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$parsestream","peg$parsefilter","peg$c13","peg$c14","peg$parseclass","peg$parseid","peg$c15","peg$parseeventType","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$parsevalue","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$result","peg$startRuleFunctions","peg$startRuleFunction","f1","f2","middle","event","target","startRule",46,"eval","../expression",47,"defFactory","interactor","inject","pd","nsSignals","nsPredicates","nsMarks","mk","injectMarks","from","ENTER","UPDATE","EXIT","ns","streams","operands","nsOperand","nsProperties","enter","exit","propset","rule","interactors",48,"legends","lgnd","legend","shape","fill","stroke","labelProperties","legendProperties","symbolProperties","symbols","gradientProperties","gradient","../scene/legend",49,"parseProperties","parseMark","mark","delay","./properties",50,"./mark",51,"signalName","ADD","REMOVE","TOGGLE","CLEAR","../dataflow/tuple",52,53,"parseSignal","parseOperands","decl","arg","pred","parseComparator","parseLogical","parseIn","parseScale","scope","invert","=","==","!=",">",">=","<","<=","and","&&","or","||","in",54,"compile","vars","valueRef","DEPS","hasPath","encoder","tpl","encode","path","tension","rules","inputs","predName","colorRef","sgRef","fRef","sRef","fieldRef","scaleRef","band","mult","xx","color","yy","zz","nested","fr",55,"dep","./expr",56,"parsePadding","parseMarks","parseSignals","parsePredicates","parseInteractors","viewFactory","../core/Model","../core/View","../parse/data","../parse/interactors","../parse/marks","../parse/padding","../parse/predicates","../parse/signals",57,"changset","selector","START","MIDDLE","END","sig","register","orderedStream","trueFn","sp","mergedStream","sel","evt","filtered","preventDefault","mouse","./events",58,"tx","../transforms/index",59,"eventName","_active","_obj","that","events","addEventListener","touchmove","mousemove","getBoundingClientRect","clientX","clientY","pick","touchend","mouseout","DOMMouseScroll","gx","gy","marktype","picker","./marks",60,"scaleCanvas","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","initializeLineDash","vgLineDash","NODASH","setLineDash","dash","vgLineDashOffset","lineDashOffset","webkitLineDash","webkitLineDashOffset","mozDash","translatedBounds","Bounds","translate","getBounds","union","setBounds","bbox","beginPath","rect","clip","_ctx","_imgload","selectAll","_ratio","element","bb2","save","clearRect","draw","encloses","renderAsync","_async_id","clearTimeout","loadImage","uri","image","Image","../../util/Bounds","../../util/config",61,"./Handler","./Renderer",62,"fontString","fontStyle","fontVariant","fontWeight","fontSize","font","arcPath","ir","innerRadius","outerRadius","startAngle","ea","endAngle","moveTo","arc","closePath","areaPath","pathCache","parsePath","area","renderPath","linePath","pathPath","symbolPath","rx","ry","lineTo","tan30","sqrt3","lineStroke","lw","strokeWidth","lc","strokeCap","lineWidth","lineCap","ruleStroke","drawPathOne","opac","opacity","globalAlpha","fillOpacity","fillStyle","strokeOpacity","strokeStyle","strokeDash","strokeDashOffset","drawPathAll","intersects","drawRect","fillRect","strokeRect","drawRule","drawImage","align","baseline","drawText","textAlign","textBaseline","radius","theta","angle","rotate","dx","dy","fillText","strokeText","drawAll","pathFunc","drawOne","drawGroup","axisItems","legendItems","grad","createLinearGradient","stops","addColorStop","pickGroup","subscene","hit","interactive","pickAll","hitTests","pickArea","pickLine","textHit","boundsCalc","tmpBounds","isPointInStroke","isPointInPath","symbol","../../util/boundscalc","./path",63,"currentPath","chunks","parsed","re","chunksParsed","jlen","command","commandLength","cmdLength","klen","drawArc","coords","rot","large","sweep","ex","ey","segs","arcToSegments","bez","segmentToBezier","bezierCurveTo","boundArc","rotateX","ox","oy","argsStr","arcToSegmentsCache","sin_th","cos_th","pl","a00","a01","a10","a11","x0","y0","sfactor_sq","sfactor","xc","yc","th0","th1","th_arc","segments","th2","th3","cx","cy","segmentToBezierCache","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","current","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","quadraticCurveTo",64,"SVGBuilder","./svg",65,66,"tag","close","escape_text","escape_font","group_bg","styl","class","clip_id","clipping","arc_path","area_path_h","area_path_v","line_path","symbol_path","xlink:href","text-anchor","cssClass","cls","xw","yh","styleProps","styles","_gid","_text","foot","svgNamespace","buildDefs","dgrad","dclip","stop-color","meta","MARKS","sty","nest","center",67,"svgHandler","__data__","_svg","dom","removeEventListener",68,"updateDefs","each","grd","cr","renderItems",69,"dup",70,"setProperty","removeProperty","area_path","setAttributeNS","removeAttribute","textContent","drawMark","evts","grps","childNodes","notG","mark_id",71,"Bounder","_mark","ilen","hasLegends","GROUP","_legendPositions","../util/boundscalc","./Encoder",72,"inlineDs","sibling","_def","geom","_parent_id","_from","_ds","_isSuper","_bounder","newItem","Item","keyf","_map","joinDatasource","fullUpdate","keyFunction","joinValues","_items","parent_id","inheritFrom","_parent","_encoder","builder","fcs","./Bounder","./Item",73,"preds","enc","EMPTY",74,"_children","_scaler","_recursor","_scales","recurse","hasMarks","hasAxes","inline","buildMarks","buildAxes","buildLegends","MARK","parseAxes","parseLegends","buildGroup","inherit","axisDef","AXIS","legendDef","LEGEND","Scale","acc","group_id","../dataflow/Collector","../parse/axes","../parse/legends","./Builder","./Scale",75,"hasPropertySet","cousin","iidx","midx","touch",76,"_updated","instance","ORDINAL","ordinal","quantitative","rng","LINEAR","scaleName","dataDrivenRange","dataRef","RANGE","DOMAIN","points","rangePoints","rangeRoundBands","rangeBands","interval","QUANTILE","domainMinMax","rangeRound","exponent","POWER","clamp","nice","TIME","which","rlen","flen","refs","uniques","ck","cache","cacheField","Aggregate","singleton","stat","group_by","MIN","MAX","order","DESC","SINGLETON","domainMin","domainMax","LOG","zero","GROUP_PROPERTY","rangeMin","rangeMax","SIGNAL","../transforms/Aggregate",77,"updates","elapsed","skip","interp","timer",78,"axis_def","newScale","oldScale","rangeBand","vg_axisScaleRange","gridLines","vg_axisTicks","tickLabels","vg_axisTickLabels","vg_axisDomain","vg_axisTitle","gridColor","vg_axisTicksExtend","tickMajorSize","tickMinorSize","vg_axisLabelExtend","vg_axisDomainExtend","tickEndSize","vg_axisTitleExtend","gridLineStyle","majorTickStyle","minorTickStyle","tickLabelStyle","domainStyle","titleStyle","vg_axisUpdate","tickFormatString","tickArguments","injest","major","minor","vg_axisSubdivide","label","tdata","vg_axisOrients","subticks","vg_axisScaleExtent","rangeExtent","vg_axisBaseline","vg_axisAlign","tickColor","tickWidth","tickLabelColor","tickLabelFont","tickLabelFontSize","titleFont","titleFontSize","titleFontWeight","titleColor","axisColor","axisWidth","../parse/mark",79,"discrete","ordinalDef","o_legend_def","symbolSize","spacing","labelStyle","labelFontSize","sz","titles","vg_legendTitle","vg_legendSymbols","vg_vLegendLabels","vg_legendSymbolExtend","symbolStyle","legendStyle","vg_legendPosition","quantDef","q_legend_def","gradientStyle","gradientWidth","layout","vg_legendGradient","vg_hLegendLabels","Gradient","gp","gh","hh","tp","formatString","vg_legendOrients","lh","cfg","symbolShape","symbolColor","symbolStrokeWidth","labelColor","labelFont","labelAlign","labelBaseline","gradientHeight","gradientStrokeColor","gradientStrokeWidth","../parse/properties","../util/Gradient",80,"GroupBy","Transform","addParameters","var","varp","_fieldsDef","_Aggregators","_singleton","meas","_reset","_keys","_gb","_new_cell","flg","./GroupBy","./Transform",81,"BatchTransform","batchTransform",82,"Bin","default","bin",83,"Cross","with","diagonal","_lastRem","_lastWith","_ids","_cache","wdata","diag","cross","upFields","selfCross","woutput",84,"Facet","_new_tuple",85,"Filter","_skip","../parse/expr",86,"Fold","rst","get_tuple","accessors","dlen","fold",87,"Force","links","linkDistance","linkStrength","charge","chargeDistance","iterations","friction","gravity","alpha","_nodes","_links","_layout","force","nodeInput","linkInput","iter","link","tick","nodeIds","linkIds",88,"Formula",89,"Geo","Parameters","lon","lat","projection","clipAngle","clipExtent","d3Projection","proj","param","_mode","_projection","geo","ll","xy",90,"GeoPath","geojson","./Geo",91,"gb","groupBy",92,"LinkPath","sx","sy","ty","curve","ix","iy","diagonalX","diagonalY","shapes",93,"Parameter","_accessors","_resolution","arrayType","dataType","fieldType","exprType","_get","isData","isField","sources","isExpr",94,"Pie","ones","./BatchTransform",95,"Sort","by",96,"Stack","sortby","partition","groups",97,"params","_parameters","./Parameter",98,"Treemap","sticky","mode","treemap",99,"Unique",100,"Zip","withKey","_lastJoin","mp","wds","dflt","prevm","wlen",101,"aggregate","linkpath","formula","geopath","pie","zip","./Aggregate","./Bin","./Cross","./Facet","./Filter","./Fold","./Force","./Formula","./GeoPath","./LinkPath","./Pie","./Sort","./Stack","./Treemap","./Unique","./Zip",102,"quickselect","_counts","../util/quickselect",103,"MAX_VALUE","expand",104,"vg_gradient_id",105,"gfx","pathBounds","boundPath","halfpi","xmin","xmax","ymin","ymax","angles","noRotate","measureText","includeLegends","itemBounds","methods","bounds_prev","pb","markBounds","../render/canvas/path","../util/Bounds","./config",106,"utc","labelOffset","rgb","lab","hcl","hsl","category10","category20",107,"sentinel","COUNT","ASC",108,"console",109,"swap","pivot"],"mappings":"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","file":"vega2.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};\n},{\"./src/core/View\":30,\"./src/dataflow/Datasource\":32,\"./src/dataflow/Graph\":33,\"./src/dataflow/Node\":34,\"./src/dataflow/changeset\":36,\"./src/parse/spec\":56,\"./src/scene/Builder\":72,\"./src/scene/GroupBuilder\":74,\"./src/transforms/index\":101,\"./src/util/config\":106,\"datalib\":20}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x));\n};\n\nproto._newcell = function(x) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      if (cell.collect) {\n        cell.data.values();\n      }\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      result.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function() {\n  var changes = {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === Flags.MOD_CELL) {\n        changes.rem.push(cell.tuple);\n      }\n      delete this._cells[k];\n    } else if (flag & Flags.ADD_CELL) {\n      changes.add.push(cell.tuple);\n    } else if (flag & Flags.MOD_CELL) {\n      changes.mod.push(cell.tuple);\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;\n},{\"../util\":25,\"./collector\":5,\"./measures\":7}],5:[function(require,module,exports){\nvar util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '$!_rem_!#';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return this._add;\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n;\n\n  if (k) {\n    // has unique key field, use that\n    var lut = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!lut.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else if (!util.isObject(r[0])) {\n    // process collection of raw values\n    var m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  this._f = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._f !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._f = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(f) {\n  return this.extent(f)[0];\n};\n\nproto.argmax = function(f) {\n  return this.extent(f)[1];\n};\n\nproto.min = function(f) {\n  var m = this.extent(f)[0];\n  return m ? f(m) : +Infinity;\n};\nproto.max = function(f) {\n  var m = this.extent(f)[1];\n  return m ? f(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._f !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._f = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(f) {\n  return this.quartile(f)[0];\n};\n\nproto.q2 = function(f) {\n  return this.quartile(f)[1];\n};\n\nproto.q3 = function(f) {\n  return this.quartile(f)[2];\n};\n\nmodule.exports = Collector;\n},{\"../stats\":22,\"../util\":25}],6:[function(require,module,exports){\nvar util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n\n},{\"../util\":25,\"./aggregator\":4}],7:[function(require,module,exports){\nvar util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;\n},{\"../stats\":22,\"../util\":25}],8:[function(require,module,exports){\nvar util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time-units\":24,\"../util\":25}],9:[function(require,module,exports){\nvar stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n},{\"../generate\":10,\"../import/type\":19,\"../stats\":22,\"../util\":25,\"./bins\":8}],10:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],11:[function(require,module,exports){\n(function (global){\nvar util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util\":25}],12:[function(require,module,exports){\nvar dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n},{\"./dsv\":11,\"./json\":13,\"./topojson\":14,\"./treejson\":15}],13:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":25}],14:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":13}],15:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":13}],16:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":25,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],17:[function(require,module,exports){\nvar util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n\n},{\"../util\":25,\"./formats\":12,\"./type\":19}],18:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":25,\"./load\":16,\"./read\":17}],19:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":25}],20:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;\n},{\"./aggregate/groupby\":6,\"./bins/bins\":8,\"./bins/histogram\":9,\"./generate\":10,\"./import/load\":16,\"./import/read\":17,\"./import/readers\":18,\"./import/type\":19,\"./print\":21,\"./stats\":22,\"./template\":23,\"./time-units\":24,\"./util\":25}],21:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}\n},{\"./import/type\":19,\"./stats\":22,\"./template\":23,\"./util\":25}],22:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":10,\"./import/type\":19,\"./util\":25}],23:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\ntemplate.source = source;\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util\":25}],24:[function(require,module,exports){\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{}],25:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"./time-units\":24,\"_process\":3,\"buffer\":2}],26:[function(require,module,exports){\nmodule.exports = require('./lib/heap');\n\n},{\"./lib/heap\":27}],27:[function(require,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n},{}],28:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/index\":61,\"../render/svg-headless/index\":65,\"../util/debug\":108,\"./View\":30,\"datalib\":20}],29:[function(require,module,exports){\nvar Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;\n},{\"../dataflow/Graph\":33,\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../scene/GroupBuilder\":74,\"datalib\":20}],30:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../parse/streams\":57,\"../render/canvas/index\":61,\"../render/svg/index\":69,\"../scene/Encoder\":73,\"../scene/Transition\":77,\"../util/config\":106,\"../util/debug\":108,\"./HeadlessView\":28,\"datalib\":20}],31:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"../util/constants\":107,\"../util/debug\":108,\"./Node\":34,\"./changeset\":36}],32:[function(require,module,exports){\nvar dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;\n},{\"../util/constants\":107,\"../util/debug\":108,\"./Collector\":31,\"./Node\":34,\"./changeset\":36,\"./tuple\":37,\"datalib\":20}],33:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;\n},{\"../util/constants\":107,\"../util/debug\":108,\"./Datasource\":32,\"./Signal\":35,\"./changeset\":36,\"datalib\":20,\"heap\":26}],34:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;\n},{\"../util/constants\":107,\"datalib\":20}],35:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;\n},{\"./Node\":34,\"./changeset\":36}],36:[function(require,module,exports){\nvar C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};\n},{\"../util/constants\":107}],37:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};\n},{\"../util/constants\":107,\"datalib\":20}],38:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};\n},{\"./constants\":39,\"./functions\":40,\"datalib\":20}],39:[function(require,module,exports){\nmodule.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};\n},{}],40:[function(require,module,exports){\nvar datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};\n},{\"datalib\":20}],41:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n\n},{\"./codegen\":38,\"./parser\":42}],42:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],43:[function(require,module,exports){\nvar dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;\n},{\"../scene/axis\":78,\"../util/config\":106,\"datalib\":20}],44:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n\n},{\"../util/config\":106,\"./modify\":51,\"./transforms\":58,\"datalib\":20}],45:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};\n},{}],46:[function(require,module,exports){\nvar dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;\n},{\"../expression\":41,\"datalib\":20}],47:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}\n},{\"../util/config\":106,\"../util/constants\":107,\"datalib\":20}],48:[function(require,module,exports){\nvar lgnd = require('../scene/legend'),\n    config = require('../util/config');\n\nfunction legends(model, spec, legends, group) {\n  (spec || []).forEach(function(def, index) {\n    legends[index] = legends[index] || lgnd(model);\n    legend(def, index, legends[index], group);\n  });\n};\n\nfunction legend(def, index, legend, group) {\n  // legend scales\n  legend.size  (def.size   ? group.scale(def.size)   : null);\n  legend.shape (def.shape  ? group.scale(def.shape)  : null);\n  legend.fill  (def.fill   ? group.scale(def.fill)   : null);\n  legend.stroke(def.stroke ? group.scale(def.stroke) : null);\n\n  // legend orientation\n  if (def.orient) legend.orient(def.orient);\n\n  // legend offset\n  if (def.offset != null) legend.offset(def.offset);\n\n  // legend title\n  legend.title(def.title || null);\n\n  // legend values\n  legend.values(def.values || null);\n\n  // legend label formatting\n  legend.format(def.format !== undefined ? def.format : null);\n\n  // style properties\n  var p = def.properties;\n  legend.titleProperties(p && p.title || {});\n  legend.labelProperties(p && p.labels || {});\n  legend.legendProperties(p && p.legend || {});\n  legend.symbolProperties(p && p.symbols || {});\n  legend.gradientProperties(p && p.gradient || {});\n}\n\nmodule.exports = legends;\n},{\"../scene/legend\":79,\"../util/config\":106}],49:[function(require,module,exports){\nvar dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};\n},{\"./properties\":54,\"datalib\":20}],50:[function(require,module,exports){\nvar parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};\n},{\"./mark\":49}],51:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}\n},{\"../dataflow/Node\":34,\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/debug\":108,\"datalib\":20}],52:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}\n},{\"datalib\":20}],53:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n},{\"datalib\":20}],54:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"../util/config\":106,\"datalib\":20}],55:[function(require,module,exports){\nvar expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n},{\"../util/constants\":107,\"./expr\":46}],56:[function(require,module,exports){\nvar dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n\n},{\"../core/Model\":29,\"../core/View\":30,\"../parse/data\":44,\"../parse/interactors\":47,\"../parse/marks\":50,\"../parse/padding\":52,\"../parse/predicates\":53,\"../parse/signals\":55,\"datalib\":20}],57:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../util/constants\":107,\"./events\":45,\"./expr\":46,\"datalib\":20}],58:[function(require,module,exports){\nvar dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};\n},{\"../transforms/index\":101,\"datalib\":20}],59:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":62,\"datalib\":20}],60:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../util/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/Bounds\":103,\"../../util/config\":106,\"./marks\":62,\"datalib\":20}],61:[function(require,module,exports){\nmodule.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};\n},{\"./Handler\":59,\"./Renderer\":60}],62:[function(require,module,exports){\nvar Bounds = require('../../util/Bounds'),\n    boundsCalc = require('../../util/boundscalc'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};\n},{\"../../util/Bounds\":103,\"../../util/boundscalc\":105,\"../../util/config\":106,\"./path\":63}],63:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../util/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/Bounds\":103}],64:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":106,\"./svg\":66,\"datalib\":20}],65:[function(require,module,exports){\nmodule.exports = {\n  Renderer: require('./Renderer')\n};\n\n},{\"./Renderer\":64}],66:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":106,\"datalib\":20}],67:[function(require,module,exports){\nvar dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;\n},{\"datalib\":20}],68:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":70,\"datalib\":20}],69:[function(require,module,exports){\narguments[4][61][0].apply(exports,arguments)\n},{\"./Handler\":67,\"./Renderer\":68,\"dup\":61}],70:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":106,\"datalib\":20}],71:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder = require('./Encoder'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n  var i, ilen, j, jlen, group, legend;\n      hasLegends = this._mark.marktype == C.GROUP \n        && dl.array(this._mark.def.legends).length > 0;\n\n  bounds.mark(this._mark, null, !hasLegends);\n\n  if(hasLegends) {\n    for(i=0, ilen=this._mark.items.length; i<ilen; ++i) {\n      group = this._mark.items[i];\n      group._legendPositions = null;\n      for(j=0, jlen=group.legendItems.length; j<jlen; ++j) {\n        legend = group.legendItems[j];\n        Encoder.update(this._graph, input.trans, \"vg_legendPosition\", legend.items);\n        bounds.mark(legend, null, true);\n      }\n    }\n\n    bounds.mark(this._mark, null, true);\n  }\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;\n},{\"../dataflow/Node\":34,\"../util/boundscalc\":105,\"../util/constants\":107,\"../util/debug\":108,\"./Encoder\":73,\"datalib\":20}],72:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../parse/data\":44,\"../util/constants\":107,\"../util/debug\":108,\"./Bounder\":71,\"./Encoder\":73,\"./Item\":75,\"datalib\":20}],73:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;\n},{\"../dataflow/Node\":34,\"../util/boundscalc\":105,\"../util/constants\":107,\"../util/debug\":108,\"datalib\":20}],74:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    parseLegends = require('../parse/legends'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n\n  scales = (def.legends||[]).reduce(function(acc, x) {\n    return (acc[x.size || x.shape || x.fill || x.stroke], acc);\n  }, scales);\n\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = dl.array(this._def.marks).length > 0,\n      hasAxes = dl.array(this._def.axes).length > 0,\n      hasLegends = dl.array(this._def.legends).length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n    if(hasLegends) buildLegends.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }\n\n    // Update legend data defs\n    if(hasLegends) {\n      parseLegends(builder._graph, builder._def.legends, group.legends, group);\n      group.legends.forEach(function(l, i) { l.def() });\n    }   \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n\n  group.legends = group.legends || [];\n  group.legendItems = group.legendItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nfunction buildLegends(input, group) {\n  var legends = group.legends,\n      legendItems = group.legendItems,\n      builder = this;\n\n  parseLegends(this._graph, this._def.legends, legends, group);\n  legends.forEach(function(l, i) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke(),\n        def = l.def(),\n        b = null;\n\n    legendItems[i] = {group: group, legendDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, legendItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.LEGEND, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n},{\"../dataflow/Collector\":31,\"../dataflow/Node\":34,\"../parse/axes\":43,\"../parse/legends\":48,\"../util/constants\":107,\"../util/debug\":108,\"./Builder\":72,\"./Scale\":76,\"datalib\":20}],75:[function(require,module,exports){\nfunction Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;\n},{}],76:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../transforms/Aggregate\":80,\"../util/config\":106,\"../util/constants\":107,\"../util/debug\":108,\"datalib\":20}],77:[function(require,module,exports){\nvar tuple = require('../dataflow/tuple'),\n    boundsCalc = require('../util/boundscalc'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    boundsCalc.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;\n},{\"../dataflow/tuple\":37,\"../util/boundscalc\":105,\"../util/constants\":107}],78:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines:  null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title:  null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"../parse/mark\":49,\"../util/config\":106,\"datalib\":20}],79:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    parseProperties = require('../parse/properties'),\n    parseMark = require('../parse/mark'),\n    Gradient = require('../util/Gradient'),\n    config = require('../util/config');\n\nfunction lgnd(model) {\n  var size = null,\n      shape = null,\n      fill = null,\n      stroke = null,\n      spacing = null,\n      values = null,\n      format = null,\n      formatString = null,\n      title = undefined,\n      orient = \"right\",\n      offset = config.legend.offset,\n      padding = config.legend.padding,\n      legendDef,\n      tickArguments = [5],\n      legendStyle = {},\n      symbolStyle = {},\n      gradientStyle = {},\n      titleStyle = {},\n      labelStyle = {},\n      m = { // Legend marks as references for updates\n        titles:  null,\n        symbols: null,\n        labels:  null,\n        gradient: null\n      };\n\n  var legend = {},\n      legendDef = {};\n\n  function reset() { legendDef.type = null; }\n  function ingest(d, i) { return {data: d, index: i} }\n\n  legend.def = function() {\n    var scale = size || shape || fill || stroke;\n    \n    format = !formatString ? null : ((scale.type === 'time')\n      ? d3.time.format(formatString)\n      : d3.format(formatString));\n    \n    if (!legendDef.type) {\n      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type)\n        ? quantDef(scale)\n        : ordinalDef(scale);      \n    }\n    legendDef.orient = orient;\n    legendDef.offset = offset;\n    legendDef.padding = padding;\n    return legendDef;\n  };\n\n  function discrete(type) {\n    return type===\"ordinal\" || type===\"quantize\"\n      || type===\"quantile\" || type===\"threshold\";\n  }\n\n  function ordinalDef(scale) {\n    var def = o_legend_def(size, shape, fill, stroke);\n\n    // generate data\n    var data = (values == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : values).map(ingest);\n    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n    \n    // determine spacing between legend entries\n    var fs, range, offset, pad=5, domain = d3.range(data.length);\n    if (size) {\n      range = data.map(function(x) { return Math.sqrt(size(x.data)); });\n      offset = d3.max(range);\n      range = range.reduce(function(a,b,i,z) {\n          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;\n          return (a[i] += b/2, a); }, [0]).map(Math.round);\n    } else {\n      offset = Math.round(Math.sqrt(config.legend.symbolSize));\n      range = spacing\n        || (fs = labelStyle.fontSize) && (fs.value + pad)\n        || (config.legend.labelFontSize + pad);\n      range = domain.map(function(d,i) {\n        return Math.round(offset/2 + i*range);\n      });\n    }\n\n    // account for padding and title size\n    var sz = padding, ts;\n    if (title) {\n      ts = titleStyle.fontSize;\n      sz += 5 + ((ts && ts.value) || config.legend.titleFontSize);\n    }\n    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;\n    \n    // build scale for label layout\n    var scale = {\n      name: \"legend\",\n      type: \"ordinal\",\n      points: true,\n      domain: domain,\n      range: range\n    };\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d) {\n      d.label = fmt(d.data);\n      d.offset = offset;\n    });\n    def.scales = [ scale ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return data; };\n    def.marks[2].from = def.marks[1].from;\n\n    return def;\n  }\n\n  function o_legend_def(size, shape, fill, stroke) {\n    // setup legend marks\n    var titles  = m.titles  || (m.titles  = vg_legendTitle()),\n        symbols = m.symbols || (m.symbols = vg_legendSymbols()),\n        labels  = m.labels  || (m.labels  = vg_vLegendLabels());\n\n    // extend legend marks\n    vg_legendSymbolExtend(symbols, size, shape, fill, stroke);\n    \n    // add / override custom style properties\n    dl.extend(titles.properties.update,  titleStyle);\n    dl.extend(symbols.properties.update, symbolStyle);\n    dl.extend(labels.properties.update,  labelStyle);\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    labels.properties.enter.x.offset += padding + 1;\n    symbols.properties.enter.x.offset = padding + 1;\n    labels.properties.update.x.offset += padding + 1;\n    symbols.properties.update.x.offset = padding + 1;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales:[], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  function quantDef(scale) {\n    var def = q_legend_def(scale),\n        dom = scale.domain(),\n        data = dom.map(ingest),\n        width = (gradientStyle.width && gradientStyle.width.value) || config.legend.gradientWidth,\n        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n\n    // build scale for label layout\n    var layout = {\n      name: \"legend\",\n      type: scale.type,\n      round: true,\n      zero: false,\n      domain: [dom[0], dom[dom.length-1]],\n      range: [padding, width+padding]\n    };\n    if (scale.type===\"pow\") layout.exponent = scale.exponent();\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d,i) {\n      d.label = fmt(d.data);\n      d.align = i==(data.length-1) ? \"right\" : i==0 ? \"left\" : \"center\";\n    });\n    def.scales = [ layout ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return [1]; };\n    def.marks[2].from = function() { return data; };\n    return def;\n  }\n  \n  function q_legend_def(scale) {\n    // setup legend marks\n    var titles = m.title || (m.title = vg_legendTitle()),\n        gradient = m.gradient || (m.gradient = vg_legendGradient()),\n        labels = m.labels || (m.labels = vg_hLegendLabels()),\n        grad = new Gradient();\n\n    // setup color gradient\n    var dom = scale.domain(),\n        min = dom[0],\n        max = dom[dom.length-1],\n        f = scale.copy().domain([min, max]).range([0,1]);\n        \n    var stops = (scale.type !== \"linear\" && scale.ticks)\n      ? scale.ticks.call(scale, 15) : dom;\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== stops[stops.length-1]) stops.push(max);\n\n    for (var i=0, n=stops.length; i<n; ++i) {\n      grad.stop(f(stops[i]), scale(stops[i]));\n    }\n    gradient.properties.enter.fill = {value: grad};\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update, titleStyle);\n    dl.extend(gradient.properties.update, gradientStyle);\n    dl.extend(labels.properties.update, labelStyle);\n\n    // account for gradient size\n    var gp = gradient.properties, gh = gradientStyle.height,\n        hh = (gh && gh.value) || gp.enter.height.value;\n    labels.properties.enter.y.value = hh;\n    labels.properties.update.y.value = hh;\n\n    // account for title size as needed\n    if (title) {\n      var tp = titles.properties, fs = titleStyle.fontSize,\n          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);\n      gradient.properties.enter.y.value += sz;\n      labels.properties.enter.y.value += sz;\n      gradient.properties.update.y.value += sz;\n      labels.properties.update.y.value += sz;\n    }\n    \n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    gradient.properties.enter.x.value += padding;\n    gradient.properties.enter.y.value += padding;\n    labels.properties.enter.y.value += padding;\n    gradient.properties.update.x.value += padding;\n    gradient.properties.update.y.value += padding;\n    labels.properties.update.y.value += padding;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales: [], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  legend.size = function(x) {\n    if (!arguments.length) return size;\n    if (size !== x) { size = x; reset(); }\n    return legend;\n  };\n\n  legend.shape = function(x) {\n    if (!arguments.length) return shape;\n    if (shape !== x) { shape = x; reset(); }\n    return legend;\n  };\n\n  legend.fill = function(x) {\n    if (!arguments.length) return fill;\n    if (fill !== x) { fill = x; reset(); }\n    return legend;\n  };\n  \n  legend.stroke = function(x) {\n    if (!arguments.length) return stroke;\n    if (stroke !== x) { stroke = x; reset(); }\n    return legend;\n  };\n\n  legend.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return legend;\n  };\n\n  legend.format = function(x) {\n    if (!arguments.length) return formatString;\n    if (formatString !== x) {\n      formatString = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.spacing = function(x) {\n    if (!arguments.length) return spacing;\n    if (spacing !== +x) { spacing = +x; reset(); }\n    return legend;\n  };\n\n  legend.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x in vg_legendOrients ? x + \"\" : config.legend.orient;\n    return legend;\n  };\n\n  legend.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = +x;\n    return legend;\n  };\n\n  legend.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return legend;\n  };\n\n  legend.legendProperties = function(x) {\n    if (!arguments.length) return legendStyle;\n    legendStyle = x;\n    return legend;\n  };\n\n  legend.symbolProperties = function(x) {\n    if (!arguments.length) return symbolStyle;\n    symbolStyle = x;\n    return legend;\n  };\n\n  legend.gradientProperties = function(x) {\n    if (!arguments.length) return gradientStyle;\n    gradientStyle = x;\n    return legend;\n  };\n\n  legend.labelProperties = function(x) {\n    if (!arguments.length) return labelStyle;\n    labelStyle = x;\n    return legend;\n  };\n  \n  legend.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    titleStyle = x;\n    return legend;\n  };\n\n  legend.reset = function() { reset(); };\n\n  return legend;\n};\n\nvar vg_legendOrients = {right: 1, left: 1};\n\nfunction vg_legendPosition(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item, gx,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      pad    = item.mark.def.padding * 2,\n      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),\n      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),\n      pos = group._legendPositions || \n        (group._legendPositions = {right: 0.5, left: 0.5});\n\n  o.x = 0.5;\n  o.width = lw;\n  o.y = pos[orient];\n  pos[orient] += (o.height = lh);\n\n  // HACK: use to estimate group bounds during animated transition\n  if (!trans && group.bounds) {\n    group.bounds.delta = group.bounds.x2 - group.width;\n  }\n\n  switch (orient) {\n    case \"left\":  {\n      gx = group.bounds ? group.bounds.x1 : 0;\n      o.x += gx - offset - lw;\n      break;\n    };\n    case \"right\": {\n      gx = group.width;\n      if (group.bounds) gx = trans\n        ? group.width + group.bounds.delta\n        : group.bounds.x2;\n      o.x += gx + offset;\n      break;\n    };\n  }\n  \n  if (trans) trans.interpolate(item, o);\n  var enc = item.mark.def.properties.enter.encode;\n  enc.call(enc, item, group, trans);\n}\n\nfunction vg_legendSymbolExtend(mark, size, shape, fill, stroke) {\n  var e = mark.properties.enter,\n      u = mark.properties.update;\n  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: \"data\"};\n  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: \"data\"};\n  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: \"data\"};\n  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: \"data\"};\n}\n\nfunction vg_legendTitle() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        fill: {value: cfg.titleColor},\n        font: {value: cfg.titleFont},\n        fontSize: {value: cfg.titleFontSize},\n        fontWeight: {value: cfg.titleFontWeight},\n        baseline: {value: \"top\"},\n        text: {field: \"data\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_legendSymbols() {\n  var cfg = config.legend;\n  return {\n    type: \"symbol\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        shape: {value: cfg.symbolShape},\n        size: {value: cfg.symbolSize},\n        stroke: {value: cfg.symbolColor},\n        strokeWidth: {value: cfg.symbolStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_vLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {value: cfg.labelAlign},\n        baseline: {value: cfg.labelBaseline},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        opacity: {value: 1},\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n      }\n    }\n  };\n}\n\nfunction vg_legendGradient() {\n  var cfg = config.legend;\n  return {\n    type: \"rect\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        width: {value: cfg.gradientWidth},\n        height: {value: cfg.gradientHeight},\n        stroke: {value: cfg.gradientStrokeColor},\n        strokeWidth: {value: cfg.gradientStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {value: 0},\n        y: {value: 0},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_hLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        dy: {value: 2},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {field: \"align\"},\n        baseline: {value: \"top\"},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nmodule.exports = lgnd;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../parse/mark\":49,\"../parse/properties\":54,\"../util/Gradient\":104,\"../util/config\":106,\"datalib\":20}],80:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/debug\":108,\"./GroupBy\":91,\"./Transform\":97,\"./measures\":102,\"datalib\":20}],81:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n\n},{\"../dataflow/Collector\":31,\"./Transform\":97}],82:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n\n},{\"../dataflow/tuple\":37,\"./Transform\":97,\"datalib\":20}],83:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;\n},{\"../dataflow/Collector\":31,\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/debug\":108,\"./Transform\":97}],84:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/debug\":108,\"./GroupBy\":91,\"./Transform\":97}],85:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n},{\"../dataflow/changeset\":36,\"../parse/expr\":46,\"../util/constants\":107,\"../util/debug\":108,\"./Transform\":97}],86:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/debug\":108,\"./Transform\":97}],87:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./Transform\":97}],88:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n},{\"../dataflow/tuple\":37,\"../parse/expr\":46,\"../util/constants\":107,\"../util/debug\":108,\"./Transform\":97}],89:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./Transform\":97,\"datalib\":20}],90:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./Geo\":89,\"./Transform\":97,\"datalib\":20}],91:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/constants\":107,\"./Transform\":97}],92:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n},{\"../dataflow/tuple\":37,\"./Transform\":97}],93:[function(require,module,exports){\nvar dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":46,\"../util/constants\":107,\"datalib\":20}],94:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./BatchTransform\":81,\"./Transform\":97,\"datalib\":20}],95:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;\n},{\"../parse/expr\":46,\"../util/debug\":108,\"./Transform\":97,\"datalib\":20}],96:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n},{\"../dataflow/tuple\":37,\"./BatchTransform\":81,\"./Transform\":97,\"datalib\":20}],97:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"../dataflow/Node\":34,\"../util/constants\":107,\"./Parameter\":93}],98:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./BatchTransform\":81,\"./Transform\":97,\"datalib\":20}],99:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;\n},{\"../dataflow/tuple\":37,\"../util/debug\":108,\"./GroupBy\":91,\"./Transform\":97}],100:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;\n},{\"../dataflow/Collector\":31,\"../util/debug\":108,\"./Transform\":97,\"datalib\":20}],101:[function(require,module,exports){\nmodule.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};\n},{\"./Aggregate\":80,\"./Bin\":82,\"./Cross\":83,\"./Facet\":84,\"./Filter\":85,\"./Fold\":86,\"./Force\":87,\"./Formula\":88,\"./Geo\":89,\"./GeoPath\":90,\"./LinkPath\":92,\"./Pie\":94,\"./Sort\":95,\"./Stack\":96,\"./Treemap\":98,\"./Unique\":99,\"./Zip\":100}],102:[function(require,module,exports){\nvar dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;\n},{\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/quickselect\":109,\"datalib\":20}],103:[function(require,module,exports){\nvar bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;\n},{}],104:[function(require,module,exports){\nvar vg_gradient_id = 0;\n\nfunction gradient(type) {\n  this.id = \"grad_\" + (vg_gradient_id++);\n  this.type = type || \"linear\";\n  this.stops = [];\n  this.x1 = 0;\n  this.x2 = 1;\n  this.y1 = 0;\n  this.y2 = 0;\n};\n\nvar prototype = gradient.prototype;\n\nprototype.stop = function(offset, color) {\n  this.stops.push({\n    offset: offset,\n    color: color\n  });\n  return this;\n};\n\nmodule.exports = gradient;\n},{}],105:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../util/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/path\":63,\"../util/Bounds\":103,\"./config\":106}],106:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],107:[function(require,module,exports){\nmodule.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n  LEGEND: \"legend\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};\n},{}],108:[function(require,module,exports){\nvar config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};\n},{\"./config\":106}],109:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};\n},{\"datalib\":20}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleCIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9jb2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2dyb3VwYnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL21lYXN1cmVzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9kc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90cmVlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90aW1lLXVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwic3JjL2NvcmUvSGVhZGxlc3NWaWV3LmpzIiwic3JjL2NvcmUvTW9kZWwuanMiLCJzcmMvY29yZS9WaWV3LmpzIiwic3JjL2RhdGFmbG93L0NvbGxlY3Rvci5qcyIsInNyYy9kYXRhZmxvdy9EYXRhc291cmNlLmpzIiwic3JjL2RhdGFmbG93L0dyYXBoLmpzIiwic3JjL2RhdGFmbG93L05vZGUuanMiLCJzcmMvZGF0YWZsb3cvU2lnbmFsLmpzIiwic3JjL2RhdGFmbG93L2NoYW5nZXNldC5qcyIsInNyYy9kYXRhZmxvdy90dXBsZS5qcyIsInNyYy9leHByZXNzaW9uL2NvZGVnZW4uanMiLCJzcmMvZXhwcmVzc2lvbi9jb25zdGFudHMuanMiLCJzcmMvZXhwcmVzc2lvbi9mdW5jdGlvbnMuanMiLCJzcmMvZXhwcmVzc2lvbi9pbmRleC5qcyIsInNyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsInNyYy9wYXJzZS9heGVzLmpzIiwic3JjL3BhcnNlL2RhdGEuanMiLCJzcmMvcGFyc2UvZXZlbnRzLmpzIiwic3JjL3BhcnNlL2V4cHIuanMiLCJzcmMvcGFyc2UvaW50ZXJhY3RvcnMuanMiLCJzcmMvcGFyc2UvbGVnZW5kcy5qcyIsInNyYy9wYXJzZS9tYXJrLmpzIiwic3JjL3BhcnNlL21hcmtzLmpzIiwic3JjL3BhcnNlL21vZGlmeS5qcyIsInNyYy9wYXJzZS9wYWRkaW5nLmpzIiwic3JjL3BhcnNlL3ByZWRpY2F0ZXMuanMiLCJzcmMvcGFyc2UvcHJvcGVydGllcy5qcyIsInNyYy9wYXJzZS9zaWduYWxzLmpzIiwic3JjL3BhcnNlL3NwZWMuanMiLCJzcmMvcGFyc2Uvc3RyZWFtcy5qcyIsInNyYy9wYXJzZS90cmFuc2Zvcm1zLmpzIiwic3JjL3JlbmRlci9jYW52YXMvSGFuZGxlci5qcyIsInNyYy9yZW5kZXIvY2FudmFzL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9jYW52YXMvaW5kZXguanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy5qcyIsInNyYy9yZW5kZXIvY2FudmFzL3BhdGguanMiLCJzcmMvcmVuZGVyL3N2Zy1oZWFkbGVzcy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvc3ZnLWhlYWRsZXNzL2luZGV4LmpzIiwic3JjL3JlbmRlci9zdmctaGVhZGxlc3Mvc3ZnLmpzIiwic3JjL3JlbmRlci9zdmcvSGFuZGxlci5qcyIsInNyYy9yZW5kZXIvc3ZnL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9zdmcvbWFya3MuanMiLCJzcmMvc2NlbmUvQm91bmRlci5qcyIsInNyYy9zY2VuZS9CdWlsZGVyLmpzIiwic3JjL3NjZW5lL0VuY29kZXIuanMiLCJzcmMvc2NlbmUvR3JvdXBCdWlsZGVyLmpzIiwic3JjL3NjZW5lL0l0ZW0uanMiLCJzcmMvc2NlbmUvU2NhbGUuanMiLCJzcmMvc2NlbmUvVHJhbnNpdGlvbi5qcyIsInNyYy9zY2VuZS9heGlzLmpzIiwic3JjL3NjZW5lL2xlZ2VuZC5qcyIsInNyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsInNyYy90cmFuc2Zvcm1zL0JhdGNoVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvQmluLmpzIiwic3JjL3RyYW5zZm9ybXMvQ3Jvc3MuanMiLCJzcmMvdHJhbnNmb3Jtcy9GYWNldC5qcyIsInNyYy90cmFuc2Zvcm1zL0ZpbHRlci5qcyIsInNyYy90cmFuc2Zvcm1zL0ZvbGQuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb3JjZS5qcyIsInNyYy90cmFuc2Zvcm1zL0Zvcm11bGEuanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW8uanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW9QYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvR3JvdXBCeS5qcyIsInNyYy90cmFuc2Zvcm1zL0xpbmtQYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvUGFyYW1ldGVyLmpzIiwic3JjL3RyYW5zZm9ybXMvUGllLmpzIiwic3JjL3RyYW5zZm9ybXMvU29ydC5qcyIsInNyYy90cmFuc2Zvcm1zL1N0YWNrLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJlZW1hcC5qcyIsInNyYy90cmFuc2Zvcm1zL1VuaXF1ZS5qcyIsInNyYy90cmFuc2Zvcm1zL1ppcC5qcyIsInNyYy90cmFuc2Zvcm1zL2luZGV4LmpzIiwic3JjL3RyYW5zZm9ybXMvbWVhc3VyZXMuanMiLCJzcmMvdXRpbC9Cb3VuZHMuanMiLCJzcmMvdXRpbC9HcmFkaWVudC5qcyIsInNyYy91dGlsL2JvdW5kc2NhbGMuanMiLCJzcmMvdXRpbC9jb25maWcuanMiLCJzcmMvdXRpbC9jb25zdGFudHMuanMiLCJzcmMvdXRpbC9kZWJ1Zy5qcyIsInNyYy91dGlsL3F1aWNrc2VsZWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvVEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2p1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29yZToge1xuICAgIFZpZXc6IHJlcXVpcmUoJy4vc3JjL2NvcmUvVmlldycpXG4gIH0sXG4gIGRhdGFmbG93OiB7XG4gICAgY2hhbmdlc2V0OiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBEYXRhc291cmNlOiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9EYXRhc291cmNlJyksXG4gICAgR3JhcGg6IHJlcXVpcmUoJy4vc3JjL2RhdGFmbG93L0dyYXBoJyksXG4gICAgTm9kZTogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvTm9kZScpXG4gIH0sXG4gIHBhcnNlOiB7XG4gICAgc3BlYzogcmVxdWlyZSgnLi9zcmMvcGFyc2Uvc3BlYycpXG4gIH0sXG4gIHNjZW5lOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi9zcmMvc2NlbmUvQnVpbGRlcicpLFxuICAgIEdyb3VwQnVpbGRlcjogcmVxdWlyZSgnLi9zcmMvc2NlbmUvR3JvdXBCdWlsZGVyJylcbiAgfSxcbiAgdHJhbnNmb3JtczogcmVxdWlyZSgnLi9zcmMvdHJhbnNmb3Jtcy9pbmRleCcpLFxuICBjb25maWc6IHJlcXVpcmUoJy4vc3JjL3V0aWwvY29uZmlnJyksXG4gIHV0aWw6IHJlcXVpcmUoJ2RhdGFsaWInKVxufTsiLG51bGwsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgICBNZWFzdXJlcyA9IHJlcXVpcmUoJy4vbWVhc3VyZXMnKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL2NvbGxlY3RvcicpO1xuXG5mdW5jdGlvbiBBZ2dyZWdhdG9yKCkge1xuICB0aGlzLl9jZWxscyA9IHt9O1xuICB0aGlzLl9hZ2dyID0gW107XG4gIHRoaXMuX3N0cmVhbSA9IGZhbHNlO1xufVxuXG52YXIgRmxhZ3MgPSBBZ2dyZWdhdG9yLkZsYWdzID0ge1xuICBBRERfQ0VMTDogMSxcbiAgTU9EX0NFTEw6IDJcbn07XG5cbnZhciBwcm90byA9IEFnZ3JlZ2F0b3IucHJvdG90eXBlO1xuXG4vLyBQYXJhbWV0ZXJzXG5cbnByb3RvLnN0cmVhbSA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKHYgPT0gbnVsbCkgcmV0dXJuIHRoaXMuX3N0cmVhbTtcbiAgdGhpcy5fc3RyZWFtID0gISF2O1xuICB0aGlzLl9hZ2dyID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8ga2V5IGFjY2Vzc29yIHRvIHVzZSBmb3Igc3RyZWFtaW5nIHJlbW92ZXNcbnByb3RvLmtleSA9IGZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ID09IG51bGwpIHJldHVybiB0aGlzLl9rZXk7XG4gIHRoaXMuX2tleSA9IHV0aWwuJChrZXkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIElucHV0OiBhcnJheSBvZiBvYmplY3RzIG9mIHRoZSBmb3JtXG4vLyB7bmFtZTogc3RyaW5nLCBnZXQ6IGZ1bmN0aW9ufVxucHJvdG8uZ3JvdXBieSA9IGZ1bmN0aW9uKGRpbXMpIHtcbiAgdGhpcy5fZGltcyA9IHV0aWwuYXJyYXkoZGltcykubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICBkID0gdXRpbC5pc1N0cmluZyhkKSA/IHtuYW1lOiBkLCBnZXQ6IHV0aWwuJChkKX1cbiAgICAgIDogdXRpbC5pc0Z1bmN0aW9uKGQpID8ge25hbWU6IHV0aWwubmFtZShkKSB8fCBkLm5hbWUgfHwgKCdfJyArIGkpLCBnZXQ6IGR9XG4gICAgICA6IChkLm5hbWUgJiYgdXRpbC5pc0Z1bmN0aW9uKGQuZ2V0KSkgPyBkIDogbnVsbDtcbiAgICBpZiAoZCA9PSBudWxsKSB0aHJvdyAnSW52YWxpZCBncm91cGJ5IGFyZ3VtZW50OiAnICsgZDtcbiAgICByZXR1cm4gZDtcbiAgfSk7XG4gIHJldHVybiB0aGlzLmNsZWFyKCk7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgb3BzOiBbc3RyaW5nLCAuLi5dfVxucHJvdG8uc3VtbWFyaXplID0gZnVuY3Rpb24oZmllbGRzKSB7XG4gIGZpZWxkcyA9IHN1bW1hcml6ZV9hcmdzKGZpZWxkcyk7XG4gIHRoaXMuX2NvdW50ID0gdHJ1ZTtcbiAgdmFyIGFnZ3IgPSAodGhpcy5fYWdnciA9IFtdKSxcbiAgICAgIG0sIGYsIGksIGosIG9wLCBhcywgZ2V0O1xuXG4gIGZvciAoaT0wOyBpPGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgIGZvciAoaj0wLCBtPVtdLCBmPWZpZWxkc1tpXTsgajxmLm9wcy5sZW5ndGg7ICsraikge1xuICAgICAgb3AgPSBmLm9wc1tqXTtcbiAgICAgIGlmIChvcCAhPT0gJ2NvdW50JykgdGhpcy5fY291bnQgPSBmYWxzZTtcbiAgICAgIGFzID0gKGYuYXMgJiYgZi5hc1tqXSkgfHwgKG9wICsgKGYubmFtZT09PScqJyA/ICcnIDogJ18nK2YubmFtZSkpO1xuICAgICAgbS5wdXNoKE1lYXN1cmVzW29wXShhcykpO1xuICAgIH1cbiAgICBnZXQgPSBmLmdldCAmJiB1dGlsLiQoZi5nZXQpIHx8XG4gICAgICAoZi5uYW1lID09PSAnKicgPyB1dGlsLmlkZW50aXR5IDogdXRpbC4kKGYubmFtZSkpO1xuICAgIGFnZ3IucHVzaCh7XG4gICAgICBuYW1lOiBmLm5hbWUsXG4gICAgICBtZWFzdXJlczogTWVhc3VyZXMuY3JlYXRlKFxuICAgICAgICBtLFxuICAgICAgICB0aGlzLl9zdHJlYW0sIC8vIHN0cmVhbWluZyByZW1vdmUgZmxhZ1xuICAgICAgICBnZXQsICAgICAgICAgIC8vIGlucHV0IHR1cGxlIGdldHRlclxuICAgICAgICB0aGlzLl9hc3NpZ24pIC8vIG91dHB1dCB0dXBsZSBzZXR0ZXJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcy5jbGVhcigpO1xufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHN1bW1hcml6ZSBieSBjb3VudFxucHJvdG8uY291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuc3VtbWFyaXplKHsnKic6J2NvdW50J30pO1xufTtcblxuLy8gT3ZlcnJpZGUgdG8gcGVyZm9ybSBjdXN0b20gdHVwbGUgdmFsdWUgYXNzaWdubWVudFxucHJvdG8uX2Fzc2lnbiA9IGZ1bmN0aW9uKG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcbiAgb2JqZWN0W25hbWVdID0gdmFsdWU7XG59O1xuXG5mdW5jdGlvbiBzdW1tYXJpemVfYXJncyhmaWVsZHMpIHtcbiAgaWYgKHV0aWwuaXNBcnJheShmaWVsZHMpKSB7IHJldHVybiBmaWVsZHM7IH1cbiAgaWYgKGZpZWxkcyA9PSBudWxsKSB7IHJldHVybiBbXTsgfVxuICB2YXIgYSA9IFtdLCBuYW1lLCBvcHM7XG4gIGZvciAobmFtZSBpbiBmaWVsZHMpIHtcbiAgICBvcHMgPSB1dGlsLmFycmF5KGZpZWxkc1tuYW1lXSk7XG4gICAgYS5wdXNoKHtuYW1lOiBuYW1lLCBvcHM6IG9wc30pO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vLyBDZWxsIE1hbmFnZW1lbnRcblxucHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl9jZWxscyA9IHt9LCB0aGlzKTtcbn07XG5cbnByb3RvLl9jZWxsa2V5ID0gZnVuY3Rpb24oeCkge1xuICB2YXIgZCA9IHRoaXMuX2RpbXMsXG4gICAgICBuID0gZC5sZW5ndGgsIGksXG4gICAgICBrID0gU3RyaW5nKGRbMF0uZ2V0KHgpKTtcbiAgZm9yIChpPTE7IGk8bjsgKytpKSB7XG4gICAgayArPSAnfCcgKyBkW2ldLmdldCh4KTtcbiAgfVxuICByZXR1cm4gaztcbn07XG5cbnByb3RvLl9jZWxsID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5ID0gdGhpcy5fZGltcy5sZW5ndGggPyB0aGlzLl9jZWxsa2V5KHgpIDogJyc7XG4gIHJldHVybiB0aGlzLl9jZWxsc1trZXldIHx8ICh0aGlzLl9jZWxsc1trZXldID0gdGhpcy5fbmV3Y2VsbCh4KSk7XG59O1xuXG5wcm90by5fbmV3Y2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSB7XG4gICAgbnVtOiAgIDAsXG4gICAgdHVwbGU6IHRoaXMuX25ld3R1cGxlKHgpLFxuICAgIGZsYWc6ICBGbGFncy5BRERfQ0VMTCxcbiAgICBhZ2dzOiAge31cbiAgfTtcblxuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG4gIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXSA9IG5ldyBhZ2dyW2ldLm1lYXN1cmVzKGNlbGwsIGNlbGwudHVwbGUpO1xuICB9XG4gIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICBjZWxsLmRhdGEgPSBuZXcgQ29sbGVjdG9yKHRoaXMuX2tleSk7XG4gIH1cbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fbmV3dHVwbGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgIHQgPSB7fSwgaSwgbjtcbiAgZm9yIChpPTAsIG49ZGltcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdFtkaW1zW2ldLm5hbWVdID0gZGltc1tpXS5nZXQoeCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2luZ2VzdCh0KTtcbn07XG5cbi8vIE92ZXJyaWRlIHRvIHBlcmZvcm0gY3VzdG9tIHR1cGxlIGluZ2VzdGlvblxucHJvdG8uX2luZ2VzdCA9IHV0aWwuaWRlbnRpdHk7XG5cbi8vIFByb2Nlc3MgVHVwbGVzXG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGNlbGwubnVtICs9IDE7XG4gIGlmICghdGhpcy5fY291bnQpIHsgLy8gc2tpcCBpZiBjb3VudC1vbmx5XG4gICAgaWYgKGNlbGwuY29sbGVjdCkgY2VsbC5kYXRhLmFkZCh4KTtcbiAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXS5hZGQoeCk7XG4gICAgfVxuICB9XG4gIGNlbGwuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbn07XG5cbnByb3RvLl9yZW0gPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuXG4gIGNlbGwubnVtIC09IDE7XG4gIGlmICghdGhpcy5fY291bnQpIHsgLy8gc2tpcCBpZiBjb3VudC1vbmx5XG4gICAgaWYgKGNlbGwuY29sbGVjdCkgY2VsbC5kYXRhLnJlbSh4KTtcbiAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICBjZWxsLmFnZ3NbYWdncltpXS5uYW1lXS5yZW0oeCk7XG4gICAgfVxuICB9XG4gIGNlbGwuZmxhZyB8PSBGbGFncy5NT0RfQ0VMTDtcbn07XG5cbnByb3RvLl9tb2QgPSBmdW5jdGlvbihjdXJyLCBwcmV2KSB7XG4gIHZhciBjZWxsMCA9IHRoaXMuX2NlbGwocHJldiksXG4gICAgICBjZWxsMSA9IHRoaXMuX2NlbGwoY3VyciksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBpZiAoY2VsbDAgIT09IGNlbGwxKSB7XG4gICAgY2VsbDAubnVtIC09IDE7XG4gICAgY2VsbDEubnVtICs9IDE7XG4gICAgaWYgKGNlbGwwLmNvbGxlY3QpIGNlbGwwLmRhdGEucmVtKHByZXYpO1xuICAgIGlmIChjZWxsMS5jb2xsZWN0KSBjZWxsMS5kYXRhLmFkZChjdXJyKTtcbiAgfSBlbHNlIGlmIChjZWxsMC5jb2xsZWN0ICYmICF1dGlsLmlzT2JqZWN0KGN1cnIpKSB7XG4gICAgY2VsbDAuZGF0YS5yZW0ocHJldik7XG4gICAgY2VsbDAuZGF0YS5hZGQoY3Vycik7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbDAuYWdnc1thZ2dyW2ldLm5hbWVdLnJlbShwcmV2KTtcbiAgICBjZWxsMS5hZ2dzW2FnZ3JbaV0ubmFtZV0uYWRkKGN1cnIpO1xuICB9XG4gIGNlbGwwLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG4gIGNlbGwxLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG59O1xuXG5wcm90by5yZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZiAoY2VsbC5udW0gPiAwKSB7XG4gICAgICBpZiAoY2VsbC5jb2xsZWN0KSB7XG4gICAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9XG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnByb3RvLmNoYW5nZXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNoYW5nZXMgPSB7YWRkOltdLCByZW06W10sIG1vZDpbXX0sXG4gICAgICBhZ2dyID0gdGhpcy5fYWdncixcbiAgICAgIGNlbGwsIGZsYWcsIGksIGs7XG5cbiAgZm9yIChrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGZsYWcgPSBjZWxsLmZsYWc7XG5cbiAgICAvLyBjb25zb2xpZGF0ZSBjb2xsZWN0b3IgdmFsdWVzXG4gICAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgICAgY2VsbC5kYXRhLnZhbHVlcygpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgfVxuXG4gICAgLy8gb3JnYW5pemUgb3V0cHV0IHR1cGxlc1xuICAgIGlmIChjZWxsLm51bSA8PSAwKSB7XG4gICAgICBpZiAoZmxhZyA9PT0gRmxhZ3MuTU9EX0NFTEwpIHtcbiAgICAgICAgY2hhbmdlcy5yZW0ucHVzaChjZWxsLnR1cGxlKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLl9jZWxsc1trXTtcbiAgICB9IGVsc2UgaWYgKGZsYWcgJiBGbGFncy5BRERfQ0VMTCkge1xuICAgICAgY2hhbmdlcy5hZGQucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9IGVsc2UgaWYgKGZsYWcgJiBGbGFncy5NT0RfQ0VMTCkge1xuICAgICAgY2hhbmdlcy5tb2QucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9XG5cbiAgICBjZWxsLmZsYWcgPSAwO1xuICB9XG5cbiAgdGhpcy5fcmVtcyA9IGZhbHNlO1xuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbnByb3RvLmV4ZWN1dGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICByZXR1cm4gdGhpcy5jbGVhcigpLmluc2VydChpbnB1dCkucmVzdWx0KCk7XG59O1xuXG5wcm90by5pbnNlcnQgPSBmdW5jdGlvbihpbnB1dCkge1xuICB0aGlzLl9jb25zb2xpZGF0ZSgpO1xuICBmb3IgKHZhciBpPTA7IGk8aW5wdXQubGVuZ3RoOyArK2kpIHtcbiAgICB0aGlzLl9hZGQoaW5wdXRbaV0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYgKCF0aGlzLl9zdHJlYW0pIHtcbiAgICB0aHJvdyAnQWdncmVnYXRvciBub3QgY29uZmlndXJlZCBmb3Igc3RyZWFtaW5nIHJlbW92ZXMuJyArXG4gICAgICAnIENhbGwgc3RyZWFtKHRydWUpIHByaW9yIHRvIGNhbGxpbmcgc3VtbWFyaXplLic7XG4gIH1cbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fcmVtKGlucHV0W2ldKTtcbiAgfVxuICB0aGlzLl9yZW1zID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBjb25zb2xpZGF0ZSByZW1vdmFsc1xucHJvdG8uX2NvbnNvbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5fcmVtcykgcmV0dXJuO1xuICBmb3IgKHZhciBrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgaWYgKHRoaXMuX2NlbGxzW2tdLmNvbGxlY3QpIHtcbiAgICAgIHRoaXMuX2NlbGxzW2tdLmRhdGEudmFsdWVzKCk7XG4gICAgfVxuICB9XG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRvcjsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4uL3N0YXRzJyk7XG5cbnZhciBSRU0gPSAnJCFfcmVtXyEjJztcblxuZnVuY3Rpb24gQ29sbGVjdG9yKGtleSkge1xuICB0aGlzLl9hZGQgPSBbXTtcbiAgdGhpcy5fcmVtID0gW107XG4gIHRoaXMuX2tleSA9IGtleSB8fCBudWxsO1xuICB0aGlzLl9sYXN0ID0gbnVsbDtcbn1cblxudmFyIHByb3RvID0gQ29sbGVjdG9yLnByb3RvdHlwZTtcblxucHJvdG8uYWRkID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9hZGQucHVzaCh2KTtcbn07XG5cbnByb3RvLnJlbSA9IGZ1bmN0aW9uKHYpIHtcbiAgdGhpcy5fcmVtLnB1c2godik7XG59O1xuXG5wcm90by52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3JlbS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9hZGQ7XG4gIHZhciBhID0gdGhpcy5fYWRkLFxuICAgICAgciA9IHRoaXMuX3JlbSxcbiAgICAgIGsgPSB0aGlzLl9rZXksXG4gICAgICB4ID0gQXJyYXkoYS5sZW5ndGggLSByLmxlbmd0aCksXG4gICAgICBpLCBqLCBuO1xuXG4gIGlmIChrKSB7XG4gICAgLy8gaGFzIHVuaXF1ZSBrZXkgZmllbGQsIHVzZSB0aGF0XG4gICAgdmFyIGx1dCA9IHV0aWwudG9NYXAociwgayk7XG4gICAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmICghbHV0Lmhhc093blByb3BlcnR5KGsoYVtpXSkpKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoclswXSkpIHtcbiAgICAvLyBwcm9jZXNzIGNvbGxlY3Rpb24gb2YgcmF3IHZhbHVlc1xuICAgIHZhciBtID0gc3RhdHMuY291bnQubWFwKHIpO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAobVthW2ldXSA+IDApIHtcbiAgICAgICAgbVthW2ldXSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFtqKytdID0gYVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdW5pcXVlIGtleSwgbWFyayB0dXBsZXMgZGlyZWN0bHlcbiAgICBmb3IgKGk9MCwgbj1yLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIHJbaV1bUkVNXSA9IDE7XG4gICAgfVxuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIWFbaV1bUkVNXSkgeyB4W2orK10gPSBhW2ldOyB9XG4gICAgfVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZGVsZXRlIHJbaV1bUkVNXTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fZiA9IG51bGw7XG4gIHJldHVybiAodGhpcy5fYWRkID0geCk7XG59O1xuXG4vLyBtZW1vaXppbmcgc3RhdGlzdGljcyBtZXRob2RzXG5cbnByb3RvLmV4dGVudCA9IGZ1bmN0aW9uKGdldCkge1xuICBpZiAodGhpcy5fZiAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIGkgPSBzdGF0cy5leHRlbnQuaW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZiA9IGdldDsgICAgXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V4dDtcbn07XG5cbnByb3RvLmFyZ21pbiA9IGZ1bmN0aW9uKGYpIHtcbiAgcmV0dXJuIHRoaXMuZXh0ZW50KGYpWzBdO1xufTtcblxucHJvdG8uYXJnbWF4ID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gdGhpcy5leHRlbnQoZilbMV07XG59O1xuXG5wcm90by5taW4gPSBmdW5jdGlvbihmKSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZilbMF07XG4gIHJldHVybiBtID8gZihtKSA6ICtJbmZpbml0eTtcbn07XG5wcm90by5tYXggPSBmdW5jdGlvbihmKSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZilbMV07XG4gIHJldHVybiBtID8gZihtKSA6IC1JbmZpbml0eTtcbn07XG5cbnByb3RvLnF1YXJ0aWxlID0gZnVuY3Rpb24oZ2V0KSB7XG4gIGlmICh0aGlzLl9mICE9PSBnZXQgfHwgIXRoaXMuX3EpIHtcbiAgICB0aGlzLl9xID0gc3RhdHMucXVhcnRpbGUodGhpcy52YWx1ZXMoKSwgZ2V0KTtcbiAgICB0aGlzLl9mID0gZ2V0OyAgICBcbiAgfVxuICByZXR1cm4gdGhpcy5fcTtcbn07XG5cbnByb3RvLnExID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShmKVswXTtcbn07XG5cbnByb3RvLnEyID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShmKVsxXTtcbn07XG5cbnByb3RvLnEzID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShmKVsyXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdG9yOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIEFnZ3JlZ2F0b3IgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gZmxhdHRlbiBhcmd1bWVudHMgaW50byBhIHNpbmdsZSBhcnJheVxuICB2YXIgYXJncyA9IFtdLnJlZHVjZS5jYWxsKGFyZ3VtZW50cywgZnVuY3Rpb24oYSwgeCkge1xuICAgIHJldHVybiBhLmNvbmNhdCh1dGlsLmFycmF5KHgpKTtcbiAgfSwgW10pO1xuICAvLyBjcmVhdGUgYW5kIHJldHVybiBhbiBhZ2dyZWdhdG9yXG4gIHJldHVybiBuZXcgQWdncmVnYXRvcigpXG4gICAgLmdyb3VwYnkoYXJncylcbiAgICAuc3VtbWFyaXplKHsnKic6J3ZhbHVlcyd9KTtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIHR5cGVzID0ge1xuICAndmFsdWVzJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbHVlcycsXG4gICAgaW5pdDogJ2NlbGwuY29sbGVjdCA9IHRydWU7JyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnZhbHVlcygpJywgaWR4OiAtMVxuICB9KSxcbiAgJ2NvdW50JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2NvdW50JyxcbiAgICBzZXQ6ICAnY2VsbC5udW0nXG4gIH0pLFxuICAnbWlzc2luZyc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaXNzaW5nJyxcbiAgICBzZXQ6ICAndGhpcy5taXNzaW5nJ1xuICB9KSxcbiAgJ3ZhbGlkJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhbGlkJyxcbiAgICBzZXQ6ICAndGhpcy52YWxpZCdcbiAgfSksXG4gICdzdW0nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3VtJyxcbiAgICBpbml0OiAndGhpcy5zdW0gPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuc3VtICs9IHY7JyxcbiAgICByZW06ICAndGhpcy5zdW0gLT0gdjsnLFxuICAgIHNldDogICd0aGlzLnN1bSdcbiAgfSksXG4gICdtZWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lYW4nLFxuICAgIGluaXQ6ICd0aGlzLm1lYW4gPSAwOycsXG4gICAgYWRkOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuICs9IGQgLyB0aGlzLnZhbGlkOycsXG4gICAgcmVtOiAgJ3ZhciBkID0gdiAtIHRoaXMubWVhbjsgdGhpcy5tZWFuIC09IGQgLyB0aGlzLnZhbGlkOycsXG4gICAgc2V0OiAgJ3RoaXMubWVhbidcbiAgfSksXG4gICdhdmVyYWdlJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ2F2ZXJhZ2UnLFxuICAgIHNldDogICd0aGlzLm1lYW4nLFxuICAgIHJlcTogIFsnbWVhbiddLCBpZHg6IDFcbiAgfSksXG4gICd2YXJpYW5jZSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YXJpYW5jZScsXG4gICAgaW5pdDogJ3RoaXMuZGV2ID0gMDsnLFxuICAgIGFkZDogICd0aGlzLmRldiArPSBkICogKHYgLSB0aGlzLm1lYW4pOycsXG4gICAgcmVtOiAgJ3RoaXMuZGV2IC09IGQgKiAodiAtIHRoaXMubWVhbik7JyxcbiAgICBzZXQ6ICAndGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKScsXG4gICAgcmVxOiAgWydtZWFuJ10sIGlkeDogMVxuICB9KSxcbiAgJ3ZhcmlhbmNlcCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICd2YXJpYW5jZXAnLFxuICAgIHNldDogICd0aGlzLmRldiAvIHRoaXMudmFsaWQnLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnc3RkZXYnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3RkZXYnLFxuICAgIHNldDogICdNYXRoLnNxcnQodGhpcy5kZXYgLyAodGhpcy52YWxpZC0xKSknLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnc3RkZXZwJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3N0ZGV2cCcsXG4gICAgc2V0OiAgJ01hdGguc3FydCh0aGlzLmRldiAvIHRoaXMudmFsaWQpJyxcbiAgICByZXE6ICBbJ3ZhcmlhbmNlJ10sIGlkeDogMlxuICB9KSxcbiAgJ21lZGlhbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtZWRpYW4nLFxuICAgIHNldDogICdjZWxsLmRhdGEucTIodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdxMSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdxMScsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMSh0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ3EzJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3EzJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnEzKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAnZGlzdGluY3QnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnZGlzdGluY3QnLFxuICAgIHNldDogICd0aGlzLmRpc3RpbmN0KGNlbGwuZGF0YS52YWx1ZXMoKSwgdGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdhcmdtaW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXJnbWluJyxcbiAgICBhZGQ6ICAnaWYgKHYgPCB0aGlzLm1pbikgdGhpcy5hcmdtaW4gPSB0OycsXG4gICAgcmVtOiAgJ2lmICh2IDw9IHRoaXMubWluKSB0aGlzLmFyZ21pbiA9IG51bGw7JyxcbiAgICBzZXQ6ICAndGhpcy5hcmdtaW4gPSB0aGlzLmFyZ21pbiB8fCBjZWxsLmRhdGEuYXJnbWluKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWydtaW4nXSwgc3RyOiBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdhcmdtYXgnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXJnbWF4JyxcbiAgICBhZGQ6ICAnaWYgKHYgPiB0aGlzLm1heCkgdGhpcy5hcmdtYXggPSB0OycsXG4gICAgcmVtOiAgJ2lmICh2ID49IHRoaXMubWF4KSB0aGlzLmFyZ21heCA9IG51bGw7JyxcbiAgICBzZXQ6ICAndGhpcy5hcmdtYXggPSB0aGlzLmFyZ21heCB8fCBjZWxsLmRhdGEuYXJnbWF4KHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWydtYXgnXSwgc3RyOiBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdtaW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWluJyxcbiAgICBpbml0OiAndGhpcy5taW4gPSArSW5maW5pdHk7JyxcbiAgICBhZGQ6ICAnaWYgKHYgPCB0aGlzLm1pbikgdGhpcy5taW4gPSB2OycsXG4gICAgcmVtOiAgJ2lmICh2IDw9IHRoaXMubWluKSB0aGlzLm1pbiA9IE5hTjsnLFxuICAgIHNldDogICd0aGlzLm1pbiA9IChpc05hTih0aGlzLm1pbikgPyBjZWxsLmRhdGEubWluKHRoaXMuZ2V0KSA6IHRoaXMubWluKScsXG4gICAgc3RyOiAgWyd2YWx1ZXMnXSwgaWR4OiA0XG4gIH0pLFxuICAnbWF4JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21heCcsXG4gICAgaW5pdDogJ3RoaXMubWF4ID0gLUluZmluaXR5OycsXG4gICAgYWRkOiAgJ2lmICh2ID4gdGhpcy5tYXgpIHRoaXMubWF4ID0gdjsnLFxuICAgIHJlbTogICdpZiAodiA+PSB0aGlzLm1heCkgdGhpcy5tYXggPSBOYU47JyxcbiAgICBzZXQ6ICAndGhpcy5tYXggPSAoaXNOYU4odGhpcy5tYXgpID8gY2VsbC5kYXRhLm1heCh0aGlzLmdldCkgOiB0aGlzLm1heCknLFxuICAgIHN0cjogIFsndmFsdWVzJ10sIGlkeDogNFxuICB9KSxcbiAgJ21vZGVza2V3JzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21vZGVza2V3JyxcbiAgICBzZXQ6ICAndGhpcy5kZXY9PT0wID8gMCA6ICh0aGlzLm1lYW4gLSBjZWxsLmRhdGEucTIodGhpcy5nZXQpKSAvIE1hdGguc3FydCh0aGlzLmRldi8odGhpcy52YWxpZC0xKSknLFxuICAgIHJlcTogIFsnbWVhbicsICdzdGRldicsICdtZWRpYW4nXSwgaWR4OiA1XG4gIH0pXG59O1xuXG5mdW5jdGlvbiBtZWFzdXJlKGJhc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCkge1xuICAgIHZhciBtID0gdXRpbC5leHRlbmQoe2luaXQ6JycsIGFkZDonJywgcmVtOicnLCBpZHg6MH0sIGJhc2UpO1xuICAgIG0ub3V0ID0gb3V0IHx8IGJhc2UubmFtZTtcbiAgICByZXR1cm4gbTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShhZ2csIHN0cmVhbSkge1xuICBmdW5jdGlvbiBjb2xsZWN0KG0sIGEpIHtcbiAgICBmdW5jdGlvbiBoZWxwZXIocikgeyBpZiAoIW1bcl0pIGNvbGxlY3QobSwgbVtyXSA9IHR5cGVzW3JdKCkpOyB9XG4gICAgaWYgKGEucmVxKSBhLnJlcS5mb3JFYWNoKGhlbHBlcik7XG4gICAgaWYgKHN0cmVhbSAmJiBhLnN0cikgYS5zdHIuZm9yRWFjaChoZWxwZXIpO1xuICAgIHJldHVybiBtO1xuICB9XG4gIHZhciBtYXAgPSBhZ2cucmVkdWNlKFxuICAgIGNvbGxlY3QsXG4gICAgYWdnLnJlZHVjZShmdW5jdGlvbihtLCBhKSB7IHJldHVybiAobVthLm5hbWVdID0gYSwgbSk7IH0sIHt9KVxuICApO1xuICByZXR1cm4gdXRpbC52YWxzKG1hcCkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmlkeCAtIGIuaWR4OyB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKGFnZywgc3RyZWFtLCBhY2Nlc3NvciwgbXV0YXRvcikge1xuICB2YXIgYWxsID0gcmVzb2x2ZShhZ2csIHN0cmVhbSksXG4gICAgICBjdHIgPSAndGhpcy5jZWxsID0gY2VsbDsgdGhpcy50dXBsZSA9IHQ7IHRoaXMudmFsaWQgPSAwOyB0aGlzLm1pc3NpbmcgPSAwOycsXG4gICAgICBhZGQgPSAnaWYgKHY9PW51bGwpIHRoaXMubWlzc2luZysrOyBpZiAoIXRoaXMuaXNWYWxpZCh2KSkgcmV0dXJuOyB0aGlzLnZhbGlkKys7JyxcbiAgICAgIHJlbSA9ICdpZiAodj09bnVsbCkgdGhpcy5taXNzaW5nLS07IGlmICghdGhpcy5pc1ZhbGlkKHYpKSByZXR1cm47IHRoaXMudmFsaWQtLTsnLFxuICAgICAgc2V0ID0gJ3ZhciB0ID0gdGhpcy50dXBsZTsgdmFyIGNlbGwgPSB0aGlzLmNlbGw7JztcblxuICBhbGwuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgaWYgKGEuaWR4IDwgMCkge1xuICAgICAgY3RyID0gYS5pbml0ICsgY3RyO1xuICAgICAgYWRkID0gYS5hZGQgKyBhZGQ7XG4gICAgICByZW0gPSBhLnJlbSArIHJlbTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3RyICs9IGEuaW5pdDtcbiAgICAgIGFkZCArPSBhLmFkZDtcbiAgICAgIHJlbSArPSBhLnJlbTtcbiAgICB9XG4gIH0pO1xuICBhZ2cuc2xpY2UoKVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pXG4gICAgLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgc2V0ICs9ICd0aGlzLmFzc2lnbih0LFxcJycrYS5vdXQrJ1xcJywnK2Euc2V0KycpOyc7XG4gICAgfSk7XG4gIHNldCArPSAncmV0dXJuIHQ7JztcblxuICAvKiBqc2hpbnQgZXZpbDogdHJ1ZSAqL1xuICBjdHIgPSBGdW5jdGlvbignY2VsbCcsICd0JywgY3RyKTtcbiAgY3RyLnByb3RvdHlwZS5hc3NpZ24gPSBtdXRhdG9yO1xuICBjdHIucHJvdG90eXBlLmFkZCA9IEZ1bmN0aW9uKCd0JywgJ3ZhciB2ID0gdGhpcy5nZXQodCk7JyArIGFkZCk7XG4gIGN0ci5wcm90b3R5cGUucmVtID0gRnVuY3Rpb24oJ3QnLCAndmFyIHYgPSB0aGlzLmdldCh0KTsnICsgcmVtKTtcbiAgY3RyLnByb3RvdHlwZS5zZXQgPSBGdW5jdGlvbihzZXQpO1xuICBjdHIucHJvdG90eXBlLmdldCA9IGFjY2Vzc29yO1xuICBjdHIucHJvdG90eXBlLm1vZCA9IG1vZDtcbiAgY3RyLnByb3RvdHlwZS5kaXN0aW5jdCA9IHJlcXVpcmUoJy4uL3N0YXRzJykuY291bnQuZGlzdGluY3Q7XG4gIGN0ci5wcm90b3R5cGUuaXNWYWxpZCA9IHV0aWwuaXNWYWxpZDtcbiAgcmV0dXJuIGN0cjtcbn1cblxuZnVuY3Rpb24gbW9kKHZfbmV3LCB2X29sZCkge1xuICBpZiAodl9vbGQgPT09IHVuZGVmaW5lZCB8fCB2X29sZCA9PT0gdl9uZXcpIHJldHVybjtcbiAgdGhpcy5yZW0odl9vbGQpO1xuICB0aGlzLmFkZCh2X25ldyk7XG59XG5cbnR5cGVzLmNyZWF0ZSA9IGNyZWF0ZTtcbm1vZHVsZS5leHBvcnRzID0gdHlwZXM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgdW5pdHMgPSByZXF1aXJlKCcuLi90aW1lLXVuaXRzJyk7XG52YXIgRVBTSUxPTiA9IDFlLTE1O1xuXG5mdW5jdGlvbiBiaW5zKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXApIHtcbiAgICAvLyBpZiBzdGVwIHNpemUgaXMgZXhwbGljaXRseSBnaXZlbiwgdXNlIHRoYXRcbiAgICBzdGVwID0gb3B0LnN0ZXA7XG4gIH0gZWxzZSBpZiAob3B0LnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICBzdGVwID0gb3B0LnN0ZXBzW01hdGgubWluKFxuICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICBiaXNlY3Qob3B0LnN0ZXBzLCBzcGFuL21heGIsIDAsIG9wdC5zdGVwcy5sZW5ndGgpXG4gICAgKV07XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSB1c2Ugc3BhbiB0byBkZXRlcm1pbmUgc3RlcCBzaXplXG4gICAgbGV2ZWwgPSBNYXRoLmNlaWwoTWF0aC5sb2cobWF4YikgLyBsb2diKTtcbiAgICBtaW5zdGVwID0gb3B0Lm1pbnN0ZXAgfHwgMDtcbiAgICBzdGVwID0gTWF0aC5tYXgoXG4gICAgICBtaW5zdGVwLFxuICAgICAgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpXG4gICAgKTtcbiAgICBcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHsgc3RlcCAqPSBiYXNlOyB9IHdoaWxlIChNYXRoLmNlaWwoc3Bhbi9zdGVwKSA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGk9MDsgaTxkaXYubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSBzdGVwIC8gZGl2W2ldO1xuICAgICAgaWYgKHYgPj0gbWluc3RlcCAmJiBzcGFuIC8gdiA8PSBtYXhiKSBzdGVwID0gdjtcbiAgICB9XG4gIH1cblxuICAvLyB1cGRhdGUgcHJlY2lzaW9uLCBtaW4gYW5kIG1heFxuICB2ID0gTWF0aC5sb2coc3RlcCk7XG4gIHByZWNpc2lvbiA9IHYgPj0gMCA/IDAgOiB+figtdiAvIGxvZ2IpICsgMTtcbiAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogIG1heCxcbiAgICBzdGVwOiAgc3RlcCxcbiAgICB1bml0OiAge3ByZWNpc2lvbjogcHJlY2lzaW9ufSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgaW5kZXg6IGluZGV4XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnN0ZXAgKiBNYXRoLmZsb29yKHYgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gaW5kZXgodikge1xuICByZXR1cm4gTWF0aC5mbG9vcigodiAtIHRoaXMuc3RhcnQpIC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGRhdGVfdmFsdWUodikge1xuICByZXR1cm4gdGhpcy51bml0LmRhdGUodmFsdWUuY2FsbCh0aGlzLCB2KSk7XG59XG5cbmZ1bmN0aW9uIGRhdGVfaW5kZXgodikge1xuICByZXR1cm4gaW5kZXguY2FsbCh0aGlzLCB0aGlzLnVuaXQudW5pdCh2KSk7XG59XG5cbmJpbnMuZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbiksXG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgc3BlYyA9IGJpbnMoe1xuICAgICAgICBtaW46ICAgICB1bml0Lm1pbiAhPSBudWxsID8gdW5pdC5taW4gOiB1bml0LnVuaXQoZG1pbiksXG4gICAgICAgIG1heDogICAgIHVuaXQubWF4ICE9IG51bGwgPyB1bml0Lm1heCA6IHVuaXQudW5pdChkbWF4KSxcbiAgICAgICAgbWF4YmluczogbWF4YixcbiAgICAgICAgbWluc3RlcDogdW5pdC5taW5zdGVwLFxuICAgICAgICBzdGVwczogICB1bml0LnN0ZXBcbiAgICAgIH0pO1xuXG4gIHNwZWMudW5pdCA9IHVuaXQ7XG4gIHNwZWMuaW5kZXggPSBkYXRlX2luZGV4O1xuICBpZiAoIW9wdC5yYXcpIHNwZWMudmFsdWUgPSBkYXRlX3ZhbHVlO1xuICByZXR1cm4gc3BlYztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmlucztcbiIsInZhciBzdGF0cyA9IHJlcXVpcmUoJy4uL3N0YXRzJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4uL2ltcG9ydC90eXBlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBnZW4gPSByZXF1aXJlKCcuLi9nZW5lcmF0ZScpO1xudmFyIGJpbnMgPSByZXF1aXJlKCcuL2JpbnMnKTtcblxudmFyIHF0eXBlID0ge1xuICAnaW50ZWdlcic6IDEsXG4gICdudW1iZXInOiAxLFxuICAnZGF0ZSc6IDFcbn07XG5cbmZ1bmN0aW9uICRiaW4odmFsdWVzLCBmLCBvcHQpIHtcbiAgb3B0ID0gb3B0aW9ucyh2YWx1ZXMsIGYsIG9wdCk7XG4gIHZhciBiID0gc3BlYyhvcHQpO1xuICByZXR1cm4gIWIgPyAob3B0LmFjY2Vzc29yIHx8IHV0aWwuaWRlbnRpdHkpIDpcbiAgICB1dGlsLiRmdW5jKCdiaW4nLCBiLnVuaXQudW5pdCA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBiLnZhbHVlKGIudW5pdC51bml0KHgpKTsgfSA6XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBiLnZhbHVlKHgpOyB9XG4gICAgKShvcHQuYWNjZXNzb3IpO1xufVxuXG5mdW5jdGlvbiBoaXN0b2dyYW0odmFsdWVzLCBmLCBvcHQpIHtcbiAgb3B0ID0gb3B0aW9ucyh2YWx1ZXMsIGYsIG9wdCk7XG4gIHZhciBiID0gc3BlYyhvcHQpO1xuICByZXR1cm4gYiA/XG4gICAgbnVtZXJpY2FsKHZhbHVlcywgb3B0LmFjY2Vzc29yLCBiKSA6XG4gICAgY2F0ZWdvcmljYWwodmFsdWVzLCBvcHQuYWNjZXNzb3IsIG9wdCAmJiBvcHQuc29ydCk7XG59XG5cbmZ1bmN0aW9uIHNwZWMob3B0KSB7XG4gIHZhciB0ID0gb3B0LnR5cGUsIGIgPSBudWxsO1xuICBpZiAodCA9PSBudWxsIHx8IHF0eXBlW3RdKSB7XG4gICAgaWYgKHQgPT09ICdpbnRlZ2VyJyAmJiBvcHQubWluc3RlcCA9PSBudWxsKSBvcHQubWluc3RlcCA9IDE7XG4gICAgYiA9ICh0ID09PSAnZGF0ZScpID8gYmlucy5kYXRlKG9wdCkgOiBiaW5zKG9wdCk7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5cbmZ1bmN0aW9uIG9wdGlvbnMoKSB7XG4gIHZhciBhID0gYXJndW1lbnRzLFxuICAgICAgaSA9IDAsXG4gICAgICB2YWx1ZXMgPSB1dGlsLmlzQXJyYXkoYVtpXSkgPyBhW2krK10gOiBudWxsLFxuICAgICAgZiA9IHV0aWwuaXNGdW5jdGlvbihhW2ldKSB8fCB1dGlsLmlzU3RyaW5nKGFbaV0pID8gdXRpbC4kKGFbaSsrXSkgOiBudWxsLFxuICAgICAgb3B0ID0gdXRpbC5leHRlbmQoe30sIGFbaV0pO1xuICBcbiAgaWYgKHZhbHVlcykge1xuICAgIG9wdC50eXBlID0gb3B0LnR5cGUgfHwgdHlwZSh2YWx1ZXMsIGYpO1xuICAgIGlmIChxdHlwZVtvcHQudHlwZV0pIHtcbiAgICAgIHZhciBleHQgPSBzdGF0cy5leHRlbnQodmFsdWVzLCBmKTtcbiAgICAgIG9wdCA9IHV0aWwuZXh0ZW5kKHttaW46IGV4dFswXSwgbWF4OiBleHRbMV19LCBvcHQpO1xuICAgIH1cbiAgfVxuICBpZiAoZikgeyBvcHQuYWNjZXNzb3IgPSBmOyB9XG4gIHJldHVybiBvcHQ7XG59XG5cbmZ1bmN0aW9uIG51bWVyaWNhbCh2YWx1ZXMsIGYsIGIpIHtcbiAgdmFyIGggPSBnZW4ucmFuZ2UoYi5zdGFydCwgYi5zdG9wICsgYi5zdGVwLzIsIGIuc3RlcClcbiAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHt2YWx1ZTogYi52YWx1ZSh2KSwgY291bnQ6IDB9OyB9KTtcblxuICBmb3IgKHZhciBpPTAsIHYsIGo7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgaiA9IGIuaW5kZXgodik7XG4gICAgICBpZiAoaiA8IDAgfHwgaiA+PSBoLmxlbmd0aCB8fCAhaXNGaW5pdGUoaikpIGNvbnRpbnVlO1xuICAgICAgaFtqXS5jb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICBoLmJpbnMgPSBiO1xuICByZXR1cm4gaDtcbn1cblxuZnVuY3Rpb24gY2F0ZWdvcmljYWwodmFsdWVzLCBmLCBzb3J0KSB7XG4gIHZhciB1ID0gc3RhdHMudW5pcXVlKHZhbHVlcywgZiksXG4gICAgICBjID0gc3RhdHMuY291bnQubWFwKHZhbHVlcywgZik7XG4gIHJldHVybiB1Lm1hcChmdW5jdGlvbihrKSB7IHJldHVybiB7dmFsdWU6IGssIGNvdW50OiBjW2tdfTsgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3Ioc29ydCA/ICctY291bnQnIDogJyt2YWx1ZScpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICRiaW46ICRiaW4sXG4gIGhpc3RvZ3JhbTogaGlzdG9ncmFtXG59OyIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICBtYXggPSBtaW47XG4gICAgbWluID0gMDtcbiAgfVxuICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYiA9IGE7XG4gICAgYSA9IDA7XG4gIH1cbiAgdmFyIGQgPSBiIC0gYTtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuICB9O1xuICBmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuICByZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcbiAgbWVhbiA9IG1lYW4gfHwgMDtcbiAgc3RkZXYgPSBzdGRldiB8fCAxO1xuICB2YXIgbmV4dDtcbiAgdmFyIGYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG4gICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgeCA9IG5leHQ7XG4gICAgICBuZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgIHggPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcbiAgICAgIHJkcyA9IHgqeCArIHkqeTtcbiAgICB9IHdoaWxlIChyZHMgPT09IDAgfHwgcmRzID4gMSk7XG4gICAgYyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgbmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG4gICAgcmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG5mdW5jdGlvbiBkc3YoZGF0YSwgZm9ybWF0KSB7XG4gIGlmIChkYXRhKSB7XG4gICAgdmFyIGggPSBmb3JtYXQuaGVhZGVyO1xuICAgIGRhdGEgPSAoaCA/IGguam9pbihmb3JtYXQuZGVsaW1pdGVyKSArICdcXG4nIDogJycpICsgZGF0YTtcbiAgfVxuICByZXR1cm4gZDMuZHN2KGZvcm1hdC5kZWxpbWl0ZXIpLnBhcnNlKGRhdGEpO1xufVxuXG5kc3YuZGVsaW1pdGVyID0gZnVuY3Rpb24oZGVsaW0pIHtcbiAgdmFyIGZtdCA9IHtkZWxpbWl0ZXI6IGRlbGltfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICAgIHJldHVybiBkc3YoZGF0YSwgZm9ybWF0ID8gdXRpbC5leHRlbmQoZm9ybWF0LCBmbXQpIDogZm10KTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZHN2OyIsInZhciBkc3YgPSByZXF1aXJlKCcuL2RzdicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAganNvbjogcmVxdWlyZSgnLi9qc29uJyksXG4gIHRvcG9qc29uOiByZXF1aXJlKCcuL3RvcG9qc29uJyksXG4gIHRyZWVqc29uOiByZXF1aXJlKCcuL3RyZWVqc29uJyksXG4gIGRzdjogZHN2LFxuICBjc3Y6IGRzdi5kZWxpbWl0ZXIoJywnKSxcbiAgdHN2OiBkc3YuZGVsaW1pdGVyKCdcXHQnKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSB1dGlsLmlzT2JqZWN0KGRhdGEpICYmICF1dGlsLmlzQnVmZmVyKGRhdGEpID9cbiAgICBkYXRhIDogSlNPTi5wYXJzZShkYXRhKTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucHJvcGVydHkpIHtcbiAgICBkID0gdXRpbC5hY2Nlc3Nvcihmb3JtYXQucHJvcGVydHkpKGQpO1xuICB9XG4gIHJldHVybiBkO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG52YXIgdG9wb2pzb24gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy50b3BvanNvbiA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudG9wb2pzb24gOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKHRvcG9qc29uID09IG51bGwpIHsgdGhyb3cgRXJyb3IoJ1RvcG9KU09OIGxpYnJhcnkgbm90IGxvYWRlZC4nKTsgfVxuXG4gIHZhciB0ID0ganNvbihkYXRhLCBmb3JtYXQpLCBvYmo7XG5cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuZmVhdHVyZSkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5mZWF0dXJlXSkpIHtcbiAgICAgIHJldHVybiB0b3BvanNvbi5mZWF0dXJlKHQsIG9iaikuZmVhdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJytmb3JtYXQuZmVhdHVyZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZvcm1hdCAmJiBmb3JtYXQubWVzaCkge1xuICAgIGlmICgob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSkpIHtcbiAgICAgIHJldHVybiBbdG9wb2pzb24ubWVzaCh0LCB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogJyArIGZvcm1hdC5tZXNoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ01pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn07XG4iLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdG9UYWJsZShkYXRhLCAoZm9ybWF0ICYmIGZvcm1hdC5jaGlsZHJlbikpO1xufTtcblxuZnVuY3Rpb24gdG9UYWJsZShyb290LCBjaGlsZHJlbkZpZWxkKSB7XG4gIGNoaWxkcmVuRmllbGQgPSBjaGlsZHJlbkZpZWxkIHx8ICdjaGlsZHJlbic7XG4gIHZhciB0YWJsZSA9IFtdO1xuICBcbiAgZnVuY3Rpb24gdmlzaXQobm9kZSkge1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB2aXNpdChyb290LCBudWxsKTtcbiAgcmV0dXJuICh0YWJsZS5yb290ID0gcm9vdCwgdGFibGUpO1xufSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vLyBNYXRjaGVzIGFic29sdXRlIFVSTHMgd2l0aCBvcHRpb25hbCBwcm90b2NvbFxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG52YXIgcHJvdG9jb2xfcmUgPSAvXihbQS1aYS16XSs6KT9cXC9cXC8vO1xuXG4vLyBTcGVjaWFsIHRyZWF0bWVudCBpbiBub2RlLmpzIGZvciB0aGUgZmlsZTogcHJvdG9jb2xcbnZhciBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG5cbi8vIFZhbGlkYXRlIGFuZCBjbGVhbnVwIFVSTCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhbGxvd2VkIHRvIGJlIGFjY2Vzc2VkXG4vLyBSZXR1cm5zIGNsZWFuZWQgdXAgVVJMLCBvciBmYWxzZSBpZiBhY2Nlc3MgaXMgbm90IGFsbG93ZWRcbmZ1bmN0aW9uIHNhbml0aXplVXJsKG9wdCkge1xuICB2YXIgdXJsID0gb3B0LnVybDtcbiAgaWYgKCF1cmwgJiYgb3B0LmZpbGUpIHsgcmV0dXJuIGZpbGVQcm90b2NvbCArIG9wdC5maWxlOyB9XG5cbiAgLy8gSW4gY2FzZSB0aGlzIGlzIGEgcmVsYXRpdmUgdXJsIChoYXMgbm8gaG9zdCksIHByZXBlbmQgb3B0LmJhc2VVUkxcbiAgaWYgKG9wdC5iYXNlVVJMICYmICFwcm90b2NvbF9yZS50ZXN0KHVybCkpIHtcbiAgICBpZiAoIXV0aWwuc3RhcnRzV2l0aCh1cmwsICcvJykgJiYgb3B0LmJhc2VVUkxbb3B0LmJhc2VVUkwubGVuZ3RoLTFdICE9PSAnLycpIHtcbiAgICAgIHVybCA9ICcvJyArIHVybDsgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYSBzbGFzaCBiZXR3ZWVuIHRoZSBiYXNlVVJMIChlLmcuIGhvc3RuYW1lKSBhbmQgdXJsXG4gICAgfVxuICAgIHVybCA9IG9wdC5iYXNlVVJMICsgdXJsO1xuICB9XG4gIC8vIHJlbGF0aXZlIHByb3RvY29sLCBzdGFydHMgd2l0aCAnLy8nXG4gIGlmICh1dGlsLmlzTm9kZSAmJiB1dGlsLnN0YXJ0c1dpdGgodXJsLCAnLy8nKSkge1xuICAgIHVybCA9IChvcHQuZGVmYXVsdFByb3RvY29sIHx8ICdodHRwJykgKyAnOicgKyB1cmw7XG4gIH1cbiAgLy8gSWYgb3B0LmRvbWFpbldoaXRlTGlzdCBpcyBzZXQsIG9ubHkgYWxsb3dzIHVybCwgd2hvc2UgaG9zdG5hbWVcbiAgLy8gKiBJcyB0aGUgc2FtZSBhcyB0aGUgb3JpZ2luICh3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpXG4gIC8vICogRXF1YWxzIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgLy8gKiBJcyBhIHByb3BlciBzdWJkb21haW4gb2Ygb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICBpZiAob3B0LmRvbWFpbldoaXRlTGlzdCkge1xuICAgIHZhciBkb21haW4sIG9yaWdpbjtcbiAgICBpZiAodXRpbC5pc05vZGUpIHtcbiAgICAgIC8vIHJlbGF0aXZlIHByb3RvY29sIGlzIGJyb2tlbjogaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS11cmwvaXNzdWVzLzVcbiAgICAgIHZhciBwYXJ0cyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHVybCk7XG4gICAgICBkb21haW4gPSBwYXJ0cy5ob3N0bmFtZTtcbiAgICAgIG9yaWdpbiA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgYS5ocmVmID0gdXJsO1xuICAgICAgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzczNjUxMy9ob3ctZG8taS1wYXJzZS1hLXVybC1pbnRvLWhvc3RuYW1lLWFuZC1wYXRoLWluLWphdmFzY3JpcHRcbiAgICAgIC8vIElFIGRvZXNuJ3QgcG9wdWxhdGUgYWxsIGxpbmsgcHJvcGVydGllcyB3aGVuIHNldHRpbmcgLmhyZWYgd2l0aCBhIHJlbGF0aXZlIFVSTCxcbiAgICAgIC8vIGhvd2V2ZXIgLmhyZWYgd2lsbCByZXR1cm4gYW4gYWJzb2x1dGUgVVJMIHdoaWNoIHRoZW4gY2FuIGJlIHVzZWQgb24gaXRzZWxmXG4gICAgICAvLyB0byBwb3B1bGF0ZSB0aGVzZSBhZGRpdGlvbmFsIGZpZWxkcy5cbiAgICAgIGlmIChhLmhvc3QgPT09ICcnKSB7XG4gICAgICAgIGEuaHJlZiA9IGEuaHJlZjtcbiAgICAgIH1cbiAgICAgIGRvbWFpbiA9IGEuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIG9yaWdpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3JpZ2luICE9PSBkb21haW4pIHtcbiAgICAgIHZhciB3aGl0ZUxpc3RlZCA9IG9wdC5kb21haW5XaGl0ZUxpc3Quc29tZShmdW5jdGlvbihkKSB7XG4gICAgICAgIHZhciBpZHggPSBkb21haW4ubGVuZ3RoIC0gZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkID09PSBkb21haW4gfHxcbiAgICAgICAgICAoaWR4ID4gMSAmJiBkb21haW5baWR4LTFdID09PSAnLicgJiYgZG9tYWluLmxhc3RJbmRleE9mKGQpID09PSBpZHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXdoaXRlTGlzdGVkKSB7XG4gICAgICAgIHRocm93ICdVUkwgaXMgbm90IHdoaXRlbGlzdGVkOiAnICsgdXJsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBsb2FkKG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZSkgeyB0aHJvdyBlOyB9LCB1cmw7XG5cbiAgdHJ5IHtcbiAgICB1cmwgPSBsb2FkLnNhbml0aXplVXJsKG9wdCk7IC8vIGVuYWJsZSBvdmVycmlkZVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnJvcihlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdXJsKSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgVVJMOiAnICsgdXJsKTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc05vZGUpIHtcbiAgICAvLyBpbiBicm93c2VyLCB1c2UgeGhyXG4gICAgcmV0dXJuIHhocih1cmwsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh1dGlsLnN0YXJ0c1dpdGgodXJsLCBmaWxlUHJvdG9jb2wpKSB7XG4gICAgLy8gaW4gbm9kZS5qcywgaWYgdXJsIHN0YXJ0cyB3aXRoICdmaWxlOi8vJywgc3RyaXAgaXQgYW5kIGxvYWQgZnJvbSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLnNsaWNlKGZpbGVQcm90b2NvbC5sZW5ndGgpLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodXJsLmluZGV4T2YoJzovLycpIDwgMCkgeyAvLyBUT0RPIGJldHRlciBwcm90b2NvbCBjaGVjaz9cbiAgICAvLyBpZiBub2RlLmpzLCBpZiBubyBwcm90b2NvbCBhc3N1bWUgZmlsZVxuICAgIHJldHVybiBmaWxlKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgaW4gbm9kZS5qc1xuICAgIHJldHVybiBodHRwKHVybCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gJ3RleHQnID9cbiAgICByZXF1ZXN0LnJlc3BvbnNlIDogLy8gbnVsbCBvbiBlcnJvclxuICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0OyAvLyAnJyBvbiBlcnJvclxufVxuXG5mdW5jdGlvbiB4aHIodXJsLCBjYWxsYmFjaykge1xuICB2YXIgYXN5bmMgPSAhIWNhbGxiYWNrO1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAvLyBJZiBJRSBkb2VzIG5vdCBzdXBwb3J0IENPUlMsIHVzZSBYRG9tYWluUmVxdWVzdCAoY29waWVkIGZyb20gZDMueGhyKVxuICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdCAmJlxuICAgICAgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgL14oaHR0cChzKT86KT9cXC9cXC8vLnRlc3QodXJsKSkgcmVxdWVzdCA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzO1xuICAgIGlmICghc3RhdHVzICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlcXVlc3QsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3luYykge1xuICAgIGlmICgnb25sb2FkJyBpbiByZXF1ZXN0KSB7XG4gICAgICByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPiAzKSByZXNwb25kKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBcbiAgcmVxdWVzdC5vcGVuKCdHRVQnLCB1cmwsIGFzeW5jKTtcbiAgcmVxdWVzdC5zZW5kKCk7XG4gIFxuICBpZiAoIWFzeW5jICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKSB7XG4gIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCAndXRmOCcpO1xuICB9XG4gIHJlcXVpcmUoJ2ZzJykucmVhZEZpbGUoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3luYy1yZXF1ZXN0JykoJ0dFVCcsIHVybCkuZ2V0Qm9keSgpO1xuICB9XG4gIHJlcXVpcmUoJ3JlcXVlc3QnKSh1cmwsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmxvYWQuc2FuaXRpemVVcmwgPSBzYW5pdGl6ZVVybDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xudmFyIGZvcm1hdHMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxuZnVuY3Rpb24gcmVhZChkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIHR5cGUgPSAoZm9ybWF0ICYmIGZvcm1hdC50eXBlKSB8fCAnanNvbic7XG4gIGRhdGEgPSBmb3JtYXRzW3R5cGVdKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnBhcnNlKSBwYXJzZShkYXRhLCBmb3JtYXQucGFyc2UpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMpIHtcbiAgdmFyIGNvbHMsIHBhcnNlcnMsIGQsIGksIGosIGNsZW4sIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gIHR5cGVzID0gKHR5cGVzPT09J2F1dG8nKSA/IHR5cGUuaW5mZXJBbGwoZGF0YSkgOiB1dGlsLmR1cGxpY2F0ZSh0eXBlcyk7XG4gIGNvbHMgPSB1dGlsLmtleXModHlwZXMpO1xuICBwYXJzZXJzID0gY29scy5tYXAoZnVuY3Rpb24oYykgeyByZXR1cm4gdHlwZS5wYXJzZXJzW3R5cGVzW2NdXTsgfSk7XG5cbiAgZm9yIChpPTAsIGNsZW49Y29scy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBmb3IgKGo9MDsgajxjbGVuOyArK2opIHtcbiAgICAgIGRbY29sc1tqXV0gPSBwYXJzZXJzW2pdKGRbY29sc1tqXV0pO1xuICAgIH1cbiAgfVxuICB0eXBlLmFubm90YXRpb24oZGF0YSwgdHlwZXMpO1xufVxuXG5yZWFkLmZvcm1hdHMgPSBmb3JtYXRzO1xubW9kdWxlLmV4cG9ydHMgPSByZWFkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgbG9hZCA9IHJlcXVpcmUoJy4vbG9hZCcpO1xudmFyIHJlYWQgPSByZXF1aXJlKCcuL3JlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsXG4gIC5rZXlzKHJlYWQuZm9ybWF0cylcbiAgLnJlZHVjZShmdW5jdGlvbihvdXQsIHR5cGUpIHtcbiAgICBvdXRbdHlwZV0gPSBmdW5jdGlvbihvcHQsIGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIHByb2Nlc3MgYXJndW1lbnRzXG4gICAgICBpZiAodXRpbC5pc1N0cmluZyhvcHQpKSB7IG9wdCA9IHt1cmw6IG9wdH07IH1cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHV0aWwuaXNGdW5jdGlvbihmb3JtYXQpKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB1cCByZWFkIGZvcm1hdFxuICAgICAgZm9ybWF0ID0gdXRpbC5leHRlbmQoe3BhcnNlOiAnYXV0byd9LCBmb3JtYXQpO1xuICAgICAgZm9ybWF0LnR5cGUgPSB0eXBlO1xuXG4gICAgICAvLyBsb2FkIGRhdGFcbiAgICAgIHZhciBkYXRhID0gbG9hZChvcHQsIGNhbGxiYWNrID8gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgaWYgKGVycm9yKSBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoYXN5bmMpXG4gICAgICAgICAgZGF0YSA9IHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgICBcbiAgICAgIC8vIGRhdGEgbG9hZGVkLCBub3cgcGFyc2UgaXQgKHN5bmMpXG4gICAgICBpZiAoZGF0YSkgcmV0dXJuIHJlYWQoZGF0YSwgZm9ybWF0KTtcbiAgICB9O1xuICAgIHJldHVybiBvdXQ7XG4gIH0sIHt9KTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgVFlQRVMgPSAnX190eXBlc19fJztcblxudmFyIFBBUlNFUlMgPSB7XG4gIGJvb2xlYW46IHV0aWwuYm9vbGVhbixcbiAgaW50ZWdlcjogdXRpbC5udW1iZXIsXG4gIG51bWJlcjogIHV0aWwubnVtYmVyLFxuICBkYXRlOiAgICB1dGlsLmRhdGUsXG4gIHN0cmluZzogIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0nJyA/IG51bGwgOiB4OyB9XG59O1xuXG52YXIgVEVTVFMgPSB7XG4gIGJvb2xlYW46IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT0ndHJ1ZScgfHwgeD09PSdmYWxzZScgfHwgdXRpbC5pc0Jvb2xlYW4oeCk7IH0sXG4gIGludGVnZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFRFU1RTLm51bWJlcih4KSAmJiAoeD0reCkgPT09IH5+eDsgfSxcbiAgbnVtYmVyOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oK3gpICYmICF1dGlsLmlzRGF0ZSh4KTsgfSxcbiAgZGF0ZTogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKERhdGUucGFyc2UoeCkpOyB9XG59O1xuXG5mdW5jdGlvbiBhbm5vdGF0aW9uKGRhdGEsIHR5cGVzKSB7XG4gIGlmICghdHlwZXMpIHJldHVybiBkYXRhICYmIGRhdGFbVFlQRVNdIHx8IG51bGw7XG4gIGRhdGFbVFlQRVNdID0gdHlwZXM7XG59XG5cbmZ1bmN0aW9uIHR5cGUodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuO1xuXG4gIC8vIGlmIGRhdGEgYXJyYXkgaGFzIHR5cGUgYW5ub3RhdGlvbnMsIHVzZSB0aGVtXG4gIGlmICh2YWx1ZXNbVFlQRVNdKSB7XG4gICAgdiA9IGYodmFsdWVzW1RZUEVTXSk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgIXV0aWwuaXNWYWxpZCh2KSAmJiBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHV0aWwuaXNEYXRlKHYpID8gJ2RhdGUnIDpcbiAgICB1dGlsLmlzTnVtYmVyKHYpICAgID8gJ251bWJlcicgOlxuICAgIHV0aWwuaXNCb29sZWFuKHYpICAgPyAnYm9vbGVhbicgOlxuICAgIHV0aWwuaXNTdHJpbmcodikgICAgPyAnc3RyaW5nJyA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHR5cGVBbGwoZGF0YSwgZmllbGRzKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICByZXR1cm4gKHR5cGVzW2ZdID0gdHlwZShkYXRhLCBmKSwgdHlwZXMpO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgaiwgdjtcblxuICAvLyB0eXBlcyB0byB0ZXN0IGZvciwgaW4gcHJlY2VkZW5jZSBvcmRlclxuICB2YXIgdHlwZXMgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIC8vIGdldCBuZXh0IHZhbHVlIHRvIHRlc3RcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICAvLyB0ZXN0IHZhbHVlIGFnYWluc3QgcmVtYWluaW5nIHR5cGVzXG4gICAgZm9yIChqPTA7IGo8dHlwZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmICh1dGlsLmlzVmFsaWQodikgJiYgIVRFU1RTW3R5cGVzW2pdXSh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzWzBdO1xufVxuXG5mdW5jdGlvbiBpbmZlckFsbChkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB2YXIgdHlwZSA9IGluZmVyKGRhdGEsIGYpO1xuICAgIGlmIChQQVJTRVJTW3R5cGVdKSB0eXBlc1tmXSA9IHR5cGU7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9LCB7fSk7XG59XG5cbnR5cGUuYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG50eXBlLmFsbCA9IHR5cGVBbGw7XG50eXBlLmluZmVyID0gaW5mZXI7XG50eXBlLmluZmVyQWxsID0gaW5mZXJBbGw7XG50eXBlLnBhcnNlcnMgPSBQQVJTRVJTO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciBkbCA9IHtcbiAgbG9hZDogICAgICByZXF1aXJlKCcuL2ltcG9ydC9sb2FkJyksXG4gIHJlYWQ6ICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZCcpLFxuICB0eXBlOiAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKSxcbiAgYmluczogICAgICByZXF1aXJlKCcuL2JpbnMvYmlucycpLFxuICAkYmluOiAgICAgIHJlcXVpcmUoJy4vYmlucy9oaXN0b2dyYW0nKS4kYmluLFxuICBncm91cGJ5OiAgIHJlcXVpcmUoJy4vYWdncmVnYXRlL2dyb3VwYnknKSxcbiAgaGlzdG9ncmFtOiByZXF1aXJlKCcuL2JpbnMvaGlzdG9ncmFtJykuaGlzdG9ncmFtLFxuICBwcmludDogICAgIHJlcXVpcmUoJy4vcHJpbnQnKSxcbiAgdGVtcGxhdGU6ICByZXF1aXJlKCcuL3RlbXBsYXRlJyksXG4gIHRpbWV1bml0czogcmVxdWlyZSgnLi90aW1lLXVuaXRzJylcbn07XG5cbnV0aWwuZXh0ZW5kKGRsLCB1dGlsKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2dlbmVyYXRlJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vc3RhdHMnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9pbXBvcnQvcmVhZGVycycpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkbDsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG52YXIgdGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5cbnZhciBGTVQgPSB7XG4gICdkYXRlJzogICAgJ3x0aW1lOlwiJW0vJWQvJVkgJUg6JU06JVNcIicsXG4gICdudW1iZXInOiAgJ3xudW1iZXI6XCIuNGZcIicsXG4gICdpbnRlZ2VyJzogJ3xudW1iZXI6XCJkXCInXG59O1xuXG52YXIgUE9TID0ge1xuICAnbnVtYmVyJzogICdsZWZ0JyxcbiAgJ2ludGVnZXInOiAnbGVmdCdcbn07XG5cbm1vZHVsZS5leHBvcnRzLnRhYmxlID0gZnVuY3Rpb24oZGF0YSwgb3B0KSB7XG4gIG9wdCA9IHV0aWwuZXh0ZW5kKHtzZXBhcmF0b3I6JyAnLCBtaW53aWR0aDogOCwgbWF4d2lkdGg6IDE1fSwgb3B0KTtcbiAgdmFyIGZpZWxkcyA9IG9wdC5maWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pLFxuICAgICAgdHlwZXMgPSB0eXBlLmFsbChkYXRhKTtcblxuICBpZiAob3B0LnN0YXJ0IHx8IG9wdC5saW1pdCkge1xuICAgIHZhciBhID0gb3B0LnN0YXJ0IHx8IDAsXG4gICAgICAgIGIgPSBvcHQubGltaXQgPyBhICsgb3B0LmxpbWl0IDogZGF0YS5sZW5ndGg7XG4gICAgZGF0YSA9IGRhdGEuc2xpY2UoYSwgYik7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgY2hhciB3aWR0aCBvZiBmaWVsZHNcbiAgdmFyIGxlbnMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgZm9ybWF0ID0gRk1UW3R5cGVzW25hbWVdXSB8fCAnJyxcbiAgICAgICAgdCA9IHRlbXBsYXRlKCd7eycgKyBuYW1lICsgZm9ybWF0ICsgJ319JyksXG4gICAgICAgIGwgPSBzdGF0cy5tYXgoZGF0YSwgZnVuY3Rpb24oeCkgeyByZXR1cm4gdCh4KS5sZW5ndGg7IH0pO1xuICAgIGwgPSBNYXRoLm1heChNYXRoLm1pbihuYW1lLmxlbmd0aCwgb3B0Lm1pbndpZHRoKSwgbCk7XG4gICAgcmV0dXJuIG9wdC5tYXh3aWR0aCA+IDAgPyBNYXRoLm1pbihsLCBvcHQubWF4d2lkdGgpIDogbDtcbiAgfSk7XG5cbiAgLy8gcHJpbnQgaGVhZGVyIHJvd1xuICB2YXIgaGVhZCA9IGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSwgaSkge1xuICAgIHJldHVybiB1dGlsLnRydW5jYXRlKHV0aWwucGFkKG5hbWUsIGxlbnNbaV0sICdjZW50ZXInKSwgbGVuc1tpXSk7XG4gIH0pLmpvaW4ob3B0LnNlcGFyYXRvcik7XG5cbiAgLy8gYnVpbGQgdGVtcGxhdGUgZnVuY3Rpb24gZm9yIGVhY2ggcm93XG4gIHZhciB0bXBsID0gdGVtcGxhdGUoZmllbGRzLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuICd7eycgK1xuICAgICAgbmFtZSArXG4gICAgICAoRk1UW3R5cGVzW25hbWVdXSB8fCAnJykgK1xuICAgICAgKCd8cGFkOicgKyBsZW5zW2ldICsgJywnICsgUE9TW3R5cGVzW25hbWVdXSB8fCAncmlnaHQnKSArXG4gICAgICAoJ3x0cnVuY2F0ZTonICsgbGVuc1tpXSkgK1xuICAgICd9fSc7XG4gIH0pLmpvaW4ob3B0LnNlcGFyYXRvcikpO1xuXG4gIC8vIHByaW50IHRhYmxlXG4gIHJldHVybiBoZWFkICsgXCJcXG5cIiArIGRhdGEubWFwKHRtcGwpLmpvaW4oJ1xcbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3VtbWFyeSA9IGZ1bmN0aW9uKHMpIHtcbiAgcyA9IHMgPyBzLl9fc3VtbWFyeV9fID8gcyA6IHN0YXRzLnN1bW1hcnkocykgOiB0aGlzO1xuICB2YXIgc3RyID0gW10sIGksIG47XG4gIGZvciAoaT0wLCBuPXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHN0ci5wdXNoKCctLSAnICsgc1tpXS5maWVsZCArICcgLS0nKTtcbiAgICBpZiAoc1tpXS50eXBlID09PSAnc3RyaW5nJyB8fCBzW2ldLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHNbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHNbaV0pKTtcbiAgICB9XG4gICAgc3RyLnB1c2goJycpO1xuICB9XG4gIHJldHVybiBzdHIuam9pbignXFxuJyk7XG59O1xuXG5mdW5jdGlvbiBwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUocCkge1xuICByZXR1cm4gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ21pbjogICAgICAnICsgcC5taW4sXG4gICAgJ21heDogICAgICAnICsgcC5tYXgsXG4gICAgJ21lZGlhbjogICAnICsgcC5tZWRpYW4sXG4gICAgJ21lYW46ICAgICAnICsgcC5tZWFuLFxuICAgICdzdGRldjogICAgJyArIHAuc3RkZXYsXG4gICAgJ21vZGVza2V3OiAnICsgcC5tb2Rlc2tld1xuICBdLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBwcmludENhdGVnb3JpY2FsUHJvZmlsZShwKSB7XG4gIHZhciBsaXN0ID0gW1xuICAgICd2YWxpZDogICAgJyArIHAudmFsaWQsXG4gICAgJ21pc3Npbmc6ICAnICsgcC5taXNzaW5nLFxuICAgICdkaXN0aW5jdDogJyArIHAuZGlzdGluY3QsXG4gICAgJ3RvcCB2YWx1ZXM6ICdcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiAnIFxcJycgKyB2ICsgJ1xcJyAoJyArIHVbdl0gKyAnKSc7IH0pO1xuICByZXR1cm4gbGlzdC5jb25jYXQodG9wKS5qb2luKCdcXG4nKTtcbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIHR5cGUgPSByZXF1aXJlKCcuL2ltcG9ydC90eXBlJyk7XG52YXIgZ2VuID0gcmVxdWlyZSgnLi9nZW5lcmF0ZScpO1xudmFyIHN0YXRzID0ge307XG5cbi8vIENvbGxlY3QgdW5pcXVlIHZhbHVlcy5cbi8vIE91dHB1dDogYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gZmlyc3Qtb2JzZXJ2ZWQgb3JkZXJcbnN0YXRzLnVuaXF1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcmVzdWx0cykge1xuICBmID0gdXRpbC4kKGYpO1xuICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICByZXN1bHRzLnB1c2godik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW5wdXQgYXJyYXkuXG5zdGF0cy5jb3VudCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gdmFsdWVzICYmIHZhbHVlcy5sZW5ndGggfHwgMDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2Ygbm9uLW51bGwsIG5vbi11bmRlZmluZWQsIG5vbi1OYU4gdmFsdWVzLlxuc3RhdHMuY291bnQudmFsaWQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG4sIHZhbGlkID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB2YWxpZCArPSAxO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn07XG5cbi8vIENvdW50IHRoZSBudW1iZXIgb2YgbnVsbCBvciB1bmRlZmluZWQgdmFsdWVzLlxuc3RhdHMuY291bnQubWlzc2luZyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4vLyBOdWxsLCB1bmRlZmluZWQgYW5kIE5hTiBhcmUgZWFjaCBjb25zaWRlcmVkIGRpc3RpbmN0IHZhbHVlcy5cbnN0YXRzLmNvdW50LmRpc3RpbmN0ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB1ID0ge30sIHYsIGksIG4sIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvbnN0cnVjdCBhIG1hcCBmcm9tIGRpc3RpbmN0IHZhbHVlcyB0byBvY2N1cnJlbmNlIGNvdW50cy5cbnN0YXRzLmNvdW50Lm1hcCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWFwID0ge30sIHYsIGksIG47XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgbWFwW3ZdID0gKHYgaW4gbWFwKSA/IG1hcFt2XSArIDEgOiAxO1xuICB9XG4gIHJldHVybiBtYXA7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWRpYW4gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lZGlhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHJldHVybiBzdGF0cy5xdWFudGlsZSh2YWx1ZXMsIDAuNSk7XG59O1xuXG4vLyBDb21wdXRlcyB0aGUgcXVhcnRpbGUgYm91bmRhcmllcyBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMucXVhcnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKGYpIHZhbHVlcyA9IHZhbHVlcy5tYXAodXRpbC4kKGYpKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzVmFsaWQpLnNvcnQodXRpbC5jbXApO1xuICB2YXIgcSA9IHN0YXRzLnF1YW50aWxlO1xuICByZXR1cm4gW3EodmFsdWVzLCAwLjI1KSwgcSh2YWx1ZXMsIDAuNTApLCBxKHZhbHVlcywgMC43NSldO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgcXVhbnRpbGUgb2YgYSBzb3J0ZWQgYXJyYXkgb2YgbnVtYmVycy5cbi8vIEFkYXB0ZWQgZnJvbSB0aGUgRDMuanMgaW1wbGVtZW50YXRpb24uXG5zdGF0cy5xdWFudGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcCkge1xuICBpZiAocCA9PT0gdW5kZWZpbmVkKSB7IHAgPSBmOyBmID0gdXRpbC5pZGVudGl0eTsgfVxuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgSCA9ICh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwICsgMSxcbiAgICAgIGggPSBNYXRoLmZsb29yKEgpLFxuICAgICAgdiA9ICtmKHZhbHVlc1toIC0gMV0pLFxuICAgICAgZSA9IEggLSBoO1xuICByZXR1cm4gZSA/IHYgKyBlICogKGYodmFsdWVzW2hdKSAtIHYpIDogdjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHN1bSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3VtID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGZvciAodmFyIHN1bT0wLCBpPTAsIG49dmFsdWVzLmxlbmd0aCwgdjsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSBzdW0gKz0gdjtcbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVhbiAoYXZlcmFnZSkgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIG1lYW4gPSAwLCBkZWx0YSwgaSwgbiwgYywgdjtcbiAgZm9yIChpPTAsIGM9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgICBNMiA9IE0yICsgZGVsdGEgKiAodiAtIG1lYW4pO1xuICAgIH1cbiAgfVxuICBNMiA9IE0yIC8gKGMgLSAxKTtcbiAgcmV0dXJuIE0yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMuc3RkZXYgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIE1hdGguc3FydChzdGF0cy52YXJpYW5jZSh2YWx1ZXMsIGYpKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFBlYXJzb24gbW9kZSBza2V3bmVzcyAoKG1lZGlhbi1tZWFuKS9zdGRldikgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1vZGVza2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIHZhbHVlIGluIGFuIGFycmF5Llxuc3RhdHMubWluID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBzdGF0cy5leHRlbnQodmFsdWVzLCBmKVswXTtcbn07XG5cbi8vIEZpbmQgdGhlIG1heGltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzFdO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHggPSAtMSwgeSA9IC0xLCBhLCBiLCB2LCBpLCBuID0gdmFsdWVzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkgeyBhID0gYiA9IHY7IHggPSB5ID0gaTsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIHsgYSA9IHY7IHggPSBpOyB9XG4gICAgICBpZiAodiA+IGIpIHsgYiA9IHY7IHkgPSBpOyB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG5zdGF0cy5kb3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHN1bSA9IDAsIGksIHY7XG4gIGlmICghYikge1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0FycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC4nKTtcbiAgICB9XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gdmFsdWVzW2ldICogYVtpXTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IGEodmFsdWVzW2ldKSAqIGIodmFsdWVzW2ldKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn07XG5cbi8vIENvbXB1dGUgYXNjZW5kaW5nIHJhbmsgc2NvcmVzIGZvciBhbiBhcnJheSBvZiB2YWx1ZXMuXG4vLyBUaWVzIGFyZSBhc3NpZ25lZCB0aGVpciBjb2xsZWN0aXZlIG1lYW4gcmFuay5cbnN0YXRzLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKSB8fCB1dGlsLmlkZW50aXR5O1xuICB2YXIgYSA9IHZhbHVlcy5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgICAgcmV0dXJuIHtpZHg6IGksIHZhbDogZih2KX07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoJ3ZhbCcpKTtcblxuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICByID0gQXJyYXkobiksXG4gICAgICB0aWUgPSAtMSwgcCA9IHt9LCBpLCB2LCBtdTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gYVtpXS52YWw7XG4gICAgaWYgKHRpZSA8IDAgJiYgcCA9PT0gdikge1xuICAgICAgdGllID0gaSAtIDE7XG4gICAgfSBlbHNlIGlmICh0aWUgPiAtMSAmJiBwICE9PSB2KSB7XG4gICAgICBtdSA9IDEgKyAoaS0xICsgdGllKSAvIDI7XG4gICAgICBmb3IgKDsgdGllPGk7ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gICAgICB0aWUgPSAtMTtcbiAgICB9XG4gICAgclthW2ldLmlkeF0gPSBpICsgMTtcbiAgICBwID0gdjtcbiAgfVxuXG4gIGlmICh0aWUgPiAtMSkge1xuICAgIG11ID0gMSArIChuLTEgKyB0aWUpIC8gMjtcbiAgICBmb3IgKDsgdGllPG47ICsrdGllKSByW2FbdGllXS5pZHhdID0gbXU7XG4gIH1cblxuICByZXR1cm4gcjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBQZWFyc29uIHByb2R1Y3QtbW9tZW50IGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmNvciA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgZm4gPSBiO1xuICBiID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuICBhID0gZm4gPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXM7XG5cbiAgdmFyIGRvdCA9IHN0YXRzLmRvdChhLCBiKSxcbiAgICAgIG11YSA9IHN0YXRzLm1lYW4oYSksXG4gICAgICBtdWIgPSBzdGF0cy5tZWFuKGIpLFxuICAgICAgc2RhID0gc3RhdHMuc3RkZXYoYSksXG4gICAgICBzZGIgPSBzdGF0cy5zdGRldihiKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIHJldHVybiAoZG90IC0gbiptdWEqbXViKSAvICgobi0xKSAqIHNkYSAqIHNkYik7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTcGVhcm1hbiByYW5rIGNvcnJlbGF0aW9uIG9mIHR3byBhcnJheXMgb2YgdmFsdWVzLlxuc3RhdHMuY29yLnJhbmsgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIHJhID0gYiA/IHN0YXRzLnJhbmsodmFsdWVzLCB1dGlsLiQoYSkpIDogc3RhdHMucmFuayh2YWx1ZXMpLFxuICAgICAgcmIgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChiKSkgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcCh1dGlsLiQoYSkpIDogdmFsdWVzLFxuICAgICAgWSA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhO1xuXG4gIHZhciBBID0gc3RhdHMuZGlzdC5tYXQoWCksXG4gICAgICBCID0gc3RhdHMuZGlzdC5tYXQoWSksXG4gICAgICBuID0gQS5sZW5ndGgsXG4gICAgICBpLCBhYSwgYmIsIGFiO1xuXG4gIGZvciAoaT0wLCBhYT0wLCBiYj0wLCBhYj0wOyBpPG47ICsraSkge1xuICAgIGFhICs9IEFbaV0qQVtpXTtcbiAgICBiYiArPSBCW2ldKkJbaV07XG4gICAgYWIgKz0gQVtpXSpCW2ldO1xuICB9XG5cbiAgcmV0dXJuIE1hdGguc3FydChhYiAvIE1hdGguc3FydChhYSpiYikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgdmVjdG9yIGRpc3RhbmNlIGJldHdlZW4gdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gRGVmYXVsdCBpcyBFdWNsaWRlYW4gKGV4cD0yKSBkaXN0YW5jZSwgY29uZmlndXJhYmxlIHZpYSBleHAgYXJndW1lbnQuXG5zdGF0cy5kaXN0ID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBleHApIHtcbiAgdmFyIGYgPSB1dGlsLmlzRnVuY3Rpb24oYikgfHwgdXRpbC5pc1N0cmluZyhiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBMMiA9IGUgPT09IDIgfHwgZSA9PSBudWxsLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIHMgPSAwLCBkLCBpO1xuICBpZiAoZikge1xuICAgIGEgPSB1dGlsLiQoYSk7XG4gICAgYiA9IHV0aWwuJChiKTtcbiAgfVxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgcyArPSBMMiA/IGQqZCA6IE1hdGgucG93KE1hdGguYWJzKGQpLCBlKTtcbiAgfVxuICByZXR1cm4gTDIgPyBNYXRoLnNxcnQocykgOiBNYXRoLnBvdyhzLCAxL2UpO1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgbiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHApIEggKz0gcCAqIE1hdGgubG9nKHApO1xuICB9XG4gIHJldHVybiAtSCAvIE1hdGguTE4yO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvcm0gW01JLCBNSV9kaXN0YW5jZV0gXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMubXV0dWFsID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgdmFyIHggPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcCh1dGlsLiQoYikpIDogYSxcbiAgICAgIHogPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChjb3VudHMpKSA6IGI7XG5cbiAgdmFyIHB4ID0ge30sXG4gICAgICBweSA9IHt9LFxuICAgICAgbiA9IHoubGVuZ3RoLFxuICAgICAgcyA9IDAsIEkgPSAwLCBIID0gMCwgcCwgdCwgaTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSA9IDA7XG4gICAgcHlbeVtpXV0gPSAwO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcHhbeFtpXV0gKz0geltpXTtcbiAgICBweVt5W2ldXSArPSB6W2ldO1xuICAgIHMgKz0geltpXTtcbiAgfVxuXG4gIHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcbiAgICBwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcbiAgICBJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG4gICAgSCArPSB6W2ldICogdCAqIE1hdGgubG9nKHpbaV0vcyk7XG4gIH1cblxuICByZXR1cm4gW0ksIDEgKyBJL0hdO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbXV0dWFsIGluZm9ybWF0aW9uIGJldHdlZW4gdHdvIGRpc2NyZXRlIHZhcmlhYmxlcy5cbnN0YXRzLm11dHVhbC5pbmZvID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiLCBjb3VudHMpIHtcbiAgcmV0dXJuIHN0YXRzLm11dHVhbCh2YWx1ZXMsIGEsIGIsIGNvdW50cylbMF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gZGlzdGFuY2UgYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gTUlfZGlzdGFuY2UgaXMgZGVmaW5lZCBhcyAxIC0gSShhLGIpIC8gSChhLGIpLlxuc3RhdHMubXV0dWFsLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVsxXTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIG1lYW4gPSAwLFxuICAgICAgdmFsaWQgPSAwLFxuICAgICAgbWlzc2luZyA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBudWxsLFxuICAgICAgbWF4ID0gbnVsbCxcbiAgICAgIE0yID0gMCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4O1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcblxuICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgdVt2XSA9ICh2IGluIHUpID8gdVt2XSArIDEgOiAoZGlzdGluY3QgKz0gMSwgMSk7XG5cbiAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICArK21pc3Npbmc7XG4gICAgfSBlbHNlIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0c1xuICAgICAgeCA9ICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpID8gdi5sZW5ndGggOiB2O1xuICAgICAgaWYgKG1pbj09PW51bGwgfHwgeCA8IG1pbikgbWluID0geDtcbiAgICAgIGlmIChtYXg9PT1udWxsIHx8IHggPiBtYXgpIG1heCA9IHg7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK3ZhbGlkKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAodmFsaWQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogICAgIHR5cGUodmFsdWVzLCBmKSxcbiAgICB1bmlxdWU6ICAgdSxcbiAgICBjb3VudDogICAgdmFsdWVzLmxlbmd0aCxcbiAgICB2YWxpZDogICAgdmFsaWQsXG4gICAgbWlzc2luZzogIG1pc3NpbmcsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgcTE6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLFxuICAgIHEzOiAgICAgICBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KSxcbiAgICBtb2Rlc2tldzogc2QgPT09IDAgPyAwIDogKG1lYW4gLSB2KSAvIHNkXG4gIH07XG59O1xuXG4vLyBDb21wdXRlIHByb2ZpbGVzIGZvciBhbGwgdmFyaWFibGVzIGluIGEgZGF0YSBzZXQuXG5zdGF0cy5zdW1tYXJ5ID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG4gIHZhciBzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuJChmKSk7XG4gICAgcmV0dXJuIChwLmZpZWxkID0gZiwgcCk7XG4gIH0pO1xuICByZXR1cm4gKHMuX19zdW1tYXJ5X18gPSB0cnVlLCBzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICB1dGlsLnRydW5jYXRlLFxuICBwYWQ6ICAgICAgICB1dGlsLnBhZFxufTtcblxuZnVuY3Rpb24gdGVtcGxhdGUodGV4dCkge1xuICB2YXIgc3JjID0gc291cmNlKHRleHQsICdkJyk7XG4gIHNyYyA9ICd2YXIgX190OyByZXR1cm4gJyArIHNyYyArICc7JztcblxuICB0cnkge1xuICAgIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ2QnLCBzcmMpKS5iaW5kKGNvbnRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5zb3VyY2UgPSBzcmM7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG50ZW1wbGF0ZS5zb3VyY2UgPSBzb3VyY2U7XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG4vLyBjbGVhciBjYWNoZSBvZiBmb3JtYXQgb2JqZWN0c1xuLy8gY2FuICpicmVhayogcHJpb3IgdGVtcGxhdGUgZnVuY3Rpb25zLCBzbyBpbnZva2Ugd2l0aCBjYXJlXG50ZW1wbGF0ZS5jbGVhckZvcm1hdENhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnRleHQuZm9ybWF0cyA9IFtdO1xuICBjb250ZXh0LmZvcm1hdF9tYXAgPSB7fTtcbn07XG5cbmZ1bmN0aW9uIHNvdXJjZSh0ZXh0LCB2YXJpYWJsZSkge1xuICB2YXJpYWJsZSA9IHZhcmlhYmxlIHx8ICdvYmonO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc3JjID0gJ1xcJyc7XG4gIHZhciByZWdleCA9IHRlbXBsYXRlX3JlO1xuXG4gIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gIHRleHQucmVwbGFjZShyZWdleCwgZnVuY3Rpb24obWF0Y2gsIGludGVycG9sYXRlLCBvZmZzZXQpIHtcbiAgICBzcmMgKz0gdGV4dFxuICAgICAgLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAucmVwbGFjZSh0ZW1wbGF0ZV9lc2NhcGVyLCB0ZW1wbGF0ZV9lc2NhcGVDaGFyKTtcbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgc3JjICs9ICdcXCdcXG4rKChfX3Q9KCcgK1xuICAgICAgICB0ZW1wbGF0ZV92YXIoaW50ZXJwb2xhdGUsIHZhcmlhYmxlKSArXG4gICAgICAgICcpKT09bnVsbD9cXCdcXCc6X190KStcXG5cXCcnO1xuICAgIH1cblxuICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gc3JjICsgJ1xcJyc7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX3Zhcih0ZXh0LCB2YXJpYWJsZSkge1xuICB2YXIgZmlsdGVycyA9IHRleHQuc3BsaXQoJ3wnKTtcbiAgdmFyIHByb3AgPSBmaWx0ZXJzLnNoaWZ0KCkudHJpbSgpO1xuICB2YXIgc3RyaW5nQ2FzdCA9IHRydWU7XG4gIFxuICBmdW5jdGlvbiBzdHJjYWxsKGZuKSB7XG4gICAgZm4gPSBmbiB8fCAnJztcbiAgICBpZiAoc3RyaW5nQ2FzdCkge1xuICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgc3JjID0gJ1N0cmluZygnICsgc3JjICsgJyknICsgZm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyYyArPSBmbjtcbiAgICB9XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICBcbiAgZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gJyh0eXBlb2YgJyArIHNyYyArICc9PT1cIm51bWJlclwiP25ldyBEYXRlKCcrc3JjKycpOicrc3JjKycpJztcbiAgfVxuICBcbiAgdmFyIHNyYyA9IHV0aWwuZmllbGQocHJvcCkubWFwKHV0aWwuc3RyKS5qb2luKCddWycpO1xuICBzcmMgPSB2YXJpYWJsZSArICdbJyArIHNyYyArICddJztcbiAgXG4gIGZvciAodmFyIGk9MDsgaTxmaWx0ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGYgPSBmaWx0ZXJzW2ldLCBhcmdzID0gbnVsbCwgcGlkeCwgYSwgYjtcblxuICAgIGlmICgocGlkeD1mLmluZGV4T2YoJzonKSkgPiAwKSB7XG4gICAgICBmID0gZi5zbGljZSgwLCBwaWR4KTtcbiAgICAgIGFyZ3MgPSBmaWx0ZXJzW2ldLnNsaWNlKHBpZHgrMSkuc3BsaXQoJywnKVxuICAgICAgICAubWFwKGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMudHJpbSgpOyB9KTtcbiAgICB9XG4gICAgZiA9IGYudHJpbSgpO1xuXG4gICAgc3dpdGNoIChmKSB7XG4gICAgICBjYXNlICdsZW5ndGgnOlxuICAgICAgICBzdHJjYWxsKCcubGVuZ3RoJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbG93ZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb3dlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VwcGVyJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlci1sb2NhbGUnOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb2NhbGVMb3dlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3VwcGVyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZVVwcGVyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJpbSc6XG4gICAgICAgIHN0cmNhbGwoJy50cmltKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoMCwnICsgYSArICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgtJyArIGEgKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWlkJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYSArIHV0aWwubnVtYmVyKGFyZ3NbMV0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoKycrYSsnLCcrYisnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NsaWNlJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoJysgYSArXG4gICAgICAgICAgKGFyZ3MubGVuZ3RoID4gMSA/ICcsJyArIHV0aWwubnVtYmVyKGFyZ3NbMV0pIDogJycpICtcbiAgICAgICAgICAnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBiID0gYXJnc1sxXTtcbiAgICAgICAgYiA9IChiIT09J2xlZnQnICYmIGIhPT0nbWlkZGxlJyAmJiBiIT09J2NlbnRlcicpID8gJ3JpZ2h0JyA6IGI7XG4gICAgICAgIHNyYyA9ICd0aGlzLnRydW5jYXRlKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcXCcnICsgYiArICdcXCcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdwYWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT0nbGVmdCcgJiYgYiE9PSdtaWRkbGUnICYmIGIhPT0nY2VudGVyJykgPyAncmlnaHQnIDogYjtcbiAgICAgICAgc3JjID0gJ3RoaXMucGFkKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcXCcnICsgYiArICdcXCcpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGQzLmZvcm1hdCk7XG4gICAgICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICAgICAgc3JjID0gJ3RoaXMuZm9ybWF0c1snK2ErJ10oJytzcmMrJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICBhID0gdGVtcGxhdGVfZm9ybWF0KGFyZ3NbMF0sIGQzLnRpbWUuZm9ybWF0KTtcbiAgICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK2RhdGUoKSsnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1VucmVjb2duaXplZCB0ZW1wbGF0ZSBmaWx0ZXI6ICcgKyBmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuXG52YXIgdGVtcGxhdGVfcmUgPSAvXFx7XFx7KC4rPylcXH1cXH18JC9nO1xuXG4vLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuLy8gc3RyaW5nIGxpdGVyYWwuXG52YXIgdGVtcGxhdGVfZXNjYXBlcyA9IHtcbiAgJ1xcJyc6ICAgICAnXFwnJyxcbiAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAnXFxyJzogICAgICdyJyxcbiAgJ1xcbic6ICAgICAnbicsXG4gICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgJ1xcdTIwMjknOiAndTIwMjknXG59O1xuXG52YXIgdGVtcGxhdGVfZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuZnVuY3Rpb24gdGVtcGxhdGVfZXNjYXBlQ2hhcihtYXRjaCkge1xuICByZXR1cm4gJ1xcXFwnICsgdGVtcGxhdGVfZXNjYXBlc1ttYXRjaF07XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2Zvcm1hdChwYXR0ZXJuLCBmbXQpIHtcbiAgaWYgKChwYXR0ZXJuWzBdID09PSAnXFwnJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXFwnJykgfHxcbiAgICAgIChwYXR0ZXJuWzBdID09PSAnXCInICAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoLTFdID09PSAnXCInKSkge1xuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnNsaWNlKDEsIC0xKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignRm9ybWF0IHBhdHRlcm4gbXVzdCBiZSBxdW90ZWQ6ICcgKyBwYXR0ZXJuKTtcbiAgfVxuICBpZiAoIWNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSkge1xuICAgIHZhciBmID0gZm10KHBhdHRlcm4pO1xuICAgIHZhciBpID0gY29udGV4dC5mb3JtYXRzLmxlbmd0aDtcbiAgICBjb250ZXh0LmZvcm1hdHMucHVzaChmKTtcbiAgICBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl07XG59XG4iLCJ2YXIgU1RFUFMgPSBbXG4gIFszMTUzNmU2LCA1XSwgIC8vIDEteWVhclxuICBbNzc3NmU2LCA0XSwgICAvLyAzLW1vbnRoXG4gIFsyNTkyZTYsIDRdLCAgIC8vIDEtbW9udGhcbiAgWzEyMDk2ZTUsIDNdLCAgLy8gMi13ZWVrXG4gIFs2MDQ4ZTUsIDNdLCAgIC8vIDEtd2Vla1xuICBbMTcyOGU1LCAzXSwgICAvLyAyLWRheVxuICBbODY0ZTUsIDNdLCAgICAvLyAxLWRheVxuICBbNDMyZTUsIDJdLCAgICAvLyAxMi1ob3VyXG4gIFsyMTZlNSwgMl0sICAgIC8vIDYtaG91clxuICBbMTA4ZTUsIDJdLCAgICAvLyAzLWhvdXJcbiAgWzM2ZTUsIDJdLCAgICAgLy8gMS1ob3VyXG4gIFsxOGU1LCAxXSwgICAgIC8vIDMwLW1pbnV0ZVxuICBbOWU1LCAxXSwgICAgICAvLyAxNS1taW51dGVcbiAgWzNlNSwgMV0sICAgICAgLy8gNS1taW51dGVcbiAgWzZlNCwgMV0sICAgICAgLy8gMS1taW51dGVcbiAgWzNlNCwgMF0sICAgICAgLy8gMzAtc2Vjb25kXG4gIFsxNWUzLCAwXSwgICAgIC8vIDE1LXNlY29uZFxuICBbNWUzLCAwXSwgICAgICAvLyA1LXNlY29uZFxuICBbMWUzLCAwXSAgICAgICAvLyAxLXNlY29uZFxuXTtcblxuZnVuY3Rpb24gaXNOdW1iZXIoZCkgeyByZXR1cm4gdHlwZW9mIGQgPT09ICdudW1iZXInOyB9XG5cbnZhciBlbnRyaWVzID0gW1xuICB7XG4gICAgdHlwZTogJ3NlY29uZCcsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWSAlYiAlLWQgJUg6JU06JVMuJUwnLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogMWUzKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAoK2QgLyAxZTMpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdtaW51dGUnLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kICVIOiVNJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDZlNCk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyA2ZTQpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdob3VyJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogJyVZICViICUtZCAlSDowMCcsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiAzNmU1KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDM2ZTUpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6ICdkYXknLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgc3RlcDogWzEsIDddLFxuICAgIGZvcm1hdDogJyVZICViICUtZCcsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiA4NjRlNSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyA4NjRlNSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ21vbnRoJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIHN0ZXA6IFsxLCAzLCA2XSxcbiAgICBmb3JtYXQ6ICclYiAlWScsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKH5+KGQgLyAxMiksIGQgJSAxMiwgMSkpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKGlzTnVtYmVyKGQpKSBkID0gbmV3IERhdGUoZCk7XG4gICAgICByZXR1cm4gMTIgKiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyBkLmdldFVUQ01vbnRoKCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ3llYXInLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVknLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyhkLCAwLCAxKSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENGdWxsWWVhcigpO1xuICAgIH1cbiAgfVxuXTtcblxudmFyIG1pbnV0ZU9mSG91ciA9IHtcbiAgdHlwZTogJ21pbnV0ZU9mSG91cicsXG4gIG1pbjogMCxcbiAgbWF4OiA1OSxcbiAgbWluc3RlcDogMSxcbiAgZm9ybWF0OiAnJU0nLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIDAsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ01pbnV0ZXMoKTtcbiAgfVxufTtcblxudmFyIGhvdXJPZkRheSA9IHtcbiAgdHlwZTogJ2hvdXJPZkRheScsXG4gIG1pbjogMCxcbiAgbWF4OiAyMyxcbiAgbWluc3RlcDogMSxcbiAgZm9ybWF0OiAnJUgnLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDEsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0hvdXJzKCk7XG4gIH1cbn07XG5cbnZhciBkYXlPZldlZWsgPSB7XG4gIHR5cGU6ICdkYXlPZldlZWsnLFxuICBtaW46IDAsXG4gIG1heDogNixcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6ICclYScsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgNCArIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0RheSgpO1xuICB9XG59O1xuXG52YXIgZGF5T2ZNb250aCA9IHtcbiAgdHlwZTogJ2RheU9mTW9udGgnLFxuICBtaW46IDEsXG4gIG1heDogMzEsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiAnJS1kJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKGlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENEYXRlKCk7XG4gIH1cbn07XG5cbnZhciBtb250aE9mWWVhciA9IHtcbiAgdHlwZTogJ21vbnRoT2ZZZWFyJyxcbiAgbWluOiAwLFxuICBtYXg6IDExLFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogJyViJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCBkICUgMTIsIDEpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ01vbnRoKCk7XG4gIH1cbn07XG5cbnZhciB1bml0cyA9IHtcbiAgJ3NlY29uZCc6ICAgICAgIGVudHJpZXNbMF0sXG4gICdtaW51dGUnOiAgICAgICBlbnRyaWVzWzFdLFxuICAnaG91cic6ICAgICAgICAgZW50cmllc1syXSxcbiAgJ2RheSc6ICAgICAgICAgIGVudHJpZXNbM10sXG4gICdtb250aCc6ICAgICAgICBlbnRyaWVzWzRdLFxuICAneWVhcic6ICAgICAgICAgZW50cmllc1s1XSxcbiAgJ21pbnV0ZU9mSG91cic6IG1pbnV0ZU9mSG91cixcbiAgJ2hvdXJPZkRheSc6ICAgIGhvdXJPZkRheSxcbiAgJ2RheU9mV2Vlayc6ICAgIGRheU9mV2VlayxcbiAgJ2RheU9mTW9udGgnOiAgIGRheU9mTW9udGgsXG4gICdtb250aE9mWWVhcic6ICBtb250aE9mWWVhcixcbiAgJ3RpbWVzdGVwcyc6ICAgIGVudHJpZXNcbn07XG5cbnVuaXRzLmZpbmQgPSBmdW5jdGlvbihzcGFuLCBtaW5iLCBtYXhiKSB7XG4gIHZhciBpLCBsZW4sIGJpbnMsIHN0ZXAgPSBTVEVQU1swXTtcblxuICBmb3IgKGkgPSAxLCBsZW4gPSBTVEVQUy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHN0ZXAgPSBTVEVQU1tpXTtcbiAgICBpZiAoc3BhbiA+IHN0ZXBbMF0pIHtcbiAgICAgIGJpbnMgPSBzcGFuIC8gc3RlcFswXTtcbiAgICAgIGlmIChiaW5zID4gbWF4Yikge1xuICAgICAgICByZXR1cm4gZW50cmllc1tTVEVQU1tpIC0gMV1bMV1dO1xuICAgICAgfVxuICAgICAgaWYgKGJpbnMgPj0gbWluYikge1xuICAgICAgICByZXR1cm4gZW50cmllc1tzdGVwWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVudHJpZXNbU1RFUFNbU1RFUFMubGVuZ3RoIC0gMV1bMV1dO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bml0cztcbiIsInZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgdW5pdHMgPSByZXF1aXJlKCcuL3RpbWUtdW5pdHMnKTtcbnZhciB1ID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gd2hlcmUgYXJlIHdlP1xuXG51LmlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICB0eXBlb2YgcHJvY2Vzcy5zdGRlcnIgIT09ICd1bmRlZmluZWQnO1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG52YXIgRk5BTUUgPSAnX19uYW1lX18nO1xuXG51Lm5hbWVkZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIGYpIHsgcmV0dXJuIChmW0ZOQU1FXSA9IG5hbWUsIGYpOyB9O1xuXG51Lm5hbWUgPSBmdW5jdGlvbihmKSB7IHJldHVybiBmPT1udWxsID8gbnVsbCA6IGZbRk5BTUVdOyB9O1xuXG51LmlkZW50aXR5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcblxudS50cnVlID0gdS5uYW1lZGZ1bmMoJ3RydWUnLCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH0pO1xuXG51LmZhbHNlID0gdS5uYW1lZGZ1bmMoJ2ZhbHNlJywgZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSk7XG5cbnUuZHVwbGljYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufTtcblxudS5lcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGEpID09PSBKU09OLnN0cmluZ2lmeShiKTtcbn07XG5cbnUuZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gIGZvciAodmFyIHgsIG5hbWUsIGk9MSwgbGVuPWFyZ3VtZW50cy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB4ID0gYXJndW1lbnRzW2ldO1xuICAgIGZvciAobmFtZSBpbiB4KSB7IG9ialtuYW1lXSA9IHhbbmFtZV07IH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxudS5sZW5ndGggPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgJiYgeC5sZW5ndGggIT0gbnVsbCA/IHgubGVuZ3RoIDogbnVsbDtcbn07XG5cbnUua2V5cyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGtleXMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIGtleXMucHVzaChrKTtcbiAgcmV0dXJuIGtleXM7XG59O1xuXG51LnZhbHMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB2YWxzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSB2YWxzLnB1c2goeFtrXSk7XG4gIHJldHVybiB2YWxzO1xufTtcblxudS50b01hcCA9IGZ1bmN0aW9uKGxpc3QsIGYpIHtcbiAgcmV0dXJuIChmID0gdS4kKGYpKSA/XG4gICAgbGlzdC5yZWR1Y2UoZnVuY3Rpb24ob2JqLCB4KSB7IHJldHVybiAob2JqW2YoeCldID0gMSwgb2JqKTsgfSwge30pIDpcbiAgICBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHsgcmV0dXJuIChvYmpbeF0gPSAxLCBvYmopOyB9LCB7fSk7XG59O1xuXG51LmtleXN0ciA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAvLyB1c2UgdG8gZW5zdXJlIGNvbnNpc3RlbnQga2V5IGdlbmVyYXRpb24gYWNyb3NzIG1vZHVsZXNcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBpZiAoIW4pIHJldHVybiAnJztcbiAgZm9yICh2YXIgcz1TdHJpbmcodmFsdWVzWzBdKSwgaT0xOyBpPG47ICsraSkge1xuICAgIHMgKz0gJ3wnICsgU3RyaW5nKHZhbHVlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG4vLyB0eXBlIGNoZWNraW5nIGZ1bmN0aW9uc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG51LmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xufTtcblxudS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG51LmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG51LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudS5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ251bWJlcicgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5cbnUuaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxudS5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxudS5pc1ZhbGlkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAhTnVtYmVyLmlzTmFOKG9iaik7XG59O1xuXG51LmlzQnVmZmVyID0gKEJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIpIHx8IHUuZmFsc2U7XG5cbi8vIHR5cGUgY29lcmNpb24gZnVuY3Rpb25zXG5cbnUubnVtYmVyID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6ICtzO1xufTtcblxudS5ib29sZWFuID0gZnVuY3Rpb24ocykge1xuICByZXR1cm4gcyA9PSBudWxsIHx8IHMgPT09ICcnID8gbnVsbCA6IHM9PT0nZmFsc2UnID8gZmFsc2UgOiAhIXM7XG59O1xuXG51LmRhdGUgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogRGF0ZS5wYXJzZShzKTtcbn07XG5cbnUuYXJyYXkgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9IG51bGwgPyAodS5pc0FycmF5KHgpID8geCA6IFt4XSkgOiBbXTtcbn07XG5cbnUuc3RyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdS5pc0FycmF5KHgpID8gJ1snICsgeC5tYXAodS5zdHIpICsgJ10nXG4gICAgOiB1LmlzT2JqZWN0KHgpID8gSlNPTi5zdHJpbmdpZnkoeClcbiAgICA6IHUuaXNTdHJpbmcoeCkgPyAoJ1xcJycrdXRpbF9lc2NhcGVfc3RyKHgpKydcXCcnKSA6IHg7XG59O1xuXG52YXIgZXNjYXBlX3N0cl9yZSA9IC8oXnxbXlxcXFxdKScvZztcblxuZnVuY3Rpb24gdXRpbF9lc2NhcGVfc3RyKHgpIHtcbiAgcmV0dXJuIHgucmVwbGFjZShlc2NhcGVfc3RyX3JlLCAnJDFcXFxcXFwnJyk7XG59XG5cbi8vIGRhdGEgYWNjZXNzIGZ1bmN0aW9uc1xuXG51LmZpZWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gU3RyaW5nKGYpLnNwbGl0KCdcXFxcLicpXG4gICAgLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkLnNwbGl0KCcuJyk7IH0pXG4gICAgLnJlZHVjZShmdW5jdGlvbihhLCBiKSB7XG4gICAgICBpZiAoYS5sZW5ndGgpIHsgYVthLmxlbmd0aC0xXSArPSAnLicgKyBiLnNoaWZ0KCk7IH1cbiAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFtdKTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gZj09bnVsbCB8fCB1LmlzRnVuY3Rpb24oZikgPyBmIDpcbiAgICB1Lm5hbWVkZnVuYyhmLCAocyA9IHUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7IHJldHVybiB4W2ZdOyB9LCB4KTsgfSA6XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiB4W2ZdOyB9XG4gICAgKTtcbn07XG5cbnUuJCA9IHUuYWNjZXNzb3I7XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDEgP1xuICAgIGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxzLmxlbmd0aC0xOyArK2kpIHggPSB4W3NbaV1dO1xuICAgICAgeFtzW2ldXSA9IHY7XG4gICAgfSA6XG4gICAgZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cbnUuJGZ1bmMgPSBmdW5jdGlvbihuYW1lLCBvcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgIGYgPSB1LiQoZikgfHwgdS5pZGVudGl0eTtcbiAgICB2YXIgbiA9IG5hbWUgKyAodS5uYW1lKGYpID8gJ18nK3UubmFtZShmKSA6ICcnKTtcbiAgICByZXR1cm4gdS5uYW1lZGZ1bmMobiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gb3AoZihkKSk7IH0pO1xuICB9O1xufTtcblxudS4kdmFsaWQgID0gdS4kZnVuYygndmFsaWQnLCB1LmlzVmFsaWQpO1xudS4kbGVuZ3RoID0gdS4kZnVuYygnbGVuZ3RoJywgdS5sZW5ndGgpO1xudS4keWVhciAgID0gdS4kZnVuYygneWVhcicsIHVuaXRzLnllYXIudW5pdCk7XG51LiRtb250aCAgPSB1LiRmdW5jKCdtb250aCcsIHVuaXRzLm1vbnRoT2ZZZWFyLnVuaXQpO1xudS4kZGF0ZSAgID0gdS4kZnVuYygnZGF0ZScsIHVuaXRzLmRheU9mTW9udGgudW5pdCk7XG51LiRkYXkgICAgPSB1LiRmdW5jKCdkYXknLCB1bml0cy5kYXlPZldlZWsudW5pdCk7XG51LiRob3VyICAgPSB1LiRmdW5jKCdob3VyJywgdW5pdHMuaG91ck9mRGF5LnVuaXQpO1xudS4kbWludXRlID0gdS4kZnVuYygnbWludXRlJywgdW5pdHMubWludXRlT2ZIb3VyLnVuaXQpO1xuXG51LiRpbiA9IGZ1bmN0aW9uKGYsIHZhbHVlcykge1xuICBmID0gdS4kKGYpO1xuICB2YXIgbWFwID0gdS5pc0FycmF5KHZhbHVlcykgPyB1LnRvTWFwKHZhbHVlcykgOiB2YWx1ZXM7XG4gIHJldHVybiBmdW5jdGlvbihkKSB7IHJldHVybiAhIW1hcFtmKGQpXTsgfTtcbn07XG5cbi8vIGNvbXBhcmlzb24gLyBzb3J0aW5nIGZ1bmN0aW9uc1xuXG51LmNvbXBhcmF0b3IgPSBmdW5jdGlvbihzb3J0KSB7XG4gIHZhciBzaWduID0gW107XG4gIGlmIChzb3J0ID09PSB1bmRlZmluZWQpIHNvcnQgPSBbXTtcbiAgc29ydCA9IHUuYXJyYXkoc29ydCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcyA9IDE7XG4gICAgaWYgICAgICAoZlswXSA9PT0gJy0nKSB7IHMgPSAtMTsgZiA9IGYuc2xpY2UoMSk7IH1cbiAgICBlbHNlIGlmIChmWzBdID09PSAnKycpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbi8vIEVTNiBjb21wYXRpYmlsaXR5IHBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aCNQb2x5ZmlsbFxuLy8gV2UgY291bGQgaGF2ZSB1c2VkIHRoZSBwb2x5ZmlsbCBjb2RlLCBidXQgbGV0cyB3YWl0IHVudGlsIEVTNiBiZWNvbWVzIGEgc3RhbmRhcmQgZmlyc3RcbnUuc3RhcnRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA/XG4gIGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XG4gIH0gOlxuICBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCAwKSA9PT0gMDtcbiAgfTtcblxudS5wYWQgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgcGFkY2hhcikge1xuICBwYWRjaGFyID0gcGFkY2hhciB8fCBcIiBcIjtcbiAgdmFyIGQgPSBsZW5ndGggLSBzLmxlbmd0aDtcbiAgaWYgKGQgPD0gMCkgcmV0dXJuIHM7XG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gc3RycmVwKGQsIHBhZGNoYXIpICsgcztcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICByZXR1cm4gc3RycmVwKE1hdGguZmxvb3IoZC8yKSwgcGFkY2hhcikgK1xuICAgICAgICAgcyArIHN0cnJlcChNYXRoLmNlaWwoZC8yKSwgcGFkY2hhcik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzICsgc3RycmVwKGQsIHBhZGNoYXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdHJyZXAobiwgc3RyKSB7XG4gIHZhciBzID0gXCJcIiwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBzICs9IHN0cjtcbiAgcmV0dXJuIHM7XG59XG5cbnUudHJ1bmNhdGUgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgIT09IHVuZGVmaW5lZCA/IFN0cmluZyhlbGxpcHNpcykgOiAnXFx1MjAyNic7XG4gIHZhciBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZWxsaXBzaXMubGVuZ3RoKTtcblxuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcmV0dXJuIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSAnbWlkZGxlJzpcbiAgICBjYXNlICdjZW50ZXInOlxuICAgICAgdmFyIGwxID0gTWF0aC5jZWlsKGwvMiksIGwyID0gTWF0aC5mbG9vcihsLzIpO1xuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMSkgOiBzLnNsaWNlKDAsbDEpKSArXG4gICAgICAgIGVsbGlwc2lzICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwyLDEpIDogcy5zbGljZShsZW4tbDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsKSA6IHMuc2xpY2UoMCxsKSkgKyBlbGxpcHNpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJ1bmNhdGVPbldvcmQocywgbGVuLCByZXYpIHtcbiAgdmFyIGNudCA9IDAsIHRvayA9IHMuc3BsaXQodHJ1bmNhdGVfd29yZF9yZSk7XG4gIGlmIChyZXYpIHtcbiAgICBzID0gKHRvayA9IHRvay5yZXZlcnNlKCkpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHRvay5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyBzLmpvaW4oJycpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgLypcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICovXG5cbiAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cblxuICAvKlxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICBcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICBcbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgKi9cblxuICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgIHZhciBtaWQ7XG4gICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobG8gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICBoaSA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICB9O1xuXG5cbiAgLypcbiAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gIFxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAqL1xuXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgKi9cblxuICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cblxuICAvKlxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgKi9cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cblxuICAvKlxuICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cbiAgICovXG5cbiAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcbiAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGVhcDtcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICByZXR1cm4gaGVhcDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICByZXR1cm4gSGVhcDtcblxuICB9KSgpO1xuXG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgcmV0dXJuIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3QuSGVhcCA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIZWFwO1xuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvY2FudmFzL2luZGV4JyksXG4gICAgc3ZnID0gcmVxdWlyZSgnLi4vcmVuZGVyL3N2Zy1oZWFkbGVzcy9pbmRleCcpLFxuICAgIFZpZXcgPSByZXF1aXJlKCcuL1ZpZXcnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxudmFyIEhlYWRsZXNzVmlldyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIG1vZGVsKSB7XG4gIFZpZXcuY2FsbChudWxsLCB3aWR0aCwgaGVpZ2h0LCBtb2RlbCk7XG4gIHRoaXMuX2VsID0gXCJib2R5XCI7XG4gIHRoaXMuX3R5cGUgPSBcImNhbnZhc1wiO1xuICB0aGlzLl9yZW5kZXJlcnMgPSB7Y2FudmFzOiBjYW52YXMsIHN2Zzogc3ZnfTtcbiAgdGhpcy5fY2FudmFzID0gbnVsbDtcbn1cblxudmFyIHByb3RvdHlwZSA9IChIZWFkbGVzc1ZpZXcucHJvdG90eXBlID0gbmV3IFZpZXcoKSk7XG5cbnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYodHlwZSkgdGhpcy5fdHlwZSA9IHR5cGU7XG4gIHJldHVybiBWaWV3LnByb3RvdHlwZS5yZW5kZXJlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxucHJvdG90eXBlLmNhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzO1xufTtcblxucHJvdG90eXBlLmNhbnZhc0FzeW5jID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHIgPSB0aGlzLl9yZW5kZXJlciwgdmlldyA9IHRoaXM7XG4gIFxuICBmdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmIChyLnBlbmRpbmdJbWFnZXMoKSA9PT0gMCkge1xuICAgICAgdmlldy5yZW5kZXIoKTsgLy8gcmUtcmVuZGVyIHdpdGggYWxsIGltYWdlc1xuICAgICAgY2FsbGJhY2sodmlldy5fY2FudmFzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh3YWl0LCAxMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgaW1hZ2VzIGxvYWRpbmcsIHBvbGwgdW50aWwgcmVhZHlcbiAgKHIucGVuZGluZ0ltYWdlcygpID4gMCkgPyB3YWl0KCkgOiBjYWxsYmFjayh0aGlzLl9jYW52YXMpO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gKHRoaXMuX3R5cGUgPT09IFwic3ZnXCIpXG4gICAgPyB0aGlzLl9yZW5kZXJlci5zdmcoKVxuICAgIDogbnVsbDtcbn07XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7ICAgIFxuICB2YXIgdyA9IHRoaXMuX3dpZHRoLFxuICAgICAgaCA9IHRoaXMuX2hlaWdodCxcbiAgICAgIHBhZCA9IHRoaXMuX3BhZGRpbmc7XG5cbiAgaWYgKHRoaXMuX3ZpZXdwb3J0KSB7XG4gICAgdyA9IHRoaXMuX3ZpZXdwb3J0WzBdIC0gKHBhZCA/IHBhZC5sZWZ0ICsgcGFkLnJpZ2h0IDogMCk7XG4gICAgaCA9IHRoaXMuX3ZpZXdwb3J0WzFdIC0gKHBhZCA/IHBhZC50b3AgKyBwYWQuYm90dG9tIDogMCk7XG4gIH1cblxuICB0aGlzLl9yZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyIHx8IG5ldyB0aGlzLl9pby5SZW5kZXJlcigpO1xuICBcbiAgaWYgKHRoaXMuX3R5cGUgPT09IFwic3ZnXCIpIHtcbiAgICB0aGlzLmluaXRTVkcodywgaCwgcGFkKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmluaXRDYW52YXModywgaCwgcGFkKTtcbiAgfVxuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaW5pdENhbnZhcyA9IGZ1bmN0aW9uKHcsIGgsIHBhZCkge1xuICB2YXIgQ2FudmFzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuY2FudmFzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5jYW52YXMgOiBudWxsKSxcbiAgICAgIHR3ID0gdyArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgICAgdGggPSBoICsgcGFkLnRvcCArIHBhZC5ib3R0b20sXG4gICAgICBjYW52YXMgPSB0aGlzLl9jYW52YXMgPSBkbC5pc05vZGUgPyBuZXcgQ2FudmFzKHR3LCB0aCkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSxcbiAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgaWYoIWRsLmlzTm9kZSkgeyAgLy8gTWFudWFsbHkgc2V0IHdpZHRoL2hlaWdodCBvbiBET00gZWxlbWVudHNcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdHcpO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGgpO1xuICB9XG4gIFxuICAvLyBzZXR1cCBjYW52YXMgY29udGV4dFxuICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIHBhZC5sZWZ0LCBwYWQudG9wKTtcblxuICAvLyBjb25maWd1cmUgcmVuZGVyZXJcbiAgdGhpcy5fcmVuZGVyZXIuY29udGV4dChjdHgpO1xuICB0aGlzLl9yZW5kZXJlci5yZXNpemUodywgaCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5pbml0U1ZHID0gZnVuY3Rpb24odywgaCwgcGFkKSB7XG4gIC8vIGNvbmZpZ3VyZSByZW5kZXJlclxuICB0aGlzLl9yZW5kZXJlci5pbml0aWFsaXplKHRoaXMuX2VsLCB3LCBoLCBwYWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkbGVzc1ZpZXc7XG4iLCJ2YXIgR3JhcGggPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9HcmFwaCcpLCBcbiAgICBOb2RlICA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBHcm91cEJ1aWxkZXIgPSByZXF1aXJlKCcuLi9zY2VuZS9Hcm91cEJ1aWxkZXInKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbmZ1bmN0aW9uIE1vZGVsKCkge1xuICB0aGlzLl9kZWZzID0ge307XG4gIHRoaXMuX3ByZWRpY2F0ZXMgPSB7fTtcbiAgdGhpcy5fc2NlbmUgPSBudWxsO1xuXG4gIHRoaXMuX25vZGUgPSBudWxsO1xuICB0aGlzLl9idWlsZGVyID0gbnVsbDsgLy8gVG9wLWxldmVsIHNjZW5lZ3JhcGggYnVpbGRlclxuXG4gIEdyYXBoLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG59O1xuXG52YXIgcHJvdG8gPSAoTW9kZWwucHJvdG90eXBlID0gbmV3IEdyYXBoKCkpO1xuXG5wcm90by5kZWZzID0gZnVuY3Rpb24oZGVmcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kZWZzO1xuICB0aGlzLl9kZWZzID0gZGVmcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5ub2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlIHx8ICh0aGlzLl9ub2RlID0gbmV3IE5vZGUodGhpcykpO1xufTtcblxucHJvdG8uZGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IEdyYXBoLnByb3RvdHlwZS5kYXRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7ICAvLyBuZXcgRGF0YXNvdXJjZVxuICAgIHRoaXMubm9kZSgpLmFkZExpc3RlbmVyKGRhdGEucGlwZWxpbmUoKVswXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn07XG5cbmZ1bmN0aW9uIHByZWRpY2F0ZXMobmFtZSkge1xuICB2YXIgbSA9IHRoaXMsIHByZWRpY2F0ZXMgPSB7fTtcbiAgaWYoIWRsLmlzQXJyYXkobmFtZSkpIHJldHVybiB0aGlzLl9wcmVkaWNhdGVzW25hbWVdO1xuICBuYW1lLmZvckVhY2goZnVuY3Rpb24obikgeyBwcmVkaWNhdGVzW25dID0gbS5fcHJlZGljYXRlc1tuXSB9KTtcbiAgcmV0dXJuIHByZWRpY2F0ZXM7XG59XG5cbnByb3RvLnByZWRpY2F0ZSA9IGZ1bmN0aW9uKG5hbWUsIHByZWRpY2F0ZSkge1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gcHJlZGljYXRlcy5jYWxsKHRoaXMsIG5hbWUpO1xuICByZXR1cm4gKHRoaXMuX3ByZWRpY2F0ZXNbbmFtZV0gPSBwcmVkaWNhdGUpO1xufTtcblxucHJvdG8ucHJlZGljYXRlcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fcHJlZGljYXRlczsgfTtcblxucHJvdG8uc2NlbmUgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NjZW5lO1xuICBpZih0aGlzLl9idWlsZGVyKSB0aGlzLm5vZGUoKS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9idWlsZGVyLmRpc2Nvbm5lY3QoKSk7XG4gIHRoaXMuX2J1aWxkZXIgPSBuZXcgR3JvdXBCdWlsZGVyKHRoaXMsIHRoaXMuX2RlZnMubWFya3MsIHRoaXMuX3NjZW5lPXt9KTtcbiAgdGhpcy5ub2RlKCkuYWRkTGlzdGVuZXIodGhpcy5fYnVpbGRlci5jb25uZWN0KCkpO1xuICB2YXIgcCA9IHRoaXMuX2J1aWxkZXIucGlwZWxpbmUoKTtcbiAgcFtwLmxlbmd0aC0xXS5hZGRMaXN0ZW5lcihyZW5kZXJlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7IHRoaXMubm9kZSgpLmFkZExpc3RlbmVyKGwpOyB9O1xucHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7IHRoaXMubm9kZSgpLnJlbW92ZUxpc3RlbmVyKGwpOyB9O1xuXG5wcm90by5maXJlID0gZnVuY3Rpb24oY3MpIHtcbiAgaWYoIWNzKSBjcyA9IGNoYW5nZXNldC5jcmVhdGUoKTtcbiAgdGhpcy5wcm9wYWdhdGUoY3MsIHRoaXMubm9kZSgpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBwYXJzZVN0cmVhbXMgPSByZXF1aXJlKCcuLi9wYXJzZS9zdHJlYW1zJyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2NhbnZhcy9pbmRleCcpLFxuICAgIHN2ZyA9IHJlcXVpcmUoJy4uL3JlbmRlci9zdmcvaW5kZXgnKSxcbiAgICBFbmNvZGVyID0gcmVxdWlyZSgnLi4vc2NlbmUvRW5jb2RlcicpLFxuICAgIFRyYW5zaXRpb24gPSByZXF1aXJlKCcuLi9zY2VuZS9UcmFuc2l0aW9uJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKTtcblxudmFyIFZpZXcgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgbW9kZWwpIHtcbiAgdGhpcy5fZWwgICAgPSBudWxsO1xuICB0aGlzLl9tb2RlbCA9IG51bGw7XG4gIHRoaXMuX3dpZHRoID0gdGhpcy5fX3dpZHRoID0gd2lkdGggfHwgNTAwO1xuICB0aGlzLl9oZWlnaHQgID0gdGhpcy5fX2hlaWdodCA9IGhlaWdodCB8fCAzMDA7XG4gIHRoaXMuX2F1dG9wYWQgPSAxO1xuICB0aGlzLl9wYWRkaW5nID0ge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXIgID0gbnVsbDtcbiAgdGhpcy5fc3RyZWFtZXIgPSBudWxsOyAvLyBUYXJnZXRlZCB1cGRhdGUgZm9yIHN0cmVhbWluZyBjaGFuZ2VzXG4gIHRoaXMuX2NoYW5nZXNldCA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVycyA9IHtjYW52YXM6IGNhbnZhcywgc3ZnOiBzdmd9O1xuICB0aGlzLl9pbyAgPSBjYW52YXM7XG4gIHRoaXMuX2FwaSA9IHt9OyAvLyBTdGFzaCBzdHJlYW1pbmcgZGF0YSBBUEkgc2FuZGJveGVzLlxufTtcblxudmFyIHByb3RvdHlwZSA9IFZpZXcucHJvdG90eXBlO1xuXG5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihtb2RlbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgaWYgKHRoaXMuX21vZGVsICE9PSBtb2RlbCkge1xuICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgdGhpcy5fc3RyZWFtZXIgPSBuZXcgTm9kZShtb2RlbCk7XG4gICAgdGhpcy5fY2hhbmdlc2V0ID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuICAgIGlmICh0aGlzLl9oYW5kbGVyKSB0aGlzLl9oYW5kbGVyLm1vZGVsKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFNhbmRib3hlZCBzdHJlYW1pbmcgZGF0YSBBUElcbmZ1bmN0aW9uIHN0cmVhbWluZyhzcmMpIHtcbiAgdmFyIHZpZXcgPSB0aGlzLFxuICAgICAgZHMgPSB0aGlzLl9tb2RlbC5kYXRhKHNyYyksXG4gICAgICBsaXN0ZW5lciA9IGRzLnBpcGVsaW5lKClbMF0sXG4gICAgICBzdHJlYW1lciA9IHRoaXMuX3N0cmVhbWVyLFxuICAgICAgY3MgID0gdGhpcy5fY2hhbmdlc2V0LFxuICAgICAgYXBpID0ge307XG5cbiAgaWYoZGwua2V5cyhjcy5zaWduYWxzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgXCJOZXcgc2lnbmFsIHZhbHVlcyBhcmUgbm90IHJlZmxlY3RlZCBpbiB0aGUgdmlzdWFsaXphdGlvbi5cIiArXG4gICAgICBcIiBQbGVhc2UgY2FsbCB2aWV3LnVwZGF0ZSgpIGJlZm9yZSB1cGRhdGluZyBkYXRhIHZhbHVlcy5cIlxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZSBpdCBzdGFzaGVkLCBkb24ndCBjcmVhdGUgYSBuZXcgY2xvc3VyZS4gXG4gIGlmKHRoaXMuX2FwaVtzcmNdKSByZXR1cm4gdGhpcy5fYXBpW3NyY107XG5cbiAgYXBpLmluc2VydCA9IGZ1bmN0aW9uKHZhbHMpIHtcbiAgICBkcy5pbnNlcnQoZGwuZHVwbGljYXRlKHZhbHMpKTsgIC8vIERvbid0IHBvbGx1dGUgdGhlIGVudmlyb25tZW50XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNzLmRhdGFbZHMubmFtZSgpXSA9IDE7XG4gICAgcmV0dXJuIGFwaTtcbiAgfTtcblxuICBhcGkudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNzLmRhdGFbZHMubmFtZSgpXSA9IDE7XG4gICAgcmV0dXJuIChkcy51cGRhdGUuYXBwbHkoZHMsIGFyZ3VtZW50cyksIGFwaSk7XG4gIH07XG5cbiAgYXBpLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjcy5kYXRhW2RzLm5hbWUoKV0gPSAxO1xuICAgIHJldHVybiAoZHMucmVtb3ZlLmFwcGx5KGRzLCBhcmd1bWVudHMpLCBhcGkpO1xuICB9O1xuXG4gIGFwaS52YWx1ZXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGRzLnZhbHVlcygpIH07ICAgIFxuXG4gIHJldHVybiAodGhpcy5fYXBpW3NyY10gPSBhcGkpO1xufTtcblxucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciB2ID0gdGhpcztcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB2Ll9tb2RlbC5kYXRhVmFsdWVzKCk7XG4gIGVsc2UgaWYoZGwuaXNTdHJpbmcoZGF0YSkpIHJldHVybiBzdHJlYW1pbmcuY2FsbCh2LCBkYXRhKTtcbiAgZWxzZSBpZihkbC5pc09iamVjdChkYXRhKSkge1xuICAgIGRsLmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgYXBpID0gc3RyZWFtaW5nLmNhbGwodiwgayk7XG4gICAgICBkYXRhW2tdKGFwaSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIG0gID0gdGhpcy5fbW9kZWwsXG4gICAgICBjcyA9IHRoaXMuX2NoYW5nZXNldCxcbiAgICAgIHN0cmVhbWVyID0gdGhpcy5fc3RyZWFtZXIsXG4gICAgICBzZXR0ZXIgPSBuYW1lOyBcblxuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG0uc2lnbmFsVmFsdWVzKCk7XG4gIGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIGRsLmlzU3RyaW5nKG5hbWUpKSByZXR1cm4gbS5zaWduYWxWYWx1ZXMobmFtZSk7XG5cbiAgaWYoZGwua2V5cyhjcy5kYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgXCJOZXcgZGF0YSB2YWx1ZXMgYXJlIG5vdCByZWZsZWN0ZWQgaW4gdGhlIHZpc3VhbGl6YXRpb24uXCIgK1xuICAgICAgXCIgUGxlYXNlIGNhbGwgdmlldy51cGRhdGUoKSBiZWZvcmUgdXBkYXRpbmcgc2lnbmFsIHZhbHVlcy5cIlxuICB9XG5cbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgc2V0dGVyID0ge307XG4gICAgc2V0dGVyW25hbWVdID0gdmFsdWU7XG4gIH1cblxuICBkbC5rZXlzKHNldHRlcikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobS5zaWduYWwoaykudmFsdWUoc2V0dGVyW2tdKSk7XG4gICAgY3Muc2lnbmFsc1trXSA9IDE7XG4gICAgY3MucmVmbG93ID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9fd2lkdGg7XG4gIGlmICh0aGlzLl9fd2lkdGggIT09IHdpZHRoKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fc3RyaWN0KSB0aGlzLl9hdXRvcGFkID0gMTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fX2hlaWdodDtcbiAgaWYgKHRoaXMuX19oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX3N0cmljdCkgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICBpZiAodGhpcy5fcGFkZGluZyAhPT0gcGFkKSB7XG4gICAgaWYgKGRsLmlzU3RyaW5nKHBhZCkpIHtcbiAgICAgIHRoaXMuX2F1dG9wYWQgPSAxO1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gICAgICB0aGlzLl9zdHJpY3QgPSAocGFkID09PSBcInN0cmljdFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDA7XG4gICAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgICAgdGhpcy5fc3RyaWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbCkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHBhZCk7XG4gICAgICBpZih0aGlzLl9oYW5kbGVyKSB0aGlzLl9oYW5kbGVyLnBhZGRpbmcocGFkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYXV0b3BhZCA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAodGhpcy5fYXV0b3BhZCA8IDEpIHJldHVybiB0aGlzO1xuICBlbHNlIHRoaXMuX2F1dG9wYWQgPSAwO1xuXG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IHRoaXMubW9kZWwoKS5zY2VuZSgpLmJvdW5kcyxcbiAgICAgIGluc2V0ID0gY29uZmlnLmF1dG9wYWRJbnNldCxcbiAgICAgIGwgPSBiLngxIDwgMCA/IE1hdGguY2VpbCgtYi54MSkgKyBpbnNldCA6IDAsXG4gICAgICB0ID0gYi55MSA8IDAgPyBNYXRoLmNlaWwoLWIueTEpICsgaW5zZXQgOiAwLFxuICAgICAgciA9IGIueDIgPiB0aGlzLl93aWR0aCAgPyBNYXRoLmNlaWwoK2IueDIgLSB0aGlzLl93aWR0aCkgKyBpbnNldCA6IDAsXG4gICAgICBiID0gYi55MiA+IHRoaXMuX2hlaWdodCA/IE1hdGguY2VpbCgrYi55MiAtIHRoaXMuX2hlaWdodCkgKyBpbnNldCA6IDA7XG4gIHBhZCA9IHtsZWZ0OmwsIHRvcDp0LCByaWdodDpyLCBib3R0b206Yn07XG5cbiAgaWYgKHRoaXMuX3N0cmljdCkge1xuICAgIHRoaXMuX2F1dG9wYWQgPSAwO1xuICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgdGhpcy5fd2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9fd2lkdGggLSAobCtyKSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5tYXgoMCwgdGhpcy5fX2hlaWdodCAtICh0K2IpKTtcbiAgICB0aGlzLl9tb2RlbC53aWR0aCh0aGlzLl93aWR0aCk7XG4gICAgdGhpcy5fbW9kZWwuaGVpZ2h0KHRoaXMuX2hlaWdodCk7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhZGRpbmcocGFkKS51cGRhdGUob3B0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gIGlmICh0aGlzLl92aWV3cG9ydCAhPT0gc2l6ZSkge1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gc2l6ZTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gIGlmICh0aGlzLl9yZW5kZXJlcnNbdHlwZV0pIHR5cGUgPSB0aGlzLl9yZW5kZXJlcnNbdHlwZV07XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJlbmRlcmVyOiBcIiArIHR5cGUpO1xuICBlbHNlIGlmICghdHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVuZGVyZXIgc3BlY2lmaWVkXCIpO1xuXG4gIGlmICh0aGlzLl9pbyAhPT0gdHlwZSkge1xuICAgIHRoaXMuX2lvID0gdHlwZTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX2J1aWxkKSB0aGlzLnJlbmRlcigpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCkge1xuICB2YXIgdiA9IHRoaXMsIHByZXZIYW5kbGVyLFxuICAgICAgdyA9IHYuX3dpZHRoLCBoID0gdi5faGVpZ2h0LCBwYWQgPSB2Ll9wYWRkaW5nO1xuXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCB8fCBlbCA9PT0gbnVsbCkge1xuICAgIGVsID0gdGhpcy5fZWwgPyB0aGlzLl9lbC5wYXJlbnROb2RlIDogbnVsbDtcbiAgICBpZighZWwpIHJldHVybiB0aGlzOyAgLy8gVGhpcyBWaWV3IGNhbm5vdCBpbml0IHcvbyBhblxuICB9XG4gIFxuICAvLyBjbGVhciBwcmUtZXhpc3RpbmcgY29udGFpbmVyXG4gIGQzLnNlbGVjdChlbCkuc2VsZWN0KFwiZGl2LnZlZ2FcIikucmVtb3ZlKCk7XG4gIFxuICAvLyBhZGQgZGl2IGNvbnRhaW5lclxuICB0aGlzLl9lbCA9IGVsID0gZDMuc2VsZWN0KGVsKVxuICAgIC5hcHBlbmQoXCJkaXZcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwidmVnYVwiKVxuICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcbiAgICAubm9kZSgpO1xuICBpZiAodi5fdmlld3BvcnQpIHtcbiAgICBkMy5zZWxlY3QoZWwpXG4gICAgICAuc3R5bGUoXCJ3aWR0aFwiLCAgKHYuX3ZpZXdwb3J0WzBdIHx8IHcpK1wicHhcIilcbiAgICAgIC5zdHlsZShcImhlaWdodFwiLCAodi5fdmlld3BvcnRbMV0gfHwgaCkrXCJweFwiKVxuICAgICAgLnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICB9XG5cbiAgLy8gcmVuZGVyZXJcbiAgdi5fcmVuZGVyZXIgPSAodi5fcmVuZGVyZXIgfHwgbmV3IHRoaXMuX2lvLlJlbmRlcmVyKCkpXG4gICAgLmluaXRpYWxpemUoZWwsIHcsIGgsIHBhZCk7XG4gIFxuICAvLyBpbnB1dCBoYW5kbGVyXG4gIHByZXZIYW5kbGVyID0gdi5faGFuZGxlcjtcbiAgdi5faGFuZGxlciA9IG5ldyB0aGlzLl9pby5IYW5kbGVyKClcbiAgICAuaW5pdGlhbGl6ZShlbCwgcGFkLCB2KVxuICAgIC5tb2RlbCh2Ll9tb2RlbCk7XG5cbiAgaWYgKHByZXZIYW5kbGVyKSB7XG4gICAgcHJldkhhbmRsZXIuaGFuZGxlcnMoKS5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgIHYuX2hhbmRsZXIub24oaC50eXBlLCBoLmhhbmRsZXIpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBmb3Igc2lnbmFsIHN0cmVhbSBkZWZpbml0aW9ucy5cbiAgICBwYXJzZVN0cmVhbXModGhpcyk7XG4gIH1cbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gYnVpbGQoKSB7XG4gIHZhciB2ID0gdGhpcztcbiAgdi5fcmVuZGVyTm9kZSA9IG5ldyBOb2RlKHYuX21vZGVsKVxuICAgIC5yb3V0ZXIodHJ1ZSk7XG5cbiAgdi5fcmVuZGVyTm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcInJlbmRlcmluZ1wiXSk7XG5cbiAgICB2YXIgcyA9IHYuX21vZGVsLnNjZW5lKCk7XG4gICAgaWYoaW5wdXQudHJhbnMpIHtcbiAgICAgIGlucHV0LnRyYW5zLnN0YXJ0KGZ1bmN0aW9uKGl0ZW1zKSB7IHYuX3JlbmRlcmVyLnJlbmRlcihzLCBpdGVtcyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2Ll9yZW5kZXJlci5yZW5kZXIocyk7XG4gICAgfVxuXG4gICAgLy8gRm9yIGFsbCB1cGRhdGVkIGRhdGFzb3VyY2VzLCBmaW5hbGl6ZSB0aGVpciBjaGFuZ2VzZXRzLlxuICAgIHZhciBkLCBkcztcbiAgICBmb3IoZCBpbiBpbnB1dC5kYXRhKSB7XG4gICAgICBkcyA9IHYuX21vZGVsLmRhdGEoZCk7XG4gICAgICBpZighZHMucmV2aXNlcygpKSBjb250aW51ZTtcbiAgICAgIGNoYW5nZXNldC5maW5hbGl6ZShkcy5sYXN0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICByZXR1cm4gKHYuX21vZGVsLnNjZW5lKHYuX3JlbmRlck5vZGUpLCB0cnVlKTsgIFxufVxuXG5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ob3B0KSB7ICAgIFxuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciB2ID0gdGhpcyxcbiAgICAgIHRyYW5zID0gb3B0LmR1cmF0aW9uXG4gICAgICAgID8gbmV3IFRyYW5zaXRpb24ob3B0LmR1cmF0aW9uLCBvcHQuZWFzZSlcbiAgICAgICAgOiBudWxsO1xuXG4gIHZhciBjcyA9IHYuX2NoYW5nZXNldDtcbiAgaWYodHJhbnMpIGNzLnRyYW5zID0gdHJhbnM7XG4gIGlmKG9wdC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYoZGwua2V5cyhjcy5kYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBcIk5ldyBkYXRhIHZhbHVlcyBhcmUgbm90IHJlZmxlY3RlZCBpbiB0aGUgdmlzdWFsaXphdGlvbi5cIiArXG4gICAgICAgIFwiIFBsZWFzZSBjYWxsIHZpZXcudXBkYXRlKCkgYmVmb3JlIHVwZGF0aW5nIGEgc3BlY2lmaWVkIHByb3BlcnR5IHNldC5cIlxuICAgIH1cblxuICAgIGNzLnJlZmxvdyAgPSB0cnVlO1xuICAgIGNzLnJlcXVlc3QgPSBvcHQucHJvcHM7XG4gIH1cblxuICB2Ll9idWlsZCA9IHYuX2J1aWxkIHx8IGJ1aWxkLmNhbGwodGhpcyk7XG5cbiAgLy8gSWYgc3BlY2lmaWMgaXRlbXMgYXJlIHNwZWNpZmllZCwgc2hvcnQtY2lyY3VpdCBkYXRhZmxvdyBncmFwaC5cbiAgLy8gRWxzZS1JZiB0aGVyZSBhcmUgc3RyZWFtaW5nIHVwZGF0ZXMsIHBlcmZvcm0gYSB0YXJnZXRlZCBwcm9wYWdhdGlvbi5cbiAgLy8gT3RoZXJ3aXNlLCByZWV2YWx1YXRlIHRoZSBlbnRpcmUgbW9kZWwgKGRhdGFzb3VyY2VzICsgc2NlbmUpLlxuICBpZihvcHQuaXRlbXMpIHsgXG4gICAgRW5jb2Rlci51cGRhdGUodGhpcy5fbW9kZWwsIG9wdC50cmFucywgb3B0LnByb3BzLCBvcHQuaXRlbXMpO1xuICAgIHYuX3JlbmRlck5vZGUuZXZhbHVhdGUoY3MpO1xuICB9IGVsc2UgaWYodi5fc3RyZWFtZXIubGlzdGVuZXJzKCkubGVuZ3RoKSB7XG4gICAgdi5fbW9kZWwucHJvcGFnYXRlKGNzLCB2Ll9zdHJlYW1lcik7XG4gICAgdi5fc3RyZWFtZXIuZGlzY29ubmVjdCgpO1xuICB9IGVsc2Uge1xuICAgIHYuX21vZGVsLmZpcmUoY3MpO1xuICB9XG5cbiAgdi5fY2hhbmdlc2V0ID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuXG4gIHJldHVybiB2LmF1dG9wYWQob3B0KTtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihpdGVtcykge1xuICB0aGlzLl9yZW5kZXJlci5yZW5kZXIodGhpcy5fbW9kZWwuc2NlbmUoKSwgaXRlbXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW5kbGVyLm9uLmFwcGx5KHRoaXMuX2hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9uU2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICB0aGlzLl9tb2RlbC5zaWduYWwobmFtZSkub24oaGFuZGxlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9oYW5kbGVyLm9mZi5hcHBseSh0aGlzLl9oYW5kbGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vZmZTaWduYWwgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuX21vZGVsLnNpZ25hbChuYW1lKS5vZmYoaGFuZGxlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuVmlldy5mYWN0b3J5ID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgdmFyIEhlYWRsZXNzVmlldyA9IHJlcXVpcmUoJy4vSGVhZGxlc3NWaWV3Jyk7XG4gIHJldHVybiBmdW5jdGlvbihvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge307XG4gICAgdmFyIGRlZnMgPSBtb2RlbC5kZWZzKCk7XG4gICAgdmFyIHYgPSAob3B0LmVsID8gbmV3IFZpZXcoKSA6IG5ldyBIZWFkbGVzc1ZpZXcoKSlcbiAgICAgIC5tb2RlbChtb2RlbClcbiAgICAgIC5yZW5kZXJlcihvcHQucmVuZGVyZXIgfHwgXCJjYW52YXNcIilcbiAgICAgIC53aWR0aChkZWZzLndpZHRoKVxuICAgICAgLmhlaWdodChkZWZzLmhlaWdodClcbiAgICAgIC5wYWRkaW5nKGRlZnMucGFkZGluZyk7XG5cbiAgICBpZihvcHQuZWwgfHwgKCFvcHQuZWwgJiYgdiBpbnN0YW5jZW9mIEhlYWRsZXNzVmlldykpIHYuaW5pdGlhbGl6ZShvcHQuZWwpO1xuICAgIGlmKG9wdC5kYXRhKSB2LmRhdGEob3B0LmRhdGEpO1xuICBcbiAgICByZXR1cm4gdjtcbiAgfTsgICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXc7XG4iLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIENvbGxlY3RvcihncmFwaCkge1xuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKVxuICAgIC5jb2xsZWN0b3IodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChDb2xsZWN0b3IucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmRhdGEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2RhdGE7IH1cblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiY29sbGVjdGluZ1wiXSk7XG5cbiAgaWYgKGlucHV0LnJlZmxvdykge1xuICAgIGlucHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCk7XG4gICAgaW5wdXQubW9kID0gdGhpcy5fZGF0YS5zbGljZSgpO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGlmIChpbnB1dC5yZW0ubGVuZ3RoKSB7XG4gICAgdmFyIGlkcyA9IGlucHV0LnJlbS5yZWR1Y2UoZnVuY3Rpb24obSx4KSB7IHJldHVybiAobVt4Ll9pZF09MSwgbSk7IH0sIHt9KTtcbiAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gaWRzW3guX2lkXSAhPT0gMTsgfSk7XG4gIH1cblxuICBpZiAoaW5wdXQuYWRkLmxlbmd0aCkge1xuICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLmxlbmd0aCA/IHRoaXMuX2RhdGEuY29uY2F0KGlucHV0LmFkZCkgOiBpbnB1dC5hZGQ7XG4gIH1cblxuICBpZiAoaW5wdXQuc29ydCkge1xuICAgIHRoaXMuX2RhdGEuc29ydChpbnB1dC5zb3J0KTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sbGVjdG9yOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuL2NoYW5nZXNldCcpLCBcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4vdHVwbGUnKSwgXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4vQ29sbGVjdG9yJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIERhdGFzb3VyY2UoZ3JhcGgsIG5hbWUsIGZhY2V0KSB7XG4gIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9kYXRhID0gW107XG4gIHRoaXMuX3NvdXJjZSA9IG51bGw7XG4gIHRoaXMuX2ZhY2V0ID0gZmFjZXQ7XG4gIHRoaXMuX2lucHV0ID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuICB0aGlzLl9vdXRwdXQgPSBudWxsOyAgICAvLyBPdXRwdXQgY2hhbmdlc2V0XG5cbiAgdGhpcy5fcGlwZWxpbmUgID0gbnVsbDsgLy8gUGlwZWxpbmUgb2YgdHJhbnNmb3JtYXRpb25zLlxuICB0aGlzLl9jb2xsZWN0b3IgPSBudWxsOyAvLyBDb2xsZWN0b3IgdG8gbWF0ZXJpYWxpemUgb3V0cHV0IG9mIHBpcGVsaW5lXG4gIHRoaXMuX3JldmlzZXMgPSBmYWxzZTsgLy8gRG9lcyBhbnkgcGlwZWxpbmUgb3BlcmF0b3IgbmVlZCB0byB0cmFjayBwcmV2P1xufTtcblxudmFyIHByb3RvID0gRGF0YXNvdXJjZS5wcm90b3R5cGU7XG5cbnByb3RvLm5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbmFtZTtcbiAgcmV0dXJuICh0aGlzLl9uYW1lID0gbmFtZSwgdGhpcyk7XG59O1xuXG5wcm90by5zb3VyY2UgPSBmdW5jdGlvbihzcmMpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gIHJldHVybiAodGhpcy5fc291cmNlID0gdGhpcy5fZ3JhcGguZGF0YShzcmMpKTtcbn07XG5cbnByb3RvLmluc2VydCA9IGZ1bmN0aW9uKGQpIHtcbiAgdmFyIHByZXYgPSB0aGlzLl9yZXZpc2VzID8gbnVsbCA6IHVuZGVmaW5lZDtcblxuICB0aGlzLl9pbnB1dC5hZGQgPSB0aGlzLl9pbnB1dC5hZGRcbiAgICAuY29uY2F0KGRsLmFycmF5KGQpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiB0dXBsZS5pbmdlc3QoZCwgcHJldik7IH0pKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmUgPSBmdW5jdGlvbih3aGVyZSkge1xuICB2YXIgZCA9IHRoaXMuX2RhdGEuZmlsdGVyKHdoZXJlKTtcbiAgdGhpcy5faW5wdXQucmVtID0gdGhpcy5faW5wdXQucmVtLmNvbmNhdChkKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by51cGRhdGUgPSBmdW5jdGlvbih3aGVyZSwgZmllbGQsIGZ1bmMpIHtcbiAgdmFyIG1vZCA9IHRoaXMuX2lucHV0Lm1vZCxcbiAgICAgIGlkcyA9IHR1cGxlLmlkTWFwKG1vZCksXG4gICAgICBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQ7IFxuXG4gIHRoaXMuX2lucHV0LmZpZWxkc1tmaWVsZF0gPSAxO1xuICB0aGlzLl9kYXRhLmZpbHRlcih3aGVyZSkuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgdmFyIHByZXYgPSB4W2ZpZWxkXSxcbiAgICAgICAgbmV4dCA9IGZ1bmMoeCk7XG4gICAgaWYgKHByZXYgIT09IG5leHQpIHtcbiAgICAgIHR1cGxlLnNldCh4LCBmaWVsZCwgbmV4dCk7XG4gICAgICBpZihpZHNbeC5faWRdICE9PSAxKSB7XG4gICAgICAgIG1vZC5wdXNoKHgpO1xuICAgICAgICBpZHNbeC5faWRdID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnZhbHVlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgcmV0dXJuIHRoaXMuX2NvbGxlY3RvciA/IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCkgOiB0aGlzLl9kYXRhO1xuXG4gIC8vIFJlcGxhY2UgYmFja2luZyBkYXRhXG4gIHRoaXMuX2lucHV0LnJlbSA9IHRoaXMuX2RhdGEuc2xpY2UoKTtcbiAgaWYgKGRhdGEpIHsgdGhpcy5pbnNlcnQoZGF0YSk7IH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBzZXRfcHJldihkKSB7IGlmKGQuX3ByZXYgPT09IHVuZGVmaW5lZCkgZC5fcHJldiA9IEMuU0VOVElORUw7IH1cblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKHApIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuXG4gIC8vIElmIHdlJ3ZlIG5vdCBuZWVkZWQgcHJldiBpbiB0aGUgcGFzdCwgYnV0IGEgbmV3IGRhdGFmbG93IG5vZGUgbmVlZHMgaXQgbm93XG4gIC8vIGVuc3VyZSBleGlzdGluZyB0dXBsZXMgaGF2ZSBwcmV2IHNldC5cbiAgaWYoIXRoaXMuX3JldmlzZXMgJiYgcCkge1xuICAgIHRoaXMuX2RhdGEuZm9yRWFjaChzZXRfcHJldik7XG4gICAgdGhpcy5faW5wdXQuYWRkLmZvckVhY2goc2V0X3ByZXYpOyAvLyBOZXcgdHVwbGVzIHRoYXQgaGF2ZW4ndCB5ZXQgYmVlbiBtZXJnZWQgaW50byBfZGF0YVxuICB9XG5cbiAgdGhpcy5fcmV2aXNlcyA9IHRoaXMuX3JldmlzZXMgfHwgcDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5sYXN0ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9vdXRwdXQ7IH07XG5cbnByb3RvLmZpcmUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBpZihpbnB1dCkgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgdGhpcy5fZ3JhcGgucHJvcGFnYXRlKHRoaXMuX2lucHV0LCB0aGlzLl9waXBlbGluZVswXSk7IFxufTtcblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbihwaXBlbGluZSkge1xuICB2YXIgZHMgPSB0aGlzLCBuLCBjO1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BpcGVsaW5lO1xuXG4gIGlmKHBpcGVsaW5lLmxlbmd0aCkge1xuICAgIC8vIElmIHdlIGhhdmUgYSBwaXBlbGluZSwgYWRkIGEgY29sbGVjdG9yIHRvIHRoZSBlbmQgdG8gbWF0ZXJpYWxpemVcbiAgICAvLyB0aGUgb3V0cHV0LlxuICAgIGRzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKHRoaXMuX2dyYXBoKTtcbiAgICBwaXBlbGluZS5wdXNoKGRzLl9jb2xsZWN0b3IpO1xuICAgIGRzLl9yZXZpc2VzID0gcGlwZWxpbmUuc29tZShmdW5jdGlvbihwKSB7IHJldHVybiBwLnJldmlzZXMoKTsgfSk7XG4gIH1cblxuICAvLyBJbnB1dCBub2RlIGFwcGxpZXMgdGhlIGRhdGFzb3VyY2UncyBkZWx0YSwgYW5kIHByb3BhZ2F0ZXMgaXQgdG8gXG4gIC8vIHRoZSByZXN0IG9mIHRoZSBwaXBlbGluZS4gSXQgcmVjZWl2ZXMgdG91Y2hlcyB0byByZWZsb3cgZGF0YS5cbiAgdmFyIGlucHV0ID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKVxuICAgIC5jb2xsZWN0b3IodHJ1ZSk7XG5cbiAgaW5wdXQuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGRlYnVnKGlucHV0LCBbXCJpbnB1dFwiLCBkcy5fbmFtZV0pO1xuXG4gICAgdmFyIGRlbHRhID0gZHMuX2lucHV0LCBcbiAgICAgICAgb3V0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICAgIHJlbTtcblxuICAgIC8vIERlbHRhIG1pZ2h0IGNvbnRhaW4gZmllbGRzIHVwZGF0ZWQgdGhyb3VnaCBBUElcbiAgICBkbC5rZXlzKGRlbHRhLmZpZWxkcykuZm9yRWFjaChmdW5jdGlvbihmKSB7IG91dC5maWVsZHNbZl0gPSAxIH0pO1xuXG4gICAgaWYoaW5wdXQucmVmbG93KSB7XG4gICAgICBvdXQubW9kID0gZHMuX2RhdGEuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdXBkYXRlIGRhdGFcbiAgICAgIGlmKGRlbHRhLnJlbS5sZW5ndGgpIHtcbiAgICAgICAgcmVtID0gdHVwbGUuaWRNYXAoZGVsdGEucmVtKTtcbiAgICAgICAgZHMuX2RhdGEgPSBkcy5fZGF0YVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gcmVtW3guX2lkXSAhPT0gMSB9KTtcbiAgICAgIH1cblxuICAgICAgaWYoZGVsdGEuYWRkLmxlbmd0aCkgZHMuX2RhdGEgPSBkcy5fZGF0YS5jb25jYXQoZGVsdGEuYWRkKTtcblxuICAgICAgLy8gcmVzZXQgY2hhbmdlIGxpc3RcbiAgICAgIGRzLl9pbnB1dCA9IGNoYW5nZXNldC5jcmVhdGUoKTtcblxuICAgICAgb3V0LmFkZCA9IGRlbHRhLmFkZDsgXG4gICAgICBvdXQubW9kID0gZGVsdGEubW9kO1xuICAgICAgb3V0LnJlbSA9IGRlbHRhLnJlbTtcbiAgICB9XG5cbiAgICByZXR1cm4gKG91dC5mYWNldCA9IGRzLl9mYWNldCwgb3V0KTtcbiAgfTtcblxuICBwaXBlbGluZS51bnNoaWZ0KGlucHV0KTtcblxuICAvLyBPdXRwdXQgbm9kZSBjYXB0dXJlcyB0aGUgbGFzdCBjaGFuZ2VzZXQgc2VlbiBieSB0aGlzIGRhdGFzb3VyY2VcbiAgLy8gKG5lZWRlZCBmb3Igam9pbnMgYW5kIGJ1aWxkcykgYW5kIG1hdGVyaWFsaXplcyBhbnkgbmVzdGVkIGRhdGEuXG4gIC8vIElmIHRoaXMgZGF0YXNvdXJjZSBpcyBmYWNldGVkLCBtYXRlcmlhbGl6ZXMgdGhlIHZhbHVlcyBpbiB0aGUgZmFjZXQuXG4gIHZhciBvdXRwdXQgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBvdXRwdXQuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGRlYnVnKGlucHV0LCBbXCJvdXRwdXRcIiwgZHMuX25hbWVdKTtcbiAgICB2YXIgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCwgdHJ1ZSk7XG5cbiAgICBpZihkcy5fZmFjZXQpIHtcbiAgICAgIGRzLl9mYWNldC52YWx1ZXMgPSBkcy52YWx1ZXMoKTtcbiAgICAgIGlucHV0LmZhY2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBkcy5fb3V0cHV0ID0gaW5wdXQ7XG4gICAgb3V0cHV0LmRhdGFbZHMuX25hbWVdID0gMTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIHBpcGVsaW5lLnB1c2gob3V0cHV0KTtcblxuICB0aGlzLl9waXBlbGluZSA9IHBpcGVsaW5lO1xuICB0aGlzLl9ncmFwaC5jb25uZWN0KGRzLl9waXBlbGluZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ubGlzdGVuZXIgPSBmdW5jdGlvbigpIHsgXG4gIHZhciBsID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpLnJvdXRlcih0cnVlKSxcbiAgICAgIGRlc3QgPSB0aGlzLFxuICAgICAgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkO1xuXG4gIGwuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGRlc3QuX3NyY01hcCA9IGRlc3QuX3NyY01hcCB8fCB7fTsgIC8vIHRvIHByb3BhZ2F0ZSB0dXBsZXMgY29ycmVjdGx5XG4gICAgdmFyIG1hcCA9IGRlc3QuX3NyY01hcCxcbiAgICAgICAgb3V0cHV0ICA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgb3V0cHV0LmFkZCA9IGlucHV0LmFkZC5tYXAoZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIChtYXBbdC5faWRdID0gdHVwbGUuZGVyaXZlKHQsIHQuX3ByZXYgIT09IHVuZGVmaW5lZCA/IHQuX3ByZXYgOiBwcmV2KSk7XG4gICAgfSk7XG4gICAgb3V0cHV0Lm1vZCA9IGlucHV0Lm1vZC5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gbWFwW3QuX2lkXTsgfSk7XG4gICAgb3V0cHV0LnJlbSA9IGlucHV0LnJlbS5tYXAoZnVuY3Rpb24odCkgeyBcbiAgICAgIHZhciBvID0gbWFwW3QuX2lkXTtcbiAgICAgIG1hcFt0Ll9pZF0gPSBudWxsO1xuICAgICAgcmV0dXJuIG87XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKGRlc3QuX2lucHV0ID0gb3V0cHV0KTtcbiAgfTtcblxuICBsLmFkZExpc3RlbmVyKHRoaXMuX3BpcGVsaW5lWzBdKTtcbiAgcmV0dXJuIGw7XG59O1xuXG5wcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYobCBpbnN0YW5jZW9mIERhdGFzb3VyY2UpIHtcbiAgICBpZih0aGlzLl9jb2xsZWN0b3IpIHRoaXMuX2NvbGxlY3Rvci5hZGRMaXN0ZW5lcihsLmxpc3RlbmVyKCkpO1xuICAgIGVsc2UgdGhpcy5fcGlwZWxpbmVbMF0uYWRkTGlzdGVuZXIobC5saXN0ZW5lcigpKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9waXBlbGluZVt0aGlzLl9waXBlbGluZS5sZW5ndGgtMV0uYWRkTGlzdGVuZXIobCk7ICAgICAgXG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICB0aGlzLl9waXBlbGluZVt0aGlzLl9waXBlbGluZS5sZW5ndGgtMV0ucmVtb3ZlTGlzdGVuZXIobCk7XG59O1xuXG5wcm90by5saXN0ZW5lcnMgPSBmdW5jdGlvbihkcykge1xuICByZXR1cm4gZHMgXG4gICAgPyB0aGlzLl9jb2xsZWN0b3IgPyB0aGlzLl9jb2xsZWN0b3IubGlzdGVuZXJzKCkgOiB0aGlzLl9waXBlbGluZVswXS5saXN0ZW5lcnMoKVxuICAgIDogdGhpcy5fcGlwZWxpbmVbdGhpcy5fcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhc291cmNlOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBIZWFwID0gcmVxdWlyZSgnaGVhcCcpLFxuICAgIERhdGFzb3VyY2UgPSByZXF1aXJlKCcuL0RhdGFzb3VyY2UnKSxcbiAgICBTaWduYWwgPSByZXF1aXJlKCcuL1NpZ25hbCcpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyYXBoKCkge1xufVxuXG52YXIgcHJvdG8gPSBHcmFwaC5wcm90b3R5cGU7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3RhbXAgPSAwO1xuICB0aGlzLl9yYW5rICA9IDA7XG5cbiAgdGhpcy5fZGF0YSA9IHt9O1xuICB0aGlzLl9zaWduYWxzID0ge307XG5cbiAgdGhpcy5kb05vdFByb3BhZ2F0ZSA9IHt9O1xufTtcblxucHJvdG8uZGF0YSA9IGZ1bmN0aW9uKG5hbWUsIHBpcGVsaW5lLCBmYWNldCkge1xuICB2YXIgZGIgPSB0aGlzLl9kYXRhO1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRsLmtleXMoZGIpLm1hcChmdW5jdGlvbihkKSB7IHJldHVybiBkYltkXTsgfSk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBkYltuYW1lXTtcbiAgcmV0dXJuIChkYltuYW1lXSA9IG5ldyBEYXRhc291cmNlKHRoaXMsIG5hbWUsIGZhY2V0KS5waXBlbGluZShwaXBlbGluZSkpO1xufTtcblxucHJvdG8uZGF0YVZhbHVlcyA9IGZ1bmN0aW9uKG5hbWVzKSB7XG4gIHZhciBncmFwaCA9IHRoaXM7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgbmFtZXMgPSBkbC5rZXlzKHRoaXMuX2RhdGEpO1xuICBpZiAoIWRsLmlzQXJyYXkobmFtZXMpKSByZXR1cm4gdGhpcy5fZGF0YVtuYW1lc10udmFsdWVzKCk7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oZGIsIG4pIHtcbiAgICByZXR1cm4gKGRiW25dID0gZ3JhcGguX2RhdGFbbl0udmFsdWVzKCksIGRiKTtcbiAgfSwge30pO1xufTtcblxuZnVuY3Rpb24gc2lnbmFsKG5hbWUpIHtcbiAgdmFyIG0gPSB0aGlzLCBpLCBsZW47XG4gIGlmKCFkbC5pc0FycmF5KG5hbWUpKSByZXR1cm4gdGhpcy5fc2lnbmFsc1tuYW1lXTtcbiAgcmV0dXJuIG5hbWUubWFwKGZ1bmN0aW9uKG4pIHsgbS5fc2lnbmFsc1tuXTsgfSk7XG59XG5cbnByb3RvLnNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGluaXQpIHtcbiAgdmFyIG0gPSB0aGlzO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gc2lnbmFsLmNhbGwodGhpcywgbmFtZSk7XG4gIHJldHVybiAodGhpcy5fc2lnbmFsc1tuYW1lXSA9IG5ldyBTaWduYWwodGhpcywgbmFtZSwgaW5pdCkpO1xufTtcblxucHJvdG8uc2lnbmFsVmFsdWVzID0gZnVuY3Rpb24obmFtZXMpIHtcbiAgdmFyIGdyYXBoID0gdGhpcztcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIG5hbWVzID0gZGwua2V5cyh0aGlzLl9zaWduYWxzKTtcbiAgaWYoIWRsLmlzQXJyYXkobmFtZXMpKSByZXR1cm4gdGhpcy5fc2lnbmFsc1tuYW1lc10udmFsdWUoKTtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihzZywgbikge1xuICAgIHJldHVybiAoc2dbbl0gPSBncmFwaC5fc2lnbmFsc1tuXS52YWx1ZSgpLCBzZyk7XG4gIH0sIHt9KTtcbn07XG5cbnByb3RvLnNpZ25hbFJlZiA9IGZ1bmN0aW9uKHJlZikge1xuICBpZighZGwuaXNBcnJheShyZWYpKSByZWYgPSBkbC5maWVsZChyZWYpO1xuICB2YXIgdmFsdWUgPSB0aGlzLnNpZ25hbChyZWYuc2hpZnQoKSkudmFsdWUoKTtcbiAgaWYocmVmLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZm4gPSBGdW5jdGlvbihcInNcIiwgXCJyZXR1cm4gc1tcIityZWYubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiKTtcbiAgICB2YWx1ZSA9IGZuLmNhbGwobnVsbCwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxudmFyIHNjaGVkdWxlID0gZnVuY3Rpb24oYSwgYikge1xuICAvLyBJZiB0aGUgbm9kZXMgYXJlIGVxdWFsLCBwcm9wYWdhdGUgdGhlIG5vbi1yZWZsb3cgcHVsc2UgZmlyc3QsXG4gIC8vIHNvIHRoYXQgd2UgY2FuIGlnbm9yZSBzdWJzZXF1ZW50IHJlZmxvdyBwdWxzZXMuIFxuICBpZihhLnJhbmsgPT0gYi5yYW5rKSByZXR1cm4gYS5wdWxzZS5yZWZsb3cgPyAxIDogLTE7XG4gIGVsc2UgcmV0dXJuIGEucmFuayAtIGIucmFuazsgXG59O1xuXG5wcm90by5wcm9wYWdhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICB2YXIgdiwgbCwgbiwgcCwgciwgaSwgbGVuLCByZWZsb3dlZDtcblxuICAvLyBuZXcgUFEgd2l0aCBlYWNoIHByb3BhZ2F0aW9uIGN5Y2xlIHNvIHRoYXQgd2UgY2FuIHB1bHNlIGJyYW5jaGVzXG4gIC8vIG9mIHRoZSBkYXRhZmxvdyBncmFwaCBkdXJpbmcgYSBwcm9wYWdhdGlvbiAoZS5nLiwgd2hlbiBjcmVhdGluZ1xuICAvLyBhIG5ldyBpbmxpbmUgZGF0YXNvdXJjZSkuXG4gIHZhciBwcSA9IG5ldyBIZWFwKHNjaGVkdWxlKTsgXG5cbiAgaWYocHVsc2Uuc3RhbXApIHRocm93IFwiUHVsc2UgYWxyZWFkeSBoYXMgYSBub24temVybyBzdGFtcFwiXG5cbiAgcHVsc2Uuc3RhbXAgPSArK3RoaXMuX3N0YW1wO1xuICBwcS5wdXNoKHsgbm9kZTogbm9kZSwgcHVsc2U6IHB1bHNlLCByYW5rOiBub2RlLnJhbmsoKSB9KTtcblxuICB3aGlsZSAocHEuc2l6ZSgpID4gMCkge1xuICAgIHYgPSBwcS5wb3AoKSwgbiA9IHYubm9kZSwgcCA9IHYucHVsc2UsIHIgPSB2LnJhbmssIGwgPSBuLl9saXN0ZW5lcnM7XG4gICAgcmVmbG93ZWQgPSBwLnJlZmxvdyAmJiBuLmxhc3QoKSA+PSBwLnN0YW1wO1xuXG4gICAgaWYocmVmbG93ZWQpIGNvbnRpbnVlOyAvLyBEb24ndCBuZWVkbGVzc2x5IHJlZmxvdyBvcHMuXG5cbiAgICAvLyBBIG5vZGUncyByYW5rIG1pZ2h0IGNoYW5nZSBkdXJpbmcgYSBwcm9wYWdhdGlvbiAoZS5nLiBpbnN0YW50aWF0aW5nXG4gICAgLy8gYSBncm91cCdzIGRhdGFmbG93IGJyYW5jaCkuIFJlLXF1ZXVlIGlmIGl0IGhhcy4gVFxuICAgIC8vIFRPRE86IHVzZSBwcS5yZXBsYWNlIG9yIHBxLnBvcHB1c2g/XG4gICAgaWYociAhPSBuLnJhbmsoKSkge1xuICAgICAgZGVidWcocCwgWydSYW5rIG1pc21hdGNoJywgciwgbi5yYW5rKCldKTtcbiAgICAgIHBxLnB1c2goeyBub2RlOiBuLCBwdWxzZTogcCwgcmFuazogbi5yYW5rKCkgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwID0gdGhpcy5ldmFsdWF0ZShwLCBuKTtcblxuICAgIC8vIEV2ZW4gaWYgd2UgZGlkbid0IHJ1biB0aGUgbm9kZSwgd2Ugc3RpbGwgd2FudCB0byBwcm9wYWdhdGUgXG4gICAgLy8gdGhlIHB1bHNlLiBcbiAgICBpZiAocCAhPT0gdGhpcy5kb05vdFByb3BhZ2F0ZSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwcS5wdXNoKHsgbm9kZTogbFtpXSwgcHVsc2U6IHAsIHJhbms6IGxbaV0uX3JhbmsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDb25uZWN0IGEgYnJhbmNoIG9mIGRhdGFmbG93IG5vZGVzLiBcbi8vIERlcGVuZGVuY2llcyBnZXQgd2lyZWQgdG8gdGhlIG5lYXJlc3QgY29sbGVjdG9yLiBcbmZ1bmN0aW9uIGZvckVhY2hOb2RlKGJyYW5jaCwgZm4pIHtcbiAgdmFyIG5vZGUsIGNvbGxlY3RvciwgaSwgbGVuO1xuICBmb3IoaT0wLCBsZW49YnJhbmNoLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG5vZGUgPSBicmFuY2hbaV07XG4gICAgaWYobm9kZS5jb2xsZWN0b3IoKSkgY29sbGVjdG9yID0gbm9kZTtcbiAgICBmbihub2RlLCBjb2xsZWN0b3IsIGkpO1xuICB9XG59XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgZGVidWcoe30sIFsnY29ubmVjdGluZyddKTtcbiAgdmFyIGdyYXBoID0gdGhpcztcbiAgZm9yRWFjaE5vZGUoYnJhbmNoLCBmdW5jdGlvbihuLCBjLCBpKSB7XG4gICAgdmFyIGRhdGEgPSBuLmRlcGVuZGVuY3koQy5EQVRBKSxcbiAgICAgICAgc2lnbmFscyA9IG4uZGVwZW5kZW5jeShDLlNJR05BTFMpO1xuXG4gICAgaWYoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyBcbiAgICAgICAgZ3JhcGguZGF0YShkKVxuICAgICAgICAgIC5yZXZpc2VzKG4ucmV2aXNlcygpKVxuICAgICAgICAgIC5hZGRMaXN0ZW5lcihjKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmKHNpZ25hbHMubGVuZ3RoID4gMCkge1xuICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgZ3JhcGguc2lnbmFsKHMpLmFkZExpc3RlbmVyKGMpOyB9KTtcbiAgICB9XG5cbiAgICBpZihpID4gMCkge1xuICAgICAgYnJhbmNoW2ktMV0uYWRkTGlzdGVuZXIoYnJhbmNoW2ldKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIGRlYnVnKHt9LCBbJ2Rpc2Nvbm5lY3RpbmcnXSk7XG4gIHZhciBncmFwaCA9IHRoaXM7XG5cbiAgZm9yRWFjaE5vZGUoYnJhbmNoLCBmdW5jdGlvbihuLCBjLCBpKSB7XG4gICAgdmFyIGRhdGEgPSBuLmRlcGVuZGVuY3koQy5EQVRBKSxcbiAgICAgICAgc2lnbmFscyA9IG4uZGVwZW5kZW5jeShDLlNJR05BTFMpO1xuXG4gICAgaWYoZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyBncmFwaC5kYXRhKGQpLnJlbW92ZUxpc3RlbmVyKGMpOyB9KTtcbiAgICB9XG5cbiAgICBpZihzaWduYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IGdyYXBoLnNpZ25hbChzKS5yZW1vdmVMaXN0ZW5lcihjKSB9KTtcbiAgICB9XG5cbiAgICBuLmRpc2Nvbm5lY3QoKTsgIFxuICB9KTtcblxuICByZXR1cm4gYnJhbmNoO1xufTtcblxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciByZWZsb3dlZCA9ICFwdWxzZS5yZWZsb3cgfHwgKHB1bHNlLnJlZmxvdyAmJiBub2RlLmxhc3QoKSA+PSBwdWxzZS5zdGFtcCksXG4gICAgICBydW4gPSAhIXB1bHNlLmFkZC5sZW5ndGggfHwgISFwdWxzZS5yZW0ubGVuZ3RoIHx8IG5vZGUucm91dGVyKCk7XG4gIHJ1biA9IHJ1biB8fCAhcmVmbG93ZWQ7XG4gIHJldHVybiBydW4gfHwgbm9kZS5yZWV2YWx1YXRlKHB1bHNlKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgaWYoIXRoaXMucmVldmFsdWF0ZShwdWxzZSwgbm9kZSkpIHJldHVybiBwdWxzZTtcbiAgcHVsc2UgPSBub2RlLmV2YWx1YXRlKHB1bHNlKTtcbiAgbm9kZS5sYXN0KHB1bHNlLnN0YW1wKTtcbiAgcmV0dXJuIHB1bHNlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKSxcbiAgICBSRUVWQUwgPSBbQy5EQVRBLCBDLkZJRUxEUywgQy5TQ0FMRVMsIEMuU0lHTkFMU107XG5cbnZhciBub2RlX2lkID0gMTtcblxuZnVuY3Rpb24gTm9kZShncmFwaCkge1xuICBpZihncmFwaCkgdGhpcy5pbml0KGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IE5vZGUucHJvdG90eXBlO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5faWQgPSBub2RlX2lkKys7XG4gIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gIHRoaXMuX3JhbmsgPSArK2dyYXBoLl9yYW5rOyAvLyBGb3IgdG9wb2xvZ2lhbCBzb3J0XG4gIHRoaXMuX3N0YW1wID0gMDsgIC8vIExhc3Qgc3RhbXAgc2VlblxuXG4gIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICB0aGlzLl9yZWdpc3RlcmVkID0ge307IC8vIFRvIHByZXZlbnQgZHVwbGljYXRlIGxpc3RlbmVyc1xuXG4gIHRoaXMuX2RlcHMgPSB7XG4gICAgZGF0YTogICAgW10sXG4gICAgZmllbGRzOiAgW10sXG4gICAgc2NhbGVzOiAgW10sXG4gICAgc2lnbmFsczogW10sXG4gIH07XG5cbiAgdGhpcy5faXNSb3V0ZXIgPSBmYWxzZTsgLy8gUmVzcG9uc2libGUgZm9yIHByb3BhZ2F0aW5nIHR1cGxlcywgY2Fubm90IGV2ZXIgYmUgc2tpcHBlZFxuICB0aGlzLl9pc0NvbGxlY3RvciA9IGZhbHNlOyAgLy8gSG9sZHMgYSBtYXRlcmlhbGl6ZWQgZGF0YXNldCwgcHVsc2UgdG8gcmVmbG93XG4gIHRoaXMuX3JldmlzZXMgPSBmYWxzZTsgLy8gRG9lcyB0aGUgb3BlcmF0b3IgcmVxdWlyZSB0dXBsZXMnIHByZXZpb3VzIHZhbHVlcz8gXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCk7XG4gIG4uZXZhbHVhdGUgPSB0aGlzLmV2YWx1YXRlO1xuICBuLl9kZXBzID0gdGhpcy5fZGVwcztcbiAgbi5faXNSb3V0ZXIgPSB0aGlzLl9pc1JvdXRlcjtcbiAgbi5faXNDb2xsZWN0b3IgPSB0aGlzLl9pc0NvbGxlY3RvcjtcbiAgcmV0dXJuIG47XG59O1xuXG5wcm90by5yYW5rID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9yYW5rOyB9O1xuXG5wcm90by5sYXN0ID0gZnVuY3Rpb24oc3RhbXApIHsgXG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc3RhbXA7XG4gIHRoaXMuX3N0YW1wID0gc3RhbXA7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uZGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHR5cGUsIGRlcHMpIHtcbiAgdmFyIGQgPSB0aGlzLl9kZXBzW3R5cGVdO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZDtcbiAgaWYoZGVwcyA9PT0gbnVsbCkgeyAvLyBDbGVhciBkZXBlbmRlbmNpZXMgb2YgYSBjZXJ0YWluIHR5cGVcbiAgICB3aGlsZShkLmxlbmd0aCA+IDApIGQucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYoIWRsLmlzQXJyYXkoZGVwcykgJiYgZC5pbmRleE9mKGRlcHMpIDwgMCkgZC5wdXNoKGRlcHMpO1xuICAgIGVsc2UgZC5wdXNoLmFwcGx5KGQsIGRsLmFycmF5KGRlcHMpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJvdXRlciA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pc1JvdXRlcjtcbiAgdGhpcy5faXNSb3V0ZXIgPSAhIWJvb2xcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5jb2xsZWN0b3IgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faXNDb2xsZWN0b3I7XG4gIHRoaXMuX2lzQ29sbGVjdG9yID0gISFib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJldmlzZXMgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmV2aXNlcztcbiAgdGhpcy5fcmV2aXNlcyA9ICEhYm9vbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5saXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycztcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZighKGwgaW5zdGFuY2VvZiBOb2RlKSkgdGhyb3cgXCJMaXN0ZW5lciBpcyBub3QgYSBOb2RlXCI7XG4gIGlmKHRoaXMuX3JlZ2lzdGVyZWRbbC5faWRdKSByZXR1cm4gdGhpcztcblxuICB0aGlzLl9saXN0ZW5lcnMucHVzaChsKTtcbiAgdGhpcy5fcmVnaXN0ZXJlZFtsLl9pZF0gPSAxO1xuICBpZih0aGlzLl9yYW5rID4gbC5fcmFuaykge1xuICAgIHZhciBxID0gW2xdO1xuICAgIHdoaWxlKHEubGVuZ3RoKSB7XG4gICAgICB2YXIgY3VyID0gcS5zcGxpY2UoMCwxKVswXTtcbiAgICAgIGN1ci5fcmFuayA9ICsrdGhpcy5fZ3JhcGguX3Jhbms7XG4gICAgICBxLnB1c2guYXBwbHkocSwgY3VyLl9saXN0ZW5lcnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAobCkge1xuICB2YXIgZm91bmRTZW5kaW5nID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuICYmICFmb3VuZFNlbmRpbmc7IGkrKykge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbaV0gPT09IGwpIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9yZWdpc3RlcmVkW2wuX2lkXSA9IG51bGw7XG4gICAgICBmb3VuZFNlbmRpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIGZvdW5kU2VuZGluZztcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX3JlZ2lzdGVyZWQgPSB7fTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHsgcmV0dXJuIHB1bHNlOyB9XG5cbnByb3RvLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkge1xuICB2YXIgbm9kZSA9IHRoaXMsIHJlZXZhbCA9IGZhbHNlO1xuICByZXR1cm4gUkVFVkFMLnNvbWUoZnVuY3Rpb24ocHJvcCkge1xuICAgIHJlZXZhbCA9IHJlZXZhbCB8fCBub2RlLl9kZXBzW3Byb3BdLnNvbWUoZnVuY3Rpb24oaykgeyByZXR1cm4gISFwdWxzZVtwcm9wXVtrXSB9KTtcbiAgICByZXR1cm4gcmVldmFsO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIFNpZ25hbChncmFwaCwgbmFtZSwgaW5pdCkge1xuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9uYW1lICA9IG5hbWU7XG4gIHRoaXMuX3ZhbHVlID0gaW5pdDtcbiAgdGhpcy5faGFuZGxlcnMgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgcHJvdG8gPSAoU2lnbmFsLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5uYW1lID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9uYW1lOyB9O1xuXG5wcm90by52YWx1ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB0aGlzLl92YWx1ZSA9IHZhbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5maXJlID0gZnVuY3Rpb24oY3MpIHtcbiAgaWYoIWNzKSBjcyA9IGNoYW5nZXNldC5jcmVhdGUobnVsbCwgdHJ1ZSk7XG4gIGNzLnNpZ25hbHNbdGhpcy5fbmFtZV0gPSAxO1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUoY3MsIHRoaXMpO1xufTtcblxucHJvdG8ub24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHZhciBzZyA9IHRoaXMsXG4gICAgICBub2RlID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpO1xuXG4gIG5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiAoaGFuZGxlcihzZy5uYW1lKCksIHNnLnZhbHVlKCkpLCBpbnB1dCk7XG4gIH07XG5cbiAgdGhpcy5faGFuZGxlcnMucHVzaCh7IGhhbmRsZXI6IGhhbmRsZXIsIG5vZGU6IG5vZGUgfSk7XG4gIHJldHVybiB0aGlzLmFkZExpc3RlbmVyKG5vZGUpO1xufTtcblxucHJvdG8ub2ZmID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICB2YXIgc2cgPSB0aGlzLCBoID0gdGhpcy5faGFuZGxlcnM7XG4gIGZvcih2YXIgaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmKCFoYW5kbGVyIHx8IGhbaV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgc2cucmVtb3ZlTGlzdGVuZXIoaC5zcGxpY2UoaSwgMSlbMF0ubm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaWduYWw7IiwidmFyIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xudmFyIFJFRVZBTCA9IFtDLkRBVEEsIEMuRklFTERTLCBDLlNDQUxFUywgQy5TSUdOQUxTXTtcblxuZnVuY3Rpb24gY3JlYXRlKGNzLCByZWZsb3cpIHtcbiAgdmFyIG91dCA9IHt9O1xuICBjb3B5KGNzLCBvdXQpO1xuXG4gIG91dC5hZGQgPSBbXTtcbiAgb3V0Lm1vZCA9IFtdO1xuICBvdXQucmVtID0gW107XG5cbiAgb3V0LnJlZmxvdyA9IHJlZmxvdztcblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiByZXNldF9wcmV2KHgpIHtcbiAgeC5fcHJldiA9ICh4Ll9wcmV2ID09PSB1bmRlZmluZWQpID8gdW5kZWZpbmVkIDogQy5TRU5USU5FTDtcbn1cblxuZnVuY3Rpb24gZmluYWxpemUoY3MpIHtcbiAgZm9yKGk9MCwgbGVuPWNzLmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHJlc2V0X3ByZXYoY3MuYWRkW2ldKTtcbiAgZm9yKGk9MCwgbGVuPWNzLm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHJlc2V0X3ByZXYoY3MubW9kW2ldKTtcbn1cblxuZnVuY3Rpb24gY29weShhLCBiKSB7XG4gIGIuc3RhbXAgPSBhID8gYS5zdGFtcCA6IDA7XG4gIGIuc29ydCAgPSBhID8gYS5zb3J0ICA6IG51bGw7XG4gIGIuZmFjZXQgPSBhID8gYS5mYWNldCA6IG51bGw7XG4gIGIudHJhbnMgPSBhID8gYS50cmFucyA6IG51bGw7XG4gIGIucmVxdWVzdCA9IGEgPyBhLnJlcXVlc3QgOiBudWxsO1xuICBSRUVWQUwuZm9yRWFjaChmdW5jdGlvbihkKSB7IGJbZF0gPSBhID8gYVtkXSA6IHt9OyB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogY3JlYXRlLFxuICBjb3B5OiBjb3B5LFxuICBmaW5hbGl6ZTogZmluYWxpemUsXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKSxcbiAgICB0dXBsZV9pZCA9IDE7XG5cbi8vIE9iamVjdC5jcmVhdGUgaXMgZXhwZW5zaXZlLiBTbywgd2hlbiBpbmdlc3RpbmcsIHRydXN0IHRoYXQgdGhlXG4vLyBkYXR1bSBpcyBhbiBvYmplY3QgdGhhdCBoYXMgYmVlbiBhcHByb3ByaWF0ZWx5IHNhbmRib3hlZCBmcm9tIFxuLy8gdGhlIG91dHNpZGUgZW52aXJvbm1lbnQuIFxuZnVuY3Rpb24gaW5nZXN0KGRhdHVtLCBwcmV2KSB7XG4gIGRhdHVtID0gZGwuaXNPYmplY3QoZGF0dW0pID8gZGF0dW0gOiB7ZGF0YTogZGF0dW19O1xuICBkYXR1bS5faWQgPSB0dXBsZV9pZCsrO1xuICBkYXR1bS5fcHJldiA9IChwcmV2ICE9PSB1bmRlZmluZWQpID8gKHByZXYgfHwgQy5TRU5USU5FTCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBkYXR1bTtcbn1cblxuZnVuY3Rpb24gZGVyaXZlKGRhdHVtLCBwcmV2KSB7XG4gIHJldHVybiBpbmdlc3QoT2JqZWN0LmNyZWF0ZShkYXR1bSksIHByZXYpO1xufVxuXG4vLyBXQVJOSU5HOiBvcGVyYXRvcnMgc2hvdWxkIG9ubHkgY2FsbCB0aGlzIG9uY2UgcGVyIHRpbWVzdGFtcCFcbmZ1bmN0aW9uIHNldCh0LCBrLCB2KSB7XG4gIHZhciBwcmV2ID0gdFtrXTtcbiAgaWYocHJldiA9PT0gdikgcmV0dXJuO1xuICBzZXRfcHJldih0LCBrKTtcbiAgdFtrXSA9IHY7XG59XG5cbmZ1bmN0aW9uIHNldF9wcmV2KHQsIGspIHtcbiAgaWYodC5fcHJldiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gIHQuX3ByZXYgPSAodC5fcHJldiA9PT0gQy5TRU5USU5FTCkgPyB7fSA6IHQuX3ByZXY7XG4gIHQuX3ByZXZba10gPSB0W2tdO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHsgdHVwbGVfaWQgPSAxOyB9XG5cbmZ1bmN0aW9uIGlkTWFwKGEpIHtcbiAgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uKG0seCkge1xuICAgIHJldHVybiAobVt4Ll9pZF0gPSAxLCBtKTtcbiAgfSwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluZ2VzdDogaW5nZXN0LFxuICBkZXJpdmU6IGRlcml2ZSxcbiAgc2V0OiAgICBzZXQsXG4gIHByZXY6ICAgc2V0X3ByZXYsXG4gIHJlc2V0OiAgcmVzZXQsXG4gIGlkTWFwOiAgaWRNYXBcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBjb25zdGFudHMgPSBvcHQuY29uc3RhbnRzIHx8IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG4gIHZhciBmdW5jdGlvbnMgPSAob3B0LmZ1bmN0aW9ucyB8fCByZXF1aXJlKCcuL2Z1bmN0aW9ucycpKShjb2RlZ2VuKTtcbiAgdmFyIGlkV2hpdGVMaXN0ID0gb3B0LmlkV2hpdGVMaXN0ID8gZGwudG9NYXAob3B0LmlkV2hpdGVMaXN0KSA6IG51bGw7XG4gIHZhciBpZEJsYWNrTGlzdCA9IG9wdC5pZEJsYWNrTGlzdCA/IGRsLnRvTWFwKG9wdC5pZEJsYWNrTGlzdCkgOiBudWxsO1xuICB2YXIgbWVtYmVyRGVwdGggPSAwO1xuXG4gIC8vIFRPRE8gZ2VuZXJhbGl6ZT9cbiAgdmFyIERBVFVNID0gJ2QnO1xuICB2YXIgU0lHTkFMX1BSRUZJWCA9ICdzZy4nO1xuICB2YXIgc2lnbmFscyA9IHt9O1xuICB2YXIgZmllbGRzID0ge307XG5cbiAgZnVuY3Rpb24gY29kZWdlbl93cmFwKGFzdCkgeyAgICBcbiAgICB2YXIgcmV0dmFsID0ge1xuICAgICAgZm46IGNvZGVnZW4oYXN0KSxcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoc2lnbmFscyksXG4gICAgICBmaWVsZHM6IGRsLmtleXMoZmllbGRzKVxuICAgIH07XG4gICAgc2lnbmFscyA9IHt9O1xuICAgIGZpZWxkcyA9IHt9O1xuICAgIHJldHVybiByZXR2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBjb2RlZ2VuKGFzdCkge1xuICAgIGlmIChhc3QgaW5zdGFuY2VvZiBTdHJpbmcpIHJldHVybiBhc3Q7XG4gICAgdmFyIGdlbmVyYXRvciA9IENPREVHRU5fVFlQRVNbYXN0LnR5cGVdO1xuICAgIGlmIChnZW5lcmF0b3IgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgdHlwZTogXCIgKyBhc3QudHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBnZW5lcmF0b3IoYXN0KTtcbiAgfVxuXG4gIHZhciBDT0RFR0VOX1RZUEVTID0ge1xuICAgIFwiTGl0ZXJhbFwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLnJhdztcbiAgICAgIH0sXG4gICAgXCJJZGVudGlmaWVyXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGlkID0gbi5uYW1lO1xuICAgICAgICBpZiAobWVtYmVyRGVwdGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdGFudHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN0YW50c1tpZF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkV2hpdGVMaXN0KSB7XG4gICAgICAgICAgaWYgKGlkV2hpdGVMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWduYWxzW2lkXSA9IDE7XG4gICAgICAgICAgICByZXR1cm4gU0lHTkFMX1BSRUZJWCArIGlkOyAvLyBIQUNLaXNoLi4uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpZEJsYWNrTGlzdCAmJiBpZEJsYWNrTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGlkZW50aWZpZXI6IFwiICsgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0sXG4gICAgXCJQcm9ncmFtXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4uYm9keS5tYXAoY29kZWdlbikuam9pbihcIlxcblwiKTtcbiAgICAgIH0sXG4gICAgXCJNZW1iZXJFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdmFyIGQgPSAhbi5jb21wdXRlZDtcbiAgICAgICAgdmFyIG8gPSBjb2RlZ2VuKG4ub2JqZWN0KTtcbiAgICAgICAgaWYgKGQpIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBwID0gY29kZWdlbihuLnByb3BlcnR5KTtcbiAgICAgICAgaWYgKG8gPT09IERBVFVNKSB7IGZpZWxkc1twXSA9IDE7IH0gLy8gSEFDS2lzaC4uLlxuICAgICAgICBpZiAoZCkgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgICAgcmV0dXJuIG8gKyAoZCA/IFwiLlwiK3AgOiBcIltcIitwK1wiXVwiKTtcbiAgICAgIH0sXG4gICAgXCJDYWxsRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIGlmIChuLmNhbGxlZS50eXBlICE9PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgY2FsbGVlIHR5cGU6IFwiICsgbi5jYWxsZWUudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxlZSA9IG4uY2FsbGVlLm5hbWU7XG4gICAgICAgIHZhciBhcmdzID0gbi5hcmd1bWVudHM7XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShjYWxsZWUpICYmIGZ1bmN0aW9uc1tjYWxsZWVdO1xuICAgICAgICBpZiAoIWZuKSB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgZnVuY3Rpb246IFwiICsgY2FsbGVlKTtcbiAgICAgICAgcmV0dXJuIGZuIGluc3RhbmNlb2YgRnVuY3Rpb25cbiAgICAgICAgICA/IGZuKGFyZ3MpXG4gICAgICAgICAgOiBmbiArIFwiKFwiICsgYXJncy5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJBcnJheUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCJbXCIgKyBuLmVsZW1lbnRzLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgfSxcbiAgICBcIkJpbmFyeUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBjb2RlZ2VuKG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLnJpZ2h0KSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIlVuYXJ5RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4uYXJndW1lbnQpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiVXBkYXRlRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIChwcmVmaXhcbiAgICAgICAgICA/IG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4uYXJndW1lbnQpXG4gICAgICAgICAgOiBjb2RlZ2VuKG4uYXJndW1lbnQpICsgbi5vcGVyYXRvclxuICAgICAgICApICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgY29kZWdlbihuLnRlc3QpXG4gICAgICAgICAgKyBcIj9cIiArIGNvZGVnZW4obi5jb25zZXF1ZW50KVxuICAgICAgICAgICsgXCI6XCIgKyBjb2RlZ2VuKG4uYWx0ZXJuYXRlKVxuICAgICAgICAgICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiTG9naWNhbEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBjb2RlZ2VuKG4ubGVmdCkgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLnJpZ2h0KSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIk9iamVjdEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCJ7XCIgKyBuLnByb3BlcnRpZXMubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICB9LFxuICAgIFwiUHJvcGVydHlcIjogZnVuY3Rpb24obikge1xuICAgICAgICBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgICB2YXIgayA9IGNvZGVnZW4obi5rZXkpO1xuICAgICAgICBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgICByZXR1cm4gayArIFwiOlwiICsgY29kZWdlbihuLnZhbHVlKTtcbiAgICAgIH0sXG4gICAgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIGNvZGVnZW4obi5leHByZXNzaW9uKTtcbiAgICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiBjb2RlZ2VuX3dyYXA7XG59OyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIk5hTlwiOiAgICAgXCJOYU5cIixcbiAgXCJFXCI6ICAgICAgIFwiTWF0aC5FXCIsXG4gIFwiTE4yXCI6ICAgICBcIk1hdGguTE4yXCIsXG4gIFwiTE4xMFwiOiAgICBcIk1hdGguTE4xMFwiLFxuICBcIkxPRzJFXCI6ICAgXCJNYXRoLkxPRzJFXCIsXG4gIFwiTE9HMTBFXCI6ICBcIk1hdGguTE9HMTBFXCIsXG4gIFwiUElcIjogICAgICBcIk1hdGguUElcIixcbiAgXCJTUVJUMV8yXCI6IFwiTWF0aC5TUVJUMV8yXCIsXG4gIFwiU1FSVDJcIjogICBcIk1hdGguU1FSVDJcIlxufTsiLCJ2YXIgZGF0YWxpYiA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb2RlZ2VuKSB7XG5cbiAgZnVuY3Rpb24gZm5jYWxsKG5hbWUsIGFyZ3MsIGNhc3QsIHR5cGUpIHtcbiAgICB2YXIgb2JqID0gY29kZWdlbihhcmdzWzBdKTtcbiAgICBpZiAoY2FzdCkge1xuICAgICAgb2JqID0gY2FzdCArIFwiKFwiICsgb2JqICsgXCIpXCI7XG4gICAgICBpZiAoZGwuc3RhcnRzV2l0aChjYXN0LCBcIm5ldyBcIikpIG9iaiA9IFwiKFwiICsgb2JqICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBvYmogKyBcIi5cIiArIG5hbWUgKyAodHlwZSA8IDAgPyBcIlwiIDogdHlwZSA9PT0gMFxuICAgICAgPyBcIigpXCJcbiAgICAgIDogXCIoXCIgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgfVxuICBcbiAgdmFyIERBVEUgPSBcIm5ldyBEYXRlXCI7XG4gIHZhciBTVFJJTkcgPSBcIlN0cmluZ1wiO1xuICB2YXIgUkVHRVhQID0gXCJSZWdFeHBcIjtcblxuICByZXR1cm4ge1xuICAgIC8vIE1BVEggZnVuY3Rpb25zXG4gICAgXCJpc05hTlwiOiAgICBcImlzTmFOXCIsXG4gICAgXCJpc0Zpbml0ZVwiOiBcImlzRmluaXRlXCIsXG4gICAgXCJhYnNcIjogICAgICBcIk1hdGguYWJzXCIsXG4gICAgXCJhY29zXCI6ICAgICBcIk1hdGguYWNvc1wiLFxuICAgIFwiYXNpblwiOiAgICAgXCJNYXRoLmFzaW5cIixcbiAgICBcImF0YW5cIjogICAgIFwiTWF0aC5hdGFuXCIsXG4gICAgXCJhdGFuMlwiOiAgICBcIk1hdGguYXRhbjJcIixcbiAgICBcImNlaWxcIjogICAgIFwiTWF0aC5jZWlsXCIsXG4gICAgXCJjb3NcIjogICAgICBcIk1hdGguY29zXCIsXG4gICAgXCJleHBcIjogICAgICBcIk1hdGguZXhwXCIsXG4gICAgXCJmbG9vclwiOiAgICBcIk1hdGguZmxvb3JcIixcbiAgICBcImxvZ1wiOiAgICAgIFwiTWF0aC5sb2dcIixcbiAgICBcIm1heFwiOiAgICAgIFwiTWF0aC5tYXhcIixcbiAgICBcIm1pblwiOiAgICAgIFwiTWF0aC5taW5cIixcbiAgICBcInBvd1wiOiAgICAgIFwiTWF0aC5wb3dcIixcbiAgICBcInJhbmRvbVwiOiAgIFwiTWF0aC5yYW5kb21cIixcbiAgICBcInJvdW5kXCI6ICAgIFwiTWF0aC5yb3VuZFwiLFxuICAgIFwic2luXCI6ICAgICAgXCJNYXRoLnNpblwiLFxuICAgIFwic3FydFwiOiAgICAgXCJNYXRoLnNxcnRcIixcbiAgICBcInRhblwiOiAgICAgIFwiTWF0aC50YW5cIixcblxuICAgIC8vIERBVEUgZnVuY3Rpb25zXG4gICAgXCJub3dcIjogICAgICBcIkRhdGUubm93XCIsXG4gICAgXCJkYXRldGltZVwiOiBcIm5ldyBEYXRlXCIsXG4gICAgXCJkYXRlXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldERhdGVcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwiZGF5XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldERheVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ5ZWFyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldEZ1bGxZZWFyXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcIm1vbnRoXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldE1vbnRoXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcImhvdXJzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldEhvdXJzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcIm1pbnV0ZXNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0TWludXRlc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFNlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwibWlsbGlzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldE1pbGxpc2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ0aW1lXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFRpbWVcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidGltZXpvbmVvZmZzZXRcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VGltZXpvbmVPZmZzZXRcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjZGF0ZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENEYXRlXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y2RheVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENEYXlcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjeWVhclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENGdWxsWWVhclwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNtb250aFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENNb250aFwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNob3Vyc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENIb3Vyc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNtaW51dGVzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ01pbnV0ZXNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjc2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENTZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y21pbGxpc2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENNaWxsaXNlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuXG4gICAgLy8gc2hhcmVkIHNlcXVlbmNlIGZ1bmN0aW9uc1xuICAgIFwibGVuZ3RoXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImxlbmd0aFwiLCBhcmdzLCBudWxsLCAtMSk7XG4gICAgICB9LFxuICAgIFwiaW5kZXhvZlwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJpbmRleE9mXCIsIGFyZ3MsIG51bGwpO1xuICAgICAgfSxcbiAgICBcImxhc3RpbmRleG9mXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImxhc3RJbmRleE9mXCIsIGFyZ3MsIG51bGwpO1xuICAgICAgfSxcblxuICAgIC8vIFNUUklORyBmdW5jdGlvbnNcbiAgICBcInBhcnNlRmxvYXRcIjogXCJwYXJzZUZsb2F0XCIsXG4gICAgXCJwYXJzZUludFwiOiBcInBhcnNlSW50XCIsXG4gICAgXCJ1cHBlclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJ0b1VwcGVyQ2FzZVwiLCBhcmdzLCBTVFJJTkcsIDApO1xuICAgICAgfSxcbiAgICBcImxvd2VyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInRvTG93ZXJDYXNlXCIsIGFyZ3MsIFNUUklORywgMCk7XG4gICAgICB9LFxuICAgIFwic2xpY2VcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwic2xpY2VcIiwgYXJncywgU1RSSU5HKTtcbiAgICAgIH0sXG4gICAgXCJzdWJzdHJpbmdcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwic3Vic3RyaW5nXCIsIGFyZ3MsIFNUUklORyk7XG4gICAgICB9LFxuXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgIFwidGVzdFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJ0ZXN0XCIsIGFyZ3MsIFJFR0VYUCk7XG4gICAgICB9LFxuICAgIFxuICAgIC8vIENvbnRyb2wgRmxvdyBmdW5jdGlvbnNcbiAgICBcImlmXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMylcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi5cIik7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRvbyBtYW55IGFyZ3VtZW50cyB0byBpZiBmdW5jdGlvbi5cIik7XG4gICAgICAgIHZhciBhID0gYXJncy5tYXAoY29kZWdlbik7XG4gICAgICAgIHJldHVybiBhWzBdK1wiP1wiK2FbMV0rXCI6XCIrYVsyXTtcbiAgICAgIH1cbiAgfTtcbn07IiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyksXG4gICAgY29kZWdlbiA9IHJlcXVpcmUoJy4vY29kZWdlbicpO1xuICAgIFxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgb3B0KSB7IHJldHVybiBwYXJzZXIucGFyc2UoXCIoXCIraW5wdXQrXCIpXCIsIG9wdCk7IH0sXG4gIGNvZGU6IGZ1bmN0aW9uKG9wdCkgeyByZXR1cm4gY29kZWdlbihvcHQpOyB9XG59O1xuIiwiLypcbiAgVGhlIGZvbGxvd2luZyBleHByZXNzaW9uIHBhcnNlciBpcyBiYXNlZCBvbiBFc3ByaW1hIChodHRwOi8vZXNwcmltYS5vcmcvKS5cbiAgT3JpZ2luYWwgaGVhZGVyIGNvbW1lbnQgYW5kIGxpY2Vuc2UgZm9yIEVzcHJpbWEgaXMgaW5jbHVkZWQgaGVyZTpcblxuICBDb3B5cmlnaHQgKEMpIDIwMTMgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBUaGFkZGVlIFR5bCA8dGhhZGRlZS50eWxAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgTWF0aGlhcyBCeW5lbnMgPG1hdGhpYXNAcWl3aS5iZT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEpvb3N0LVdpbSBCb2VrZXN0ZWlqbiA8am9vc3Qtd2ltQGJvZWtlc3RlaWpuLm5sPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgS3JpcyBLb3dhbCA8a3Jpcy5rb3dhbEBjaXhhci5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBZdXN1a2UgU3V6dWtpIDx1dGF0YW5lLnRlYUBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcnBhZCBCb3Jzb3MgPGFycGFkLmJvcnNvc0Bnb29nbGVtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDExIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBUb2tlbixcbiAgICAgIFRva2VuTmFtZSxcbiAgICAgIFN5bnRheCxcbiAgICAgIFByb3BlcnR5S2luZCxcbiAgICAgIE1lc3NhZ2VzLFxuICAgICAgUmVnZXgsXG4gICAgICBzb3VyY2UsXG4gICAgICBzdHJpY3QsXG4gICAgICBpbmRleCxcbiAgICAgIGxpbmVOdW1iZXIsXG4gICAgICBsaW5lU3RhcnQsXG4gICAgICBsZW5ndGgsXG4gICAgICBsb29rYWhlYWQsXG4gICAgICBzdGF0ZSxcbiAgICAgIGV4dHJhO1xuXG4gIFRva2VuID0ge1xuICAgICAgQm9vbGVhbkxpdGVyYWw6IDEsXG4gICAgICBFT0Y6IDIsXG4gICAgICBJZGVudGlmaWVyOiAzLFxuICAgICAgS2V5d29yZDogNCxcbiAgICAgIE51bGxMaXRlcmFsOiA1LFxuICAgICAgTnVtZXJpY0xpdGVyYWw6IDYsXG4gICAgICBQdW5jdHVhdG9yOiA3LFxuICAgICAgU3RyaW5nTGl0ZXJhbDogOCxcbiAgICAgIFJlZ3VsYXJFeHByZXNzaW9uOiA5XG4gIH07XG5cbiAgVG9rZW5OYW1lID0ge307XG4gIFRva2VuTmFtZVtUb2tlbi5Cb29sZWFuTGl0ZXJhbF0gPSAnQm9vbGVhbic7XG4gIFRva2VuTmFtZVtUb2tlbi5FT0ZdID0gJzxlbmQ+JztcbiAgVG9rZW5OYW1lW1Rva2VuLklkZW50aWZpZXJdID0gJ0lkZW50aWZpZXInO1xuICBUb2tlbk5hbWVbVG9rZW4uS2V5d29yZF0gPSAnS2V5d29yZCc7XG4gIFRva2VuTmFtZVtUb2tlbi5OdWxsTGl0ZXJhbF0gPSAnTnVsbCc7XG4gIFRva2VuTmFtZVtUb2tlbi5OdW1lcmljTGl0ZXJhbF0gPSAnTnVtZXJpYyc7XG4gIFRva2VuTmFtZVtUb2tlbi5QdW5jdHVhdG9yXSA9ICdQdW5jdHVhdG9yJztcbiAgVG9rZW5OYW1lW1Rva2VuLlN0cmluZ0xpdGVyYWxdID0gJ1N0cmluZyc7XG4gIFRva2VuTmFtZVtUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbl0gPSAnUmVndWxhckV4cHJlc3Npb24nO1xuXG4gIFN5bnRheCA9IHtcbiAgICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiAnQXNzaWdubWVudEV4cHJlc3Npb24nLFxuICAgICAgQXJyYXlFeHByZXNzaW9uOiAnQXJyYXlFeHByZXNzaW9uJyxcbiAgICAgIEJpbmFyeUV4cHJlc3Npb246ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgICAgIENhbGxFeHByZXNzaW9uOiAnQ2FsbEV4cHJlc3Npb24nLFxuICAgICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgICAgIEV4cHJlc3Npb25TdGF0ZW1lbnQ6ICdFeHByZXNzaW9uU3RhdGVtZW50JyxcbiAgICAgIElkZW50aWZpZXI6ICdJZGVudGlmaWVyJyxcbiAgICAgIExpdGVyYWw6ICdMaXRlcmFsJyxcbiAgICAgIExvZ2ljYWxFeHByZXNzaW9uOiAnTG9naWNhbEV4cHJlc3Npb24nLFxuICAgICAgTWVtYmVyRXhwcmVzc2lvbjogJ01lbWJlckV4cHJlc3Npb24nLFxuICAgICAgT2JqZWN0RXhwcmVzc2lvbjogJ09iamVjdEV4cHJlc3Npb24nLFxuICAgICAgUHJvZ3JhbTogJ1Byb2dyYW0nLFxuICAgICAgUHJvcGVydHk6ICdQcm9wZXJ0eScsXG4gICAgICBVbmFyeUV4cHJlc3Npb246ICdVbmFyeUV4cHJlc3Npb24nLFxuICAgICAgVXBkYXRlRXhwcmVzc2lvbjogJ1VwZGF0ZUV4cHJlc3Npb24nXG4gIH07XG5cbiAgUHJvcGVydHlLaW5kID0ge1xuICAgICAgRGF0YTogMSxcbiAgICAgIEdldDogMixcbiAgICAgIFNldDogNFxuICB9O1xuXG4gIC8vIEVycm9yIG1lc3NhZ2VzIHNob3VsZCBiZSBpZGVudGljYWwgdG8gVjguXG4gIE1lc3NhZ2VzID0ge1xuICAgICAgVW5leHBlY3RlZFRva2VuOiAgJ1VuZXhwZWN0ZWQgdG9rZW4gJTAnLFxuICAgICAgVW5leHBlY3RlZE51bWJlcjogICdVbmV4cGVjdGVkIG51bWJlcicsXG4gICAgICBVbmV4cGVjdGVkU3RyaW5nOiAgJ1VuZXhwZWN0ZWQgc3RyaW5nJyxcbiAgICAgIFVuZXhwZWN0ZWRJZGVudGlmaWVyOiAgJ1VuZXhwZWN0ZWQgaWRlbnRpZmllcicsXG4gICAgICBVbmV4cGVjdGVkUmVzZXJ2ZWQ6ICAnVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkJyxcbiAgICAgIFVuZXhwZWN0ZWRFT1M6ICAnVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnLFxuICAgICAgTmV3bGluZUFmdGVyVGhyb3c6ICAnSWxsZWdhbCBuZXdsaW5lIGFmdGVyIHRocm93JyxcbiAgICAgIEludmFsaWRSZWdFeHA6ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbicsXG4gICAgICBVbnRlcm1pbmF0ZWRSZWdFeHA6ICAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb246IG1pc3NpbmcgLycsXG4gICAgICBJbnZhbGlkTEhTSW5Bc3NpZ25tZW50OiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gYXNzaWdubWVudCcsXG4gICAgICBJbnZhbGlkTEhTSW5Gb3JJbjogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGZvci1pbicsXG4gICAgICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6ICdNb3JlIHRoYW4gb25lIGRlZmF1bHQgY2xhdXNlIGluIHN3aXRjaCBzdGF0ZW1lbnQnLFxuICAgICAgTm9DYXRjaE9yRmluYWxseTogICdNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgYWZ0ZXIgdHJ5JyxcbiAgICAgIFVua25vd25MYWJlbDogJ1VuZGVmaW5lZCBsYWJlbCBcXCclMFxcJycsXG4gICAgICBSZWRlY2xhcmF0aW9uOiAnJTAgXFwnJTFcXCcgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZCcsXG4gICAgICBJbGxlZ2FsQ29udGludWU6ICdJbGxlZ2FsIGNvbnRpbnVlIHN0YXRlbWVudCcsXG4gICAgICBJbGxlZ2FsQnJlYWs6ICdJbGxlZ2FsIGJyZWFrIHN0YXRlbWVudCcsXG4gICAgICBJbGxlZ2FsUmV0dXJuOiAnSWxsZWdhbCByZXR1cm4gc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdE1vZGVXaXRoOiAgJ1N0cmljdCBtb2RlIGNvZGUgbWF5IG5vdCBpbmNsdWRlIGEgd2l0aCBzdGF0ZW1lbnQnLFxuICAgICAgU3RyaWN0Q2F0Y2hWYXJpYWJsZTogICdDYXRjaCB2YXJpYWJsZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFZhck5hbWU6ICAnVmFyaWFibGUgbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFBhcmFtTmFtZTogICdQYXJhbWV0ZXIgbmFtZSBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbUR1cGU6ICdTdHJpY3QgbW9kZSBmdW5jdGlvbiBtYXkgbm90IGhhdmUgZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcycsXG4gICAgICBTdHJpY3RGdW5jdGlvbk5hbWU6ICAnRnVuY3Rpb24gbmFtZSBtYXkgbm90IGJlIGV2YWwgb3IgYXJndW1lbnRzIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdE9jdGFsTGl0ZXJhbDogICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdERlbGV0ZTogICdEZWxldGUgb2YgYW4gdW5xdWFsaWZpZWQgaWRlbnRpZmllciBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgU3RyaWN0RHVwbGljYXRlUHJvcGVydHk6ICAnRHVwbGljYXRlIGRhdGEgcHJvcGVydHkgaW4gb2JqZWN0IGxpdGVyYWwgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgQWNjZXNzb3JEYXRhUHJvcGVydHk6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIGRhdGEgYW5kIGFjY2Vzc29yIHByb3BlcnR5IHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBBY2Nlc3NvckdldFNldDogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgbXVsdGlwbGUgZ2V0L3NldCBhY2Nlc3NvcnMgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgIFN0cmljdExIU0Fzc2lnbm1lbnQ6ICAnQXNzaWdubWVudCB0byBldmFsIG9yIGFyZ3VtZW50cyBpcyBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RMSFNQb3N0Zml4OiAgJ1Bvc3RmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RMSFNQcmVmaXg6ICAnUHJlZml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UmVzZXJ2ZWRXb3JkOiAgJ1VzZSBvZiBmdXR1cmUgcmVzZXJ2ZWQgd29yZCBpbiBzdHJpY3QgbW9kZSdcbiAgfTtcblxuICAvLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxuICBSZWdleCA9IHtcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclN0YXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjJcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNEXFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjFcXHUwQjcxXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkQwXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRFxcdTBDNThcXHUwQzU5XFx1MEM2MFxcdTBDNjFcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENjBcXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QzEtXFx1MTlDN1xcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNFRVxcdTJDRjJcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ4MC1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QTkwQS1cXHVBOTI1XFx1QTkzMC1cXHVBOTQ2XFx1QTk2MC1cXHVBOTdDXFx1QTk4NC1cXHVBOUIyXFx1QTlDRlxcdUE5RTAtXFx1QTlFNFxcdUE5RTYtXFx1QTlFRlxcdUE5RkEtXFx1QTlGRVxcdUFBMDAtXFx1QUEyOFxcdUFBNDAtXFx1QUE0MlxcdUFBNDQtXFx1QUE0QlxcdUFBNjAtXFx1QUE3NlxcdUFBN0FcXHVBQTdFLVxcdUFBQUZcXHVBQUIxXFx1QUFCNVxcdUFBQjZcXHVBQUI5LVxcdUFBQkRcXHVBQUMwXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFQVxcdUFBRjItXFx1QUFGNFxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpLFxuICAgICAgTm9uQXNjaWlJZGVudGlmaWVyUGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCMlxcdTA4RTQtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNThcXHUwQzU5XFx1MEM2MC1cXHUwQzYzXFx1MEM2Ni1cXHUwQzZGXFx1MEM4MS1cXHUwQzgzXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCQy1cXHUwQ0M0XFx1MENDNi1cXHUwQ0M4XFx1MENDQS1cXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0RFXFx1MENFMC1cXHUwQ0UzXFx1MENFNi1cXHUwQ0VGXFx1MENGMVxcdTBDRjJcXHUwRDAxLVxcdTBEMDNcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNELVxcdTBENDRcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENEVcXHUwRDU3XFx1MEQ2MC1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZDLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNjlEXFx1QTY5Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBNzhFXFx1QTc5MC1cXHVBN0FEXFx1QTdCMFxcdUE3QjFcXHVBN0Y3LVxcdUE4MjdcXHVBODQwLVxcdUE4NzNcXHVBODgwLVxcdUE4QzRcXHVBOEQwLVxcdUE4RDlcXHVBOEUwLVxcdUE4RjdcXHVBOEZCXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJEXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXScpXG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBjb25kaXRpb24gaXMgdHJ1ZSwgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAvLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbiAgLy8gdG8gY2F0Y2ggYSBsb2dpYyBlcnJvci4gVGhlIGNvbmRpdGlvbiBzaGFsbCBiZSBmdWxmaWxsZWQgaW4gbm9ybWFsIGNhc2UuXG4gIC8vIERvIE5PVCB1c2UgdGhpcyB0byBlbmZvcmNlIGEgY2VydGFpbiBjb25kaXRpb24gb24gYW55IHVzZXIgaW5wdXQuXG5cbiAgZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FTU0VSVDogJyArIG1lc3NhZ2UpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNEZWNpbWFsRGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KTsgICAvLyAwLi45XG4gIH1cblxuICBmdW5jdGlvbiBpc0hleERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3ODlhYmNkZWZBQkNERUYnLmluZGV4T2YoY2gpID49IDA7XG4gIH1cblxuICBmdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpID49IDA7XG4gIH1cblxuICAvLyA3LjIgV2hpdGUgU3BhY2VcblxuICBmdW5jdGlvbiBpc1doaXRlU3BhY2UoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjApIHx8IChjaCA9PT0gMHgwOSkgfHwgKGNoID09PSAweDBCKSB8fCAoY2ggPT09IDB4MEMpIHx8IChjaCA9PT0gMHhBMCkgfHxcbiAgICAgICAgICAoY2ggPj0gMHgxNjgwICYmIFsweDE2ODAsIDB4MTgwRSwgMHgyMDAwLCAweDIwMDEsIDB4MjAwMiwgMHgyMDAzLCAweDIwMDQsIDB4MjAwNSwgMHgyMDA2LCAweDIwMDcsIDB4MjAwOCwgMHgyMDA5LCAweDIwMEEsIDB4MjAyRiwgMHgyMDVGLCAweDMwMDAsIDB4RkVGRl0uaW5kZXhPZihjaCkgPj0gMCk7XG4gIH1cblxuICAvLyA3LjMgTGluZSBUZXJtaW5hdG9yc1xuXG4gIGZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MEEpIHx8IChjaCA9PT0gMHgwRCkgfHwgKGNoID09PSAweDIwMjgpIHx8IChjaCA9PT0gMHgyMDI5KTtcbiAgfVxuXG4gIC8vIDcuNiBJZGVudGlmaWVyIE5hbWVzIGFuZCBJZGVudGlmaWVyc1xuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllclBhcnQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSkgfHwgICAgICAgICAvLyAwLi45XG4gICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICAvLyA3LjYuMS4yIEZ1dHVyZSBSZXNlcnZlZCBXb3Jkc1xuXG4gIGZ1bmN0aW9uIGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICBjYXNlICdjbGFzcyc6XG4gICAgICBjYXNlICdlbnVtJzpcbiAgICAgIGNhc2UgJ2V4cG9ydCc6XG4gICAgICBjYXNlICdleHRlbmRzJzpcbiAgICAgIGNhc2UgJ2ltcG9ydCc6XG4gICAgICBjYXNlICdzdXBlcic6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICBjYXNlICdpbnRlcmZhY2UnOlxuICAgICAgY2FzZSAncGFja2FnZSc6XG4gICAgICBjYXNlICdwcml2YXRlJzpcbiAgICAgIGNhc2UgJ3Byb3RlY3RlZCc6XG4gICAgICBjYXNlICdwdWJsaWMnOlxuICAgICAgY2FzZSAnc3RhdGljJzpcbiAgICAgIGNhc2UgJ3lpZWxkJzpcbiAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIDcuNi4xLjEgS2V5d29yZHNcblxuICBmdW5jdGlvbiBpc0tleXdvcmQoaWQpIHtcbiAgICAgIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyAnY29uc3QnIGlzIHNwZWNpYWxpemVkIGFzIEtleXdvcmQgaW4gVjguXG4gICAgICAvLyAneWllbGQnIGFuZCAnbGV0JyBhcmUgZm9yIGNvbXBhdGlibGl0eSB3aXRoIFNwaWRlck1vbmtleSBhbmQgRVMubmV4dC5cbiAgICAgIC8vIFNvbWUgb3RoZXJzIGFyZSBmcm9tIGZ1dHVyZSByZXNlcnZlZCB3b3Jkcy5cblxuICAgICAgc3dpdGNoIChpZC5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnaWYnKSB8fCAoaWQgPT09ICdpbicpIHx8IChpZCA9PT0gJ2RvJyk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3ZhcicpIHx8IChpZCA9PT0gJ2ZvcicpIHx8IChpZCA9PT0gJ25ldycpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3RyeScpIHx8IChpZCA9PT0gJ2xldCcpO1xuICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd0aGlzJykgfHwgKGlkID09PSAnZWxzZScpIHx8IChpZCA9PT0gJ2Nhc2UnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd2b2lkJykgfHwgKGlkID09PSAnd2l0aCcpIHx8IChpZCA9PT0gJ2VudW0nKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnd2hpbGUnKSB8fCAoaWQgPT09ICdicmVhaycpIHx8IChpZCA9PT0gJ2NhdGNoJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndGhyb3cnKSB8fCAoaWQgPT09ICdjb25zdCcpIHx8IChpZCA9PT0gJ3lpZWxkJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnY2xhc3MnKSB8fCAoaWQgPT09ICdzdXBlcicpO1xuICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdyZXR1cm4nKSB8fCAoaWQgPT09ICd0eXBlb2YnKSB8fCAoaWQgPT09ICdkZWxldGUnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICdzd2l0Y2gnKSB8fCAoaWQgPT09ICdleHBvcnQnKSB8fCAoaWQgPT09ICdpbXBvcnQnKTtcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnZGVmYXVsdCcpIHx8IChpZCA9PT0gJ2ZpbmFsbHknKSB8fCAoaWQgPT09ICdleHRlbmRzJyk7XG4gICAgICBjYXNlIDg6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2Z1bmN0aW9uJykgfHwgKGlkID09PSAnY29udGludWUnKSB8fCAoaWQgPT09ICdkZWJ1Z2dlcicpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnaW5zdGFuY2VvZicpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBza2lwQ29tbWVudCgpIHtcbiAgICAgIHZhciBjaCwgc3RhcnQ7XG5cbiAgICAgIHN0YXJ0ID0gKGluZGV4ID09PSAwKTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICAgICAgaWYgKGlzV2hpdGVTcGFjZShjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gMHgwRCAmJiBzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4MEEpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gICAgICB2YXIgaSwgbGVuLCBjaCwgY29kZSA9IDA7XG5cbiAgICAgIGxlbiA9IChwcmVmaXggPT09ICd1JykgPyA0IDogMjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKSB7XG4gICAgICB2YXIgY2gsIGNvZGUsIGN1MSwgY3UyO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBjb2RlID0gMDtcblxuICAgICAgLy8gQXQgbGVhc3QsIG9uZSBoZXggZGlnaXQgaXMgcmVxdWlyZWQuXG4gICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgaWYgKCFpc0hleERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29kZSA+IDB4MTBGRkZGIHx8IGNoICE9PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVURi0xNiBFbmNvZGluZ1xuICAgICAgaWYgKGNvZGUgPD0gMHhGRkZGKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICB9XG4gICAgICBjdTEgPSAoKGNvZGUgLSAweDEwMDAwKSA+PiAxMCkgKyAweEQ4MDA7XG4gICAgICBjdTIgPSAoKGNvZGUgLSAweDEwMDAwKSAmIDEwMjMpICsgMHhEQzAwO1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY3UxLCBjdTIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgY2gsIGlkO1xuXG4gICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KyspO1xuICAgICAgaWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJTdGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlkID0gY2g7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgIGlkID0gaWQuc3Vic3RyKDAsIGlkLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlkICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzdGFydCwgY2g7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXgrKztcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICBpbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0RXNjYXBlZElkZW50aWZpZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzdGFydCwgaWQsIHR5cGU7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIC8vIEJhY2tzbGFzaCAoVSswMDVDKSBzdGFydHMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICBpZCA9IChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4NUMpID8gZ2V0RXNjYXBlZElkZW50aWZpZXIoKSA6IGdldElkZW50aWZpZXIoKTtcblxuICAgICAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAgICAgLy8gVGh1cywgaXQgbXVzdCBiZSBhbiBpZGVudGlmaWVyLlxuICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgfSBlbHNlIGlmIChpc0tleXdvcmQoaWQpKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLktleXdvcmQ7XG4gICAgICB9IGVsc2UgaWYgKGlkID09PSAnbnVsbCcpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uTnVsbExpdGVyYWw7XG4gICAgICB9IGVsc2UgaWYgKGlkID09PSAndHJ1ZScgfHwgaWQgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uQm9vbGVhbkxpdGVyYWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5JZGVudGlmaWVyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdmFsdWU6IGlkLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICAvLyA3LjcgUHVuY3R1YXRvcnNcblxuICBmdW5jdGlvbiBzY2FuUHVuY3R1YXRvcigpIHtcbiAgICAgIHZhciBzdGFydCA9IGluZGV4LFxuICAgICAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgICAgICAgY29kZTIsXG4gICAgICAgICAgY2gxID0gc291cmNlW2luZGV4XSxcbiAgICAgICAgICBjaDIsXG4gICAgICAgICAgY2gzLFxuICAgICAgICAgIGNoNDtcblxuICAgICAgc3dpdGNoIChjb2RlKSB7XG5cbiAgICAgIC8vIENoZWNrIGZvciBtb3N0IGNvbW1vbiBzaW5nbGUtY2hhcmFjdGVyIHB1bmN0dWF0b3JzLlxuICAgICAgY2FzZSAweDJFOiAgLy8gLiBkb3RcbiAgICAgIGNhc2UgMHgyODogIC8vICggb3BlbiBicmFja2V0XG4gICAgICBjYXNlIDB4Mjk6ICAvLyApIGNsb3NlIGJyYWNrZXRcbiAgICAgIGNhc2UgMHgzQjogIC8vIDsgc2VtaWNvbG9uXG4gICAgICBjYXNlIDB4MkM6ICAvLyAsIGNvbW1hXG4gICAgICBjYXNlIDB4N0I6ICAvLyB7IG9wZW4gY3VybHkgYnJhY2VcbiAgICAgIGNhc2UgMHg3RDogIC8vIH0gY2xvc2UgY3VybHkgYnJhY2VcbiAgICAgIGNhc2UgMHg1QjogIC8vIFtcbiAgICAgIGNhc2UgMHg1RDogIC8vIF1cbiAgICAgIGNhc2UgMHgzQTogIC8vIDpcbiAgICAgIGNhc2UgMHgzRjogIC8vID9cbiAgICAgIGNhc2UgMHg3RTogIC8vIH5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gMHgyOCkge1xuICAgICAgICAgICAgICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4N0IpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29kZTIgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpO1xuXG4gICAgICAgICAgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICAgICAgICBpZiAoY29kZTIgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgMHgyQjogIC8vICtcbiAgICAgICAgICAgICAgY2FzZSAweDJEOiAgLy8gLVxuICAgICAgICAgICAgICBjYXNlIDB4MkY6ICAvLyAvXG4gICAgICAgICAgICAgIGNhc2UgMHgzQzogIC8vIDxcbiAgICAgICAgICAgICAgY2FzZSAweDNFOiAgLy8gPlxuICAgICAgICAgICAgICBjYXNlIDB4NUU6ICAvLyBeXG4gICAgICAgICAgICAgIGNhc2UgMHg3QzogIC8vIHxcbiAgICAgICAgICAgICAgY2FzZSAweDI1OiAgLy8gJVxuICAgICAgICAgICAgICBjYXNlIDB4MjY6ICAvLyAmXG4gICAgICAgICAgICAgIGNhc2UgMHgyQTogIC8vICpcbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUyKSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGNhc2UgMHgyMTogLy8gIVxuICAgICAgICAgICAgICBjYXNlIDB4M0Q6IC8vID1cbiAgICAgICAgICAgICAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgICAgICAgICAgICAgIC8vICE9PSBhbmQgPT09XG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gNC1jaGFyYWN0ZXIgcHVuY3R1YXRvcjogPj4+PVxuXG4gICAgICBjaDQgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcblxuICAgICAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2g0LFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuICAgICAgY2gzID0gY2g0LnN1YnN0cigwLCAzKTtcblxuICAgICAgaWYgKGNoMyA9PT0gJz4+PicgfHwgY2gzID09PSAnPDw9JyB8fCBjaDMgPT09ICc+Pj0nKSB7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gzLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gT3RoZXIgMi1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ICsrIC0tIDw8ID4+ICYmIHx8XG4gICAgICBjaDIgPSBjaDMuc3Vic3RyKDAsIDIpO1xuXG4gICAgICBpZiAoKGNoMSA9PT0gY2gyWzFdICYmICgnKy08PiZ8Jy5pbmRleE9mKGNoMSkgPj0gMCkpIHx8IGNoMiA9PT0gJz0+Jykge1xuICAgICAgICAgIGluZGV4ICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xuXG4gICAgICBpZiAoJzw+PSErLSolJnxeLycuaW5kZXhPZihjaDEpID49IDApIHtcbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDEsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gIH1cblxuICAvLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhbkhleExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnJztcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlSW50KCcweCcgKyBudW1iZXIsIDE2KSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCkge1xuICAgICAgdmFyIG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSB8fCBpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludChudW1iZXIsIDgpLFxuICAgICAgICAgIG9jdGFsOiB0cnVlLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuTnVtZXJpY0xpdGVyYWwoKSB7XG4gICAgICB2YXIgbnVtYmVyLCBzdGFydCwgY2g7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCAoY2ggPT09ICcuJyksXG4gICAgICAgICAgJ051bWVyaWMgbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBkZWNpbWFsIGRpZ2l0IG9yIGEgZGVjaW1hbCBwb2ludCcpO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgbnVtYmVyID0gJyc7XG4gICAgICBpZiAoY2ggIT09ICcuJykge1xuICAgICAgICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAgICAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgICAgICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICAgICAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAneCcgfHwgY2ggPT09ICdYJykge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuSGV4TGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIGRlY2ltYWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJyBzdWNoIGFzICcwOScgaXMgaWxsZWdhbC5cbiAgICAgICAgICAgICAgaWYgKGNoICYmIGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmIChjaCA9PT0gJysnIHx8IGNoID09PSAnLScpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICAvLyA3LjguNCBTdHJpbmcgTGl0ZXJhbHNcblxuICBmdW5jdGlvbiBzY2FuU3RyaW5nTGl0ZXJhbCgpIHtcbiAgICAgIHZhciBzdHIgPSAnJywgcXVvdGUsIHN0YXJ0LCBjaCwgY29kZSwgdW5lc2NhcGVkLCByZXN0b3JlLCBvY3RhbCA9IGZhbHNlLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0TGluZVN0YXJ0O1xuICAgICAgc3RhcnRMaW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0TGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuXG4gICAgICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoKHF1b3RlID09PSAnXFwnJyB8fCBxdW90ZSA9PT0gJ1wiJyksXG4gICAgICAgICAgJ1N0cmluZyBsaXRlcmFsIG11c3Qgc3RhcnRzIHdpdGggYSBxdW90ZScpO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuICAgICAgKytpbmRleDtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICBpZiAoY2ggPT09IHF1b3RlKSB7XG4gICAgICAgICAgICAgIHF1b3RlID0gJyc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgaWYgKCFjaCB8fCAhaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2luZGV4XSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5lc2NhcGVkID0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSB1bmVzY2FwZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xccic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcYic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcZic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDMgZGlnaXRzIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiBzdHJpbmcgc3RhcnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgnMDEyMycuaW5kZXhPZihjaCkgPj0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCA8IGxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgKytsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAgJ1xccicgJiYgc291cmNlW2luZGV4XSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5TdHJpbmdMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBzdHIsXG4gICAgICAgICAgb2N0YWw6IG9jdGFsLFxuICAgICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgIHN0YXJ0TGluZVN0YXJ0OiBzdGFydExpbmVTdGFydCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdGVzdFJlZ0V4cChwYXR0ZXJuLCBmbGFncykge1xuICAgICAgdmFyIHRtcCA9IHBhdHRlcm4sXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGlmIChmbGFncy5pbmRleE9mKCd1JykgPj0gMCkge1xuICAgICAgICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBBU0NJSSBzeW1ib2wgdG8gYXZvaWQgdGhyb3dpbmcgb25cbiAgICAgICAgICAvLyByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGVcbiAgICAgICAgICAvLyBgL3VgIGZsYWcuXG4gICAgICAgICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggdGhlIEFTQ0lJIHN5bWJvbCBgeGAgbWlnaHQgY2F1c2UgZmFsc2VcbiAgICAgICAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdFxuICAgICAgICAgIC8vIHdvdWxkIGJlIHJlcGxhY2VkIGJ5IGBbeC1iXWAgd2hpY2ggdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICAgIHRtcCA9IHRtcFxuICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXHVcXHsoWzAtOWEtZkEtRl0rKVxcfS9nLCBmdW5jdGlvbiAoJDAsICQxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoJDEsIDE2KSA8PSAweDEwRkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAneCc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgJ3gnKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cCh0bXApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvclxuICAgICAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAgICAgLy8gdXNlcy5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwQm9keSgpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBjbGFzc01hcmtlciwgdGVybWluYXRlZCwgYm9keTtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICAgICAgc3RyID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgdGVybWluYXRlZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICAvLyBFQ01BLTI2MiA3LjguNVxuICAgICAgICAgICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc01hcmtlcikge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICB0ZXJtaW5hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXJtaW5hdGVkKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgICAgIGJvZHkgPSBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGJvZHksXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEZsYWdzKCkge1xuICAgICAgdmFyIGNoLCBzdHIsIGZsYWdzLCByZXN0b3JlO1xuXG4gICAgICBzdHIgPSAnJztcbiAgICAgIGZsYWdzID0gJyc7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIHJlc3RvcmUgPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChzdHIgKz0gJ1xcXFx1JzsgcmVzdG9yZSA8IGluZGV4OyArK3Jlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNvdXJjZVtyZXN0b3JlXTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBmbGFncyxcbiAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwKCkge1xuICAgICAgdmFyIHN0YXJ0LCBib2R5LCBmbGFncywgdmFsdWU7XG5cbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgYm9keSA9IHNjYW5SZWdFeHBCb2R5KCk7XG4gICAgICBmbGFncyA9IHNjYW5SZWdFeHBGbGFncygpO1xuICAgICAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcblxuICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUmVndWxhckV4cHJlc3Npb24sXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGl0ZXJhbDogYm9keS5saXRlcmFsICsgZmxhZ3MubGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcmVnZXg6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RSZWdleCgpIHtcbiAgICAgIHZhciBwb3MsIGxvYywgcmVnZXgsIHRva2VuO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxvYyA9IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmVnZXggPSBzY2FuUmVnRXhwKCk7XG5cbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgLy8gUG9wIHRoZSBwcmV2aW91cyB0b2tlbiwgd2hpY2ggaXMgbGlrZWx5ICcvJyBvciAnLz0nXG4gICAgICAgICAgaWYgKGV4dHJhLnRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgaWYgKHRva2VuLnJhbmdlWzBdID09PSBwb3MgJiYgdG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgPT09ICcvJyB8fCB0b2tlbi52YWx1ZSA9PT0gJy89Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vucy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogJ1JlZ3VsYXJFeHByZXNzaW9uJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHJlZ2V4LmxpdGVyYWwsXG4gICAgICAgICAgICAgIHJlZ2V4OiByZWdleC5yZWdleCxcbiAgICAgICAgICAgICAgcmFuZ2U6IFtwb3MsIGluZGV4XSxcbiAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlZ2V4O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZSh0b2tlbikge1xuICAgICAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkdmFuY2VTbGFzaCgpIHtcbiAgICAgIHZhciBwcmV2VG9rZW4sXG4gICAgICAgICAgY2hlY2tUb2tlbjtcbiAgICAgIC8vIFVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3dlZXQuanMvd2lraS9kZXNpZ25cbiAgICAgIHByZXZUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoIXByZXZUb2tlbikge1xuICAgICAgICAgIC8vIE5vdGhpbmcgYmVmb3JlIHRoYXQ6IGl0IGNhbm5vdCBiZSBhIGRpdmlzaW9uLlxuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ1B1bmN0dWF0b3InKSB7XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnKScpIHtcbiAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuUGFyZW5Ub2tlbiAtIDFdO1xuICAgICAgICAgICAgICBpZiAoY2hlY2tUb2tlbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgKGNoZWNrVG9rZW4udmFsdWUgPT09ICdpZicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3doaWxlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnZm9yJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2l0aCcpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICd9Jykge1xuICAgICAgICAgICAgICAvLyBEaXZpZGluZyBhIGZ1bmN0aW9uIGJ5IGFueXRoaW5nIG1ha2VzIGxpdHRsZSBzZW5zZSxcbiAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoYXQuXG4gICAgICAgICAgICAgIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5hbWVkIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDVdO1xuICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja1Rva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2VG9rZW4udHlwZSA9PT0gJ0tleXdvcmQnICYmIHByZXZUb2tlbi52YWx1ZSAhPT0gJ3RoaXMnKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICAgICAgdmFyIGNoO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uRU9GLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IGluZGV4LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2NhbklkZW50aWZpZXIoKTtcbiAgICAgIH1cblxuICAgICAgLy8gVmVyeSBjb21tb246ICggYW5kICkgYW5kIDtcbiAgICAgIGlmIChjaCA9PT0gMHgyOCB8fCBjaCA9PT0gMHgyOSB8fCBjaCA9PT0gMHgzQikge1xuICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJpbmcgbGl0ZXJhbCBzdGFydHMgd2l0aCBzaW5nbGUgcXVvdGUgKFUrMDAyNykgb3IgZG91YmxlIHF1b3RlIChVKzAwMjIpLlxuICAgICAgaWYgKGNoID09PSAweDI3IHx8IGNoID09PSAweDIyKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5TdHJpbmdMaXRlcmFsKCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gICAgICAvLyB0byBjaGVjayB0aGUgbmV4dCBjaGFyYWN0ZXIuXG4gICAgICBpZiAoY2ggPT09IDB4MkUpIHtcbiAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KGNoKSkge1xuICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2xhc2ggKC8pIFUrMDAyRiBjYW4gYWxzbyBzdGFydCBhIHJlZ2V4LlxuICAgICAgaWYgKGV4dHJhLnRva2VuaXplICYmIGNoID09PSAweDJGKSB7XG4gICAgICAgICAgcmV0dXJuIGFkdmFuY2VTbGFzaCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbGxlY3RUb2tlbigpIHtcbiAgICAgIHZhciBsb2MsIHRva2VuLCB2YWx1ZSwgZW50cnk7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRva2VuID0gYWR2YW5jZSgpO1xuICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgIH07XG5cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB2YWx1ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5OYW1lW3Rva2VuLnR5cGVdLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJhbmdlOiBbdG9rZW4uc3RhcnQsIHRva2VuLmVuZF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgZW50cnkucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiB0b2tlbi5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IHRva2VuLnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4dHJhLnRva2Vucy5wdXNoKGVudHJ5KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgZnVuY3Rpb24gbGV4KCkge1xuICAgICAgdmFyIHRva2VuO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcblxuICAgICAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgcmV0dXJuIHRva2VuO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0O1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG4gIH1cblxuICBmdW5jdGlvbiBQb3NpdGlvbigpIHtcbiAgICAgIHRoaXMubGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICB0aGlzLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gU291cmNlTG9jYXRpb24oKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChzdGFydFRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFRva2VuLnN0YXJ0IC0gc3RhcnRUb2tlbi5zdGFydExpbmVTdGFydFxuICAgICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4ubGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBzdGFydFRva2VuLnN0YXJ0IC0gc3RhcnRUb2tlbi5saW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9kZSgpIHtcbiAgICAgIC8vIFNraXAgY29tbWVudC5cbiAgICAgIGluZGV4ID0gbG9va2FoZWFkLnN0YXJ0O1xuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbG9va2FoZWFkLnN0YXJ0TGluZVN0YXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLmxpbmVOdW1iZXI7XG4gICAgICAgICAgbGluZVN0YXJ0ID0gbG9va2FoZWFkLmxpbmVTdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbaW5kZXgsIDBdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikge1xuICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgdGhpcy5yYW5nZSA9IFtzdGFydFRva2VuLnN0YXJ0LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBXcmFwcGluZ1NvdXJjZUxvY2F0aW9uKHN0YXJ0VG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgV3JhcHBpbmdOb2RlLnByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlID0ge1xuXG4gICAgICBmaW5pc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgdGhpcy5yYW5nZVsxXSA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9jLmVuZCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgICAgICAgICBpZiAoZXh0cmEuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvYy5zb3VyY2UgPSBleHRyYS5zb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hBcnJheUV4cHJlc3Npb246IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5BcnJheUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hBc3NpZ25tZW50RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Bc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEJpbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicpID8gU3ludGF4LkxvZ2ljYWxFeHByZXNzaW9uIDogU3ludGF4LkJpbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDYWxsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGNhbGxlZSwgYXJncykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5DYWxsRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmNhbGxlZSA9IGNhbGxlZTtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbjogZnVuY3Rpb24gKHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy50ZXN0ID0gdGVzdDtcbiAgICAgICAgICB0aGlzLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICAgICAgICAgIHRoaXMuYWx0ZXJuYXRlID0gYWx0ZXJuYXRlO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hFeHByZXNzaW9uU3RhdGVtZW50OiBmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5FeHByZXNzaW9uU3RhdGVtZW50O1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaElkZW50aWZpZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LklkZW50aWZpZXI7XG4gICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoTGl0ZXJhbDogZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkxpdGVyYWw7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICAgIHRoaXMucmF3ID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5yYXcgPT0gJy8vJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmF3ID0gJy8oPzopLyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5yZWdleCA9IHRva2VuLnJlZ2V4O1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKGFjY2Vzc29yLCBvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jb21wdXRlZCA9IGFjY2Vzc29yID09PSAnWyc7XG4gICAgICAgICAgdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hPYmplY3RFeHByZXNzaW9uOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5PYmplY3RFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb2dyYW06IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb2dyYW07XG4gICAgICAgICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoUHJvcGVydHk6IGZ1bmN0aW9uIChraW5kLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LlByb3BlcnR5O1xuICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hVbmFyeUV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSAob3BlcmF0b3IgPT09ICcrKycgfHwgb3BlcmF0b3IgPT09ICctLScpID8gU3ludGF4LlVwZGF0ZUV4cHJlc3Npb24gOiBTeW50YXguVW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgICAgICAgdGhpcy5wcmVmaXggPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlcmUgaXMgYSBsaW5lIHRlcm1pbmF0b3IgYmVmb3JlIHRoZSBuZXh0IHRva2VuLlxuXG4gIGZ1bmN0aW9uIHBlZWtMaW5lVGVybWluYXRvcigpIHtcbiAgICAgIHZhciBwb3MsIGxpbmUsIHN0YXJ0LCBmb3VuZDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGZvdW5kID0gbGluZU51bWJlciAhPT0gbGluZTtcbiAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBzdGFydDtcblxuICAgICAgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uXG5cbiAgZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICAgICAgdmFyIGVycm9yLFxuICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICAgIG1zZyA9IG1lc3NhZ2VGb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgLyUoXFxkKS9nLFxuICAgICAgICAgICAgICBmdW5jdGlvbiAod2hvbGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICBhc3NlcnQoaW5kZXggPCBhcmdzLmxlbmd0aCwgJ01lc3NhZ2UgcmVmZXJlbmNlIG11c3QgYmUgaW4gcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhcmdzW2luZGV4XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4ubGluZU51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgdG9rZW4ubGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgIGVycm9yLmluZGV4ID0gdG9rZW4uc3RhcnQ7XG4gICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICAgICAgZXJyb3IuY29sdW1uID0gdG9rZW4uc3RhcnQgLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignTGluZSAnICsgbGluZU51bWJlciArICc6ICcgKyBtc2cpO1xuICAgICAgICAgIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgZXJyb3IubGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgZXJyb3IuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQgKyAxO1xuICAgICAgfVxuXG4gICAgICBlcnJvci5kZXNjcmlwdGlvbiA9IG1zZztcbiAgICAgIHRocm93IGVycm9yO1xuICB9XG5cbiAgZnVuY3Rpb24gdGhyb3dFcnJvclRvbGVyYW50KCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvd0Vycm9yLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG5cbiAgLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxuXG4gIGZ1bmN0aW9uIHRocm93VW5leHBlY3RlZCh0b2tlbikge1xuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRFT1MpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkTnVtYmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkU3RyaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgaWYgKGlzRnV0dXJlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RSZXNlcnZlZFdvcmQpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBCb29sZWFuTGl0ZXJhbCwgTnVsbExpdGVyYWwsIG9yIFB1bmN0dWF0b3IuXG4gICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG4gIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdCh2YWx1ZSkge1xuICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciB8fCB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIGV4cGVjdFRvbGVyYW50XG4gICAqIEBkZXNjcmlwdGlvbiBRdWlldGx5IGV4cGVjdCB0aGUgZ2l2ZW4gdG9rZW4gdmFsdWUgd2hlbiBpbiB0b2xlcmFudCBtb2RlLCBvdGhlcndpc2UgZGVsZWdhdGVzXG4gICAqIHRvIDxjb2RlPmV4cGVjdCh2YWx1ZSk8L2NvZGU+XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgd2UgYXJlIGV4cGVjdGluZyB0aGUgbG9va2FoZWFkIHRva2VuIHRvIGhhdmVcbiAgICogQHNpbmNlIDIuMFxuICAgKi9cbiAgZnVuY3Rpb24gZXhwZWN0VG9sZXJhbnQodmFsdWUpIHtcbiAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICB2YXIgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBlY3QodmFsdWUpO1xuICAgICAgfVxuICB9XG5cbiAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgZnVuY3Rpb24gZXhwZWN0S2V5d29yZChrZXl3b3JkKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkIHx8IHRva2VuLnZhbHVlICE9PSBrZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuXG4gIGZ1bmN0aW9uIG1hdGNoKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZSBuZXh0IHRva2VuIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBrZXl3b3JkXG5cbiAgZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCAmJiBsb29rYWhlYWQudmFsdWUgPT09IGtleXdvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lU2VtaWNvbG9uKCkge1xuICAgICAgdmFyIGxpbmU7XG5cbiAgICAgIC8vIENhdGNoIHRoZSB2ZXJ5IGNvbW1vbiBjYXNlIGZpcnN0OiBpbW1lZGlhdGVseSBhIHNlbWljb2xvbiAoVSswMDNCKS5cbiAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0IgfHwgbWF0Y2goJzsnKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgaWYgKGxpbmVOdW1iZXIgIT09IGxpbmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GICYmICFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiBwcm92aWRlZCBleHByZXNzaW9uIGlzIExlZnRIYW5kU2lkZUV4cHJlc3Npb25cblxuICBmdW5jdGlvbiBpc0xlZnRIYW5kU2lkZShleHByKSB7XG4gICAgICByZXR1cm4gZXhwci50eXBlID09PSBTeW50YXguSWRlbnRpZmllciB8fCBleHByLnR5cGUgPT09IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICB9XG5cbiAgLy8gMTEuMS40IEFycmF5IEluaXRpYWxpc2VyXG5cbiAgZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICAgICAgdmFyIGVsZW1lbnRzID0gW10sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgd2hpbGUgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuXG4gICAgICAgICAgICAgIGlmICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgICAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxleCgpO1xuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpO1xuICB9XG5cbiAgLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAgICAgLy8gRU9GIGFuZCBQdW5jdHVhdG9yIHRva2VucyBhcmUgYWxyZWFkeSBmaWx0ZXJlZCBvdXQuXG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKHN0cmljdCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0UHJvcGVydHkoKSB7XG4gICAgICB2YXIgdG9rZW4sIGtleSwgaWQsIHZhbHVlLCBwYXJhbSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgIGlkID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0JywgaWQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleSA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gW10sIHRva2VuLCBwcm9wZXJ0eSwgbmFtZSwga2V5LCBraW5kLCBtYXAgPSB7fSwgdG9TdHJpbmcgPSBTdHJpbmcsIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBleHBlY3QoJ3snKTtcblxuICAgICAgd2hpbGUgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU9iamVjdFByb3BlcnR5KCk7XG5cbiAgICAgICAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuYW1lID0gdG9TdHJpbmcocHJvcGVydHkua2V5LnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2luZCA9IChwcm9wZXJ0eS5raW5kID09PSAnaW5pdCcpID8gUHJvcGVydHlLaW5kLkRhdGEgOiAocHJvcGVydHkua2luZCA9PT0gJ2dldCcpID8gUHJvcGVydHlLaW5kLkdldCA6IFByb3BlcnR5S2luZC5TZXQ7XG5cbiAgICAgICAgICBrZXkgPSAnJCcgKyBuYW1lO1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICAgIGlmIChtYXBba2V5XSA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYga2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLlN0cmljdER1cGxpY2F0ZVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2luZCAhPT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXBba2V5XSAmIGtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yR2V0U2V0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtYXBba2V5XSB8PSBraW5kO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hcFtrZXldID0ga2luZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaCgnfScpKSB7XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJ30nKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoT2JqZWN0RXhwcmVzc2lvbihwcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIC8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgKytzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG5cbiAgLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbiAgdmFyIGxlZ2FsS2V5d29yZHMgPSB7XCJpZlwiOjEsIFwidGhpc1wiOjF9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgdHlwZSwgdG9rZW4sIGV4cHIsIG5vZGU7XG5cbiAgICAgIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2goJ3snKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fCBsZWdhbEtleXdvcmRzW2xvb2thaGVhZC52YWx1ZV0pIHtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hJZGVudGlmaWVyKGxleCgpLnZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgbG9va2FoZWFkLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChsb29rYWhlYWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwobGV4KCkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCkge1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSAodG9rZW4udmFsdWUgPT09ICd0cnVlJyk7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9IG51bGw7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcvJykgfHwgbWF0Y2goJy89JykpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChjb2xsZWN0UmVnZXgoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChzY2FuUmVnRXhwKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwZWVrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMiBMZWZ0LUhhbmQtU2lkZSBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXTtcblxuICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgIGlmICghbWF0Y2goJyknKSkge1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV4cGVjdFRvbGVyYW50KCcsJyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3QoJyknKTtcblxuICAgICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKSB7XG4gICAgICB2YXIgdG9rZW4sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxleCgpO1xuXG4gICAgICBpZiAoIWlzSWRlbnRpZmllck5hbWUodG9rZW4pKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgZXhwZWN0KCcuJyk7XG5cbiAgICAgIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCddJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCkge1xuICAgICAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5LCBzdGFydFRva2VuLCBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSBwYXJzZUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgcHJvcGVydHksIHN0YXJ0VG9rZW47XG4gICAgICBhc3NlcnQoc3RhdGUuYWxsb3dJbiwgJ2NhbGxlZSBvZiBuZXcgZXhwcmVzc2lvbiBhbHdheXMgYWxsb3cgaW4ga2V5d29yZC4nKTtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZU5vbkNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4zIFBvc3RmaXggRXhwcmVzc2lvbnNcblxuICBmdW5jdGlvbiBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHRva2VuLCBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uQWxsb3dDYWxsKCk7XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIGlmICgobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpICYmICFwZWVrTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjQgVW5hcnkgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VVbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgdG9rZW4sIGV4cHIsIHN0YXJ0VG9rZW47XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKycpIHx8IG1hdGNoKCctJykgfHwgbWF0Y2goJ34nKSB8fCBtYXRjaCgnIScpKSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaFVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoS2V5d29yZCgnZGVsZXRlJykgfHwgbWF0Y2hLZXl3b3JkKCd2b2lkJykgfHwgbWF0Y2hLZXl3b3JkKCd0eXBlb2YnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBhbGxvd0luKSB7XG4gICAgICB2YXIgcHJlYyA9IDA7XG5cbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgICAgY2FzZSAnfHwnOlxuICAgICAgICAgIHByZWMgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcmJic6XG4gICAgICAgICAgcHJlYyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgIHByZWMgPSAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgICBwcmVjID0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgcHJlYyA9IDU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz09JzpcbiAgICAgIGNhc2UgJyE9JzpcbiAgICAgIGNhc2UgJz09PSc6XG4gICAgICBjYXNlICchPT0nOlxuICAgICAgICAgIHByZWMgPSA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc8JzpcbiAgICAgIGNhc2UgJz4nOlxuICAgICAgY2FzZSAnPD0nOlxuICAgICAgY2FzZSAnPj0nOlxuICAgICAgY2FzZSAnaW5zdGFuY2VvZic6XG4gICAgICAgICAgcHJlYyA9IDc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2luJzpcbiAgICAgICAgICBwcmVjID0gYWxsb3dJbiA/IDcgOiAwO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc8PCc6XG4gICAgICBjYXNlICc+Pic6XG4gICAgICBjYXNlICc+Pj4nOlxuICAgICAgICAgIHByZWMgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIHByZWMgPSA5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcqJzpcbiAgICAgIGNhc2UgJy8nOlxuICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgcHJlYyA9IDExO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlYztcbiAgfVxuXG4gIC8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4gIC8vIDExLjYgQWRkaXRpdmUgT3BlcmF0b3JzXG4gIC8vIDExLjcgQml0d2lzZSBTaGlmdCBPcGVyYXRvcnNcbiAgLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuICAvLyAxMS45IEVxdWFsaXR5IE9wZXJhdG9yc1xuICAvLyAxMS4xMCBCaW5hcnkgQml0d2lzZSBPcGVyYXRvcnNcbiAgLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIG1hcmtlciwgbWFya2VycywgZXhwciwgdG9rZW4sIHByZWMsIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGk7XG5cbiAgICAgIG1hcmtlciA9IGxvb2thaGVhZDtcbiAgICAgIGxlZnQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKHRva2VuLCBzdGF0ZS5hbGxvd0luKTtcbiAgICAgIGlmIChwcmVjID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9XG4gICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgIGxleCgpO1xuXG4gICAgICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgICAgIHJpZ2h0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgc3RhY2sgPSBbbGVmdCwgdG9rZW4sIHJpZ2h0XTtcblxuICAgICAgd2hpbGUgKChwcmVjID0gYmluYXJ5UHJlY2VkZW5jZShsb29rYWhlYWQsIHN0YXRlLmFsbG93SW4pKSA+IDApIHtcblxuICAgICAgICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICAgICAgICB3aGlsZSAoKHN0YWNrLmxlbmd0aCA+IDIpICYmIChwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIG9wZXJhdG9yID0gc3RhY2sucG9wKCkudmFsdWU7XG4gICAgICAgICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vyc1ttYXJrZXJzLmxlbmd0aCAtIDFdKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2hpZnQuXG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi5wcmVjID0gcHJlYztcbiAgICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICAgICAgICBtYXJrZXJzLnB1c2gobG9va2FoZWFkKTtcbiAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaW5hbCByZWR1Y2UgdG8gY2xlYW4tdXAgdGhlIHN0YWNrLlxuICAgICAgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICBleHByID0gc3RhY2tbaV07XG4gICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgd2hpbGUgKGkgPiAxKSB7XG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUobWFya2Vycy5wb3AoKSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihzdGFja1tpIC0gMV0udmFsdWUsIHN0YWNrW2kgLSAyXSwgZXhwcik7XG4gICAgICAgICAgaSAtPSAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjEyIENvbmRpdGlvbmFsIE9wZXJhdG9yXG5cbiAgZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgcHJldmlvdXNBbGxvd0luLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUsIHN0YXJ0VG9rZW47XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICBwcmV2aW91c0FsbG93SW4gPSBzdGF0ZS5hbGxvd0luO1xuICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgICAgIGNvbnNlcXVlbnQgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHByZXZpb3VzQWxsb3dJbjtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICBhbHRlcm5hdGUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xMyBBc3NpZ25tZW50IE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgb2xkUGFyZW50aGVzaXNDb3VudCwgdG9rZW4sIGV4cHIsIHJpZ2h0LCBsaXN0LCBzdGFydFRva2VuO1xuXG4gICAgICBvbGRQYXJlbnRoZXNpc0NvdW50ID0gc3RhdGUucGFyZW50aGVzaXNDb3VudDtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xNCBDb21tYSBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBzdGFydFRva2VuID0gbG9va2FoZWFkLCBleHByZXNzaW9ucztcblxuICAgICAgZXhwciA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIG5vIHNlcXVlbmNlIGV4cHJlc3Npb25zXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTIuNCBFeHByZXNzaW9uIFN0YXRlbWVudFxuXG4gIGZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gICAgICB2YXIgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDEyIFN0YXRlbWVudHNcblxuICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICAgIHZhciB0eXBlID0gbG9va2FoZWFkLnR5cGUsXG4gICAgICAgICAgZXhwcixcbiAgICAgICAgICBsYWJlbGVkQm9keSxcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgbm9kZTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09ICd7Jykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gYmxvY2sgc3RhdGVtZW50XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvcikge1xuICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnOyc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gZW1wdHkgc3RhdGVtZW50XG4gICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBrZXl3b3JkXG4gICAgICB9XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gIH1cblxuICAvLyAxNCBQcm9ncmFtXG5cbiAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50KCkge1xuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdjb25zdCc6XG4gICAgICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudHMoKSB7XG4gICAgICB2YXIgc291cmNlRWxlbWVudCwgc291cmNlRWxlbWVudHMgPSBbXSwgdG9rZW4sIGRpcmVjdGl2ZSwgZmlyc3RSZXN0cmljdGVkO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICBpZiAoc291cmNlRWxlbWVudC5leHByZXNzaW9uLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IGRpcmVjdGl2ZVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlyZWN0aXZlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0ICsgMSwgdG9rZW4uZW5kIC0gMSk7XG4gICAgICAgICAgaWYgKGRpcmVjdGl2ZSA9PT0gJ3VzZSBzdHJpY3QnKSB7XG4gICAgICAgICAgICAgIHN0cmljdCA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChmaXJzdFJlc3RyaWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudChmaXJzdFJlc3RyaWN0ZWQsIE1lc3NhZ2VzLlN0cmljdE9jdGFsTGl0ZXJhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0UmVzdHJpY3RlZCAmJiB0b2tlbi5vY3RhbCkge1xuICAgICAgICAgICAgICAgICAgZmlyc3RSZXN0cmljdGVkID0gdG9rZW47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZUVsZW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNvdXJjZUVsZW1lbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQcm9ncmFtKCkge1xuICAgICAgdmFyIGJvZHksIG5vZGU7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBwZWVrKCk7XG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcbiAgICAgIHN0cmljdCA9IHRydWU7IC8vIGFzc3VtZSBzdHJpY3RcblxuICAgICAgYm9keSA9IHBhcnNlU291cmNlRWxlbWVudHMoKTtcbiAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb2dyYW0oYm9keSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaWx0ZXJUb2tlbkxvY2F0aW9uKCkge1xuICAgICAgdmFyIGksIGVudHJ5LCB0b2tlbiwgdG9rZW5zID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYS50b2tlbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBlbnRyeSA9IGV4dHJhLnRva2Vuc1tpXTtcbiAgICAgICAgICB0b2tlbiA9IHtcbiAgICAgICAgICAgICAgdHlwZTogZW50cnkudHlwZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5LnZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoZW50cnkucmVnZXgpIHtcbiAgICAgICAgICAgICAgdG9rZW4ucmVnZXggPSB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBlbnRyeS5yZWdleC5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IGVudHJ5LnJlZ2V4LmZsYWdzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICB0b2tlbi5yYW5nZSA9IGVudHJ5LnJhbmdlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgICAgIHRva2VuLmxvYyA9IGVudHJ5LmxvYztcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgfVxuXG4gICAgICBleHRyYS50b2tlbnMgPSB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiB0b2tlbml6ZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdG9TdHJpbmcsXG4gICAgICAgICAgdG9rZW5zO1xuXG4gICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gY29kZTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxuICAgICAgfTtcblxuICAgICAgZXh0cmEgPSB7fTtcblxuICAgICAgLy8gT3B0aW9ucyBtYXRjaGluZy5cbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBPZiBjb3Vyc2Ugd2UgY29sbGVjdCB0b2tlbnMgaGVyZS5cbiAgICAgIG9wdGlvbnMudG9rZW5zID0gdHJ1ZTtcbiAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgZXh0cmEudG9rZW5pemUgPSB0cnVlO1xuICAgICAgLy8gVGhlIGZvbGxvd2luZyB0d28gZmllbGRzIGFyZSBuZWNlc3NhcnkgdG8gY29tcHV0ZSB0aGUgUmVnZXggdG9rZW5zLlxuICAgICAgZXh0cmEub3BlblBhcmVuVG9rZW4gPSAtMTtcbiAgICAgIGV4dHJhLm9wZW5DdXJseVRva2VuID0gLTE7XG5cbiAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcGVlaygpO1xuICAgICAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHRyYS50b2tlbnM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgd2hpbGUgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChsZXhFcnJvcikge1xuICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGxleEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRvIGJyZWFrIG9uIHRoZSBmaXJzdCBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBsZXhFcnJvcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICB0b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHRva2Vucy5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHByb2dyYW0sIHRvU3RyaW5nO1xuXG4gICAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgICAgIGlmICh0eXBlb2YgY29kZSAhPT0gJ3N0cmluZycgJiYgIShjb2RlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgIGNvZGUgPSB0b1N0cmluZyhjb2RlKTtcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gY29kZTtcbiAgICAgIGluZGV4ID0gMDtcbiAgICAgIGxpbmVOdW1iZXIgPSAoc291cmNlLmxlbmd0aCA+IDApID8gMSA6IDA7XG4gICAgICBsaW5lU3RhcnQgPSAwO1xuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgIGxvb2thaGVhZCA9IG51bGw7XG4gICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICBhbGxvd0luOiB0cnVlLFxuICAgICAgICAgIGxhYmVsU2V0OiB7fSxcbiAgICAgICAgICBwYXJlbnRoZXNpc0NvdW50OiAwLFxuICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICB9O1xuXG4gICAgICBleHRyYSA9IHt9O1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGV4dHJhLnJhbmdlID0gKHR5cGVvZiBvcHRpb25zLnJhbmdlID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMucmFuZ2U7XG4gICAgICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcblxuICAgICAgICAgIGlmIChleHRyYS5sb2MgJiYgb3B0aW9ucy5zb3VyY2UgIT09IG51bGwgJiYgb3B0aW9ucy5zb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleHRyYS5zb3VyY2UgPSB0b1N0cmluZyhvcHRpb25zLnNvdXJjZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRva2VucyA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9rZW5zKSB7XG4gICAgICAgICAgICAgIGV4dHJhLnRva2VucyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9sZXJhbnQgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRvbGVyYW50KSB7XG4gICAgICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgICBwcm9ncmFtID0gcGFyc2VQcm9ncmFtKCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGZpbHRlclRva2VuTG9jYXRpb24oKTtcbiAgICAgICAgICAgICAgcHJvZ3JhbS50b2tlbnMgPSBleHRyYS50b2tlbnM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBwcm9ncmFtLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb2dyYW07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRva2VuaXplOiB0b2tlbml6ZSxcbiAgICBwYXJzZTogcGFyc2VcbiAgfTtcblxufSkoKTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgYXhzID0gcmVxdWlyZSgnLi4vc2NlbmUvYXhpcycpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyk7XG5cbnZhciBPUklFTlQgPSB7XG4gIFwieFwiOiAgICAgIFwiYm90dG9tXCIsXG4gIFwieVwiOiAgICAgIFwibGVmdFwiLFxuICBcInRvcFwiOiAgICBcInRvcFwiLFxuICBcImJvdHRvbVwiOiBcImJvdHRvbVwiLFxuICBcImxlZnRcIjogICBcImxlZnRcIixcbiAgXCJyaWdodFwiOiAgXCJyaWdodFwiXG59O1xuXG5mdW5jdGlvbiBheGVzKG1vZGVsLCBzcGVjLCBheGVzLCBncm91cCkge1xuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgYXhlc1tpbmRleF0gPSBheGVzW2luZGV4XSB8fCBheHMobW9kZWwpO1xuICAgIGF4aXMoZGVmLCBpbmRleCwgYXhlc1tpbmRleF0sIGdyb3VwKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBheGlzKGRlZiwgaW5kZXgsIGF4aXMsIGdyb3VwKSB7XG4gIC8vIGF4aXMgc2NhbGVcbiAgaWYgKGRlZi5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYXhpcy5zY2FsZShncm91cC5zY2FsZShkZWYuc2NhbGUpKTtcbiAgfVxuXG4gIC8vIGF4aXMgb3JpZW50YXRpb25cbiAgYXhpcy5vcmllbnQoZGVmLm9yaWVudCB8fCBPUklFTlRbZGVmLnR5cGVdKTtcbiAgLy8gYXhpcyBvZmZzZXRcbiAgYXhpcy5vZmZzZXQoZGVmLm9mZnNldCB8fCAwKTtcbiAgLy8gYXhpcyBsYXllclxuICBheGlzLmxheWVyKGRlZi5sYXllciB8fCBcImZyb250XCIpO1xuICAvLyBheGlzIGdyaWQgbGluZXNcbiAgYXhpcy5ncmlkKGRlZi5ncmlkIHx8IGZhbHNlKTtcbiAgLy8gYXhpcyB0aXRsZVxuICBheGlzLnRpdGxlKGRlZi50aXRsZSB8fCBudWxsKTtcbiAgLy8gYXhpcyB0aXRsZSBvZmZzZXRcbiAgYXhpcy50aXRsZU9mZnNldChkZWYudGl0bGVPZmZzZXQgIT0gbnVsbFxuICAgID8gZGVmLnRpdGxlT2Zmc2V0IDogY29uZmlnLmF4aXMudGl0bGVPZmZzZXQpO1xuICAvLyBheGlzIHZhbHVlc1xuICBheGlzLnRpY2tWYWx1ZXMoZGVmLnZhbHVlcyB8fCBudWxsKTtcbiAgLy8gYXhpcyBsYWJlbCBmb3JtYXR0aW5nXG4gIGF4aXMudGlja0Zvcm1hdChkZWYuZm9ybWF0IHx8IG51bGwpO1xuICAvLyBheGlzIHRpY2sgc3ViZGl2aXNpb25cbiAgYXhpcy50aWNrU3ViZGl2aWRlKGRlZi5zdWJkaXZpZGUgfHwgMCk7XG4gIC8vIGF4aXMgdGljayBwYWRkaW5nXG4gIGF4aXMudGlja1BhZGRpbmcoZGVmLnRpY2tQYWRkaW5nIHx8IGNvbmZpZy5heGlzLnBhZGRpbmcpO1xuXG4gIC8vIGF4aXMgdGljayBzaXplKHMpXG4gIHZhciBzaXplID0gW107XG4gIGlmIChkZWYudGlja1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGk9MDsgaTwzOyArK2kpIHNpemUucHVzaChkZWYudGlja1NpemUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0cyA9IGNvbmZpZy5heGlzLnRpY2tTaXplO1xuICAgIHNpemUgPSBbdHMsIHRzLCB0c107XG4gIH1cbiAgaWYgKGRlZi50aWNrU2l6ZU1ham9yICE9IG51bGwpIHNpemVbMF0gPSBkZWYudGlja1NpemVNYWpvcjtcbiAgaWYgKGRlZi50aWNrU2l6ZU1pbm9yICE9IG51bGwpIHNpemVbMV0gPSBkZWYudGlja1NpemVNaW5vcjtcbiAgaWYgKGRlZi50aWNrU2l6ZUVuZCAgICE9IG51bGwpIHNpemVbMl0gPSBkZWYudGlja1NpemVFbmQ7XG4gIGlmIChzaXplLmxlbmd0aCkge1xuICAgIGF4aXMudGlja1NpemUuYXBwbHkoYXhpcywgc2l6ZSk7XG4gIH1cblxuICAvLyB0aWNrIGFyZ3VtZW50c1xuICBpZiAoZGVmLnRpY2tzICE9IG51bGwpIHtcbiAgICB2YXIgdGlja3MgPSBkbC5pc0FycmF5KGRlZi50aWNrcykgPyBkZWYudGlja3MgOiBbZGVmLnRpY2tzXTtcbiAgICBheGlzLnRpY2tzLmFwcGx5KGF4aXMsIHRpY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBheGlzLnRpY2tzKGNvbmZpZy5heGlzLnRpY2tzKTtcbiAgfVxuXG4gIC8vIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHAgPSBkZWYucHJvcGVydGllcztcbiAgaWYgKHAgJiYgcC50aWNrcykge1xuICAgIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyhwLm1ham9yVGlja3NcbiAgICAgID8gZGwuZXh0ZW5kKHt9LCBwLnRpY2tzLCBwLm1ham9yVGlja3MpIDogcC50aWNrcyk7XG4gICAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzKHAubWlub3JUaWNrc1xuICAgICAgPyBkbC5leHRlbmQoe30sIHAudGlja3MsIHAubWlub3JUaWNrcykgOiBwLnRpY2tzKTtcbiAgfSBlbHNlIHtcbiAgICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMocCAmJiBwLm1ham9yVGlja3MgfHwge30pO1xuICAgIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyhwICYmIHAubWlub3JUaWNrcyB8fCB7fSk7XG4gIH1cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzKHAgJiYgcC5sYWJlbHMgfHwge30pO1xuICBheGlzLnRpdGxlUHJvcGVydGllcyhwICYmIHAudGl0bGUgfHwge30pO1xuICBheGlzLmdyaWRMaW5lUHJvcGVydGllcyhwICYmIHAuZ3JpZCB8fCB7fSk7XG4gIGF4aXMuZG9tYWluUHJvcGVydGllcyhwICYmIHAuYXhpcyB8fCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhlczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBwYXJzZVRyYW5zZm9ybXMgPSByZXF1aXJlKCcuL3RyYW5zZm9ybXMnKSxcbiAgICBwYXJzZU1vZGlmeSA9IHJlcXVpcmUoJy4vbW9kaWZ5Jyk7XG5cbnZhciBwYXJzZURhdGEgPSBmdW5jdGlvbihtb2RlbCwgc3BlYywgY2FsbGJhY2spIHtcbiAgdmFyIGNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBsb2FkZWQoZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGRsLmVycm9yKFwiTE9BRElORyBGQUlMRUQ6IFwiICsgZC51cmwgKyBcIiBcIiArIGVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsLmRhdGEoZC5uYW1lKS52YWx1ZXMoZGwucmVhZChkYXRhLCBkLmZvcm1hdCkpO1xuICAgICAgfVxuICAgICAgaWYgKC0tY291bnQgPT09IDApIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJvY2VzcyBlYWNoIGRhdGEgc2V0IGRlZmluaXRpb25cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgIGlmIChkLnVybCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IGQudXJsfSwgY29uZmlnLmxvYWQpLCBsb2FkZWQoZCkpO1xuICAgIH1cbiAgICBwYXJzZURhdGEuZGF0YXNvdXJjZShtb2RlbCwgZCk7XG4gIH0pO1xuXG4gIGlmIChjb3VudCA9PT0gMCkgc2V0VGltZW91dChjYWxsYmFjaywgMSk7XG4gIHJldHVybiBzcGVjO1xufTtcblxucGFyc2VEYXRhLmRhdGFzb3VyY2UgPSBmdW5jdGlvbihtb2RlbCwgZCkge1xuICB2YXIgdHJhbnNmb3JtID0gKGQudHJhbnNmb3JtfHxbXSkubWFwKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHBhcnNlVHJhbnNmb3Jtcyhtb2RlbCwgdCkgfSksXG4gICAgICBtb2QgPSAoZC5tb2RpZnl8fFtdKS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNb2RpZnkobW9kZWwsIG0sIGQpIH0pLFxuICAgICAgZHMgPSBtb2RlbC5kYXRhKGQubmFtZSwgbW9kLmNvbmNhdCh0cmFuc2Zvcm0pKTtcblxuICBpZiAoZC52YWx1ZXMpIHtcbiAgICBkcy52YWx1ZXMoZGwucmVhZChkLnZhbHVlcywgZC5mb3JtYXQpKTtcbiAgfSBlbHNlIGlmIChkLnNvdXJjZSkge1xuICAgIGRzLnNvdXJjZShkLnNvdXJjZSlcbiAgICAgIC5yZXZpc2VzKGRzLnJldmlzZXMoKSkgLy8gSWYgbmV3IGRzIHJldmlzZXMsIHRoZW4gaXQncyBvcmlnaW4gbXVzdCByZXZpc2UgdG9vLlxuICAgICAgLmFkZExpc3RlbmVyKGRzKTsgIC8vIERlcml2ZWQgZHMgd2lsbCBiZSBwdWxzZWQgYnkgaXRzIHNyYyByYXRoZXIgdGhhbiB0aGUgbW9kZWwuXG4gICAgbW9kZWwucmVtb3ZlTGlzdGVuZXIoZHMucGlwZWxpbmUoKVswXSk7IFxuICB9XG5cbiAgcmV0dXJuIGRzOyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VEYXRhO1xuIiwiLypcbiAqIEdlbmVyYXRlZCBieSBQRUcuanMgMC44LjAuXG4gKlxuICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICovXG5cbmZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfVxuICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG59XG5cbmZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UsIGV4cGVjdGVkLCBmb3VuZCwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgdGhpcy5mb3VuZCAgICA9IGZvdW5kO1xuICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICB0aGlzLmxpbmUgICAgID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gICA9IGNvbHVtbjtcblxuICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xufVxuXG5wZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuXG4gICAgICBwZWckRkFJTEVEID0ge30sXG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHN0YXJ0OiBwZWckcGFyc2VzdGFydCB9LFxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZXN0YXJ0LFxuXG4gICAgICBwZWckYzAgPSBwZWckRkFJTEVELFxuICAgICAgcGVnJGMxID0gXCIsXCIsXG4gICAgICBwZWckYzIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICBwZWckYzMgPSBmdW5jdGlvbihvLCBtKSB7IHJldHVybiBbb10uY29uY2F0KG0pIH0sXG4gICAgICBwZWckYzQgPSBmdW5jdGlvbihvKSB7IHJldHVybiBbb10gfSxcbiAgICAgIHBlZyRjNSA9IFwiW1wiLFxuICAgICAgcGVnJGM2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiW1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiW1xcXCJcIiB9LFxuICAgICAgcGVnJGM3ID0gXCJdXCIsXG4gICAgICBwZWckYzggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJdXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJdXFxcIlwiIH0sXG4gICAgICBwZWckYzkgPSBcIj5cIixcbiAgICAgIHBlZyRjMTAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICBwZWckYzExID0gZnVuY3Rpb24oZjEsIGYyLCBvKSB7IHJldHVybiB7c3RhcnQ6IGYxLCBlbmQ6IGYyLCBtaWRkbGU6IG99fSxcbiAgICAgIHBlZyRjMTIgPSBbXSxcbiAgICAgIHBlZyRjMTMgPSBmdW5jdGlvbihzLCBmKSB7IHJldHVybiAocy5maWx0ZXJzID0gZiksIHMgfSxcbiAgICAgIHBlZyRjMTQgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzIH0sXG4gICAgICBwZWckYzE1ID0gbnVsbCxcbiAgICAgIHBlZyRjMTYgPSBmdW5jdGlvbih0LCBlKSB7IHJldHVybiB7IGV2ZW50OiBlLCB0YXJnZXQ6IHQgfSB9LFxuICAgICAgcGVnJGMxNyA9IC9eWzphLXpBLXowLTlfXFwtXS8sXG4gICAgICBwZWckYzE4ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIls6YS16QS16MC05X1xcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbOmEtekEtejAtOV9cXFxcLV1cIiB9LFxuICAgICAgcGVnJGMxOSA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHsgc2lnbmFsOiBzLmpvaW4oXCJcIikgfX0sXG4gICAgICBwZWckYzIwID0gXCIoXCIsXG4gICAgICBwZWckYzIxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKFxcXCJcIiB9LFxuICAgICAgcGVnJGMyMiA9IFwiKVwiLFxuICAgICAgcGVnJGMyMyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgIHBlZyRjMjQgPSBmdW5jdGlvbihtKSB7IHJldHVybiB7IHN0cmVhbTogbSB9fSxcbiAgICAgIHBlZyRjMjUgPSBcIi5cIixcbiAgICAgIHBlZyRjMjYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIuXFxcIlwiIH0sXG4gICAgICBwZWckYzI3ID0gXCI6XCIsXG4gICAgICBwZWckYzI4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiOlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiOlxcXCJcIiB9LFxuICAgICAgcGVnJGMyOSA9IGZ1bmN0aW9uKGMpIHsgcmV0dXJuIHsgdHlwZTonY2xhc3MnLCB2YWx1ZTogYyB9IH0sXG4gICAgICBwZWckYzMwID0gXCIjXCIsXG4gICAgICBwZWckYzMxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiI1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiI1xcXCJcIiB9LFxuICAgICAgcGVnJGMzMiA9IGZ1bmN0aW9uKGlkKSB7IHJldHVybiB7IHR5cGU6J2lkJywgdmFsdWU6IGlkIH0gfSxcbiAgICAgIHBlZyRjMzMgPSBcIm1vdXNlZG93blwiLFxuICAgICAgcGVnJGMzNCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlZG93blwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2Vkb3duXFxcIlwiIH0sXG4gICAgICBwZWckYzM1ID0gXCJtb3VzZXVwXCIsXG4gICAgICBwZWckYzM2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2V1cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2V1cFxcXCJcIiB9LFxuICAgICAgcGVnJGMzNyA9IFwiY2xpY2tcIixcbiAgICAgIHBlZyRjMzggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJjbGlja1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiY2xpY2tcXFwiXCIgfSxcbiAgICAgIHBlZyRjMzkgPSBcImRibGNsaWNrXCIsXG4gICAgICBwZWckYzQwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZGJsY2xpY2tcIiwgZGVzY3JpcHRpb246IFwiXFxcImRibGNsaWNrXFxcIlwiIH0sXG4gICAgICBwZWckYzQxID0gXCJ3aGVlbFwiLFxuICAgICAgcGVnJGM0MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIndoZWVsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ3aGVlbFxcXCJcIiB9LFxuICAgICAgcGVnJGM0MyA9IFwia2V5ZG93blwiLFxuICAgICAgcGVnJGM0NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleWRvd25cIiwgZGVzY3JpcHRpb246IFwiXFxcImtleWRvd25cXFwiXCIgfSxcbiAgICAgIHBlZyRjNDUgPSBcImtleXByZXNzXCIsXG4gICAgICBwZWckYzQ2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5cHJlc3NcIiwgZGVzY3JpcHRpb246IFwiXFxcImtleXByZXNzXFxcIlwiIH0sXG4gICAgICBwZWckYzQ3ID0gXCJrZXl1cFwiLFxuICAgICAgcGVnJGM0OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXl1cFxcXCJcIiB9LFxuICAgICAgcGVnJGM0OSA9IFwibW91c2V3aGVlbFwiLFxuICAgICAgcGVnJGM1MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNld2hlZWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNld2hlZWxcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTEgPSBcIm1vdXNlbW92ZVwiLFxuICAgICAgcGVnJGM1MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlbW92ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2Vtb3ZlXFxcIlwiIH0sXG4gICAgICBwZWckYzUzID0gXCJtb3VzZW91dFwiLFxuICAgICAgcGVnJGM1NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlb3V0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW91dFxcXCJcIiB9LFxuICAgICAgcGVnJGM1NSA9IFwibW91c2VvdmVyXCIsXG4gICAgICBwZWckYzU2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VvdmVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW92ZXJcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTcgPSBcIm1vdXNlZW50ZXJcIixcbiAgICAgIHBlZyRjNTggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZWVudGVyXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZWVudGVyXFxcIlwiIH0sXG4gICAgICBwZWckYzU5ID0gXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICBwZWckYzYwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2hzdGFydFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidG91Y2hzdGFydFxcXCJcIiB9LFxuICAgICAgcGVnJGM2MSA9IFwidG91Y2htb3ZlXCIsXG4gICAgICBwZWckYzYyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2htb3ZlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaG1vdmVcXFwiXCIgfSxcbiAgICAgIHBlZyRjNjMgPSBcInRvdWNoZW5kXCIsXG4gICAgICBwZWckYzY0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidG91Y2hlbmRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNoZW5kXFxcIlwiIH0sXG4gICAgICBwZWckYzY1ID0gZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkICB9LFxuICAgICAgcGVnJGM2NiA9IC9eWydcImEtekEtWjAtOV8uPjw9ISBcXHRcXC1dLyxcbiAgICAgIHBlZyRjNjcgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWydcXFwiYS16QS1aMC05Xy4+PD0hIFxcXFx0XFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIlsnXFxcImEtekEtWjAtOV8uPjw9ISBcXFxcdFxcXFwtXVwiIH0sXG4gICAgICBwZWckYzY4ID0gZnVuY3Rpb24odikgeyByZXR1cm4gdi5qb2luKFwiXCIpIH0sXG4gICAgICBwZWckYzY5ID0gL15bIFxcdFxcclxcbl0vLFxuICAgICAgcGVnJGM3MCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIFxcXFx0XFxcXHJcXFxcbl1cIiwgZGVzY3JpcHRpb246IFwiWyBcXFxcdFxcXFxyXFxcXG5dXCIgfSxcblxuICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLFxuICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLFxuICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LFxuICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLFxuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCxcblxuICAgICAgcGVnJHJlc3VsdDtcblxuICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHBhcnNpbmcgZnJvbSBydWxlIFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFwiLlwiKTtcbiAgICB9XG5cbiAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgcmV0dXJuIGlucHV0LnN1YnN0cmluZyhwZWckcmVwb3J0ZWRQb3MsIHBlZyRjdXJyUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICByZXR1cm4gcGVnJHJlcG9ydGVkUG9zO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykubGluZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykuY29sdW1uO1xuICB9XG5cbiAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24oXG4gICAgICBudWxsLFxuICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICBwZWckcmVwb3J0ZWRQb3NcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBudWxsLCBwZWckcmVwb3J0ZWRQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcykge1xuICAgIGZ1bmN0aW9uIGFkdmFuY2UoZGV0YWlscywgc3RhcnRQb3MsIGVuZFBvcykge1xuICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICBmb3IgKHAgPSBzdGFydFBvczsgcCA8IGVuZFBvczsgcCsrKSB7XG4gICAgICAgIGNoID0gaW5wdXQuY2hhckF0KHApO1xuICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICBpZiAoIWRldGFpbHMuc2VlbkNSKSB7IGRldGFpbHMubGluZSsrOyB9XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IFwiXFxyXCIgfHwgY2ggPT09IFwiXFx1MjAyOFwiIHx8IGNoID09PSBcIlxcdTIwMjlcIikge1xuICAgICAgICAgIGRldGFpbHMubGluZSsrO1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBlZyRjYWNoZWRQb3MgIT09IHBvcykge1xuICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IDA7XG4gICAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIGFkdmFuY2UocGVnJGNhY2hlZFBvc0RldGFpbHMsIHBlZyRjYWNoZWRQb3MsIHBvcyk7XG4gICAgICBwZWckY2FjaGVkUG9zID0gcG9zO1xuICAgIH1cblxuICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlscztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgaWYgKHBlZyRjdXJyUG9zIDwgcGVnJG1heEZhaWxQb3MpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAocGVnJGN1cnJQb3MgPiBwZWckbWF4RmFpbFBvcykge1xuICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgPSBbXTtcbiAgICB9XG5cbiAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIGV4cGVjdGVkLCBwb3MpIHtcbiAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgIHZhciBpID0gMTtcblxuICAgICAgZXhwZWN0ZWQuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChhLmRlc2NyaXB0aW9uID4gYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgd2hpbGUgKGkgPCBleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICBleHBlY3RlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgZnVuY3Rpb24gc3RyaW5nRXNjYXBlKHMpIHtcbiAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXC9nLCAgICdcXFxcXFxcXCcpXG4gICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHgwOC9nLCAnXFxcXGInKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHQvZywgICAnXFxcXHQnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXGYvZywgICAnXFxcXGYnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cXHIvZywgICAnXFxcXHInKVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHgxMC1cXHgxRlxceDgwLVxceEZGXS9nLCAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4JyAgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDE4MC1cXHUwRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBleHBlY3RlZERlc2NzID0gbmV3IEFycmF5KGV4cGVjdGVkLmxlbmd0aCksXG4gICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHBlY3RlZERlc2NzW2ldID0gZXhwZWN0ZWRbaV0uZGVzY3JpcHRpb247XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdGVkRGVzYyA9IGV4cGVjdGVkLmxlbmd0aCA+IDFcbiAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXVxuICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07XG5cbiAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkRGVzYyArIFwiIGJ1dCBcIiArIGZvdW5kRGVzYyArIFwiIGZvdW5kLlwiO1xuICAgIH1cblxuICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgIGZvdW5kICAgICAgPSBwb3MgPCBpbnB1dC5sZW5ndGggPyBpbnB1dC5jaGFyQXQocG9zKSA6IG51bGw7XG5cbiAgICBpZiAoZXhwZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihcbiAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICBleHBlY3RlZCxcbiAgICAgIGZvdW5kLFxuICAgICAgcG9zLFxuICAgICAgcG9zRGV0YWlscy5saW5lLFxuICAgICAgcG9zRGV0YWlscy5jb2x1bW5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3RhcnQoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgczAgPSBwZWckcGFyc2VtZXJnZWQoKTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW1lcmdlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VtZXJnZWQoKTtcbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzMoczEsIHM1KTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZW9yZGVyZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczgsIHM5LCBzMTAsIHMxMSwgczEyLCBzMTM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJGMxO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNyA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzOCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRjNztcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMTAgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczEwICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRjOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczEyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMTMgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTEoczMsIHM3LCBzMTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmaWx0ZXJlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlc3RyZWFtKCk7XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IFtdO1xuICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXIoKTtcbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzEzKHMxLCBzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXN0cmVhbSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzdHJlYW0oKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZWNsYXNzKCk7XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRwYXJzZWlkKCk7XG4gICAgfVxuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckYzE1O1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlZXZlbnRUeXBlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNihzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTgpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxOShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDApIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIxKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQxKSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMyMjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIzKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMjQoczIpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWNsYXNzKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nikge1xuICAgICAgczEgPSBwZWckYzI1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMjkoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VpZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzUpIHtcbiAgICAgIHMxID0gcGVnJGMzMDtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMSk7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICAgIHMzID0gcGVnJGMyNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzMyKHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZXZlbnRUeXBlKCkge1xuICAgIHZhciBzMDtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzMzKSB7XG4gICAgICBzMCA9IHBlZyRjMzM7XG4gICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzQpOyB9XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjMzUpIHtcbiAgICAgICAgczAgPSBwZWckYzM1O1xuICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzYpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjMzcpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjMzc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzM5KSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMzk7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDApOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNDEpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzQxO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDIpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjNDMpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDM7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ0KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzQ1KSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDU7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDYpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ3O1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzQ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ5O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTApOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1MTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM1Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1NCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1NTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTYpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzU3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM1OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYyKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzYzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjQpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZmlsdGVyKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgczEgPSBwZWckYzU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgIHMzID0gcGVnJGM3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM2NShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXZhbHVlKCkge1xuICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IFtdO1xuICAgIGlmIChwZWckYzY2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Nyk7IH1cbiAgICB9XG4gICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIGlmIChwZWckYzY2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY3KTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgczEgPSBwZWckYzY4KHMxKTtcbiAgICB9XG4gICAgczAgPSBzMTtcblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXNlcCgpIHtcbiAgICB2YXIgczAsIHMxO1xuXG4gICAgczAgPSBbXTtcbiAgICBpZiAocGVnJGM2OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgfVxuICAgIHdoaWxlIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAucHVzaChzMSk7XG4gICAgICBpZiAocGVnJGM2OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcwKTsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHBlZyRmYWlsKHsgdHlwZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiZW5kIG9mIGlucHV0XCIgfSk7XG4gICAgfVxuXG4gICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICBwYXJzZTogICAgICAgcGFyc2Vcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGV4cHJlc3Npb24gPSByZXF1aXJlKCcuLi9leHByZXNzaW9uJyk7XG5cbnZhciBleHByID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgcGFyc2UgPSBleHByZXNzaW9uLnBhcnNlO1xuICB2YXIgY29kZWdlbiA9IGV4cHJlc3Npb24uY29kZSh7XG4gICAgaWRXaGl0ZUxpc3Q6IFsnZCcsICdlJywgJ2knLCAncCcsICdzZyddXG4gIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbihleHByKSB7ICAgIFxuICAgIHZhciB2YWx1ZSA9IGNvZGVnZW4ocGFyc2UoZXhwcikpO1xuICAgIHZhbHVlLmZuID0gRnVuY3Rpb24oJ2QnLCAnZScsICdpJywgJ3AnLCAnc2cnLFxuICAgICAgJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcgKyB2YWx1ZS5mbiArICcpOycpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0pKCk7XG5cbmV4cHIuZXZhbCA9IGZ1bmN0aW9uKGdyYXBoLCBmbiwgZCwgZSwgaSwgcCwgc2cpIHtcbiAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoZGwuYXJyYXkoc2cpKTtcbiAgcmV0dXJuIGZuLmNhbGwobnVsbCwgZCwgZSwgaSwgcCwgc2cpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHByOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSW50ZXJhY3RvcnMobW9kZWwsIHNwZWMsIGRlZkZhY3RvcnkpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIHNnID0ge30sIHBkID0ge30sIG1rID0ge30sXG4gICAgICBzaWduYWxzID0gW10sIHByZWRpY2F0ZXMgPSBbXTtcblxuICBmdW5jdGlvbiBsb2FkZWQoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGRsLmVycm9yKFwiTE9BRElORyBGQUlMRUQ6IFwiICsgaS51cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRlZiA9IGRsLmlzT2JqZWN0KGRhdGEpID8gZGF0YSA6IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIGludGVyYWN0b3IoaS5uYW1lLCBkZWYpO1xuICAgICAgfVxuICAgICAgaWYgKC0tY291bnQgPT0gMCkgaW5qZWN0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJhY3RvcihuYW1lLCBkZWYpIHtcbiAgICBzZyA9IHt9LCBwZCA9IHt9O1xuICAgIGlmIChkZWYuc2lnbmFscykgICAgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIG5zU2lnbmFscyhuYW1lLCBkZWYuc2lnbmFscykpO1xuICAgIGlmIChkZWYucHJlZGljYXRlcykgcHJlZGljYXRlcy5wdXNoLmFwcGx5KHByZWRpY2F0ZXMsIG5zUHJlZGljYXRlcyhuYW1lLCBkZWYucHJlZGljYXRlcykpO1xuICAgIG5zTWFya3MobmFtZSwgZGVmLm1hcmtzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICBpZiAoZGwua2V5cyhtaykubGVuZ3RoID4gMCkgaW5qZWN0TWFya3Moc3BlYy5tYXJrcyk7XG4gICAgc3BlYy5zaWduYWxzID0gZGwuYXJyYXkoc3BlYy5zaWduYWxzKTtcbiAgICBzcGVjLnByZWRpY2F0ZXMgPSBkbC5hcnJheShzcGVjLnByZWRpY2F0ZXMpO1xuICAgIHNwZWMuc2lnbmFscy51bnNoaWZ0LmFwcGx5KHNwZWMuc2lnbmFscywgc2lnbmFscyk7XG4gICAgc3BlYy5wcmVkaWNhdGVzLnVuc2hpZnQuYXBwbHkoc3BlYy5wcmVkaWNhdGVzLCBwcmVkaWNhdGVzKTtcbiAgICBkZWZGYWN0b3J5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RNYXJrcyhtYXJrcykge1xuICAgIHZhciBtLCByLCBpLCBsZW47XG4gICAgbWFya3MgPSBkbC5hcnJheShtYXJrcyk7XG5cbiAgICBmb3IoaSA9IDAsIGxlbiA9IG1hcmtzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtID0gbWFya3NbaV07XG4gICAgICBpZiAociA9IG1rW20udHlwZV0pIHtcbiAgICAgICAgbWFya3NbaV0gPSBkbC5kdXBsaWNhdGUocik7XG4gICAgICAgIGlmIChtLmZyb20pIG1hcmtzW2ldLmZyb20gPSBtLmZyb207XG4gICAgICAgIGlmIChtLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICBbQy5FTlRFUiwgQy5VUERBVEUsIEMuRVhJVF0uZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICBtYXJrc1tpXS5wcm9wZXJ0aWVzW3BdID0gZGwuZXh0ZW5kKHIucHJvcGVydGllc1twXSwgbS5wcm9wZXJ0aWVzW3BdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtLm1hcmtzKSB7ICAvLyBUT0RPIGhvdyB0byBvdmVycmlkZSBwcm9wZXJ0aWVzIG9mIG5lc3RlZCBtYXJrcz9cbiAgICAgICAgaW5qZWN0TWFya3MobS5tYXJrcyk7XG4gICAgICB9XG4gICAgfSAgICBcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zKG4sIHMpIHsgXG4gICAgaWYgKGRsLmlzU3RyaW5nKHMpKSB7XG4gICAgICByZXR1cm4gcyArIFwiX1wiICsgbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGwua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgXG4gICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoJ1xcXFxiJyt4KydcXFxcYicsIFwiZ1wiKTtcbiAgICAgICAgbiA9IG4ucmVwbGFjZShyZWdleCwgc1t4XSkgXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5zU2lnbmFscyhuYW1lLCBzaWduYWxzKSB7XG4gICAgc2lnbmFscyA9IGRsLmFycmF5KHNpZ25hbHMpO1xuICAgIC8vIFR3byBwYXNzZXMgdG8gbnMgYWxsIHNpZ25hbHMsIGFuZCB0aGVuIG92ZXJ3cml0ZSB0aGVpciBkZWZpbml0aW9uc1xuICAgIC8vIGluIGNhc2Ugc2lnbmFsIG9yZGVyIGlzIGltcG9ydGFudC5cbiAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBzLm5hbWUgPSBzZ1tzLm5hbWVdID0gbnMocy5uYW1lLCBuYW1lKTsgfSk7XG4gICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIChzLnN0cmVhbXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICB0LnR5cGUgPSBucyh0LnR5cGUsIHNnKTtcbiAgICAgICAgdC5leHByID0gbnModC5leHByLCBzZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2lnbmFscztcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zUHJlZGljYXRlcyhuYW1lLCBwcmVkaWNhdGVzKSB7XG4gICAgcHJlZGljYXRlcyA9IGRsLmFycmF5KHByZWRpY2F0ZXMpO1xuICAgIHByZWRpY2F0ZXMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBwLm5hbWUgPSBwZFtwLm5hbWVdID0gbnMocC5uYW1lLCBuYW1lKTtcblxuICAgICAgW3Aub3BlcmFuZHMsIHAucmFuZ2VdLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICAoeCB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgaWYgKG8uc2lnbmFsKSBvLnNpZ25hbCA9IG5zKG8uc2lnbmFsLCBzZyk7XG4gICAgICAgICAgZWxzZSBpZiAoby5wcmVkaWNhdGUpIG5zT3BlcmFuZChvKTtcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgfSk7ICBcbiAgICByZXR1cm4gcHJlZGljYXRlczsgXG4gIH1cblxuICBmdW5jdGlvbiBuc09wZXJhbmQobykge1xuICAgIG8ucHJlZGljYXRlID0gcGRbby5wcmVkaWNhdGVdO1xuICAgIGRsLmtleXMoby5pbnB1dCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgaSA9IG8uaW5wdXRba107XG4gICAgICBpZiAoaS5zaWduYWwpIGkuc2lnbmFsID0gbnMoaS5zaWduYWwsIHNnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zTWFya3MobmFtZSwgbWFya3MpIHtcbiAgICAobWFya3MgfHwgW10pLmZvckVhY2goZnVuY3Rpb24obSkgeyBcbiAgICAgIG5zUHJvcGVydGllcyhtLnByb3BlcnRpZXMuZW50ZXIpO1xuICAgICAgbnNQcm9wZXJ0aWVzKG0ucHJvcGVydGllcy51cGRhdGUpO1xuICAgICAgbnNQcm9wZXJ0aWVzKG0ucHJvcGVydGllcy5leGl0KTtcbiAgICAgIG1rW25zKG0ubmFtZSwgbmFtZSldID0gbTsgXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuc1Byb3BlcnRpZXMocHJvcHNldCkge1xuICAgIGRsLmtleXMocHJvcHNldCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgcCA9IHByb3BzZXRba107XG4gICAgICBpZiAocC5zaWduYWwpIHAuc2lnbmFsID0gbnMocC5zaWduYWwsIHNnKTtcbiAgICAgIGVsc2UgaWYgKHAucnVsZSkge1xuICAgICAgICBwLnJ1bGUuZm9yRWFjaChmdW5jdGlvbihyKSB7IFxuICAgICAgICAgIGlmIChyLnNpZ25hbCkgci5zaWduYWwgPSBucyhyLnNpZ25hbCwgc2cpO1xuICAgICAgICAgIGlmIChyLnByZWRpY2F0ZSkgbnNPcGVyYW5kKHIpOyBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAoc3BlYy5pbnRlcmFjdG9ycyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgaWYgKGkudXJsKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgZGwubG9hZChkbC5leHRlbmQoe3VybDogaS51cmx9LCBjb25maWcubG9hZCksIGxvYWRlZChpKSk7XG4gICAgfVxuICB9KTtcblxuICBpZiAoY291bnQgPT09IDApIHNldFRpbWVvdXQoaW5qZWN0LCAxKTtcbiAgcmV0dXJuIHNwZWM7XG59IiwidmFyIGxnbmQgPSByZXF1aXJlKCcuLi9zY2VuZS9sZWdlbmQnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpO1xuXG5mdW5jdGlvbiBsZWdlbmRzKG1vZGVsLCBzcGVjLCBsZWdlbmRzLCBncm91cCkge1xuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkZWYsIGluZGV4KSB7XG4gICAgbGVnZW5kc1tpbmRleF0gPSBsZWdlbmRzW2luZGV4XSB8fCBsZ25kKG1vZGVsKTtcbiAgICBsZWdlbmQoZGVmLCBpbmRleCwgbGVnZW5kc1tpbmRleF0sIGdyb3VwKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBsZWdlbmQoZGVmLCBpbmRleCwgbGVnZW5kLCBncm91cCkge1xuICAvLyBsZWdlbmQgc2NhbGVzXG4gIGxlZ2VuZC5zaXplICAoZGVmLnNpemUgICA/IGdyb3VwLnNjYWxlKGRlZi5zaXplKSAgIDogbnVsbCk7XG4gIGxlZ2VuZC5zaGFwZSAoZGVmLnNoYXBlICA/IGdyb3VwLnNjYWxlKGRlZi5zaGFwZSkgIDogbnVsbCk7XG4gIGxlZ2VuZC5maWxsICAoZGVmLmZpbGwgICA/IGdyb3VwLnNjYWxlKGRlZi5maWxsKSAgIDogbnVsbCk7XG4gIGxlZ2VuZC5zdHJva2UoZGVmLnN0cm9rZSA/IGdyb3VwLnNjYWxlKGRlZi5zdHJva2UpIDogbnVsbCk7XG5cbiAgLy8gbGVnZW5kIG9yaWVudGF0aW9uXG4gIGlmIChkZWYub3JpZW50KSBsZWdlbmQub3JpZW50KGRlZi5vcmllbnQpO1xuXG4gIC8vIGxlZ2VuZCBvZmZzZXRcbiAgaWYgKGRlZi5vZmZzZXQgIT0gbnVsbCkgbGVnZW5kLm9mZnNldChkZWYub2Zmc2V0KTtcblxuICAvLyBsZWdlbmQgdGl0bGVcbiAgbGVnZW5kLnRpdGxlKGRlZi50aXRsZSB8fCBudWxsKTtcblxuICAvLyBsZWdlbmQgdmFsdWVzXG4gIGxlZ2VuZC52YWx1ZXMoZGVmLnZhbHVlcyB8fCBudWxsKTtcblxuICAvLyBsZWdlbmQgbGFiZWwgZm9ybWF0dGluZ1xuICBsZWdlbmQuZm9ybWF0KGRlZi5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IGRlZi5mb3JtYXQgOiBudWxsKTtcblxuICAvLyBzdHlsZSBwcm9wZXJ0aWVzXG4gIHZhciBwID0gZGVmLnByb3BlcnRpZXM7XG4gIGxlZ2VuZC50aXRsZVByb3BlcnRpZXMocCAmJiBwLnRpdGxlIHx8IHt9KTtcbiAgbGVnZW5kLmxhYmVsUHJvcGVydGllcyhwICYmIHAubGFiZWxzIHx8IHt9KTtcbiAgbGVnZW5kLmxlZ2VuZFByb3BlcnRpZXMocCAmJiBwLmxlZ2VuZCB8fCB7fSk7XG4gIGxlZ2VuZC5zeW1ib2xQcm9wZXJ0aWVzKHAgJiYgcC5zeW1ib2xzIHx8IHt9KTtcbiAgbGVnZW5kLmdyYWRpZW50UHJvcGVydGllcyhwICYmIHAuZ3JhZGllbnQgfHwge30pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxlZ2VuZHM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHBhcnNlUHJvcGVydGllcyA9IHJlcXVpcmUoJy4vcHJvcGVydGllcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTWFyayhtb2RlbCwgbWFyaykge1xuICB2YXIgcHJvcHMgPSBtYXJrLnByb3BlcnRpZXMsXG4gICAgICBncm91cCA9IG1hcmsubWFya3M7XG5cbiAgLy8gcGFyc2UgbWFyayBwcm9wZXJ0eSBkZWZpbml0aW9uc1xuICBkbC5rZXlzKHByb3BzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBwcm9wc1trXSA9IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgbWFyay50eXBlLCBwcm9wc1trXSk7XG4gIH0pO1xuXG4gIC8vIHBhcnNlIGRlbGF5IGZ1bmN0aW9uXG4gIGlmIChtYXJrLmRlbGF5KSB7XG4gICAgbWFyay5kZWxheSA9IHBhcnNlUHJvcGVydGllcyhtb2RlbCwgbWFyay50eXBlLCB7ZGVsYXk6IG1hcmsuZGVsYXl9KTtcbiAgfVxuXG4gIC8vIHJlY3Vyc2UgaWYgZ3JvdXAgdHlwZVxuICBpZiAoZ3JvdXApIHtcbiAgICBtYXJrLm1hcmtzID0gZ3JvdXAubWFwKGZ1bmN0aW9uKGcpIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgZyk7IH0pO1xuICB9XG4gICAgXG4gIHJldHVybiBtYXJrO1xufTsiLCJ2YXIgcGFyc2VNYXJrID0gcmVxdWlyZSgnLi9tYXJrJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kZWwsIHNwZWMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHNjYWxlczogc3BlYy5zY2FsZXMgfHwgW10sXG4gICAgYXhlczogc3BlYy5heGVzIHx8IFtdLFxuICAgIGxlZ2VuZHM6IHNwZWMubGVnZW5kcyB8fCBbXSxcbiAgICBtYXJrczogKHNwZWMubWFya3MgfHwgW10pLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KVxuICB9O1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbnZhciBmaWx0ZXIgPSBmdW5jdGlvbihmaWVsZCwgdmFsdWUsIHNyYywgZGVzdCkge1xuICBmb3IodmFyIGkgPSBzcmMubGVuZ3RoLTE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYoc3JjW2ldW2ZpZWxkXSA9PSB2YWx1ZSlcbiAgICAgIGRlc3QucHVzaC5hcHBseShkZXN0LCBzcmMuc3BsaWNlKGksIDEpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZU1vZGlmeShtb2RlbCwgZGVmLCBkcykge1xuICB2YXIgc2lnbmFsID0gZGVmLnNpZ25hbCA/IGRsLmZpZWxkKGRlZi5zaWduYWwpIDogbnVsbCwgXG4gICAgICBzaWduYWxOYW1lID0gc2lnbmFsID8gc2lnbmFsWzBdIDogbnVsbCxcbiAgICAgIHByZWRpY2F0ZSA9IGRlZi5wcmVkaWNhdGUgPyBtb2RlbC5wcmVkaWNhdGUoZGVmLnByZWRpY2F0ZSkgOiBudWxsLFxuICAgICAgcmVldmFsID0gKHByZWRpY2F0ZSA9PT0gbnVsbCksXG4gICAgICBub2RlID0gbmV3IE5vZGUobW9kZWwpO1xuXG4gIG5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmKHByZWRpY2F0ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRiID0ge307XG4gICAgICAocHJlZGljYXRlLmRhdGF8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZGJbZF0gPSBtb2RlbC5kYXRhKGQpLnZhbHVlcygpOyB9KTtcblxuICAgICAgLy8gVE9ETzogaW5wdXRcbiAgICAgIHJlZXZhbCA9IHByZWRpY2F0ZS5jYWxsKHByZWRpY2F0ZSwge30sIGRiLCBtb2RlbC5zaWduYWxWYWx1ZXMocHJlZGljYXRlLnNpZ25hbHN8fFtdKSwgbW9kZWwuX3ByZWRpY2F0ZXMpO1xuICAgIH1cblxuICAgIGRlYnVnKGlucHV0LCBbZGVmLnR5cGUrXCJpbmdcIiwgcmVldmFsXSk7XG4gICAgaWYoIXJlZXZhbCkgcmV0dXJuIGlucHV0O1xuXG4gICAgdmFyIGRhdHVtID0ge30sIFxuICAgICAgICB2YWx1ZSA9IHNpZ25hbCA/IG1vZGVsLnNpZ25hbFJlZihkZWYuc2lnbmFsKSA6IG51bGwsXG4gICAgICAgIGQgPSBtb2RlbC5kYXRhKGRzLm5hbWUpLFxuICAgICAgICBwcmV2ID0gZC5yZXZpc2VzKCkgPyBudWxsIDogdW5kZWZpbmVkLFxuICAgICAgICB0ID0gbnVsbDtcblxuICAgIGRhdHVtW2RlZi5maWVsZF0gPSB2YWx1ZTtcblxuICAgIC8vIFdlIGhhdmUgdG8gbW9kaWZ5IGRzLl9kYXRhIHNvIHRoYXQgc3Vic2VxdWVudCBwdWxzZXMgY29udGFpblxuICAgIC8vIG91ciBkeW5hbWljIGRhdGEuIFcvbyBtb2RpZnlpbmcgZHMuX2RhdGEsIG9ubHkgdGhlIG91dHB1dFxuICAgIC8vIGNvbGxlY3RvciB3aWxsIGNvbnRhaW4gZHluYW1pYyB0dXBsZXMuIFxuICAgIGlmKGRlZi50eXBlID09IEMuQUREKSB7XG4gICAgICB0ID0gdHVwbGUuaW5nZXN0KGRhdHVtLCBwcmV2KTtcbiAgICAgIGlucHV0LmFkZC5wdXNoKHQpO1xuICAgICAgZC5fZGF0YS5wdXNoKHQpO1xuICAgIH0gZWxzZSBpZihkZWYudHlwZSA9PSBDLlJFTU9WRSkge1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LmFkZCwgaW5wdXQucmVtKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5tb2QsIGlucHV0LnJlbSk7XG4gICAgICBkLl9kYXRhID0gZC5fZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4geFtkZWYuZmllbGRdICE9PSB2YWx1ZSB9KTtcbiAgICB9IGVsc2UgaWYoZGVmLnR5cGUgPT0gQy5UT0dHTEUpIHtcbiAgICAgIHZhciBhZGQgPSBbXSwgcmVtID0gW107XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQucmVtLCBhZGQpO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LmFkZCwgcmVtKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5tb2QsIHJlbSk7XG4gICAgICBpZihhZGQubGVuZ3RoID09IDAgJiYgcmVtLmxlbmd0aCA9PSAwKSBhZGQucHVzaCh0dXBsZS5pbmdlc3QoZGF0dW0pKTtcblxuICAgICAgaW5wdXQuYWRkLnB1c2guYXBwbHkoaW5wdXQuYWRkLCBhZGQpO1xuICAgICAgZC5fZGF0YS5wdXNoLmFwcGx5KGQuX2RhdGEsIGFkZCk7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIHJlbSk7XG4gICAgICBkLl9kYXRhID0gZC5fZGF0YS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gcmVtLmluZGV4T2YoeCkgPT09IC0xIH0pO1xuICAgIH0gZWxzZSBpZihkZWYudHlwZSA9PSBDLkNMRUFSKSB7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIGlucHV0LmFkZCk7XG4gICAgICBpbnB1dC5yZW0ucHVzaC5hcHBseShpbnB1dC5yZW0sIGlucHV0Lm1vZCk7XG4gICAgICBpbnB1dC5hZGQgPSBbXTtcbiAgICAgIGlucHV0Lm1vZCA9IFtdO1xuICAgICAgZC5fZGF0YSAgPSBbXTtcbiAgICB9IFxuXG4gICAgaW5wdXQuZmllbGRzW2RlZi5maWVsZF0gPSAxO1xuICAgIHJldHVybiBpbnB1dDtcbiAgfTtcblxuICBpZihzaWduYWxOYW1lKSBub2RlLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzaWduYWxOYW1lKTtcbiAgaWYocHJlZGljYXRlKSAgbm9kZS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgcHJlZGljYXRlLnNpZ25hbHMpO1xuICBcbiAgcmV0dXJuIG5vZGU7XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUGFkZGluZyhwYWQpIHtcbiAgaWYgKHBhZCA9PSBudWxsKSByZXR1cm4gXCJhdXRvXCI7XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHBhZCkpIHJldHVybiBwYWQ9PT1cInN0cmljdFwiID8gXCJzdHJpY3RcIiA6IFwiYXV0b1wiO1xuICBlbHNlIGlmIChkbC5pc09iamVjdChwYWQpKSByZXR1cm4gcGFkO1xuICB2YXIgcCA9IGRsLmlzTnVtYmVyKHBhZCkgPyBwYWQgOiAyMDtcbiAgcmV0dXJuIHt0b3A6cCwgbGVmdDpwLCByaWdodDpwLCBib3R0b206cH07XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlUHJlZGljYXRlKG1vZGVsLCBzcGVjKSB7XG4gIHZhciB0eXBlcyA9IHtcbiAgICAnPSc6ICBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJz09JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICchPSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPic6ICBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJz49JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICc8JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPD0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJ2FuZCc6IHBhcnNlTG9naWNhbCxcbiAgICAnJiYnOiAgcGFyc2VMb2dpY2FsLFxuICAgICdvcic6ICBwYXJzZUxvZ2ljYWwsXG4gICAgJ3x8JzogIHBhcnNlTG9naWNhbCxcbiAgICAnaW4nOiBwYXJzZUluXG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VTaWduYWwoc2lnbmFsLCBzaWduYWxzKSB7XG4gICAgdmFyIHMgPSBkbC5maWVsZChzaWduYWwpLFxuICAgICAgICBjb2RlID0gXCJzaWduYWxzW1wiK3MubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiO1xuICAgIHNpZ25hbHNbcy5zaGlmdCgpXSA9IDE7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VPcGVyYW5kcyhvcGVyYW5kcykge1xuICAgIHZhciBkZWNsID0gW10sIGRlZnMgPSBbXSxcbiAgICAgICAgc2lnbmFscyA9IHt9LCBkYiA9IHt9O1xuXG4gICAgZGwuYXJyYXkob3BlcmFuZHMpLmZvckVhY2goZnVuY3Rpb24obywgaSkge1xuICAgICAgdmFyIHNpZ25hbCwgbmFtZSA9IFwib1wiK2ksIGRlZiA9IFwiXCI7XG4gICAgICBcbiAgICAgIGlmKG8udmFsdWUgIT09IHVuZGVmaW5lZCkgZGVmID0gZGwuc3RyKG8udmFsdWUpO1xuICAgICAgZWxzZSBpZihvLmFyZykgICAgZGVmID0gXCJhcmdzW1wiK2RsLnN0cihvLmFyZykrXCJdXCI7XG4gICAgICBlbHNlIGlmKG8uc2lnbmFsKSBkZWYgPSBwYXJzZVNpZ25hbChvLnNpZ25hbCwgc2lnbmFscyk7XG4gICAgICBlbHNlIGlmKG8ucHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBwcmVkID0gbW9kZWwucHJlZGljYXRlKG8ucHJlZGljYXRlKSxcbiAgICAgICAgICAgIHAgPSBcInByZWRpY2F0ZXNbXCIrZGwuc3RyKG8ucHJlZGljYXRlKStcIl1cIjtcblxuICAgICAgICBwcmVkLnNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IHNpZ25hbHNbc10gPSAxOyB9KTtcbiAgICAgICAgcHJlZC5kYXRhLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkYltkXSA9IDEgfSk7XG5cbiAgICAgICAgZGwua2V5cyhvLmlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICB2YXIgaSA9IG8uaW5wdXRba10sIHNpZ25hbDtcbiAgICAgICAgICBkZWYgKz0gXCJhcmdzW1wiK2RsLnN0cihrKStcIl0gPSBcIjtcbiAgICAgICAgICBpZihpLnNpZ25hbCkgICBkZWYgKz0gcGFyc2VTaWduYWwoaS5zaWduYWwsIHNpZ25hbHMpO1xuICAgICAgICAgIGVsc2UgaWYoaS5hcmcpIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGkuYXJnKStcIl1cIjtcbiAgICAgICAgICBkZWYrPVwiLCBcIjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZGVmKz0gcCtcIi5jYWxsKFwiK3ArXCIsIGFyZ3MsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKVwiO1xuICAgICAgfVxuXG4gICAgICBkZWNsLnB1c2gobmFtZSk7XG4gICAgICBkZWZzLnB1c2gobmFtZStcIj0oXCIrZGVmK1wiKVwiKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBcInZhciBcIiArIGRlY2wuam9pbihcIiwgXCIpICsgXCI7XFxuXCIgKyBkZWZzLmpvaW4oXCI7XFxuXCIpICsgXCI7XFxuXCIsXG4gICAgICBzaWduYWxzOiBkbC5rZXlzKHNpZ25hbHMpLFxuICAgICAgZGF0YTogZGwua2V5cyhkYilcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKHNwZWMpIHtcbiAgICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhzcGVjLm9wZXJhbmRzKTtcbiAgICBpZihzcGVjLnR5cGUgPT0gJz0nKSBzcGVjLnR5cGUgPSAnPT0nO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG9wcy5jb2RlICsgXCJyZXR1cm4gXCIgKyBbXCJvMFwiLCBcIm8xXCJdLmpvaW4oc3BlYy50eXBlKSArIFwiO1wiLFxuICAgICAgc2lnbmFsczogb3BzLnNpZ25hbHMsXG4gICAgICBkYXRhOiBvcHMuZGF0YVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2dpY2FsKHNwZWMpIHtcbiAgICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhzcGVjLm9wZXJhbmRzKSxcbiAgICAgICAgbyA9IFtdLCBpID0gMCwgbGVuID0gc3BlYy5vcGVyYW5kcy5sZW5ndGg7XG5cbiAgICB3aGlsZShvLnB1c2goXCJvXCIraSsrKTxsZW4pO1xuICAgIGlmKHNwZWMudHlwZSA9PSAnYW5kJykgc3BlYy50eXBlID0gJyYmJztcbiAgICBlbHNlIGlmKHNwZWMudHlwZSA9PSAnb3InKSBzcGVjLnR5cGUgPSAnfHwnO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IG9wcy5jb2RlICsgXCJyZXR1cm4gXCIgKyBvLmpvaW4oc3BlYy50eXBlKSArIFwiO1wiLFxuICAgICAgc2lnbmFsczogb3BzLnNpZ25hbHMsXG4gICAgICBkYXRhOiBvcHMuZGF0YVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VJbihzcGVjKSB7XG4gICAgdmFyIG8gPSBbc3BlYy5pdGVtXSwgY29kZSA9IFwiXCI7XG4gICAgaWYoc3BlYy5yYW5nZSkgby5wdXNoLmFwcGx5KG8sIHNwZWMucmFuZ2UpO1xuICAgIGlmKHNwZWMuc2NhbGUpIHtcbiAgICAgIGNvZGUgPSBwYXJzZVNjYWxlKHNwZWMuc2NhbGUsIG8pO1xuICAgIH1cblxuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKG8pO1xuICAgIGNvZGUgPSBvcHMuY29kZSArIGNvZGU7XG5cbiAgICBpZihzcGVjLmRhdGEpIHtcbiAgICAgIHZhciBmaWVsZCA9IGRsLmZpZWxkKHNwZWMuZmllbGQpLm1hcChkbC5zdHIpO1xuICAgICAgY29kZSArPSBcInZhciB3aGVyZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbXCIrZmllbGQuam9pbihcIl1bXCIpK1wiXSA9PSBvMCB9O1xcblwiO1xuICAgICAgY29kZSArPSBcInJldHVybiBkYltcIitkbC5zdHIoc3BlYy5kYXRhKStcIl0uZmlsdGVyKHdoZXJlKS5sZW5ndGggPiAwO1wiO1xuICAgIH0gZWxzZSBpZihzcGVjLnJhbmdlKSB7XG4gICAgICAvLyBUT0RPOiBpbmNsdXNpdmUvZXhjbHVzaXZlIHJhbmdlP1xuICAgICAgLy8gVE9ETzogaW52ZXJ0aW5nIG9yZGluYWwgc2NhbGVzXG4gICAgICBpZihzcGVjLnNjYWxlKSBjb2RlICs9IFwibzEgPSBzY2FsZShvMSk7XFxubzIgPSBzY2FsZShvMik7XFxuXCI7XG4gICAgICBjb2RlICs9IFwicmV0dXJuIG8xIDwgbzIgPyBvMSA8PSBvMCAmJiBvMCA8PSBvMiA6IG8yIDw9IG8wICYmIG8wIDw9IG8xXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IGNvZGUsIFxuICAgICAgc2lnbmFsczogb3BzLnNpZ25hbHMsIFxuICAgICAgZGF0YTogb3BzLmRhdGEuY29uY2F0KHNwZWMuZGF0YSA/IFtzcGVjLmRhdGFdIDogW10pXG4gICAgfTtcbiAgfTtcblxuICAvLyBQb3B1bGF0ZSBvcHMgc3VjaCB0aGF0IHVsdGltYXRlIHNjYWxlL2ludmVyc2lvbiBmdW5jdGlvbiB3aWxsIGJlIGluIGBzY2FsZWAgdmFyLiBcbiAgZnVuY3Rpb24gcGFyc2VTY2FsZShzcGVjLCBvcHMpIHtcbiAgICB2YXIgY29kZSA9IFwidmFyIHNjYWxlID0gXCIsIFxuICAgICAgICBpZHggID0gb3BzLmxlbmd0aDtcblxuICAgIGlmKGRsLmlzU3RyaW5nKHNwZWMpKSB7XG4gICAgICBvcHMucHVzaCh7IHZhbHVlOiBzcGVjIH0pO1xuICAgICAgY29kZSArPSBcInRoaXMucm9vdCgpLnNjYWxlKG9cIitpZHgrXCIpXCI7XG4gICAgfSBlbHNlIGlmKHNwZWMuYXJnKSB7ICAvLyBTY2FsZSBmdW5jdGlvbiBpcyBiZWluZyBwYXNzZWQgYXMgYW4gYXJnXG4gICAgICBvcHMucHVzaChzcGVjKTtcbiAgICAgIGNvZGUgKz0gXCJvXCIraWR4O1xuICAgIH0gZWxzZSBpZihzcGVjLm5hbWUpIHsgLy8gRnVsbCBzY2FsZSBwYXJhbWV0ZXIge25hbWU6IC4ufVxuICAgICAgb3BzLnB1c2goZGwuaXNTdHJpbmcoc3BlYy5uYW1lKSA/IHt2YWx1ZTogc3BlYy5uYW1lfSA6IHNwZWMubmFtZSk7XG4gICAgICBjb2RlICs9IFwiKHRoaXMuaXNGdW5jdGlvbihvXCIraWR4K1wiKSA/IG9cIitpZHgrXCIgOiBcIjtcbiAgICAgIGlmKHNwZWMuc2NvcGUpIHtcbiAgICAgICAgb3BzLnB1c2goc3BlYy5zY29wZSk7XG4gICAgICAgIGNvZGUgKz0gXCIob1wiKyhpZHgrMSkrXCIuc2NhbGUgfHwgdGhpcy5yb290KCkuc2NhbGUpKG9cIitpZHgrXCIpXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2RlICs9IFwidGhpcy5yb290KCkuc2NhbGUob1wiK2lkeCtcIilcIjtcbiAgICAgIH1cbiAgICAgIGNvZGUgKz0gXCIpXCJcbiAgICB9XG5cbiAgICBpZihzcGVjLmludmVydCA9PT0gdHJ1ZSkgeyAgLy8gQWxsb3cgc3BlYy5pbnZlcnQuYXJnP1xuICAgICAgY29kZSArPSBcIi5pbnZlcnRcIlxuICAgIH1cblxuICAgIHJldHVybiBjb2RlK1wiO1xcblwiO1xuICB9XG5cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBwYXJzZSA9IHR5cGVzW3MudHlwZV0ocyksXG4gICAgICAgIHByZWQgID0gRnVuY3Rpb24oXCJhcmdzXCIsIFwiZGJcIiwgXCJzaWduYWxzXCIsIFwicHJlZGljYXRlc1wiLCBwYXJzZS5jb2RlKTtcbiAgICBwcmVkLnJvb3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1vZGVsLnNjZW5lKCkuaXRlbXNbMF0gfTsgLy8gRm9yIGdsb2JhbCBzY2FsZXNcbiAgICBwcmVkLmlzRnVuY3Rpb24gPSBkbC5pc0Z1bmN0aW9uO1xuICAgIHByZWQuc2lnbmFscyA9IHBhcnNlLnNpZ25hbHM7XG4gICAgcHJlZC5kYXRhID0gcGFyc2UuZGF0YTtcbiAgICBtb2RlbC5wcmVkaWNhdGUocy5uYW1lLCBwcmVkKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyk7XG5cbnZhciBERVBTID0gW1wic2lnbmFsc1wiLCBcInNjYWxlc1wiLCBcImRhdGFcIiwgXCJmaWVsZHNcIl07XG5cbmZ1bmN0aW9uIGNvbXBpbGUobW9kZWwsIG1hcmssIHNwZWMpIHtcbiAgdmFyIGNvZGUgPSBcIlwiLFxuICAgICAgbmFtZXMgPSBkbC5rZXlzKHNwZWMpLFxuICAgICAgaSwgbGVuLCBuYW1lLCByZWYsIHZhcnMgPSB7fSwgXG4gICAgICBkZXBzID0ge1xuICAgICAgICBzaWduYWxzOiB7fSxcbiAgICAgICAgc2NhbGVzOiAge30sXG4gICAgICAgIGRhdGE6ICAgIHt9LFxuICAgICAgICBmaWVsZHM6ICB7fSxcbiAgICAgICAgcmVmbG93OiAgZmFsc2VcbiAgICAgIH07XG4gICAgICBcbiAgY29kZSArPSBcInZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW07XFxuXCJcbiAgXG4gIGZvciAoaT0wLCBsZW49bmFtZXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgcmVmID0gc3BlY1tuYW1lID0gbmFtZXNbaV1dO1xuICAgIGNvZGUgKz0gKGkgPiAwKSA/IFwiXFxuICBcIiA6IFwiICBcIjtcbiAgICBpZihyZWYucnVsZSkge1xuICAgICAgcmVmID0gcnVsZShtb2RlbCwgbmFtZSwgcmVmLnJ1bGUpO1xuICAgICAgY29kZSArPSBcIlxcbiAgXCIgKyByZWYuY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB2YWx1ZVJlZihuYW1lLCByZWYpO1xuICAgICAgY29kZSArPSBcInRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1wiO1xuICAgIH1cblxuICAgIHZhcnNbbmFtZV0gPSB0cnVlO1xuICAgIERFUFMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICBpZihyZWZbcF0gIT0gbnVsbCkgZGwuYXJyYXkocmVmW3BdKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHsgZGVwc1twXVtrXSA9IDEgfSk7XG4gICAgfSk7XG4gICAgZGVwcy5yZWZsb3cgPSBkZXBzLnJlZmxvdyB8fCByZWYucmVmbG93O1xuICB9XG5cbiAgaWYgKHZhcnMueDIpIHtcbiAgICBpZiAodmFycy54KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby54ID4gby54MikgeyBcIlxuICAgICAgICAgICAgKyBcInZhciB0ID0gby54O1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd4Jywgby54Mik7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3gyJywgdCk7IFwiXG4gICAgICAgICAgICArIFwifTtcIjtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAnd2lkdGgnLCAoby54MiAtIG8ueCkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy53aWR0aCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd4JywgKG8ueDIgLSBvLndpZHRoKSk7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneCcsIG8ueDIpO1wiXG4gICAgfVxuICB9XG5cbiAgaWYgKHZhcnMueTIpIHtcbiAgICBpZiAodmFycy55KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby55ID4gby55MikgeyBcIlxuICAgICAgICAgICAgKyBcInZhciB0ID0gby55O1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd5Jywgby55Mik7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3kyJywgdCk7XCJcbiAgICAgICAgICAgICsgXCJ9O1wiO1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICdoZWlnaHQnLCAoby55MiAtIG8ueSkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy5oZWlnaHQpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneScsIChvLnkyIC0gby5oZWlnaHQpKTtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd5Jywgby55Mik7XCJcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChoYXNQYXRoKG1hcmssIHZhcnMpKSBjb2RlICs9IFwiXFxuICBpdGVtLnRvdWNoKCk7XCI7XG4gIGNvZGUgKz0gXCJcXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XCI7XG5cbiAgdHJ5IHtcbiAgICB2YXIgZW5jb2RlciA9IEZ1bmN0aW9uKFwiaXRlbVwiLCBcImdyb3VwXCIsIFwidHJhbnNcIiwgXCJkYlwiLCBcbiAgICAgIFwic2lnbmFsc1wiLCBcInByZWRpY2F0ZXNcIiwgY29kZSk7XG4gICAgZW5jb2Rlci50cGwgID0gdHVwbGU7XG4gICAgZW5jb2Rlci51dGlsID0gZGw7XG4gICAgZW5jb2Rlci5kMyAgID0gZDM7IC8vIEZvciBjb2xvciBzcGFjZXNcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiAgZW5jb2RlcixcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoZGVwcy5zaWduYWxzKSxcbiAgICAgIHNjYWxlczogIGRsLmtleXMoZGVwcy5zY2FsZXMpLFxuICAgICAgZGF0YTogICAgZGwua2V5cyhkZXBzLmRhdGEpLFxuICAgICAgZmllbGRzOiAgZGwua2V5cyhkZXBzLmZpZWxkcyksXG4gICAgICByZWZsb3c6ICBkZXBzLnJlZmxvd1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRsLmVycm9yKGUpO1xuICAgIGRsLmxvZyhjb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXRoKG1hcmssIHZhcnMpIHtcbiAgcmV0dXJuIHZhcnMucGF0aCB8fFxuICAgICgobWFyaz09PVwiYXJlYVwiIHx8IG1hcms9PT1cImxpbmVcIikgJiZcbiAgICAgICh2YXJzLnggfHwgdmFycy54MiB8fCB2YXJzLndpZHRoIHx8XG4gICAgICAgdmFycy55IHx8IHZhcnMueTIgfHwgdmFycy5oZWlnaHQgfHxcbiAgICAgICB2YXJzLnRlbnNpb24gfHwgdmFycy5pbnRlcnBvbGF0ZSkpO1xufVxuXG5mdW5jdGlvbiBydWxlKG1vZGVsLCBuYW1lLCBydWxlcykge1xuICB2YXIgc2lnbmFscyA9IFtdLCBzY2FsZXMgPSBbXSwgZGIgPSBbXSxcbiAgICAgIGlucHV0cyA9IFtdLCBjb2RlID0gXCJcIjtcblxuICAocnVsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICB2YXIgcHJlZE5hbWUgPSByLnByZWRpY2F0ZSxcbiAgICAgICAgcHJlZCA9IG1vZGVsLnByZWRpY2F0ZShwcmVkTmFtZSksXG4gICAgICAgIHAgPSBcInByZWRpY2F0ZXNbXCIrZGwuc3RyKHByZWROYW1lKStcIl1cIixcbiAgICAgICAgaW5wdXQgPSBbXSwgYXJncyA9IG5hbWUrXCJfYXJnXCIraSxcbiAgICAgICAgcmVmO1xuXG4gICAgZGwua2V5cyhyLmlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciByZWYgPSB2YWx1ZVJlZihpLCByLmlucHV0W2tdKTtcbiAgICAgIGlucHV0LnB1c2goZGwuc3RyKGspK1wiOiBcIityZWYudmFsKTtcbiAgICAgIGlmKHJlZi5zaWduYWxzKSBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgZGwuYXJyYXkocmVmLnNpZ25hbHMpKTtcbiAgICAgIGlmKHJlZi5zY2FsZXMpICBzY2FsZXMucHVzaC5hcHBseShzY2FsZXMsIGRsLmFycmF5KHJlZi5zY2FsZXMpKTtcbiAgICB9KTtcblxuICAgIHJlZiA9IHZhbHVlUmVmKG5hbWUsIHIpO1xuICAgIGlmKHJlZi5zaWduYWxzKSBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgZGwuYXJyYXkocmVmLnNpZ25hbHMpKTtcbiAgICBpZihyZWYuc2NhbGVzKSAgc2NhbGVzLnB1c2guYXBwbHkoc2NhbGVzLCBkbC5hcnJheShyZWYuc2NhbGVzKSk7XG5cbiAgICBpZihwcmVkTmFtZSkge1xuICAgICAgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIHByZWQuc2lnbmFscyk7XG4gICAgICBkYi5wdXNoLmFwcGx5KGRiLCBwcmVkLmRhdGEpO1xuICAgICAgaW5wdXRzLnB1c2goYXJncytcIiA9IHtcIitpbnB1dC5qb2luKCcsICcpK1wifVwiKTtcbiAgICAgIGNvZGUgKz0gXCJpZihcIitwK1wiLmNhbGwoXCIrcCtcIixcIithcmdzK1wiLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykpIHtcXG5cIiArXG4gICAgICAgIFwiICAgIHRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1xcblwiO1xuICAgICAgY29kZSArPSBydWxlc1tpKzFdID8gXCIgIH0gZWxzZSBcIiA6IFwiICB9XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJ7XFxuXCIgKyBcbiAgICAgICAgXCIgICAgdGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XFxuXCIrXG4gICAgICAgIFwiICB9XCI7XG4gICAgfVxuICB9KTtcblxuICBjb2RlID0gXCJ2YXIgXCIgKyBpbnB1dHMuam9pbihcIixcXG4gICAgICBcIikgKyBcIjtcXG4gIFwiICsgY29kZTtcbiAgcmV0dXJuIHtjb2RlOiBjb2RlLCBzaWduYWxzOiBzaWduYWxzLCBzY2FsZXM6IHNjYWxlcywgZGF0YTogZGJ9O1xufVxuXG5mdW5jdGlvbiB2YWx1ZVJlZihuYW1lLCByZWYpIHtcbiAgaWYgKHJlZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICBpZiAobmFtZT09PVwiZmlsbFwiIHx8IG5hbWU9PT1cInN0cm9rZVwiKSB7XG4gICAgaWYgKHJlZi5jKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJoY2xcIiwgcmVmLmgsIHJlZi5jLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYuaCB8fCByZWYucykge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwiaHNsXCIsIHJlZi5oLCByZWYucywgcmVmLmwpO1xuICAgIH0gZWxzZSBpZiAocmVmLmwgfHwgcmVmLmEpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcImxhYlwiLCByZWYubCwgcmVmLmEsIHJlZi5iKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5yIHx8IHJlZi5nIHx8IHJlZi5iKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJyZ2JcIiwgcmVmLnIsIHJlZi5nLCByZWYuYik7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhbGl6ZSB2YWx1ZVxuICB2YXIgdmFsID0gbnVsbCwgc2NhbGUgPSBudWxsLCBcbiAgICAgIHNnUmVmID0ge30sIGZSZWYgPSB7fSwgc1JlZiA9IHt9LFxuICAgICAgc2lnbmFscyA9IFtdLCBmaWVsZHMgPSBbXSwgcmVmbG93ID0gZmFsc2U7XG5cbiAgaWYgKHJlZi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsID0gZGwuc3RyKHJlZi52YWx1ZSk7XG4gIH1cblxuICBpZiAocmVmLnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2dSZWYgPSBkbC5maWVsZChyZWYuc2lnbmFsKTtcbiAgICB2YWwgPSBcInNpZ25hbHNbXCIrc2dSZWYubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiOyBcbiAgICBzaWduYWxzLnB1c2goc2dSZWYuc2hpZnQoKSk7XG4gIH1cblxuICBpZihyZWYuZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJlZi5maWVsZCA9IGRsLmlzU3RyaW5nKHJlZi5maWVsZCkgPyB7ZGF0dW06IHJlZi5maWVsZH0gOiByZWYuZmllbGQ7XG4gICAgZlJlZiAgPSBmaWVsZFJlZihyZWYuZmllbGQpO1xuICAgIHZhbCA9IGZSZWYudmFsO1xuICB9XG5cbiAgaWYgKHJlZi5zY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc1JlZiA9IHNjYWxlUmVmKHJlZi5zY2FsZSk7XG4gICAgc2NhbGUgPSBzUmVmLnZhbDtcblxuICAgIC8vIHJ1biB0aHJvdWdoIHNjYWxlIGZ1bmN0aW9uIGlmIHZhbCBzcGVjaWZpZWQuXG4gICAgLy8gaWYgbm8gdmFsLCBzY2FsZSBmdW5jdGlvbiBpcyBwcmVkaWNhdGUgYXJnLlxuICAgIGlmKHZhbCAhPT0gbnVsbCB8fCByZWYuYmFuZCB8fCByZWYubXVsdCB8fCByZWYub2Zmc2V0KSB7XG4gICAgICB2YWwgPSBzY2FsZSArIChyZWYuYmFuZCA/IFwiLnJhbmdlQmFuZCgpXCIgOiBcbiAgICAgICAgXCIoXCIrKHZhbCAhPT0gbnVsbCA/IHZhbCA6IFwiaXRlbS5kYXR1bS5kYXRhXCIpK1wiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gc2NhbGU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBtdWx0aXBseSwgb2Zmc2V0LCByZXR1cm4gdmFsdWVcbiAgdmFsID0gXCIoXCIgKyAocmVmLm11bHQ/KGRsLm51bWJlcihyZWYubXVsdCkrXCIgKiBcIik6XCJcIikgKyB2YWwgKyBcIilcIlxuICAgICsgKHJlZi5vZmZzZXQgPyBcIiArIFwiICsgZGwubnVtYmVyKHJlZi5vZmZzZXQpIDogXCJcIik7XG5cbiAgLy8gQ29sbGF0ZSBkZXBlbmRlbmNpZXNcbiAgcmV0dXJuIHtcbiAgICB2YWw6IHZhbCxcbiAgICBzaWduYWxzOiBzaWduYWxzLmNvbmNhdChkbC5hcnJheShmUmVmLnNpZ25hbHMpKS5jb25jYXQoZGwuYXJyYXkoc1JlZi5zaWduYWxzKSksXG4gICAgZmllbGRzOiAgZmllbGRzLmNvbmNhdChkbC5hcnJheShmUmVmLmZpZWxkcykpLmNvbmNhdChkbC5hcnJheShzUmVmLmZpZWxkcykpLFxuICAgIHNjYWxlczogIHJlZi5zY2FsZSA/IChyZWYuc2NhbGUubmFtZSB8fCByZWYuc2NhbGUpIDogbnVsbCwgLy8gVE9ETzogY29ubmVjdCBzUmVmJ2Qgc2NhbGU/XG4gICAgcmVmbG93OiAgcmVmbG93IHx8IGZSZWYucmVmbG93IHx8IHNSZWYucmVmbG93XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbG9yUmVmKHR5cGUsIHgsIHksIHopIHtcbiAgdmFyIHh4ID0geCA/IHZhbHVlUmVmKFwiXCIsIHgpIDogY29uZmlnLmNvbG9yW3R5cGVdWzBdLFxuICAgICAgeXkgPSB5ID8gdmFsdWVSZWYoXCJcIiwgeSkgOiBjb25maWcuY29sb3JbdHlwZV1bMV0sXG4gICAgICB6eiA9IHogPyB2YWx1ZVJlZihcIlwiLCB6KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsyXVxuICAgICAgc2lnbmFscyA9IFtdLCBzY2FsZXMgPSBbXTtcblxuICBbeHgsIHl5LCB6el0uZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgaWYodi5zaWduYWxzKSBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgdi5zaWduYWxzKTtcbiAgICBpZih2LnNjYWxlcykgIHNjYWxlcy5wdXNoKHYuc2NhbGVzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2YWw6IFwiKHRoaXMuZDMuXCIgKyB0eXBlICsgXCIoXCIgKyBbeHgudmFsLCB5eS52YWwsIHp6LnZhbF0uam9pbihcIixcIikgKyAnKSArIFwiXCIpJyxcbiAgICBzaWduYWxzOiBzaWduYWxzLFxuICAgIHNjYWxlczogc2NhbGVzXG4gIH07XG59XG5cbi8vIHtmaWVsZDoge2RhdHVtOiBcImZvb1wifSB9ICAtPiBpdGVtLmRhdHVtLmZvb1xuLy8ge2ZpZWxkOiB7Z3JvdXA6IFwiZm9vXCJ9IH0gIC0+IGdyb3VwLmZvb1xuLy8ge2ZpZWxkOiB7cGFyZW50OiBcImZvb1wifSB9IC0+IGdyb3VwLmRhdHVtLmZvb1xuZnVuY3Rpb24gZmllbGRSZWYocmVmKSB7XG4gIGlmKGRsLmlzU3RyaW5nKHJlZikpIHtcbiAgICByZXR1cm4ge3ZhbDogZGwuZmllbGQocmVmKS5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIil9O1xuICB9IFxuXG4gIC8vIFJlc29sdmUgbmVzdGluZy9wYXJlbnQgbG9va3Vwc1xuICB2YXIgbCA9IHJlZi5sZXZlbCxcbiAgICAgIG5lc3RlZCA9IChyZWYuZ3JvdXAgfHwgcmVmLnBhcmVudCkgJiYgbCxcbiAgICAgIHNjb3BlID0gbmVzdGVkID8gQXJyYXkobCkuam9pbihcImdyb3VwLm1hcmsuXCIpIDogXCJcIixcbiAgICAgIHIgPSBmaWVsZFJlZihyZWYuZGF0dW0gfHwgcmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQgfHwgcmVmLnNpZ25hbCksXG4gICAgICB2YWwgPSByLnZhbCxcbiAgICAgIGZpZWxkcyAgPSByLmZpZWxkcyAgfHwgW10sXG4gICAgICBzaWduYWxzID0gci5zaWduYWxzIHx8IFtdLFxuICAgICAgcmVmbG93ICA9IHIucmVmbG93ICB8fCBmYWxzZTsgLy8gTmVzdGVkIGZpZWxkcmVmcyB0cmlnZ2VyIGZ1bGwgcmVldmFsIG9mIEVuY29kZXIuXG5cbiAgaWYocmVmLmRhdHVtKSB7XG4gICAgdmFsID0gXCJpdGVtLmRhdHVtW1wiK3ZhbCtcIl1cIjtcbiAgICBmaWVsZHMucHVzaChyZWYuZGF0dW0pO1xuICB9IGVsc2UgaWYocmVmLmdyb3VwKSB7XG4gICAgdmFsID0gc2NvcGUrXCJncm91cFtcIit2YWwrXCJdXCI7XG4gICAgcmVmbG93ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHJlZi5wYXJlbnQpIHtcbiAgICB2YWwgPSBzY29wZStcImdyb3VwLmRhdHVtW1wiK3ZhbCtcIl1cIjtcbiAgICByZWZsb3cgPSB0cnVlO1xuICB9IGVsc2UgaWYocmVmLnNpZ25hbCkge1xuICAgIHZhbCA9IFwic2lnbmFsc1tcIit2YWwrXCJdXCI7XG4gICAgc2lnbmFscy5wdXNoKGRsLmZpZWxkKHJlZi5zaWduYWwpWzBdKTtcbiAgICByZWZsb3cgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHt2YWw6IHZhbCwgZmllbGRzOiBmaWVsZHMsIHNpZ25hbHM6IHNpZ25hbHMsIHJlZmxvdzogcmVmbG93fTtcbn1cblxuLy8ge3NjYWxlOiBcInhcIn1cbi8vIHtzY2FsZToge25hbWU6IFwieFwifX0sXG4vLyB7c2NhbGU6IGZpZWxkUmVmfVxuZnVuY3Rpb24gc2NhbGVSZWYocmVmKSB7XG4gIHZhciBzY2FsZSA9IG51bGwsXG4gICAgICBmciA9IG51bGw7XG5cbiAgaWYoZGwuaXNTdHJpbmcocmVmKSkge1xuICAgIHNjYWxlID0gZGwuc3RyKHJlZik7XG4gIH0gZWxzZSBpZihyZWYubmFtZSkge1xuICAgIHNjYWxlID0gZGwuaXNTdHJpbmcocmVmLm5hbWUpID8gZGwuc3RyKHJlZi5uYW1lKSA6IChmciA9IGZpZWxkUmVmKHJlZi5uYW1lKSkudmFsO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlID0gKGZyID0gZmllbGRSZWYocmVmKSkudmFsO1xuICB9XG5cbiAgc2NhbGUgPSBcImdyb3VwLnNjYWxlKFwiK3NjYWxlK1wiKVwiO1xuICBpZihyZWYuaW52ZXJ0KSBzY2FsZSArPSBcIi5pbnZlcnRcIjsgIC8vIFRPRE86IG9yZGluYWwgc2NhbGVzXG5cbiAgcmV0dXJuIGZyID8gKGZyLnZhbCA9IHNjYWxlLCBmcikgOiB7dmFsOiBzY2FsZX07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGlsZTsiLCJ2YXIgZXhwciA9IHJlcXVpcmUoJy4vZXhwcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlU2lnbmFscyhtb2RlbCwgc3BlYykge1xuICAvLyBwcm9jZXNzIGVhY2ggc2lnbmFsIGRlZmluaXRpb25cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBzaWduYWwgPSBtb2RlbC5zaWduYWwocy5uYW1lLCBzLmluaXQpLFxuICAgICAgICBleHA7XG5cbiAgICBpZihzLmV4cHIpIHtcbiAgICAgIGV4cCA9IGV4cHIocy5leHByKTtcbiAgICAgIHNpZ25hbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV4cHIuZXZhbChtb2RlbCwgZXhwLmZuLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBleHAuc2lnbmFscyk7XG4gICAgICAgIGlmKHNwZWMuc2NhbGUpIHZhbHVlID0gbW9kZWwuc2NhbGUoc3BlYywgdmFsdWUpO1xuICAgICAgICBzaWduYWwudmFsdWUodmFsdWUpO1xuICAgICAgICBpbnB1dC5zaWduYWxzW3MubmFtZV0gPSAxO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9O1xuICAgICAgc2lnbmFsLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBleHAuc2lnbmFscyk7XG4gICAgICBleHAuc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKGRlcCkgeyBtb2RlbC5zaWduYWwoZGVwKS5hZGRMaXN0ZW5lcihzaWduYWwpOyB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzcGVjO1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTW9kZWwgPSByZXF1aXJlKCcuLi9jb3JlL01vZGVsJyksIFxuICAgIFZpZXcgPSByZXF1aXJlKCcuLi9jb3JlL1ZpZXcnKSwgXG4gICAgcGFyc2VQYWRkaW5nID0gcmVxdWlyZSgnLi4vcGFyc2UvcGFkZGluZycpLFxuICAgIHBhcnNlTWFya3MgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrcycpLFxuICAgIHBhcnNlU2lnbmFscyA9IHJlcXVpcmUoJy4uL3BhcnNlL3NpZ25hbHMnKSxcbiAgICBwYXJzZVByZWRpY2F0ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9wcmVkaWNhdGVzJyksXG4gICAgcGFyc2VEYXRhID0gcmVxdWlyZSgnLi4vcGFyc2UvZGF0YScpLFxuICAgIHBhcnNlSW50ZXJhY3RvcnMgPSByZXF1aXJlKCcuLi9wYXJzZS9pbnRlcmFjdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlU3BlYyhzcGVjLCBjYWxsYmFjaywgdmlld0ZhY3RvcnkpIHtcbiAgLy8gcHJvdGVjdCBhZ2FpbnN0IHN1YnNlcXVlbnQgc3BlYyBtb2RpZmljYXRpb25cbiAgc3BlYyA9IGRsLmR1cGxpY2F0ZShzcGVjKTtcblxuICB2aWV3RmFjdG9yeSA9IHZpZXdGYWN0b3J5IHx8IFZpZXcuZmFjdG9yeTtcblxuICB2YXIgd2lkdGggPSBzcGVjLndpZHRoIHx8IDUwMCxcbiAgICAgIGhlaWdodCA9IHNwZWMuaGVpZ2h0IHx8IDUwMCxcbiAgICAgIHZpZXdwb3J0ID0gc3BlYy52aWV3cG9ydCB8fCBudWxsLFxuICAgICAgbW9kZWwgPSBuZXcgTW9kZWwoKTtcblxuICBwYXJzZUludGVyYWN0b3JzKG1vZGVsLCBzcGVjLCBmdW5jdGlvbigpIHtcbiAgICBtb2RlbC5kZWZzKHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgcGFkZGluZzogcGFyc2VQYWRkaW5nKHNwZWMucGFkZGluZyksXG4gICAgICBzaWduYWxzOiBwYXJzZVNpZ25hbHMobW9kZWwsIHNwZWMuc2lnbmFscyksXG4gICAgICBwcmVkaWNhdGVzOiBwYXJzZVByZWRpY2F0ZXMobW9kZWwsIHNwZWMucHJlZGljYXRlcyksXG4gICAgICBtYXJrczogcGFyc2VNYXJrcyhtb2RlbCwgc3BlYywgd2lkdGgsIGhlaWdodCksXG4gICAgICBkYXRhOiBwYXJzZURhdGEobW9kZWwsIHNwZWMuZGF0YSwgZnVuY3Rpb24oKSB7IGNhbGxiYWNrKHZpZXdGYWN0b3J5KG1vZGVsKSk7IH0pXG4gICAgfSk7XG4gIH0pO1xufVxuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBjaGFuZ3NldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIHNlbGVjdG9yID0gcmVxdWlyZSgnLi9ldmVudHMnKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi9leHByJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbnZhciBTVEFSVCA9IFwic3RhcnRcIiwgTUlERExFID0gXCJtaWRkbGVcIiwgRU5EID0gXCJlbmRcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciBtb2RlbCA9IHZpZXcubW9kZWwoKSxcbiAgICAgIHNwZWMgID0gbW9kZWwuZGVmcygpLnNpZ25hbHMsXG4gICAgICByZWdpc3RlciA9IHt9LCBub2RlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHNwZWMsIHZhbHVlKSB7XG4gICAgdmFyIGRlZiA9IHNwZWMuc2NhbGUsXG4gICAgICAgIG5hbWUgID0gZGVmLm5hbWUgfHwgZGVmLnNpZ25hbCB8fCBkZWYsXG4gICAgICAgIHNjb3BlID0gZGVmLnNjb3BlID8gbW9kZWwuc2lnbmFsUmVmKGRlZi5zY29wZS5zaWduYWwpIDogbnVsbDtcblxuICAgIGlmKCFzY29wZSB8fCAhc2NvcGUuc2NhbGUpIHtcbiAgICAgIHNjb3BlID0gKHNjb3BlICYmIHNjb3BlLm1hcmspID8gc2NvcGUubWFyay5ncm91cCA6IG1vZGVsLnNjZW5lKCkuaXRlbXNbMF07XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gc2NvcGUuc2NhbGUobmFtZSk7XG4gICAgaWYoIXNjYWxlKSByZXR1cm4gdmFsdWU7XG4gICAgcmV0dXJuIGRlZi5pbnZlcnQgPyBzY2FsZS5pbnZlcnQodmFsdWUpIDogc2NhbGUodmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBuID0gbmV3IE5vZGUobW9kZWwpO1xuICAgIG4uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgaWYoIWlucHV0LnNpZ25hbHNbc2VsZWN0b3Iuc2lnbmFsXSkgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuICAgICAgdmFyIHZhbCA9IGV4cHIuZXZhbChtb2RlbCwgZXhwLmZuLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBleHAuc2lnbmFscyk7XG4gICAgICBpZihzcGVjLnNjYWxlKSB2YWwgPSBzY2FsZShzcGVjLCB2YWwpO1xuICAgICAgc2lnLnZhbHVlKHZhbCk7XG4gICAgICBpbnB1dC5zaWduYWxzW3NpZy5uYW1lKCldID0gMTtcbiAgICAgIGlucHV0LnJlZmxvdyA9IHRydWU7XG4gICAgICByZXR1cm4gaW5wdXQ7ICBcbiAgICB9O1xuICAgIG4uZGVwZW5kZW5jeShDLlNJR05BTFMsIHNlbGVjdG9yLnNpZ25hbCk7XG4gICAgbi5hZGRMaXN0ZW5lcihzaWcpO1xuICAgIG1vZGVsLnNpZ25hbChzZWxlY3Rvci5zaWduYWwpLmFkZExpc3RlbmVyKG4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGV2ZW50KHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBmaWx0ZXJzID0gc2VsZWN0b3IuZmlsdGVycyB8fCBbXSxcbiAgICAgICAgdGFyZ2V0ID0gc2VsZWN0b3IudGFyZ2V0O1xuXG4gICAgaWYodGFyZ2V0KSBmaWx0ZXJzLnB1c2goXCJpLlwiK3RhcmdldC50eXBlK1wiPT1cIitkbC5zdHIodGFyZ2V0LnZhbHVlKSk7XG5cbiAgICByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0gPSByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0gfHwgW107XG4gICAgcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdLnB1c2goe1xuICAgICAgc2lnbmFsOiBzaWcsXG4gICAgICBleHA6IGV4cCxcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGV4cHIoZik7IH0pLFxuICAgICAgc3BlYzogc3BlY1xuICAgIH0pO1xuXG4gICAgbm9kZXNbc2VsZWN0b3IuZXZlbnRdID0gbm9kZXNbc2VsZWN0b3IuZXZlbnRdIHx8IG5ldyBOb2RlKG1vZGVsKTtcbiAgICBub2Rlc1tzZWxlY3Rvci5ldmVudF0uYWRkTGlzdGVuZXIoc2lnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvcmRlcmVkU3RyZWFtKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBuYW1lID0gc2lnLm5hbWUoKSwgXG4gICAgICAgIHRydWVGbiA9IGV4cHIoXCJ0cnVlXCIpLFxuICAgICAgICBzID0ge307XG5cbiAgICBzW1NUQVJUXSAgPSBtb2RlbC5zaWduYWwobmFtZSArIFNUQVJULCAgZmFsc2UpO1xuICAgIHNbTUlERExFXSA9IG1vZGVsLnNpZ25hbChuYW1lICsgTUlERExFLCBmYWxzZSk7XG4gICAgc1tFTkRdICAgID0gbW9kZWwuc2lnbmFsKG5hbWUgKyBFTkQsICAgIGZhbHNlKTtcblxuICAgIHZhciByb3V0ZXIgPSBuZXcgTm9kZShtb2RlbCk7XG4gICAgcm91dGVyLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGlmKHNbU1RBUlRdLnZhbHVlKCkgPT09IHRydWUgJiYgc1tFTkRdLnZhbHVlKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFRPRE86IEV4cGFuZCBzZWxlY3RvciBzeW50YXggdG8gYWxsb3cgc3RhcnQvZW5kIHNpZ25hbHMgaW50byBzdHJlYW0uXG4gICAgICAgIC8vIFVudGlsIHRoZW4sIHByZXZlbnQgb2xkIG1pZGRsZXMgZW50ZXJpbmcgc3RyZWFtIG9uIG5ldyBzdGFydC5cbiAgICAgICAgaWYoaW5wdXQuc2lnbmFsc1tuYW1lK1NUQVJUXSkgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuXG4gICAgICAgIHNpZy52YWx1ZShzW01JRERMRV0udmFsdWUoKSk7XG4gICAgICAgIGlucHV0LnNpZ25hbHNbbmFtZV0gPSAxO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmKHNbRU5EXS52YWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgIHNbU1RBUlRdLnZhbHVlKGZhbHNlKTtcbiAgICAgICAgc1tFTkRdLnZhbHVlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1vZGVsLmRvTm90UHJvcGFnYXRlO1xuICAgIH07XG4gICAgcm91dGVyLmFkZExpc3RlbmVyKHNpZyk7XG5cbiAgICBbU1RBUlQsIE1JRERMRSwgRU5EXS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciB2YWwgPSAoeCA9PSBNSURETEUpID8gZXhwIDogdHJ1ZUZuLFxuICAgICAgICAgIHNwID0gKHggPT0gTUlERExFKSA/IHNwZWMgOiB7fTtcblxuICAgICAgaWYoc2VsZWN0b3JbeF0uZXZlbnQpIGV2ZW50KHNbeF0sIHNlbGVjdG9yW3hdLCB2YWwsIHNwKTtcbiAgICAgIGVsc2UgaWYoc2VsZWN0b3JbeF0uc2lnbmFsKSBzaWduYWwoc1t4XSwgc2VsZWN0b3JbeF0sIHZhbCwgc3ApO1xuICAgICAgZWxzZSBpZihzZWxlY3Rvclt4XS5zdHJlYW0pIG1lcmdlZFN0cmVhbShzW3hdLCBzZWxlY3Rvclt4XS5zdHJlYW0sIHZhbCwgc3ApO1xuICAgICAgc1t4XS5hZGRMaXN0ZW5lcihyb3V0ZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICBzZWxlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIGlmKHMuZXZlbnQpICAgICAgIGV2ZW50KHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zaWduYWwpIHNpZ25hbChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc3RhcnQpICBvcmRlcmVkU3RyZWFtKHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zdHJlYW0pIG1lcmdlZFN0cmVhbShzaWcsIHMuc3RyZWFtLCBleHAsIHNwZWMpO1xuICAgIH0pO1xuICB9O1xuXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaWduYWwgPSBtb2RlbC5zaWduYWwoc2lnLm5hbWUpO1xuICAgIGlmKHNpZy5leHByKSByZXR1cm47ICAvLyBDYW5ub3QgaGF2ZSBhbiBleHByIGFuZCBzdHJlYW0gZGVmaW5pdGlvbi5cblxuICAgIChzaWcuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBzZWwgPSBzZWxlY3Rvci5wYXJzZShzdHJlYW0udHlwZSksXG4gICAgICAgICAgZXhwID0gZXhwcihzdHJlYW0uZXhwcik7XG4gICAgICBtZXJnZWRTdHJlYW0oc2lnbmFsLCBzZWwsIGV4cCwgc3RyZWFtKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2UgcmVnaXN0ZXIgdGhlIGV2ZW50IGxpc3RlbmVycyBhbGwgdG9nZXRoZXIgc28gdGhhdCBpZiBtdWx0aXBsZVxuICAvLyBzaWduYWxzIGFyZSByZWdpc3RlcmVkIG9uIHRoZSBzYW1lIGV2ZW50LCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGVcbiAgLy8gbmV3IHZhbHVlIG9uIHRoZSBzYW1lIHB1bHNlLiBcblxuICAvLyBUT0RPOiBGaWx0ZXJzLCB0aW1lIGludGVydmFscywgdGFyZ2V0IHNlbGVjdG9yc1xuICBkbC5rZXlzKHJlZ2lzdGVyKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSByZWdpc3RlcltyXSwgXG4gICAgICAgIG5vZGUgPSBub2Rlc1tyXTtcblxuICAgIHZpZXcub24ociwgZnVuY3Rpb24oZXZ0LCBpdGVtKSB7XG4gICAgICB2YXIgY3MgPSBjaGFuZ3NldC5jcmVhdGUobnVsbCwgdHJ1ZSksXG4gICAgICAgICAgcGFkID0gdmlldy5wYWRkaW5nKCksXG4gICAgICAgICAgZmlsdGVyZWQgPSBmYWxzZSxcbiAgICAgICAgICB2YWwsIGgsIGksIG0sIGQ7XG5cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIHRleHQgc2VsZWN0aW9uXG4gICAgICBtID0gZDMubW91c2UoKGQzLmV2ZW50PWV2dCwgdmlldy5fZWwpKTsgLy8gUmVsYXRpdmUgcG9zaXRpb24gd2l0aGluIGNvbnRhaW5lclxuICAgICAgaXRlbSA9IGl0ZW18fHt9O1xuICAgICAgZCA9IGl0ZW0uZGF0dW18fHt9O1xuICAgICAgdmFyIHAgPSB7eDogbVswXSAtIHBhZC5sZWZ0LCB5OiBtWzFdIC0gcGFkLnRvcH07XG5cbiAgICAgIGZvcihpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGggPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgZmlsdGVyZWQgPSBoLmZpbHRlcnMuc29tZShmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuICFleHByLmV2YWwobW9kZWwsIGYuZm4sIGQsIGV2dCwgaXRlbSwgcCwgZi5zaWduYWxzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGZpbHRlcmVkKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhbCA9IGV4cHIuZXZhbChtb2RlbCwgaC5leHAuZm4sIGQsIGV2dCwgaXRlbSwgcCwgaC5leHAuc2lnbmFscyk7IFxuICAgICAgICBpZihoLnNwZWMuc2NhbGUpIHZhbCA9IHNjYWxlKGguc3BlYywgdmFsLCBpdGVtKTtcbiAgICAgICAgaC5zaWduYWwudmFsdWUodmFsKTtcbiAgICAgICAgY3Muc2lnbmFsc1toLnNpZ25hbC5uYW1lKCldID0gMTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwucHJvcGFnYXRlKGNzLCBub2RlKTtcbiAgICB9KTtcbiAgfSlcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHRyYW5zZm9ybXMgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL2luZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCBkZWYpIHtcbiAgdmFyIHR4ID0gbmV3IHRyYW5zZm9ybXNbZGVmLnR5cGVdKG1vZGVsKTtcbiAgaWYoZGVmLnR5cGUgPT0gJ2ZhY2V0Jykge1xuICAgIHZhciBwaXBlbGluZSA9IChkZWYudHJhbnNmb3JtfHxbXSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCB0KTsgfSk7XG4gICAgdHgucGlwZWxpbmUocGlwZWxpbmUpO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byByZW5hbWUgb3V0cHV0IGZpZWxkcyBiZWZvcmUgc2V0dGluZyBhbnkgb3RoZXIgcHJvcGVydGllcyxcbiAgLy8gYXMgc3Vic2VxdWVudCBwcm9wZXJ0aWVzIG1heSByZXF1aXJlIG91dHB1dCB0byBiZSBzZXQgKGUuZy4gZ3JvdXAgYnkpLlxuICBpZihkZWYub3V0cHV0KSB0eC5vdXRwdXQoZGVmLm91dHB1dCk7XG5cbiAgZGwua2V5cyhkZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmKGsgPT09ICd0eXBlJyB8fCBrID09PSAnb3V0cHV0JykgcmV0dXJuO1xuICAgIGlmKGsgPT09ICd0cmFuc2Zvcm0nICYmIGRlZi50eXBlID09PSAnZmFjZXQnKSByZXR1cm47XG4gICAgKHR4W2tdKS5zZXQodHgsIGRlZltrXSk7XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbnZhciBoYW5kbGVyID0gZnVuY3Rpb24oZWwsIG1vZGVsKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGlmIChlbCkgdGhpcy5pbml0aWFsaXplKGVsKTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsKG1vZGVsKTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSBoYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBkMy5zZWxlY3QoZWwpLm5vZGUoKTtcbiAgdGhpcy5fY2FudmFzID0gZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJjYW52YXMubWFya3NcIikubm9kZSgpO1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcywgdGhhdCA9IHRoaXM7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHByb3RvdHlwZVt0eXBlXS5jYWxsKHRoYXQsIGV2dCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICByZXR1cm4gZGwua2V5cyhoKS5yZWR1Y2UoZnVuY3Rpb24oYSwgaykge1xuICAgIHJldHVybiBoW2tdLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7IHJldHVybiAoYS5wdXNoKHgpLCBhKTsgfSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbi8vIHNldHVwIGV2ZW50c1xudmFyIGV2ZW50cyA9IFtcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZXVwXCIsXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIndoZWVsXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXByZXNzXCIsXG4gIFwia2V5dXBcIixcbiAgXCJtb3VzZXdoZWVsXCIsXG4gIFwidG91Y2hzdGFydFwiXG5dO1xuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICBwcm90b3R5cGVbdHlwZV0gPSBmdW5jdGlvbihldnQpIHtcbiAgICB0aGlzLmZpcmUodHlwZSwgZXZ0KTtcbiAgfTtcbn0pO1xuZXZlbnRzLnB1c2goXCJtb3VzZW1vdmVcIik7XG5ldmVudHMucHVzaChcIm1vdXNlb3V0XCIpO1xuZXZlbnRzLnB1c2goXCJ0b3VjaG1vdmVcIik7XG5ldmVudHMucHVzaChcInRvdWNoZW5kXCIpO1xuXG5mdW5jdGlvbiBldmVudE5hbWUobmFtZSkge1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi5cIik7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59XG5cbnByb3RvdHlwZS50b3VjaG1vdmUgPSBwcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IGV2dC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB4ID0gZXZ0LmNsaWVudFggLSBiLmxlZnQsXG4gICAgICB5ID0gZXZ0LmNsaWVudFkgLSBiLnRvcCxcbiAgICAgIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBwID0gdGhpcy5waWNrKHRoaXMuX21vZGVsLnNjZW5lKCksIHgsIHksIHgtcGFkLmxlZnQsIHktcGFkLnRvcCk7XG5cbiAgaWYgKHAgPT09IGEpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW1vdmVcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNobW92ZVwiKSB0aGlzLmZpcmUoXCJ0b3VjaG1vdmVcIiwgZXZ0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaGVuZFwiKSB0aGlzLmZpcmUoXCJ0b3VjaGVuZFwiLCBldnQpO1xuICB9XG4gIHRoaXMuX2FjdGl2ZSA9IHA7XG4gIGlmIChwKSB7XG4gICAgdGhpcy5maXJlKFwibW91c2VvdmVyXCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaHN0YXJ0XCIpIHRoaXMuZmlyZShcInRvdWNoc3RhcnRcIiwgZXZ0KTtcbiAgfVxufTtcblxucHJvdG90eXBlLnRvdWNoZW5kID0gcHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW91dFwiLCBldnQpO1xuICAgIHRoaXMuZmlyZShcInRvdWNoZW5kXCIsIGV2dCk7XG4gIH1cbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbn07XG5cbi8vIHRvIGtlZXAgZmlyZWZveCBoYXBweVxucHJvdG90eXBlLkRPTU1vdXNlU2Nyb2xsID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuZmlyZShcIm1vdXNld2hlZWxcIiwgZXZ0KTtcbn07XG5cbi8vIGZpcmUgYW4gZXZlbnRcbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZXZ0KSB7XG4gIHZhciBhID0gdGhpcy5fYWN0aXZlLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuICBpZiAoaCkge1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBoW2ldLmhhbmRsZXIuY2FsbCh0aGlzLl9vYmosIGV2dCwgYSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycztcbiAgaCA9IGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSk7XG4gIGgucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSBoLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbn07XG5cbi8vIGZpbmQgdGhlIHNjZW5lZ3JhcGggaXRlbSBhdCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuLy8geCwgeSAtLSB0aGUgYWJzb2x1dGUgeCwgeSBtb3VzZSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzIGVsZW1lbnRcbi8vIGd4LCBneSAtLSB0aGUgcmVsYXRpdmUgY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBjdXJyZW50IGdyb3VwXG5wcm90b3R5cGUucGljayA9IGZ1bmN0aW9uKHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICBwaWNrZXIgPSBtYXJrcy5waWNrW21hcmt0eXBlXTtcbiAgcmV0dXJuIHBpY2tlci5jYWxsKHRoaXMsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQm91bmRzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N0eCA9IG51bGw7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5faW1nbG9hZCA9IDA7XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgXG4gIGlmICghZWwpIHJldHVybiB0aGlzOyAvLyBlYXJseSBleGl0IGlmIG5vIERPTSBlbGVtZW50XG5cbiAgLy8gc2VsZWN0IGNhbnZhcyBlbGVtZW50XG4gIHZhciBjYW52YXMgPSBkMy5zZWxlY3QoZWwpXG4gICAgLnNlbGVjdEFsbChcImNhbnZhcy5tYXJrc1wiKVxuICAgIC5kYXRhKFsxXSk7XG4gIFxuICAvLyBjcmVhdGUgbmV3IGNhbnZhcyBlbGVtZW50IGlmIG5lZWRlZFxuICBjYW52YXMuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjYW52YXNcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwibWFya3NcIik7XG4gIFxuICAvLyByZW1vdmUgZXh0cmFuZW91cyBjYW52YXMgaWYgbmVlZGVkXG4gIGNhbnZhcy5leGl0KCkucmVtb3ZlKCk7XG4gIFxuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICBcbiAgaWYgKHRoaXMuX2VsKSB7XG4gICAgdmFyIGNhbnZhcyA9IGQzLnNlbGVjdCh0aGlzLl9lbCkuc2VsZWN0KFwiY2FudmFzLm1hcmtzXCIpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjYW52YXMgYXR0cmlidXRlc1xuICAgIGNhbnZhc1xuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0KVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20pO1xuXG4gICAgLy8gZ2V0IHRoZSBjYW52YXMgZ3JhcGhpY3MgY29udGV4dFxuICAgIHZhciBzO1xuICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5ub2RlKCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHRoaXMuX2N0eC5fcmF0aW8gPSAocyA9IHNjYWxlQ2FudmFzKGNhbnZhcy5ub2RlKCksIHRoaXMuX2N0eCkgfHwgMSk7XG4gICAgdGhpcy5fY3R4LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCBzKnBhZC5sZWZ0LCBzKnBhZC50b3ApO1xuICB9XG4gIFxuICBpbml0aWFsaXplTGluZURhc2godGhpcy5fY3R4KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBzY2FsZUNhbnZhcyhjYW52YXMsIGN0eCkge1xuICAvLyBnZXQgY2FudmFzIHBpeGVsIGRhdGFcbiAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSAoXG4gICAgICAgIGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvKSB8fCAxLFxuICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cbiAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IGJhY2tpbmdTdG9yZVJhdGlvKSB7XG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGgsIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIC8vIHNldCBhY3R1YWwgYW5kIHZpc2libGUgY2FudmFzIHNpemVcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyAqIHJhdGlvKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGggKiByYXRpbyk7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICB9XG4gIHJldHVybiByYXRpbztcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUxpbmVEYXNoKGN0eCkge1xuICBpZiAoY3R4LnZnTGluZURhc2gpIHJldHVybjsgLy8gYWxyZWFkeSBzZXRcblxuICB2YXIgTk9EQVNIID0gW107XG4gIGlmIChjdHguc2V0TGluZURhc2gpIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5zZXRMaW5lRGFzaChkYXNoIHx8IE5PREFTSCk7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy5saW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgud2Via2l0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICBcdGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLndlYmtpdExpbmVEYXNoID0gZGFzaCB8fCBOT0RBU0g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgubW96RGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMubW96RGFzaCA9IGRhc2g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgfSBlbHNlIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICB9XG59XG5cbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gIGlmIChjdHgpIHsgdGhpcy5fY3R4ID0gY3R4OyByZXR1cm4gdGhpczsgfVxuICBlbHNlIHJldHVybiB0aGlzLl9jdHg7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUucGVuZGluZ0ltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW1nbG9hZDtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgYm91bmRzKSB7XG4gIHZhciBiID0gbmV3IEJvdW5kcyhib3VuZHMpO1xuICB3aGlsZSAoKGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApICE9IG51bGwpIHtcbiAgICBiLnRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xuICB9XG4gIHJldHVybiBiO1xufVxuICBcbmZ1bmN0aW9uIGdldEJvdW5kcyhpdGVtcykge1xuICByZXR1cm4gIWl0ZW1zID8gbnVsbCA6XG4gICAgZGwuYXJyYXkoaXRlbXMpLnJlZHVjZShmdW5jdGlvbihiLCBpdGVtKSB7XG4gICAgICByZXR1cm4gYi51bmlvbih0cmFuc2xhdGVkQm91bmRzKGl0ZW0sIGl0ZW0uYm91bmRzKSlcbiAgICAgICAgICAgICAgLnVuaW9uKHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgaXRlbVsnYm91bmRzOnByZXYnXSkpO1xuICAgIH0sIG5ldyBCb3VuZHMoKSk7ICBcbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGcsIGJvdW5kcykge1xuICB2YXIgYmJveCA9IG51bGw7XG4gIGlmIChib3VuZHMpIHtcbiAgICBiYm94ID0gKG5ldyBCb3VuZHMoYm91bmRzKSkucm91bmQoKTtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGcucmVjdChiYm94LngxLCBiYm94LnkxLCBiYm94LndpZHRoKCksIGJib3guaGVpZ2h0KCkpO1xuICAgIGcuY2xpcCgpO1xuICB9XG4gIHJldHVybiBiYm94O1xufVxuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIHZhciBnID0gdGhpcy5fY3R4LFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIHcgPSB0aGlzLl93aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgICAgaCA9IHRoaXMuX2hlaWdodCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICAgICAgYmIgPSBudWxsLCBiYjI7XG5cbiAgLy8gc2V0dXBcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgZy5zYXZlKCk7XG4gIGJiID0gc2V0Qm91bmRzKGcsIGdldEJvdW5kcyhpdGVtcykpO1xuICBnLmNsZWFyUmVjdCgtcGFkLmxlZnQsIC1wYWQudG9wLCB3LCBoKTtcblxuICAvLyByZW5kZXJcbiAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYik7XG5cbiAgLy8gcmVuZGVyIGFnYWluIHRvIGhhbmRsZSBwb3NzaWJsZSBib3VuZHMgY2hhbmdlXG4gIGlmIChpdGVtcykge1xuICAgIGcucmVzdG9yZSgpO1xuICAgIGcuc2F2ZSgpO1xuICAgIGJiMiA9IHNldEJvdW5kcyhnLCBnZXRCb3VuZHMoaXRlbXMpKTtcbiAgICBpZiAoIWJiLmVuY2xvc2VzKGJiMikpIHtcbiAgICAgIGcuY2xlYXJSZWN0KC1wYWQubGVmdCwgLXBhZC50b3AsIHcsIGgpO1xuICAgICAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYjIpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gdGFrZWRvd25cbiAgZy5yZXN0b3JlKCk7XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBtYXJrdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgcmVuZGVyZXIgPSBtYXJrcy5kcmF3W21hcmt0eXBlXTtcbiAgcmVuZGVyZXIuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xufTtcblxucHJvdG90eXBlLnJlbmRlckFzeW5jID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgLy8gVE9ETyBtYWtlIHNhZmUgZm9yIG11bHRpcGxlIHNjZW5lIHJlbmRlcmluZz9cbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgaWYgKHJlbmRlcmVyLl9hc3luY19pZCkge1xuICAgIGNsZWFyVGltZW91dChyZW5kZXJlci5fYXN5bmNfaWQpO1xuICB9XG4gIHJlbmRlcmVyLl9hc3luY19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lKTtcbiAgICBkZWxldGUgcmVuZGVyZXIuX2FzeW5jX2lkO1xuICB9LCA1MCk7XG59O1xuXG5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJpKSB7XG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBzY2VuZSA9IHJlbmRlcmVyLl9zY2VuZSxcbiAgICAgIGltYWdlID0gbnVsbCwgdXJsO1xuXG4gIHJlbmRlcmVyLl9pbWdsb2FkICs9IDE7XG4gIGlmIChkbC5pc05vZGUpIHtcbiAgICBpbWFnZSA9IG5ldyAoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuY2FudmFzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5jYW52YXMgOiBudWxsKS5JbWFnZSkoKTtcbiAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiB1cml9LCBjb25maWcubG9hZCksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgeyBkbC5lcnJvcihlcnIpOyByZXR1cm47IH1cbiAgICAgIGltYWdlLnNyYyA9IGRhdGE7XG4gICAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuX2ltZ2xvYWQgLT0gMTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgdXJpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaW1hZ2UubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJlbmRlcmVyLl9pbWdsb2FkIC09IDE7XG4gICAgICByZW5kZXJlci5yZW5kZXJBc3luYyhzY2VuZSk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gIH1cblxuICByZXR1cm4gaW1hZ2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9IYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1JlbmRlcmVyJylcbn07IiwidmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQm91bmRzJyksXG4gICAgYm91bmRzQ2FsYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyksXG4gICAgcGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpO1xuXG52YXIgcGFyc2VQYXRoID0gcGF0aC5wYXJzZSxcbiAgICByZW5kZXJQYXRoID0gcGF0aC5yZW5kZXIsXG4gICAgaGFsZnBpID0gTWF0aC5QSSAvIDIsXG4gICAgc3FydDMgPSBNYXRoLnNxcnQoMyksXG4gICAgdGFuMzAgPSBNYXRoLnRhbigzMCAqIE1hdGguUEkgLyAxODApLFxuICAgIHRtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG4vLyBwYXRoIGdlbmVyYXRvcnNcblxuZnVuY3Rpb24gYXJjUGF0aChnLCBvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBpciA9IG8uaW5uZXJSYWRpdXMgfHwgMCxcbiAgICAgIG9yID0gby5vdXRlclJhZGl1cyB8fCAwLFxuICAgICAgc2EgPSAoby5zdGFydEFuZ2xlIHx8IDApIC0gTWF0aC5QSS8yLFxuICAgICAgZWEgPSAoby5lbmRBbmdsZSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgZy5iZWdpblBhdGgoKTtcbiAgaWYgKGlyID09PSAwKSBnLm1vdmVUbyh4LCB5KTtcbiAgZWxzZSBnLmFyYyh4LCB5LCBpciwgc2EsIGVhLCAwKTtcbiAgZy5hcmMoeCwgeSwgb3IsIGVhLCBzYSwgMSk7XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQYXRoKGcsIGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBtID0gby5tYXJrLFxuICAgICAgcCA9IG0ucGF0aENhY2hlIHx8IChtLnBhdGhDYWNoZSA9IHBhcnNlUGF0aChwYXRoLmFyZWEoaXRlbXMpKSk7XG4gIHJlbmRlclBhdGgoZywgcCk7XG59XG5cbmZ1bmN0aW9uIGxpbmVQYXRoKGcsIGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBtID0gby5tYXJrLFxuICAgICAgcCA9IG0ucGF0aENhY2hlIHx8IChtLnBhdGhDYWNoZSA9IHBhcnNlUGF0aChwYXRoLmxpbmUoaXRlbXMpKSk7XG4gIHJlbmRlclBhdGgoZywgcCk7XG59XG5cbmZ1bmN0aW9uIHBhdGhQYXRoKGcsIG8pIHtcbiAgaWYgKG8ucGF0aCA9PSBudWxsKSByZXR1cm47XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2VQYXRoKG8ucGF0aCkpO1xuICByZXR1cm4gcmVuZGVyUGF0aChnLCBwLCBvLngsIG8ueSk7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbFBhdGgoZywgbykge1xuICBnLmJlZ2luUGF0aCgpO1xuICB2YXIgc2l6ZSA9IG8uc2l6ZSAhPSBudWxsID8gby5zaXplIDogMTAwLFxuICAgICAgeCA9IG8ueCwgeSA9IG8ueSwgciwgdCwgcngsIHJ5O1xuXG4gIGlmIChvLnNoYXBlID09IG51bGwgfHwgby5zaGFwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgIHIgPSBNYXRoLnNxcnQoc2l6ZS9NYXRoLlBJKTtcbiAgICBnLmFyYyh4LCB5LCByLCAwLCAyKk1hdGguUEksIDApO1xuICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChvLnNoYXBlKSB7XG4gICAgY2FzZSBcImNyb3NzXCI6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICB0ID0gMypyO1xuICAgICAgZy5tb3ZlVG8oeC10LCB5LXIpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5LXIpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5LXQpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5LXQpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5LXIpO1xuICAgICAgZy5saW5lVG8oeCt0LCB5LXIpO1xuICAgICAgZy5saW5lVG8oeCt0LCB5K3IpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5K3IpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5K3QpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5K3QpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5K3IpO1xuICAgICAgZy5saW5lVG8oeC10LCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeSk7XG4gICAgICBnLmxpbmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICB0ID0gTWF0aC5zcXJ0KHNpemUpO1xuICAgICAgciA9IHQgLyAyO1xuICAgICAgZy5yZWN0KHgtciwgeS1yLCB0LCB0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLWRvd25cIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHktcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGUtdXBcIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkrcnkpO1xuICB9XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGxpbmVTdHJva2UoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIGx3ID0gby5zdHJva2VXaWR0aCxcbiAgICAgIGxjID0gby5zdHJva2VDYXA7XG4gIGcubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gIGcubGluZUNhcCAgID0gbGMgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICBsaW5lUGF0aChnLCBpdGVtcyk7XG59XG5cbmZ1bmN0aW9uIHJ1bGVTdHJva2UoZywgbykge1xuICB2YXIgeDEgPSBvLnggfHwgMCxcbiAgICAgIHkxID0gby55IHx8IDAsXG4gICAgICB4MiA9IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSxcbiAgICAgIHkyID0gby55MiAhPSBudWxsID8gby55MiA6IHkxLFxuICAgICAgbHcgPSBvLnN0cm9rZVdpZHRoLFxuICAgICAgbGMgPSBvLnN0cm9rZUNhcDtcblxuICBnLmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgZy5iZWdpblBhdGgoKTtcbiAgZy5tb3ZlVG8oeDEsIHkxKTtcbiAgZy5saW5lVG8oeDIsIHkyKTtcbn1cblxuLy8gZHJhd2luZyBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZHJhd1BhdGhPbmUocGF0aCwgZywgbywgaXRlbXMpIHtcbiAgdmFyIGZpbGwgPSBvLmZpbGwsIHN0cm9rZSA9IG8uc3Ryb2tlLCBvcGFjLCBsYywgbHc7XG5cbiAgcGF0aChnLCBpdGVtcyk7XG5cbiAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgaWYgKG9wYWMgPT0gMCB8fCAhZmlsbCAmJiAhc3Ryb2tlKSByZXR1cm47XG5cbiAgaWYgKGZpbGwpIHtcbiAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgZmlsbCk7XG4gICAgZy5maWxsKCk7XG4gIH1cblxuICBpZiAoc3Ryb2tlKSB7XG4gICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgICBpZiAobHcgPiAwKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBzdHJva2UpO1xuICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgIGcubGluZUNhcCA9IChsYyA9IG8uc3Ryb2tlQ2FwKSAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gICAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgIGcuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQYXRoQWxsKHBhdGgsIGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmFyIGksIGxlbiwgaXRlbTtcbiAgZm9yIChpPTAsIGxlbj1zY2VuZS5pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gc2NlbmUuaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuICAgIGRyYXdQYXRoT25lKHBhdGgsIGcsIGl0ZW0sIGl0ZW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSZWN0KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBmaWxsLCBzdHJva2UsIG9wYWMsIGxjLCBsdywgeCwgeSwgdywgaDtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgeCA9IG8ueCB8fCAwO1xuICAgIHkgPSBvLnkgfHwgMDtcbiAgICB3ID0gby53aWR0aCB8fCAwO1xuICAgIGggPSBvLmhlaWdodCB8fCAwO1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PSAwKSBjb250aW51ZTtcblxuICAgIGlmIChmaWxsID0gby5maWxsKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICAgICAgZy5maWxsU3R5bGUgPSBjb2xvcihnLCBvLCBmaWxsKTtcbiAgICAgIGcuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSA9IG8uc3Ryb2tlKSB7XG4gICAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICAgICAgaWYgKGx3ID4gMCkge1xuICAgICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKGcsIG8sIHN0cm9rZSk7XG4gICAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGcubGluZUNhcCA9IChsYyA9IG8uc3Ryb2tlQ2FwKSAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gICAgICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgICAgIGcuc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1J1bGUoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIHN0cm9rZSwgb3BhYywgbGMsIGx3LCB4MSwgeTEsIHgyLCB5MjtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgeDEgPSBvLnggfHwgMDtcbiAgICB5MSA9IG8ueSB8fCAwO1xuICAgIHgyID0gby54MiAhPSBudWxsID8gby54MiA6IHgxO1xuICAgIHkyID0gby55MiAhPSBudWxsID8gby55MiA6IHkxO1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PSAwKSBjb250aW51ZTtcbiAgICBcbiAgICBpZiAoc3Ryb2tlID0gby5zdHJva2UpIHtcbiAgICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gICAgICBpZiAobHcgPiAwKSB7XG4gICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgc3Ryb2tlKTtcbiAgICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgICAgICAgZy52Z0xpbmVEYXNoKG8uc3Ryb2tlRGFzaCB8fCBudWxsKTtcbiAgICAgICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgICAgZy5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgZy5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgZy5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ltYWdlKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcyxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMsIG87XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIGlmICghKG8uaW1hZ2UgJiYgby5pbWFnZS51cmwgPT09IG8udXJsKSkge1xuICAgICAgby5pbWFnZSA9IHJlbmRlcmVyLmxvYWRJbWFnZShvLnVybCk7XG4gICAgICBvLmltYWdlLnVybCA9IG8udXJsO1xuICAgIH1cblxuICAgIHZhciB4LCB5LCB3LCBoLCBvcGFjO1xuICAgIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDA7XG4gICAgaCA9IG8uaGVpZ2h0IHx8IChvLmltYWdlICYmIG8uaW1hZ2UuaGVpZ2h0KSB8fCAwO1xuICAgIHggPSAoby54fHwwKSAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpO1xuICAgIHkgPSAoby55fHwwKSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKTtcblxuICAgIGlmIChvLmltYWdlLmxvYWRlZCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IChvcGFjID0gby5vcGFjaXR5KSAhPSBudWxsID8gb3BhYyA6IDE7XG4gICAgICBnLmRyYXdJbWFnZShvLmltYWdlLCB4LCB5LCB3LCBoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1RleHQoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGZpbGwsIHN0cm9rZSwgb3BhYywgbHcsIHgsIHksIHIsIHQ7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIGcuZm9udCA9IGZvbnRTdHJpbmcobyk7XG4gICAgZy50ZXh0QWxpZ24gPSBvLmFsaWduIHx8IFwibGVmdFwiO1xuICAgIGcudGV4dEJhc2VsaW5lID0gby5iYXNlbGluZSB8fCBcImFscGhhYmV0aWNcIjtcblxuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT0gMCkgY29udGludWU7XG5cbiAgICB4ID0gby54IHx8IDA7XG4gICAgeSA9IG8ueSB8fCAwO1xuICAgIGlmIChyID0gby5yYWRpdXMpIHtcbiAgICAgIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gICAgfVxuXG4gICAgaWYgKG8uYW5nbGUpIHtcbiAgICAgIGcuc2F2ZSgpO1xuICAgICAgZy50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBnLnJvdGF0ZShvLmFuZ2xlICogTWF0aC5QSS8xODApO1xuICAgICAgeCA9IG8uZHggfHwgMDtcbiAgICAgIHkgPSBvLmR5IHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gKG8uZHggfHwgMCk7XG4gICAgICB5ICs9IChvLmR5IHx8IDApO1xuICAgIH1cblxuICAgIGlmIChmaWxsID0gby5maWxsKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICAgICAgZy5maWxsU3R5bGUgPSBjb2xvcihnLCBvLCBmaWxsKTtcbiAgICAgIGcuZmlsbFRleHQoby50ZXh0LCB4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlID0gby5zdHJva2UpIHtcbiAgICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogMTtcbiAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihvLCBzdHJva2UpO1xuICAgICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBnLnN0cm9rZVRleHQoby50ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoby5hbmdsZSkgZy5yZXN0b3JlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0FsbChwYXRoRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oZywgc2NlbmUsIGJvdW5kcykge1xuICAgIGRyYXdQYXRoQWxsKHBhdGhGdW5jLCBnLCBzY2VuZSwgYm91bmRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3T25lKHBhdGhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgYm91bmRzKSB7XG4gICAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhzY2VuZS5pdGVtc1swXS5ib3VuZHMpKVxuICAgICAgcmV0dXJuOyAvLyBib3VuZHMgY2hlY2tcbiAgICBkcmF3UGF0aE9uZShwYXRoRnVuYywgZywgc2NlbmUuaXRlbXNbMF0sIHNjZW5lLml0ZW1zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3R3JvdXAoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcywgZ3JvdXAsIGF4ZXMsIGxlZ2VuZHMsXG4gICAgICByZW5kZXJlciA9IHRoaXMsIGd4LCBneSwgZ2IsIGksIG4sIGosIG07XG5cbiAgZHJhd1JlY3QoZywgc2NlbmUsIGJvdW5kcyk7XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGdyb3VwID0gaXRlbXNbaV07XG4gICAgYXhlcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXTtcbiAgICBsZWdlbmRzID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW107XG4gICAgZ3ggPSBncm91cC54IHx8IDA7XG4gICAgZ3kgPSBncm91cC55IHx8IDA7XG5cbiAgICAvLyByZW5kZXIgZ3JvdXAgY29udGVudHNcbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGlmIChncm91cC5jbGlwKSB7XG4gICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgZy5yZWN0KDAsIDAsIGdyb3VwLndpZHRoIHx8IDAsIGdyb3VwLmhlaWdodCB8fCAwKTtcbiAgICAgIGcuY2xpcCgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgICBcbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhdyhnLCBheGVzW2pdLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1ncm91cC5pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICByZW5kZXJlci5kcmF3KGcsIGdyb3VwLml0ZW1zW2pdLCBib3VuZHMpO1xuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciAhPT0gXCJiYWNrXCIpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhdyhnLCBheGVzW2pdLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgbGVnZW5kc1tqXSwgYm91bmRzKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGcucmVzdG9yZSgpO1xuICB9ICAgIFxufVxuXG5mdW5jdGlvbiBjb2xvcihnLCBvLCB2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlLmlkKVxuICAgID8gZ3JhZGllbnQoZywgdmFsdWUsIG8uYm91bmRzKVxuICAgIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdyYWRpZW50KGcsIHAsIGIpIHtcbiAgdmFyIHcgPSBiLndpZHRoKCksXG4gICAgICBoID0gYi5oZWlnaHQoKSxcbiAgICAgIHgxID0gYi54MSArIHAueDEgKiB3LFxuICAgICAgeTEgPSBiLnkxICsgcC55MSAqIGgsXG4gICAgICB4MiA9IGIueDEgKyBwLngyICogdyxcbiAgICAgIHkyID0gYi55MSArIHAueTIgKiBoLFxuICAgICAgZ3JhZCA9IGcuY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpLFxuICAgICAgc3RvcCA9IHAuc3RvcHMsXG4gICAgICBpLCBuO1xuXG4gIGZvciAoaT0wLCBuPXN0b3AubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGdyYWQuYWRkQ29sb3JTdG9wKHN0b3BbaV0ub2Zmc2V0LCBzdG9wW2ldLmNvbG9yKTtcbiAgfVxuICByZXR1cm4gZ3JhZDtcbn1cblxuLy8gaGl0IHRlc3RpbmdcblxuZnVuY3Rpb24gcGlja0dyb3VwKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKHNjZW5lLml0ZW1zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgc2NlbmUuYm91bmRzICYmICFzY2VuZS5ib3VuZHMuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcywgc3Vic2NlbmUsIGdyb3VwLCBoaXQsIGR4LCBkeSxcbiAgICAgIGhhbmRsZXIgPSB0aGlzLCBpLCBqO1xuXG4gIGZvciAoaT1pdGVtcy5sZW5ndGg7IC0taT49MDspIHtcbiAgICBncm91cCA9IGl0ZW1zW2ldO1xuICAgIGR4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGR5ID0gZ3JvdXAueSB8fCAwO1xuXG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZHgsIGR5KTtcbiAgICBmb3IgKGo9Z3JvdXAuaXRlbXMubGVuZ3RoOyAtLWogPj0gMDspIHtcbiAgICAgIHN1YnNjZW5lID0gZ3JvdXAuaXRlbXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgIGhpdCA9IGhhbmRsZXIucGljayhzdWJzY2VuZSwgeCwgeSwgZ3gtZHgsIGd5LWR5KTtcbiAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgZy5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGcucmVzdG9yZSgpO1xuICB9XG5cbiAgcmV0dXJuIHNjZW5lLmludGVyYWN0aXZlXG4gICAgPyBwaWNrQWxsKGhpdFRlc3RzLmdyb3VwLCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KVxuICAgIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBpY2tBbGwodGVzdCwgZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbywgYiwgaTtcblxuICBpZiAoZy5fcmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcuX3JhdGlvO1xuICAgIHkgKj0gZy5fcmF0aW87XG4gIH1cblxuICBmb3IgKGk9c2NlbmUuaXRlbXMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICBvID0gc2NlbmUuaXRlbXNbaV07IGIgPSBvLmJvdW5kcztcbiAgICAvLyBmaXJzdCBoaXQgdGVzdCBhZ2FpbnN0IGJvdW5kaW5nIGJveFxuICAgIGlmICgoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSB8fCAhYikgY29udGludWU7XG4gICAgLy8gaWYgaW4gYm91bmRpbmcgYm94LCBwZXJmb3JtIG1vcmUgY2FyZWZ1bCB0ZXN0XG4gICAgaWYgKHRlc3QoZywgbywgeCwgeSwgZ3gsIGd5KSkgcmV0dXJuIG87XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJlYShnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgYiwgaSwgZGksIGRkLCBvZCwgZHgsIGR5O1xuXG4gIGIgPSBpdGVtc1swXS5ib3VuZHM7XG4gIGlmIChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGcuX3JhdGlvICE9PSAxKSB7XG4gICAgeCAqPSBnLl9yYXRpbztcbiAgICB5ICo9IGcuX3JhdGlvO1xuICB9XG4gIGlmICghaGl0VGVzdHMuYXJlYShnLCBpdGVtcywgeCwgeSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZW1zWzBdO1xufVxuXG5mdW5jdGlvbiBwaWNrTGluZShnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgYiwgaSwgZGksIGRkLCBvZCwgZHgsIGR5O1xuXG4gIGIgPSBpdGVtc1swXS5ib3VuZHM7XG4gIGlmIChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGcuX3JhdGlvICE9PSAxKSB7XG4gICAgeCAqPSBnLl9yYXRpbztcbiAgICB5ICo9IGcuX3JhdGlvO1xuICB9XG4gIGlmICghaGl0VGVzdHMubGluZShnLCBpdGVtcywgeCwgeSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZW1zWzBdO1xufVxuXG5mdW5jdGlvbiBwaWNrKHRlc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gICAgcmV0dXJuIHBpY2tBbGwodGVzdCwgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRIaXQoZywgbywgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghby5mb250U2l6ZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIW8uYW5nbGUpIHJldHVybiB0cnVlOyAvLyBib3VuZHMgc3VmZmljaWVudCBpZiBubyByb3RhdGlvblxuXG4gIHZhciBiID0gYm91bmRzQ2FsYy50ZXh0KG8sIHRtcEJvdW5kcywgdHJ1ZSksXG4gICAgICBhID0gLW8uYW5nbGUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgY29zID0gTWF0aC5jb3MoYSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhKSxcbiAgICAgIHggPSBvLngsXG4gICAgICB5ID0gby55LFxuICAgICAgcHggPSBjb3MqZ3ggLSBzaW4qZ3kgKyAoeCAtIHgqY29zICsgeSpzaW4pLFxuICAgICAgcHkgPSBzaW4qZ3ggKyBjb3MqZ3kgKyAoeSAtIHgqc2luIC0geSpjb3MpO1xuXG4gIHJldHVybiBiLmNvbnRhaW5zKHB4LCBweSk7XG59XG5cbnZhciBoaXRUZXN0cyA9IHtcbiAgdGV4dDogICB0ZXh0SGl0LFxuICByZWN0OiAgIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcmV0dXJuIHRydWU7IH0sIC8vIGJvdW5kcyB0ZXN0IGlzIHN1ZmZpY2llbnRcbiAgaW1hZ2U6ICBmdW5jdGlvbihnLG8seCx5KSB7IHJldHVybiB0cnVlOyB9LCAvLyBib3VuZHMgdGVzdCBpcyBzdWZmaWNpZW50XG4gIGdyb3VwOiAgZnVuY3Rpb24oZyxvLHgseSkgeyByZXR1cm4gby5maWxsIHx8IG8uc3Ryb2tlOyB9LFxuICBydWxlOiAgIGZ1bmN0aW9uKGcsbyx4LHkpIHtcbiAgICAgICAgICAgIGlmICghZy5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJ1bGVTdHJva2UoZyxvKTsgcmV0dXJuIGcuaXNQb2ludEluU3Ryb2tlKHgseSk7XG4gICAgICAgICAgfSxcbiAgbGluZTogICBmdW5jdGlvbihnLHMseCx5KSB7XG4gICAgICAgICAgICBpZiAoIWcuaXNQb2ludEluU3Ryb2tlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsaW5lU3Ryb2tlKGcscyk7IHJldHVybiBnLmlzUG9pbnRJblN0cm9rZSh4LHkpO1xuICAgICAgICAgIH0sXG4gIGFyYzogICAgZnVuY3Rpb24oZyxvLHgseSkgeyBhcmNQYXRoKGcsbyk7ICByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH0sXG4gIGFyZWE6ICAgZnVuY3Rpb24oZyxzLHgseSkgeyBhcmVhUGF0aChnLHMpOyByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH0sXG4gIHBhdGg6ICAgZnVuY3Rpb24oZyxvLHgseSkgeyBwYXRoUGF0aChnLG8pOyByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH0sXG4gIHN5bWJvbDogZnVuY3Rpb24oZyxvLHgseSkgeyBzeW1ib2xQYXRoKGcsbyk7IHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IHtcbiAgICBncm91cDogICBkcmF3R3JvdXAsXG4gICAgYXJlYTogICAgZHJhd09uZShhcmVhUGF0aCksXG4gICAgbGluZTogICAgZHJhd09uZShsaW5lUGF0aCksXG4gICAgYXJjOiAgICAgZHJhd0FsbChhcmNQYXRoKSxcbiAgICBwYXRoOiAgICBkcmF3QWxsKHBhdGhQYXRoKSxcbiAgICBzeW1ib2w6ICBkcmF3QWxsKHN5bWJvbFBhdGgpLFxuICAgIHJlY3Q6ICAgIGRyYXdSZWN0LFxuICAgIHJ1bGU6ICAgIGRyYXdSdWxlLFxuICAgIHRleHQ6ICAgIGRyYXdUZXh0LFxuICAgIGltYWdlOiAgIGRyYXdJbWFnZSxcbiAgICBkcmF3T25lOiBkcmF3T25lLCAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgICBkcmF3QWxsOiBkcmF3QWxsICAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgfSxcbiAgcGljazoge1xuICAgIGdyb3VwOiAgIHBpY2tHcm91cCxcbiAgICBhcmVhOiAgICBwaWNrQXJlYSxcbiAgICBsaW5lOiAgICBwaWNrTGluZSxcbiAgICBhcmM6ICAgICBwaWNrKGhpdFRlc3RzLmFyYyksXG4gICAgcGF0aDogICAgcGljayhoaXRUZXN0cy5wYXRoKSxcbiAgICBzeW1ib2w6ICBwaWNrKGhpdFRlc3RzLnN5bWJvbCksXG4gICAgcmVjdDogICAgcGljayhoaXRUZXN0cy5yZWN0KSxcbiAgICBydWxlOiAgICBwaWNrKGhpdFRlc3RzLnJ1bGUpLFxuICAgIHRleHQ6ICAgIHBpY2soaGl0VGVzdHMudGV4dCksXG4gICAgaW1hZ2U6ICAgcGljayhoaXRUZXN0cy5pbWFnZSksXG4gICAgcGlja0FsbDogcGlja0FsbCAgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gIH1cbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Cb3VuZHMnKTtcblxuLy8gUGF0aCBwYXJzaW5nIGFuZCByZW5kZXJpbmcgY29kZSB0YWtlbiBmcm9tIGZhYnJpYy5qcyAtLSBUaGFua3MhXG52YXIgY21kTGVuZ3RoID0geyBtOjIsIGw6MiwgaDoxLCB2OjEsIGM6Niwgczo0LCBxOjQsIHQ6MiwgYTo3IH0sXG4gICAgcmUgPSBbLyhbTUxIVkNTUVRBWm1saHZjc3F0YXpdKS9nLCAvIyMjLywgLyhcXGQpLS9nLCAvXFxzfCx8IyMjL107XG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgY3VycmVudFBhdGgsXG4gICAgICBjaHVua3MsXG4gICAgICBwYXJzZWQ7XG5cbiAgLy8gRmlyc3QsIGJyZWFrIHBhdGggaW50byBjb21tYW5kIHNlcXVlbmNlXG4gIHBhdGggPSBwYXRoLnNsaWNlKCkucmVwbGFjZShyZVswXSwgJyMjIyQxJykuc3BsaXQocmVbMV0pLnNsaWNlKDEpO1xuXG4gIC8vIE5leHQsIHBhcnNlIGVhY2ggY29tbWFuZCBpbiB0dXJuXG4gIGZvciAodmFyIGk9MCwgaiwgY2h1bmtzUGFyc2VkLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICBjdXJyZW50UGF0aCA9IHBhdGhbaV07XG4gICAgY2h1bmtzID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpLnJlcGxhY2UocmVbMl0sJyQxIyMjLScpLnNwbGl0KHJlWzNdKTtcbiAgICBjaHVua3NQYXJzZWQgPSBbY3VycmVudFBhdGguY2hhckF0KDApXTtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gY2h1bmtzLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgcGFyc2VkID0gcGFyc2VGbG9hdChjaHVua3Nbal0pO1xuICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgIGNodW5rc1BhcnNlZC5wdXNoKHBhcnNlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbW1hbmQgPSBjaHVua3NQYXJzZWRbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgY29tbWFuZExlbmd0aCA9IGNtZExlbmd0aFtjb21tYW5kXTtcblxuICAgIGlmIChjaHVua3NQYXJzZWQubGVuZ3RoIC0gMSA+IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY2h1bmtzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChbIGNodW5rc1BhcnNlZFswXSBdLmNvbmNhdChjaHVua3NQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goY2h1bmtzUGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKGcsIHgsIHksIGNvb3JkcywgYm91bmRzLCBsLCB0KSB7XG4gIHZhciByeCA9IGNvb3Jkc1swXTtcbiAgdmFyIHJ5ID0gY29vcmRzWzFdO1xuICB2YXIgcm90ID0gY29vcmRzWzJdO1xuICB2YXIgbGFyZ2UgPSBjb29yZHNbM107XG4gIHZhciBzd2VlcCA9IGNvb3Jkc1s0XTtcbiAgdmFyIGV4ID0gY29vcmRzWzVdO1xuICB2YXIgZXkgPSBjb29yZHNbNl07XG4gIHZhciBzZWdzID0gYXJjVG9TZWdtZW50cyhleCwgZXksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QsIHgsIHkpO1xuICBmb3IgKHZhciBpPTA7IGk8c2Vncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiZXogPSBzZWdtZW50VG9CZXppZXIuYXBwbHkobnVsbCwgc2Vnc1tpXSk7XG4gICAgZy5iZXppZXJDdXJ2ZVRvLmFwcGx5KGcsIGJleik7XG4gICAgYm91bmRzLmFkZChiZXpbMF0tbCwgYmV6WzFdLXQpO1xuICAgIGJvdW5kcy5hZGQoYmV6WzJdLWwsIGJlelszXS10KTtcbiAgICBib3VuZHMuYWRkKGJlels0XS1sLCBiZXpbNV0tdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRBcmMoeCwgeSwgY29vcmRzLCBib3VuZHMpIHtcbiAgdmFyIHJ4ID0gY29vcmRzWzBdO1xuICB2YXIgcnkgPSBjb29yZHNbMV07XG4gIHZhciByb3QgPSBjb29yZHNbMl07XG4gIHZhciBsYXJnZSA9IGNvb3Jkc1szXTtcbiAgdmFyIHN3ZWVwID0gY29vcmRzWzRdO1xuICB2YXIgZXggPSBjb29yZHNbNV07XG4gIHZhciBleSA9IGNvb3Jkc1s2XTtcbiAgdmFyIHNlZ3MgPSBhcmNUb1NlZ21lbnRzKGV4LCBleSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCwgeCwgeSk7XG4gIGZvciAodmFyIGk9MDsgaTxzZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJleiA9IHNlZ21lbnRUb0Jlemllci5hcHBseShudWxsLCBzZWdzW2ldKTtcbiAgICBib3VuZHMuYWRkKGJlelswXSwgYmV6WzFdKTtcbiAgICBib3VuZHMuYWRkKGJlelsyXSwgYmV6WzNdKTtcbiAgICBib3VuZHMuYWRkKGJlels0XSwgYmV6WzVdKTtcbiAgfVxufVxuXG52YXIgYXJjVG9TZWdtZW50c0NhY2hlID0geyB9LFxuICAgIHNlZ21lbnRUb0JlemllckNhY2hlID0geyB9LFxuICAgIGpvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbixcbiAgICBhcmdzU3RyO1xuXG4vLyBDb3BpZWQgZnJvbSBJbmtzY2FwZSBzdmd0b3BkZiwgdGhhbmtzIVxuZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh4LCB5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCwgb3gsIG95KSB7XG4gIGFyZ3NTdHIgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgaWYgKGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyXSkge1xuICAgIHJldHVybiBhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cl07XG4gIH1cblxuICB2YXIgdGggPSByb3RhdGVYICogKE1hdGguUEkvMTgwKTtcbiAgdmFyIHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgdmFyIGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICB2YXIgcHggPSBjb3NfdGggKiAob3ggLSB4KSAqIDAuNSArIHNpbl90aCAqIChveSAtIHkpICogMC41O1xuICB2YXIgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICB2YXIgcGwgPSAocHgqcHgpIC8gKHJ4KnJ4KSArIChweSpweSkgLyAocnkqcnkpO1xuICBpZiAocGwgPiAxKSB7XG4gICAgcGwgPSBNYXRoLnNxcnQocGwpO1xuICAgIHJ4ICo9IHBsO1xuICAgIHJ5ICo9IHBsO1xuICB9XG5cbiAgdmFyIGEwMCA9IGNvc190aCAvIHJ4O1xuICB2YXIgYTAxID0gc2luX3RoIC8gcng7XG4gIHZhciBhMTAgPSAoLXNpbl90aCkgLyByeTtcbiAgdmFyIGExMSA9IChjb3NfdGgpIC8gcnk7XG4gIHZhciB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIHZhciB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIHZhciB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICB2YXIgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcblxuICB2YXIgZCA9ICh4MS14MCkgKiAoeDEteDApICsgKHkxLXkwKSAqICh5MS15MCk7XG4gIHZhciBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuICBpZiAoc2ZhY3Rvcl9zcSA8IDApIHNmYWN0b3Jfc3EgPSAwO1xuICB2YXIgc2ZhY3RvciA9IE1hdGguc3FydChzZmFjdG9yX3NxKTtcbiAgaWYgKHN3ZWVwID09IGxhcmdlKSBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIHZhciB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEteTApO1xuICB2YXIgeWMgPSAwLjUgKiAoeTAgKyB5MSkgKyBzZmFjdG9yICogKHgxLXgwKTtcblxuICB2YXIgdGgwID0gTWF0aC5hdGFuMih5MC15YywgeDAteGMpO1xuICB2YXIgdGgxID0gTWF0aC5hdGFuMih5MS15YywgeDEteGMpO1xuXG4gIHZhciB0aF9hcmMgPSB0aDEtdGgwO1xuICBpZiAodGhfYXJjIDwgMCAmJiBzd2VlcCA9PSAxKXtcbiAgICB0aF9hcmMgKz0gMipNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT0gMCkge1xuICAgIHRoX2FyYyAtPSAyICogTWF0aC5QSTtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyh0aF9hcmMgLyAoTWF0aC5QSSAqIDAuNSArIDAuMDAxKSkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGk9MDsgaTxzZWdtZW50czsgaSsrKSB7XG4gICAgdmFyIHRoMiA9IHRoMCArIGkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICB2YXIgdGgzID0gdGgwICsgKGkrMSkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICByZXN1bHRbaV0gPSBbeGMsIHljLCB0aDIsIHRoMywgcngsIHJ5LCBzaW5fdGgsIGNvc190aF07XG4gIH1cblxuICByZXR1cm4gKGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyXSA9IHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHNlZ21lbnRUb0JlemllcihjeCwgY3ksIHRoMCwgdGgxLCByeCwgcnksIHNpbl90aCwgY29zX3RoKSB7XG4gIGFyZ3NTdHIgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgaWYgKHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJdKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJdO1xuICB9XG5cbiAgdmFyIGEwMCA9IGNvc190aCAqIHJ4O1xuICB2YXIgYTAxID0gLXNpbl90aCAqIHJ5O1xuICB2YXIgYTEwID0gc2luX3RoICogcng7XG4gIHZhciBhMTEgPSBjb3NfdGggKiByeTtcblxuICB2YXIgY29zX3RoMCA9IE1hdGguY29zKHRoMCk7XG4gIHZhciBzaW5fdGgwID0gTWF0aC5zaW4odGgwKTtcbiAgdmFyIGNvc190aDEgPSBNYXRoLmNvcyh0aDEpO1xuICB2YXIgc2luX3RoMSA9IE1hdGguc2luKHRoMSk7XG5cbiAgdmFyIHRoX2hhbGYgPSAwLjUgKiAodGgxIC0gdGgwKTtcbiAgdmFyIHNpbl90aF9oMiA9IE1hdGguc2luKHRoX2hhbGYgKiAwLjUpO1xuICB2YXIgdCA9ICg4LzMpICogc2luX3RoX2gyICogc2luX3RoX2gyIC8gTWF0aC5zaW4odGhfaGFsZik7XG4gIHZhciB4MSA9IGN4ICsgY29zX3RoMCAtIHQgKiBzaW5fdGgwO1xuICB2YXIgeTEgPSBjeSArIHNpbl90aDAgKyB0ICogY29zX3RoMDtcbiAgdmFyIHgzID0gY3ggKyBjb3NfdGgxO1xuICB2YXIgeTMgPSBjeSArIHNpbl90aDE7XG4gIHZhciB4MiA9IHgzICsgdCAqIHNpbl90aDE7XG4gIHZhciB5MiA9IHkzIC0gdCAqIGNvc190aDE7XG5cbiAgcmV0dXJuIChzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyXSA9IFtcbiAgICBhMDAgKiB4MSArIGEwMSAqIHkxLCAgYTEwICogeDEgKyBhMTEgKiB5MSxcbiAgICBhMDAgKiB4MiArIGEwMSAqIHkyLCAgYTEwICogeDIgKyBhMTEgKiB5MixcbiAgICBhMDAgKiB4MyArIGEwMSAqIHkzLCAgYTEwICogeDMgKyBhMTEgKiB5M1xuICBdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKGcsIHBhdGgsIGwsIHQpIHtcbiAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFksXG4gICAgICBib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gIGlmIChsID09IHVuZGVmaW5lZCkgbCA9IDA7XG4gIGlmICh0ID09IHVuZGVmaW5lZCkgdCA9IDA7XG5cbiAgZy5iZWdpblBhdGgoKTtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuXG4gICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnSCc6IC8vIGhvcml6b250YWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHkgKz0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgZy5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgZy5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgeCArIGN1cnJlbnRbMV0gKyBsLCAvLyB4MVxuICAgICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCwgLy8geTFcbiAgICAgICAgICBjb250cm9sWCArIGwsIC8vIHgyXG4gICAgICAgICAgY29udHJvbFkgKyB0LCAvLyB5MlxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgeCArIGwsXG4gICAgICAgICAgeSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcblxuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyKnggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyKnkgLSBjb250cm9sWTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3QnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHRcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gdGVtcENvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSB0ZW1wQ29udHJvbFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICdxJykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciBxXG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBDb250cm9sWCA9IGNvbnRyb2xYO1xuICAgICAgICB0ZW1wQ29udHJvbFkgPSBjb250cm9sWTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgZHJhd0FyYyhnLCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIHggKyBsLFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB5ICsgdFxuICAgICAgICBdLCBib3VuZHMsIGwsIHQpO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICBdLCBib3VuZHMsIGwsIHQpO1xuICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICBnLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG4gIHJldHVybiBib3VuZHMudHJhbnNsYXRlKGwsIHQpO1xufVxuXG5mdW5jdGlvbiBib3VuZHMocGF0aCwgYm91bmRzKSB7XG4gIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICBwcmV2aW91cyA9IG51bGwsXG4gICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICB0ZW1wWCxcbiAgICAgIHRlbXBZLFxuICAgICAgdGVtcENvbnRyb2xYLFxuICAgICAgdGVtcENvbnRyb2xZO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHBhdGhbaV07XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcblxuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyKnggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyKnkgLSBjb250cm9sWTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAndCcpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgdFxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSB0ZW1wQ29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIHRlbXBDb250cm9sWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHFcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgYm91bmRBcmMoeCwgeSwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgeCxcbiAgICAgICAgICBjdXJyZW50WzddICsgeVxuICAgICAgICBdLCBib3VuZHMpO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBib3VuZEFyYyh4LCB5LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0sXG4gICAgICAgICAgY3VycmVudFs3XVxuICAgICAgICBdLCBib3VuZHMpO1xuICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGFyZWEoaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KVxuICAgIC55MShmdW5jdGlvbihkKSB7IHJldHVybiBkLnk7IH0pXG4gICAgLnkwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSArIGQuaGVpZ2h0OyB9KTtcbiAgaWYgKG8uaW50ZXJwb2xhdGUpIGFyZWEuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSk7XG4gIGlmIChvLnRlbnNpb24gIT0gbnVsbCkgYXJlYS50ZW5zaW9uKG8udGVuc2lvbik7XG4gIHJldHVybiBhcmVhKGl0ZW1zKTtcbn1cblxuZnVuY3Rpb24gbGluZShpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgIC54KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueDsgfSlcbiAgIC55KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueTsgfSk7XG4gIGlmIChvLmludGVycG9sYXRlKSBsaW5lLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUpO1xuICBpZiAoby50ZW5zaW9uICE9IG51bGwpIGxpbmUudGVuc2lvbihvLnRlbnNpb24pO1xuICByZXR1cm4gbGluZShpdGVtcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogIHBhcnNlLFxuICByZW5kZXI6IHJlbmRlcixcbiAgYm91bmRzOiBib3VuZHMsXG4gIGFyZWE6ICAgYXJlYSxcbiAgbGluZTogICBsaW5lXG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyksXG4gICAgU1ZHQnVpbGRlciA9IHJlcXVpcmUoJy4vc3ZnJyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9idWlsZGVyID0gbnVsbDtcbn07XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl9idWlsZGVyID0gbmV3IFNWR0J1aWxkZXIoKTtcbiAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIHBhZCk7XG59XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkIHx8IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHRoaXMuX2F1dG9wYWQgPSBkbC5pc1N0cmluZyh0aGlzLl9wYWRkaW5nKSA/IDEgOiAwO1xuXG4gIHZhciB3ID0gdGhpcy5fd2lkdGgsIGggPSB0aGlzLl9oZWlnaHQsIHBhZCA9IHRoaXMuX3BhZGRpbmc7XG4gIFxuICAvLyAocmUtKWNvbmZpZ3VyZSBidWlsZGVyIHNpemVcbiAgdGhpcy5fYnVpbGRlci5pbml0aWFsaXplKG51bGwsIHcsIGgsIHBhZCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIC8vIGhlYWRsZXNzIGFsd2F5cyBkcmF3cyB0aGUgZW50aXJlIHNjZW5lLCBpZ25vcmluZyBpdGVtc1xuICB0aGlzLl9idWlsZGVyLnJlbmRlcihzY2VuZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYnVpbGRlci5zdmcoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vUmVuZGVyZXInKVxufTtcbiIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9naWQgPSAwOyAvLyBncm91cCBpZCBjb3VudGVyIGZvciBkMyBkb20gY29tcGF0XG4gIHRoaXMuX3RleHQgPSB7XG4gICAgaGVhZDogXCJcIixcbiAgICByb290OiBcIlwiLFxuICAgIGZvb3Q6IFwiXCIsXG4gICAgZGVmczogXCJcIixcbiAgICBib2R5OiBcIlwiXG4gIH07XG4gIHRoaXMuX2RlZnMgPSB7XG4gICAgZ3JhZGllbnQ6IHt9LFxuICAgIGNsaXBwaW5nOiB7fVxuICB9O1xufTtcblxuZnVuY3Rpb24gb3Blbih0YWcsIGF0dHIsIHJhdykge1xuICB2YXIgcyA9IFwiPFwiICsgdGFnO1xuICBpZiAoYXR0cikge1xuICAgIGZvciAodmFyIGtleSBpbiBhdHRyKSB7XG4gICAgICB2YXIgdmFsID0gYXR0cltrZXldO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHMgKz0gXCIgXCIgKyBrZXkgKyAnPVwiJyArIHZhbCArICdcIic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyYXcpIHMgKz0gXCIgXCIgKyByYXc7XG4gIHJldHVybiBzICsgXCI+XCI7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKHRhZykge1xuICByZXR1cm4gXCI8L1wiICsgdGFnICsgXCI+XCI7XG59XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHcsIGgsIHBhZCkge1xuICB2YXIgdCA9IHRoaXMuX3RleHQ7XG5cbiAgdC5oZWFkID0gb3Blbignc3ZnJywge1xuICAgIFwiY2xhc3NcIjogJ21hcmtzJyxcbiAgICB3aWR0aDogdyArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgIGhlaWdodDogaCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICB9LCBjb25maWcuc3ZnTmFtZXNwYWNlKTtcblxuICB0LnJvb3QgPSBvcGVuKCdnJywge1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgcGFkLmxlZnQgKyAnLCcgKyBwYWQudG9wICsgJyknXG4gIH0pO1xuXG4gIHQuZm9vdCA9IGNsb3NlKCdnJykgKyBjbG9zZSgnc3ZnJyk7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy5fdGV4dDtcbiAgcmV0dXJuIHQuaGVhZCArIHQuZGVmcyArIHQucm9vdCArIHQuYm9keSArIHQuZm9vdDtcbn07XG5cbnByb3RvdHlwZS5idWlsZERlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFsbCA9IHRoaXMuX2RlZnMsXG4gICAgICBkZ3JhZCA9IGRsLmtleXMoYWxsLmdyYWRpZW50KSxcbiAgICAgIGRjbGlwID0gZGwua2V5cyhhbGwuY2xpcHBpbmcpLFxuICAgICAgZGVmcyA9IFwiXCIsIGdyYWQsIGNsaXAsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8ZGdyYWQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaWQgPSBkZ3JhZFtpXSxcbiAgICAgICAgZGVmID0gYWxsLmdyYWRpZW50W2lkXSxcbiAgICAgICAgc3RvcHMgPSBkZWYuc3RvcHM7XG5cbiAgICBkZWZzICs9IG9wZW4oXCJsaW5lYXJHcmFkaWVudFwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICB4MTogZGVmLngxLFxuICAgICAgeDI6IGRlZi54MixcbiAgICAgIHkxOiBkZWYueTEsXG4gICAgICB5MjogZGVmLnkyXG4gICAgfSk7XG4gICAgXG4gICAgZm9yIChqPTA7IGo8c3RvcHMubGVuZ3RoOyArK2opIHtcbiAgICAgIGRlZnMgKz0gb3BlbihcInN0b3BcIiwge1xuICAgICAgICBvZmZzZXQ6IHN0b3BzW2pdLm9mZnNldCxcbiAgICAgICAgXCJzdG9wLWNvbG9yXCI6IHN0b3BzW2pdLmNvbG9yXG4gICAgICB9KSArIGNsb3NlKFwic3RvcFwiKTtcbiAgICB9XG4gICAgXG4gICAgZGVmcyArPSBjbG9zZShcImxpbmVhckdyYWRpZW50XCIpO1xuICB9XG4gIFxuICBmb3IgKGk9MDsgaTxkY2xpcC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IGRjbGlwW2ldLFxuICAgICAgICBkZWYgPSBhbGwuY2xpcHBpbmdbaWRdO1xuXG4gICAgZGVmcyArPSBvcGVuKFwiY2xpcFBhdGhcIiwge2lkOiBpZH0pO1xuXG4gICAgZGVmcyArPSBvcGVuKFwicmVjdFwiLCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBkZWYud2lkdGgsXG4gICAgICBoZWlnaHQ6IGRlZi5oZWlnaHRcbiAgICB9KSArIGNsb3NlKFwicmVjdFwiKTtcblxuICAgIGRlZnMgKz0gY2xvc2UoXCJjbGlwUGF0aFwiKTtcbiAgfVxuICBcbiAgaWYgKGRlZnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBvcGVuKFwiZGVmc1wiKSArIGRlZnMgKyBjbG9zZShcImRlZnNcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCJcbiAgfVxuICByZXR1cm4gZGVmcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSkge1xuICB0aGlzLl9naWQgPSAwOyAvLyByZXNldCB0aGUgZ3JvdXAgY291bnRlclxuICB0aGlzLl90ZXh0LmJvZHkgPSB0aGlzLmRyYXcoc2NlbmUpO1xuICB0aGlzLl90ZXh0LmRlZnMgPSB0aGlzLmJ1aWxkRGVmcygpO1xufTtcblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgbWV0YSA9IE1BUktTW3NjZW5lLm1hcmt0eXBlXTtcbiAgaWYgKCFtZXRhKSB7XG4gICAgcmV0dXJuOyAvLyBubyBrbm93biBtYXJrdHlwZSAoZS5nLiwgYW4gaW50ZXJhY3RvcilcbiAgfVxuICB2YXIgdGFnICA9IG1ldGFbMF0sXG4gICAgICBhdHRyID0gbWV0YVsxXSxcbiAgICAgIG5lc3QgPSBtZXRhWzJdIHx8IGZhbHNlLFxuICAgICAgZGF0YSA9IG5lc3QgPyBbc2NlbmUuaXRlbXNdIDogc2NlbmUuaXRlbXMsXG4gICAgICBkZWZzID0gdGhpcy5fZGVmcyxcbiAgICAgIHN2ZyA9IFwiXCIsIGksIHN0eTtcblxuICB2YXIgY2xzID0gY3NzQ2xhc3Moc2NlbmUuZGVmKTtcblxuICAvLyBzdHlsZSBsaXRlcmFscyB0byBleGFjdGx5IG1hdGNoIHRoZSBkMyBkb21cbiAgdmFyIHN0eWwgPSBudWxsO1xuICBpZiAoY2xzID09PSAndHlwZS1ydWxlJyB8fCBjbHMgPT09ICd0eXBlLXBhdGgnKVxuICAgIHN0eWwgPSAnc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIic7XG4gIGVsc2UgaWYgKGNscyAhPT0gJ3R5cGUtZ3JvdXAnKVxuICAgIHN0eWwgPSAnc3R5bGU9XCJcIic7XG5cbiAgc3ZnICs9IG9wZW4oJ2cnLCB7XG4gICAgJ2lkJzogJ2cnICsgKyt0aGlzLl9naWQsIC8vIGQzIGRvbSBjb21wYXRcbiAgICAnY2xhc3MnOiBjc3NDbGFzcyhzY2VuZS5kZWYpXG4gIH0sIHN0eWwpO1xuXG4gIGZvciAoaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc3R5ID0gdGFnID09PSAnZycgPyBudWxsIDogc3R5bGUoZGF0YVtpXSwgdGFnLCBkZWZzKTtcbiAgICBzdmcgKz0gb3Blbih0YWcsIGF0dHIoZGF0YVtpXSwgZGVmcyksIHN0eSk7XG4gICAgaWYgKHRhZyA9PT0gJ3RleHQnKSBzdmcgKz0gZXNjYXBlX3RleHQoZGF0YVtpXS50ZXh0KTtcbiAgICBpZiAodGFnID09PSAnZycpIHN2ZyArPSB0aGlzLmRyYXdHcm91cChkYXRhW2ldKTtcbiAgICBzdmcgKz0gY2xvc2UodGFnKTtcbiAgfVxuXG4gIHJldHVybiBzdmcgKyBjbG9zZSgnZycpO1xufTtcblxuZnVuY3Rpb24gZXNjYXBlX3RleHQocykge1xuICBzID0gKHMgPT0gbnVsbCA/IFwiXCIgOiBTdHJpbmcocykpO1xuICByZXR1cm4gcy5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZV9mb250KHMpIHtcbiAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC9cXFwiL2csIFwiJ1wiKTtcbn1cblxudmFyIE1BUktTID0ge1xuICBncm91cDogIFsnZycsIGdyb3VwXSxcbiAgYXJlYTogICBbJ3BhdGgnLCBhcmVhLCB0cnVlXSxcbiAgbGluZTogICBbJ3BhdGgnLCBsaW5lLCB0cnVlXSxcbiAgYXJjOiAgICBbJ3BhdGgnLCBhcmNdLFxuICBwYXRoOiAgIFsncGF0aCcsIHBhdGhdLFxuICBzeW1ib2w6IFsncGF0aCcsIHN5bWJvbF0sXG4gIHJlY3Q6ICAgWydyZWN0JywgcmVjdF0sXG4gIHJ1bGU6ICAgWydsaW5lJywgcnVsZV0sXG4gIHRleHQ6ICAgWyd0ZXh0JywgdGV4dF0sXG4gIGltYWdlOiAgWydpbWFnZScsIGltYWdlXVxufTtcblxucHJvdG90eXBlLmRyYXdHcm91cCA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBzdmcgPSBcIlwiLFxuICAgICAgYXhlcyA9IHNjZW5lLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBsZWdlbmRzID0gc2NlbmUubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBpLCBqLCBtO1xuXG4gIHN2ZyArPSBncm91cF9iZyhzY2VuZSk7XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyID09PSBcImJhY2tcIikge1xuICAgICAgc3ZnICs9IHRoaXMuZHJhdyhheGVzW2pdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHN2ZyArPSB0aGlzLmRyYXcoaXRlbXNbal0pO1xuICB9XG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmRlZi5sYXllciAhPT0gXCJiYWNrXCIpIHtcbiAgICAgIHN2ZyArPSB0aGlzLmRyYXcoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHN2ZyArPSB0aGlzLmRyYXcobGVnZW5kc1tqXSk7XG4gIH1cblxuICByZXR1cm4gc3ZnO1xufTtcblxuLy8vXG5cbmZ1bmN0aW9uIGdyb3VwX2JnKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMDtcblxuICB2YXIgc3R5bCA9IG8ubWFyay5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgP1xuICAgICdzdHlsZT1cInBvaW50ZXItZXZlbnRzOiBub25lO1wiJyA6IFxuICAgICdzdHlsZT1cIlwiJztcblxuICByZXR1cm4gb3BlbigncmVjdCcsIHtcbiAgICAnY2xhc3MnOiAnYmFja2dyb3VuZCdcbiAgfSwgc3R5bCkgKyBjbG9zZSgncmVjdCcpO1xufVxuXG5mdW5jdGlvbiBncm91cChvLCBkZWZzKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBhdHRyID0ge3RyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwifTtcblxuICBpZiAoby5jbGlwKSB7XG4gICAgdmFyIGMgPSB7d2lkdGg6IG8ud2lkdGggfHwgMCwgaGVpZ2h0OiBvLmhlaWdodCB8fCAwfSxcbiAgICAgICAgaWQgPSBvLmNsaXBfaWQgfHwgKG8uY2xpcF9pZCA9IFwiY2xpcFwiICsgY2xpcF9pZCsrKTtcbiAgICBkZWZzLmNsaXBwaW5nW2lkXSA9IGM7XG4gICAgYXR0cltcImNsaXAtcGF0aFwiXSA9IFwidXJsKCNcIitpZCtcIilcIjtcbiAgfVxuXG4gIHJldHVybiBhdHRyO1xufVxuXG5mdW5jdGlvbiBhcmMobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiLFxuICAgIGQ6IGFyY19wYXRoKG8pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFyZWEoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIHBhdGggPSBvLm9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIgPyBhcmVhX3BhdGhfaCA6IGFyZWFfcGF0aF92O1xuICBwYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHJldHVybiB7ZDogcGF0aChpdGVtcyl9O1xufVxuXG5mdW5jdGlvbiBsaW5lKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIGxpbmVfcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICByZXR1cm4ge2Q6IGxpbmVfcGF0aChpdGVtcyl9O1xufVxuXG5mdW5jdGlvbiBwYXRoKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIixcbiAgICBkOiBvLnBhdGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVjdChvKSB7XG4gIHJldHVybiB7XG4gICAgeDogby54IHx8IDAsXG4gICAgeTogby55IHx8IDAsXG4gICAgd2lkdGg6IG8ud2lkdGggfHwgMCxcbiAgICBoZWlnaHQ6IG8uaGVpZ2h0IHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gcnVsZShvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4MTogeDEsXG4gICAgeTE6IHkxLFxuICAgIHgyOiBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgeTI6IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MVxuICB9O1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiLFxuICAgIGQ6IHN5bWJvbF9wYXRoKG8pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDAsXG4gICAgICB4ID0gby54IC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKSxcbiAgICAgIHkgPSBvLnkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKSxcbiAgICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgby51cmw7XG4gIFxuICByZXR1cm4ge1xuICAgIFwieGxpbms6aHJlZlwiOiB1cmwsXG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaFxuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0KG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGR4ID0gby5keCB8fCAwLFxuICAgICAgZHkgPSBvLmR5IHx8IDAsXG4gICAgICBhID0gby5hbmdsZSB8fCAwLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBhbGlnbiA9IHRleHRBbGlnbltvLmFsaWduIHx8IFwibGVmdFwiXSxcbiAgICAgIGJhc2UgPSBvLmJhc2VsaW5lPT09XCJ0b3BcIiA/IFwiLjllbVwiXG4gICAgICAgICAgIDogby5iYXNlbGluZT09PVwibWlkZGxlXCIgPyBcIi4zNWVtXCIgOiAwO1xuXG4gIGlmIChyKSB7XG4gICAgdmFyIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCArIGR4LFxuICAgIHk6IHkgKyBkeSxcbiAgICAndGV4dC1hbmNob3InOiBhbGlnbixcbiAgICB0cmFuc2Zvcm06IGEgPyBcInJvdGF0ZShcIithK1wiIFwiK3grXCIsXCIreStcIilcIiA6IG51bGwsXG4gICAgZHk6IGJhc2UgPyBiYXNlIDogbnVsbFxuICB9O1xufVxuXG4vLy9cblxuZnVuY3Rpb24gY3NzQ2xhc3MoZGVmKSB7XG4gIHZhciBjbHMgPSBcInR5cGUtXCIgKyBkZWYudHlwZTtcbiAgaWYgKGRlZi5uYW1lKSBjbHMgKz0gXCIgXCIgKyBkZWYubmFtZTtcbiAgcmV0dXJuIGNscztcbn1cblxuZnVuY3Rpb24geChvKSAgICAgeyByZXR1cm4gby54IHx8IDA7IH1cbmZ1bmN0aW9uIHkobykgICAgIHsgcmV0dXJuIG8ueSB8fCAwOyB9XG5mdW5jdGlvbiB4dyhvKSAgICB7IHJldHVybiBvLnggKyBvLndpZHRoIHx8IDA7IH1cbmZ1bmN0aW9uIHloKG8pICAgIHsgcmV0dXJuIG8ueSArIG8uaGVpZ2h0IHx8IDA7IH1cbmZ1bmN0aW9uIGtleShvKSAgIHsgcmV0dXJuIG8ua2V5OyB9XG5mdW5jdGlvbiBzaXplKG8pICB7IHJldHVybiBvLnNpemU9PW51bGwgPyAxMDAgOiBvLnNpemU7IH1cbmZ1bmN0aW9uIHNoYXBlKG8pIHsgcmV0dXJuIG8uc2hhcGUgfHwgXCJjaXJjbGVcIjsgfVxuXG52YXIgYXJjX3BhdGggICAgPSBkMy5zdmcuYXJjKCksXG4gICAgYXJlYV9wYXRoX3YgPSBkMy5zdmcuYXJlYSgpLngoeCkueTEoeSkueTAoeWgpLFxuICAgIGFyZWFfcGF0aF9oID0gZDMuc3ZnLmFyZWEoKS55KHkpLngwKHh3KS54MSh4KSxcbiAgICBsaW5lX3BhdGggICA9IGQzLnN2Zy5saW5lKCkueCh4KS55KHkpLFxuICAgIHN5bWJvbF9wYXRoID0gZDMuc3ZnLnN5bWJvbCgpLnR5cGUoc2hhcGUpLnNpemUoc2l6ZSk7XG5cbnZhciBtYXJrX2lkID0gMCxcbiAgICBjbGlwX2lkID0gMDtcblxudmFyIHRleHRBbGlnbiA9IHtcbiAgXCJsZWZ0XCI6ICAgXCJzdGFydFwiLFxuICBcImNlbnRlclwiOiBcIm1pZGRsZVwiLFxuICBcInJpZ2h0XCI6ICBcImVuZFwiXG59O1xuXG52YXIgc3R5bGVzID0ge1xuICBcImZpbGxcIjogICAgICAgICAgICAgXCJmaWxsXCIsXG4gIFwiZmlsbE9wYWNpdHlcIjogICAgICBcImZpbGwtb3BhY2l0eVwiLFxuICBcInN0cm9rZVwiOiAgICAgICAgICAgXCJzdHJva2VcIixcbiAgXCJzdHJva2VXaWR0aFwiOiAgICAgIFwic3Ryb2tlLXdpZHRoXCIsXG4gIFwic3Ryb2tlT3BhY2l0eVwiOiAgICBcInN0cm9rZS1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlQ2FwXCI6ICAgICAgICBcInN0cm9rZS1saW5lY2FwXCIsXG4gIFwic3Ryb2tlRGFzaFwiOiAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgXCJzdHJva2VEYXNoT2Zmc2V0XCI6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgXCJvcGFjaXR5XCI6ICAgICAgICAgIFwib3BhY2l0eVwiXG59O1xuXG52YXIgc3R5bGVQcm9wcyA9IGRsLmtleXMoc3R5bGVzKTtcblxuZnVuY3Rpb24gc3R5bGUoZCwgdGFnLCBkZWZzKSB7XG4gIHZhciBpLCBuLCBwcm9wLCBuYW1lLCB2YWx1ZSxcbiAgICAgIG8gPSBkLm1hcmsgPyBkIDogZC5sZW5ndGggPyBkWzBdIDogbnVsbDtcbiAgaWYgKG8gPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBzID0gXCJcIjtcblxuICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICBzICs9ICdmb250OiAnICsgZm9udFN0cmluZyhvKSArICc7JztcbiAgfVxuICBcbiAgZm9yIChpPTAsIG49c3R5bGVQcm9wcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IHN0eWxlUHJvcHNbaV07XG4gICAgbmFtZSA9IHN0eWxlc1twcm9wXTtcbiAgICB2YWx1ZSA9IG9bcHJvcF07XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5hbWUgPT09IFwiZmlsbFwiKSBzICs9ICdmaWxsOiBub25lOyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5pZCkge1xuICAgICAgICAvLyBlbnN1cmUgZGVmaW5pdGlvbiBpcyBpbmNsdWRlZFxuICAgICAgICBkZWZzLmdyYWRpZW50W3ZhbHVlLmlkXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IFwidXJsKFwiICsgd2luZG93LmxvY2F0aW9uLmhyZWYgKyBcIiNcIiArIHZhbHVlLmlkICsgXCIpXCI7XG4gICAgICB9XG4gICAgICBzICs9IChzLmxlbmd0aCA/ICcgJyA6ICcnKSArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnOydcbiAgICB9XG4gIH1cbiAgXG4gIC8vIG5vdCB0aGF0IHdlIGRvbid0IGV4Y2x1ZGUgYmxhbmsgc3R5bGVzIGZvciBkMyBkb20gY29tcGF0XG4gIHJldHVybiAnc3R5bGU9XCInK3MrJ1wiJztcbn1cblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHZhciBmID0gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgJiYgZXNjYXBlX2ZvbnQoby5mb250KSB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xuICByZXR1cm4gZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJlcjtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxudmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlbCwgbW9kZWwpIHtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaWYgKGVsKSB0aGlzLmluaXRpYWxpemUoZWwpO1xuICBpZiAobW9kZWwpIHRoaXMubW9kZWwobW9kZWwpO1xufTtcblxuZnVuY3Rpb24gc3ZnSGFuZGxlcihoYW5kbGVyKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBpdGVtID0gdGFyZ2V0Ll9fZGF0YV9fO1xuXG4gICAgaWYgKGl0ZW0pIGl0ZW0gPSBpdGVtLm1hcmsgPyBpdGVtIDogaXRlbVswXTtcbiAgICBoYW5kbGVyLmNhbGwodGhhdC5fb2JqLCBldnQsIGl0ZW0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBldmVudE5hbWUobmFtZSkge1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi5cIik7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSBoYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBkMy5zZWxlY3QoZWwpLm5vZGUoKTtcbiAgdGhpcy5fc3ZnID0gZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJzdmcubWFya3NcIikubm9kZSgpO1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICByZXR1cm4gZGwua2V5cyhoKS5yZWR1Y2UoZnVuY3Rpb24oYSwgaykge1xuICAgIHJldHVybiBoW2tdLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7IHJldHVybiAoYS5wdXNoKHgpLCBhKTsgfSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzLFxuICAgICAgZG9tID0gZDMuc2VsZWN0KHRoaXMuX3N2Zykubm9kZSgpO1xuICAgICAgXG4gIHZhciB4ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICBzdmc6IHN2Z0hhbmRsZXIuY2FsbCh0aGlzLCBoYW5kbGVyKVxuICB9O1xuICBoID0gaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKTtcbiAgaC5wdXNoKHgpO1xuXG4gIGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHguc3ZnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyByZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSBldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sXG4gICAgICBkb20gPSBkMy5zZWxlY3QodGhpcy5fc3ZnKS5ub2RlKCk7XG4gIGlmICghaCkgcmV0dXJuO1xuICBmb3IgKHZhciBpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYgKGhbaV0udHlwZSAhPT0gdHlwZSkgY29udGludWU7XG4gICAgaWYgKCFoYW5kbGVyIHx8IGhbaV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaFtpXS5zdmcpO1xuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3ZnID0gbnVsbDtcbiAgdGhpcy5fY3R4ID0gbnVsbDtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9kZWZzID0ge1xuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl9lbCA9IGVsO1xuXG4gIC8vIHJlbW92ZSBhbnkgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRcbiAgZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJzdmcubWFya3NcIikucmVtb3ZlKCk7XG5cbiAgLy8gY3JlYXRlIHN2ZyBlbGVtZW50IGFuZCBpbml0aWFsaXplIGF0dHJpYnV0ZXNcbiAgdGhpcy5fc3ZnID0gZDMuc2VsZWN0KGVsKVxuICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwibWFya3NcIik7XG4gIFxuICAvLyBzZXQgdGhlIHN2ZyByb290IGdyb3VwXG4gIHRoaXMuX2N0eCA9IHRoaXMuX3N2Zy5hcHBlbmQoXCJnXCIpO1xuICBcbiAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIHBhZCk7XG59O1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgXG4gIHRoaXMuX3N2Z1xuICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBwYWQubGVmdCArIHBhZC5yaWdodClcbiAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBwYWQudG9wICsgcGFkLmJvdHRvbSk7XG4gICAgXG4gIHRoaXMuX2N0eFxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3BhZC5sZWZ0K1wiLFwiK3BhZC50b3ArXCIpXCIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N0eDtcbn07XG5cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbnByb3RvdHlwZS51cGRhdGVEZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICBhbGwgPSB0aGlzLl9kZWZzLFxuICAgICAgZGdyYWQgPSBkbC5rZXlzKGFsbC5ncmFkaWVudCksXG4gICAgICBkY2xpcCA9IGRsLmtleXMoYWxsLmNsaXBwaW5nKSxcbiAgICAgIGRlZnMgPSBzdmcuc2VsZWN0KFwiZGVmc1wiKSwgZ3JhZCwgY2xpcDtcblxuICAvLyBnZXQgb3IgY3JlYXRlIHN2ZyBkZWZzIGJsb2NrXG4gIGlmIChkZ3JhZC5sZW5ndGg9PT0wICYmIGRjbGlwLmxlbmd0aD09MCkgeyBkZWZzLnJlbW92ZSgpOyByZXR1cm47IH1cbiAgaWYgKGRlZnMuZW1wdHkoKSkgZGVmcyA9IHN2Zy5pbnNlcnQoXCJkZWZzXCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBcbiAgZ3JhZCA9IGRlZnMuc2VsZWN0QWxsKFwibGluZWFyR3JhZGllbnRcIikuZGF0YShkZ3JhZCwgZGwuaWRlbnRpdHkpO1xuICBncmFkLmVudGVyKCkuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIikuYXR0cihcImlkXCIsIGRsLmlkZW50aXR5KTtcbiAgZ3JhZC5leGl0KCkucmVtb3ZlKCk7XG4gIGdyYWQuZWFjaChmdW5jdGlvbihpZCkge1xuICAgIHZhciBkZWYgPSBhbGwuZ3JhZGllbnRbaWRdLFxuICAgICAgICBncmQgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAvLyBzZXQgZ3JhZGllbnQgY29vcmRpbmF0ZXNcbiAgICBncmQuYXR0cih7eDE6IGRlZi54MSwgeDI6IGRlZi54MiwgeTE6IGRlZi55MSwgeTI6IGRlZi55Mn0pO1xuXG4gICAgLy8gc2V0IGdyYWRpZW50IHN0b3BzXG4gICAgc3RvcCA9IGdyZC5zZWxlY3RBbGwoXCJzdG9wXCIpLmRhdGEoZGVmLnN0b3BzKTtcbiAgICBzdG9wLmVudGVyKCkuYXBwZW5kKFwic3RvcFwiKTtcbiAgICBzdG9wLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBzdG9wLmF0dHIoXCJvZmZzZXRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5vZmZzZXQ7IH0pXG4gICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmNvbG9yOyB9KTtcbiAgfSk7XG4gIFxuICBjbGlwID0gZGVmcy5zZWxlY3RBbGwoXCJjbGlwUGF0aFwiKS5kYXRhKGRjbGlwLCBkbC5pZGVudGl0eSk7XG4gIGNsaXAuZW50ZXIoKS5hcHBlbmQoXCJjbGlwUGF0aFwiKS5hdHRyKFwiaWRcIiwgZGwuaWRlbnRpdHkpO1xuICBjbGlwLmV4aXQoKS5yZW1vdmUoKTtcbiAgY2xpcC5lYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGRlZiA9IGFsbC5jbGlwcGluZ1tpZF0sXG4gICAgICAgIGNyID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbChcInJlY3RcIikuZGF0YShbMV0pO1xuICAgIGNyLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKTtcbiAgICBjci5hdHRyKFwieFwiLCAwKVxuICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAuYXR0cihcIndpZHRoXCIsIGRlZi53aWR0aClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGRlZi5oZWlnaHQpO1xuICB9KTtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgbWFya3MuY3VycmVudCA9IHRoaXM7XG5cbiAgaWYgKGl0ZW1zKSB7XG4gICAgdGhpcy5yZW5kZXJJdGVtcyhkbC5hcnJheShpdGVtcykpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZHJhdyh0aGlzLl9jdHgsIHNjZW5lLCAtMSk7XG4gIH1cbiAgdGhpcy51cGRhdGVEZWZzKCk7XG5cbiBkZWxldGUgbWFya3MuY3VycmVudDtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHZhciBpdGVtLCBub2RlLCB0eXBlLCBuZXN0LCBpLCBuO1xuXG4gIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgbm9kZSA9IGl0ZW0uX3N2ZztcbiAgICB0eXBlID0gaXRlbS5tYXJrLm1hcmt0eXBlO1xuXG4gICAgaXRlbSA9IG1hcmtzLm5lc3RlZFt0eXBlXSA/IGl0ZW0ubWFyay5pdGVtcyA6IGl0ZW07XG4gICAgbWFya3MudXBkYXRlW3R5cGVdLmNhbGwobm9kZSwgaXRlbSk7XG4gICAgbWFya3Muc3R5bGUuY2FsbChub2RlLCBpdGVtKTtcbiAgfVxufVxuXG5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgc2NlbmUsIGluZGV4KSB7XG4gIHZhciBtYXJrdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgcmVuZGVyZXIgPSBtYXJrcy5kcmF3W21hcmt0eXBlXTtcbiAgcmVuZGVyZXIuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBpbmRleCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKTtcblxuZnVuY3Rpb24geChvKSAgICAgeyByZXR1cm4gby54IHx8IDA7IH1cbmZ1bmN0aW9uIHkobykgICAgIHsgcmV0dXJuIG8ueSB8fCAwOyB9XG5mdW5jdGlvbiB5aChvKSAgICB7IHJldHVybiBvLnkgKyBvLmhlaWdodCB8fCAwOyB9XG5mdW5jdGlvbiBrZXkobykgICB7IHJldHVybiBvLmtleTsgfVxuZnVuY3Rpb24gc2l6ZShvKSAgeyByZXR1cm4gby5zaXplPT1udWxsID8gMTAwIDogby5zaXplOyB9XG5mdW5jdGlvbiBzaGFwZShvKSB7IHJldHVybiBvLnNoYXBlIHx8IFwiY2lyY2xlXCI7IH1cbiAgICBcbnZhciBhcmNfcGF0aCAgICA9IGQzLnN2Zy5hcmMoKSxcbiAgICBhcmVhX3BhdGggICA9IGQzLnN2Zy5hcmVhKCkueCh4KS55MSh5KS55MCh5aCksXG4gICAgbGluZV9wYXRoICAgPSBkMy5zdmcubGluZSgpLngoeCkueSh5KSxcbiAgICBzeW1ib2xfcGF0aCA9IGQzLnN2Zy5zeW1ib2woKS50eXBlKHNoYXBlKS5zaXplKHNpemUpO1xuXG52YXIgbWFya19pZCA9IDAsXG4gICAgY2xpcF9pZCA9IDA7XG5cbnZhciB0ZXh0QWxpZ24gPSB7XG4gIFwibGVmdFwiOiAgIFwic3RhcnRcIixcbiAgXCJjZW50ZXJcIjogXCJtaWRkbGVcIixcbiAgXCJyaWdodFwiOiAgXCJlbmRcIlxufTtcblxudmFyIHN0eWxlcyA9IHtcbiAgXCJmaWxsXCI6ICAgICAgICAgICAgIFwiZmlsbFwiLFxuICBcImZpbGxPcGFjaXR5XCI6ICAgICAgXCJmaWxsLW9wYWNpdHlcIixcbiAgXCJzdHJva2VcIjogICAgICAgICAgIFwic3Ryb2tlXCIsXG4gIFwic3Ryb2tlV2lkdGhcIjogICAgICBcInN0cm9rZS13aWR0aFwiLFxuICBcInN0cm9rZU9wYWNpdHlcIjogICAgXCJzdHJva2Utb3BhY2l0eVwiLFxuICBcInN0cm9rZUNhcFwiOiAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZURhc2hcIjogICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCIsXG4gIFwic3Ryb2tlRGFzaE9mZnNldFwiOiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gIFwib3BhY2l0eVwiOiAgICAgICAgICBcIm9wYWNpdHlcIlxufTtcbnZhciBzdHlsZVByb3BzID0gZGwua2V5cyhzdHlsZXMpO1xuXG5mdW5jdGlvbiBzdHlsZShkKSB7XG4gIHZhciBpLCBuLCBwcm9wLCBuYW1lLCB2YWx1ZSxcbiAgICAgIG8gPSBkLm1hcmsgPyBkIDogZC5sZW5ndGggPyBkWzBdIDogbnVsbDtcbiAgaWYgKG8gPT09IG51bGwpIHJldHVybjtcblxuICBmb3IgKGk9MCwgbj1zdHlsZVByb3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gc3R5bGVQcm9wc1tpXTtcbiAgICBuYW1lID0gc3R5bGVzW3Byb3BdO1xuICAgIHZhbHVlID0gb1twcm9wXTtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJmaWxsXCIpIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgXCJub25lXCIsIG51bGwpO1xuICAgICAgZWxzZSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgbWFya3MuY3VycmVudC5fZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBcInVybCgjXCIgKyB2YWx1ZS5pZCArIFwiKVwiO1xuICAgICAgfVxuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZStcIlwiLCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJjKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIGFyY19wYXRoKG8pKTtcbn1cblxuZnVuY3Rpb24gYXJlYShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICBhcmVhX3BhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIGFyZWFfcGF0aChpdGVtcykpO1xufVxuXG5mdW5jdGlvbiBsaW5lKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIGxpbmVfcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgbGluZV9wYXRoKGl0ZW1zKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGgobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuICBpZiAoby5wYXRoICE9IG51bGwpIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBvLnBhdGgpO1xufVxuXG5mdW5jdGlvbiByZWN0KG8pIHtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4XCIsIG8ueCB8fCAwKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIG8ueSB8fCAwKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBvLndpZHRoIHx8IDApO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBvLmhlaWdodCB8fCAwKTtcbn1cblxuZnVuY3Rpb24gcnVsZShvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCB4MSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieTFcIiwgeTEpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIngyXCIsIG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieTJcIiwgby55MiAhPSBudWxsID8gby55MiA6IHkxKTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIHN5bWJvbF9wYXRoKG8pKTtcbn1cblxuZnVuY3Rpb24gaW1hZ2Uobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS53aWR0aCkgfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMCxcbiAgICAgIHggPSBvLnggLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IG8ueSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpLFxuICAgICAgdXJsID0gY29uZmlnLmJhc2VVUkwgKyBvLnVybDtcbiAgXG4gIHRoaXMuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIFwiaHJlZlwiLCB1cmwpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaCk7XG59XG4gIFxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG5mdW5jdGlvbiB0ZXh0KG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGR4ID0gby5keCB8fCAwLFxuICAgICAgZHkgPSBvLmR5IHx8IDAsXG4gICAgICBhID0gby5hbmdsZSB8fCAwLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBhbGlnbiA9IHRleHRBbGlnbltvLmFsaWduIHx8IFwibGVmdFwiXSxcbiAgICAgIGJhc2UgPSBvLmJhc2VsaW5lPT09XCJ0b3BcIiA/IFwiLjllbVwiXG4gICAgICAgICAgIDogby5iYXNlbGluZT09PVwibWlkZGxlXCIgPyBcIi4zNWVtXCIgOiAwO1xuXG4gIGlmIChyKSB7XG4gICAgdmFyIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCB4ICsgZHgpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgeSArIGR5KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLCBhbGlnbik7XG4gIFxuICBpZiAoYSkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoXCIrYStcIiBcIit4K1wiLFwiK3krXCIpXCIpO1xuICBlbHNlIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICBcbiAgaWYgKGJhc2UpIHRoaXMuc2V0QXR0cmlidXRlKFwiZHlcIiwgYmFzZSk7XG4gIGVsc2UgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJkeVwiKTtcbiAgXG4gIHRoaXMudGV4dENvbnRlbnQgPSBvLnRleHQ7XG4gIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoXCJmb250XCIsIGZvbnRTdHJpbmcobyksIG51bGwpO1xufVxuXG5mdW5jdGlvbiBncm91cChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG5cbiAgaWYgKG8uY2xpcCkge1xuICAgIHZhciBjID0ge3dpZHRoOiBvLndpZHRoIHx8IDAsIGhlaWdodDogby5oZWlnaHQgfHwgMH0sXG4gICAgICAgIGlkID0gby5jbGlwX2lkIHx8IChvLmNsaXBfaWQgPSBcImNsaXBcIiArIGNsaXBfaWQrKyk7XG4gICAgbWFya3MuY3VycmVudC5fZGVmcy5jbGlwcGluZ1tpZF0gPSBjO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNcIitpZCtcIilcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ3JvdXBfYmcobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHcpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoKTtcbn1cblxuZnVuY3Rpb24gY3NzQ2xhc3MoZGVmKSB7XG4gIHZhciBjbHMgPSBcInR5cGUtXCIgKyBkZWYudHlwZTtcbiAgaWYgKGRlZi5uYW1lKSBjbHMgKz0gXCIgXCIgKyBkZWYubmFtZTtcbiAgcmV0dXJuIGNscztcbn1cblxuZnVuY3Rpb24gZHJhdyh0YWcsIGF0dHIsIG5lc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBpbmRleCkge1xuICAgIGRyYXdNYXJrKGcsIHNjZW5lLCBpbmRleCwgXCJtYXJrX1wiLCB0YWcsIGF0dHIsIG5lc3QpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3TWFyayhnLCBzY2VuZSwgaW5kZXgsIHByZWZpeCwgdGFnLCBhdHRyLCBuZXN0KSB7XG4gIHZhciBkYXRhID0gbmVzdCA/IFtzY2VuZS5pdGVtc10gOiBzY2VuZS5pdGVtcyxcbiAgICAgIGV2dHMgPSBzY2VuZS5pbnRlcmFjdGl2ZT09PWZhbHNlID8gXCJub25lXCIgOiBudWxsLFxuICAgICAgZ3JwcyA9IGcubm9kZSgpLmNoaWxkTm9kZXMsXG4gICAgICBub3RHID0gKHRhZyAhPT0gXCJnXCIpLFxuICAgICAgcCA9IChwID0gZ3Jwc1tpbmRleCsxXSkgLy8gKzEgdG8gc2tpcCBncm91cCBiYWNrZ3JvdW5kIHJlY3RcbiAgICAgICAgPyBkMy5zZWxlY3QocClcbiAgICAgICAgOiBnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdcIisoKyttYXJrX2lkKSlcbiAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBjc3NDbGFzcyhzY2VuZS5kZWYpKTtcblxuICB2YXIgaWQgPSBwLmF0dHIoXCJpZFwiKSxcbiAgICAgIHMgPSBcIiNcIiArIGlkICsgXCIgPiBcIiArIHRhZyxcbiAgICAgIG0gPSBwLnNlbGVjdEFsbChzKS5kYXRhKGRhdGEpLFxuICAgICAgZSA9IG0uZW50ZXIoKS5hcHBlbmQodGFnKTtcblxuICBpZiAobm90Rykge1xuICAgIHAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBldnRzKTtcbiAgICBlLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKGQubWFyaykgZC5fc3ZnID0gdGhpcztcbiAgICAgIGVsc2UgaWYgKGQubGVuZ3RoKSBkWzBdLl9zdmcgPSB0aGlzO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGUuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIixcImJhY2tncm91bmRcIikuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLGV2dHMpO1xuICB9XG4gIFxuICBtLmV4aXQoKS5yZW1vdmUoKTtcbiAgbS5lYWNoKGF0dHIpO1xuICBpZiAobm90RykgbS5lYWNoKHN0eWxlKTtcbiAgZWxzZSBwLnNlbGVjdEFsbChzK1wiID4gcmVjdC5iYWNrZ3JvdW5kXCIpLmVhY2goZ3JvdXBfYmcpLmVhY2goc3R5bGUpO1xuICBcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGRyYXdHcm91cChnLCBzY2VuZSwgaW5kZXgsIHByZWZpeCkgeyAgICBcbiAgdmFyIHAgPSBkcmF3TWFyayhnLCBzY2VuZSwgaW5kZXgsIHByZWZpeCB8fCBcImdyb3VwX1wiLCBcImdcIiwgZ3JvdXApLFxuICAgICAgYyA9IHAubm9kZSgpLmNoaWxkTm9kZXMsIG4gPSBjLmxlbmd0aCwgaSwgaiwgbTtcbiAgXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBpdGVtcyA9IGNbaV0uX19kYXRhX18uaXRlbXMsXG4gICAgICAgIGxlZ2VuZHMgPSBjW2ldLl9fZGF0YV9fLmxlZ2VuZEl0ZW1zIHx8IFtdLFxuICAgICAgICBheGVzID0gY1tpXS5fX2RhdGFfXy5heGlzSXRlbXMgfHwgW10sXG4gICAgICAgIHNlbCA9IGQzLnNlbGVjdChjW2ldKSxcbiAgICAgICAgaWR4ID0gMDtcblxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyID09PSBcImJhY2tcIikge1xuICAgICAgICBkcmF3R3JvdXAuY2FsbCh0aGlzLCBzZWwsIGF4ZXNbal0sIGlkeCsrLCBcImF4aXNfXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICB0aGlzLmRyYXcoc2VsLCBpdGVtc1tqXSwgaWR4KyspO1xuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciAhPT0gXCJiYWNrXCIpIHtcbiAgICAgICAgZHJhd0dyb3VwLmNhbGwodGhpcywgc2VsLCBheGVzW2pdLCBpZHgrKywgXCJheGlzX1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBkcmF3R3JvdXAuY2FsbCh0aGlzLCBzZWwsIGxlZ2VuZHNbal0sIGlkeCsrLCBcImxlZ2VuZF9cIik7XG4gICAgfVxuICB9XG59XG5cbnZhciBtYXJrcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB1cGRhdGU6IHtcbiAgICBncm91cDogICByZWN0LFxuICAgIGFyZWE6ICAgIGFyZWEsXG4gICAgbGluZTogICAgbGluZSxcbiAgICBhcmM6ICAgICBhcmMsXG4gICAgcGF0aDogICAgcGF0aCxcbiAgICBzeW1ib2w6ICBzeW1ib2wsXG4gICAgcmVjdDogICAgcmVjdCxcbiAgICBydWxlOiAgICBydWxlLFxuICAgIHRleHQ6ICAgIHRleHQsXG4gICAgaW1hZ2U6ICAgaW1hZ2VcbiAgfSxcbiAgbmVzdGVkOiB7XG4gICAgXCJhcmVhXCI6IHRydWUsXG4gICAgXCJsaW5lXCI6IHRydWVcbiAgfSxcbiAgc3R5bGU6IHN0eWxlLFxuICBkcmF3OiB7XG4gICAgZ3JvdXA6ICAgZHJhd0dyb3VwLFxuICAgIGFyZWE6ICAgIGRyYXcoXCJwYXRoXCIsIGFyZWEsIHRydWUpLFxuICAgIGxpbmU6ICAgIGRyYXcoXCJwYXRoXCIsIGxpbmUsIHRydWUpLFxuICAgIGFyYzogICAgIGRyYXcoXCJwYXRoXCIsIGFyYyksXG4gICAgcGF0aDogICAgZHJhdyhcInBhdGhcIiwgcGF0aCksXG4gICAgc3ltYm9sOiAgZHJhdyhcInBhdGhcIiwgc3ltYm9sKSxcbiAgICByZWN0OiAgICBkcmF3KFwicmVjdFwiLCByZWN0KSxcbiAgICBydWxlOiAgICBkcmF3KFwibGluZVwiLCBydWxlKSxcbiAgICB0ZXh0OiAgICBkcmF3KFwidGV4dFwiLCB0ZXh0KSxcbiAgICBpbWFnZTogICBkcmF3KFwiaW1hZ2VcIiwgaW1hZ2UpLFxuICAgIGRyYXc6ICAgIGRyYXcgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gIH0sXG4gIGN1cnJlbnQ6IG51bGxcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2RlcicpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBCb3VuZGVyKGdyYXBoLCBtYXJrKSB7XG4gIHRoaXMuX21hcmsgPSBtYXJrO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKS5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChCb3VuZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJib3VuZHNcIiwgdGhpcy5fbWFyay5tYXJrdHlwZV0pO1xuICB2YXIgaSwgaWxlbiwgaiwgamxlbiwgZ3JvdXAsIGxlZ2VuZDtcbiAgICAgIGhhc0xlZ2VuZHMgPSB0aGlzLl9tYXJrLm1hcmt0eXBlID09IEMuR1JPVVAgXG4gICAgICAgICYmIGRsLmFycmF5KHRoaXMuX21hcmsuZGVmLmxlZ2VuZHMpLmxlbmd0aCA+IDA7XG5cbiAgYm91bmRzLm1hcmsodGhpcy5fbWFyaywgbnVsbCwgIWhhc0xlZ2VuZHMpO1xuXG4gIGlmKGhhc0xlZ2VuZHMpIHtcbiAgICBmb3IoaT0wLCBpbGVuPXRoaXMuX21hcmsuaXRlbXMubGVuZ3RoOyBpPGlsZW47ICsraSkge1xuICAgICAgZ3JvdXAgPSB0aGlzLl9tYXJrLml0ZW1zW2ldO1xuICAgICAgZ3JvdXAuX2xlZ2VuZFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBmb3Ioaj0wLCBqbGVuPWdyb3VwLmxlZ2VuZEl0ZW1zLmxlbmd0aDsgajxqbGVuOyArK2opIHtcbiAgICAgICAgbGVnZW5kID0gZ3JvdXAubGVnZW5kSXRlbXNbal07XG4gICAgICAgIEVuY29kZXIudXBkYXRlKHRoaXMuX2dyYXBoLCBpbnB1dC50cmFucywgXCJ2Z19sZWdlbmRQb3NpdGlvblwiLCBsZWdlbmQuaXRlbXMpO1xuICAgICAgICBib3VuZHMubWFyayhsZWdlbmQsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvdW5kcy5tYXJrKHRoaXMuX21hcmssIG51bGwsIHRydWUpO1xuICB9XG5cbiAgaW5wdXQucmVmbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEVuY29kZXIgID0gcmVxdWlyZSgnLi9FbmNvZGVyJyksXG4gICAgQm91bmRlciAgPSByZXF1aXJlKCcuL0JvdW5kZXInKSxcbiAgICBJdGVtICA9IHJlcXVpcmUoJy4vSXRlbScpLFxuICAgIHBhcnNlRGF0YSA9IHJlcXVpcmUoJy4uL3BhcnNlL2RhdGEnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7ICAgIFxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbn1cblxudmFyIHByb3RvID0gKEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIHRoaXMuX2RlZiAgID0gZGVmO1xuICB0aGlzLl9tYXJrICA9IG1hcms7XG4gIHRoaXMuX2Zyb20gID0gKGRlZi5mcm9tID8gZGVmLmZyb20uZGF0YSA6IG51bGwpIHx8IGluaGVyaXRGcm9tO1xuICB0aGlzLl9kcyAgICA9IGRsLmlzU3RyaW5nKHRoaXMuX2Zyb20pID8gZ3JhcGguZGF0YSh0aGlzLl9mcm9tKSA6IG51bGw7XG4gIHRoaXMuX21hcCAgID0ge307XG5cbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAgLy8gU2hvdWxkIHNjZW5lZ3JhcGggaXRlbXMgdHJhY2sgX3ByZXY/XG5cbiAgbWFyay5kZWYgPSBkZWY7XG4gIG1hcmsubWFya3R5cGUgPSBkZWYudHlwZTtcbiAgbWFyay5pbnRlcmFjdGl2ZSA9ICEoZGVmLmludGVyYWN0aXZlID09PSBmYWxzZSk7XG4gIG1hcmsuaXRlbXMgPSBbXTtcblxuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX3BhcmVudF9pZCA9IHBhcmVudF9pZDtcblxuICBpZihkZWYuZnJvbSAmJiAoZGVmLmZyb20ubWFyayB8fCBkZWYuZnJvbS50cmFuc2Zvcm0gfHwgZGVmLmZyb20ubW9kaWZ5KSkge1xuICAgIGlubGluZURzLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBOb24tZ3JvdXAgbWFyayBidWlsZGVycyBhcmUgc3VwZXIgbm9kZXMuIEVuY29kZXIgYW5kIEJvdW5kZXIgcmVtYWluIFxuICAvLyBzZXBhcmF0ZSBvcGVyYXRvcnMgYnV0IGFyZSBlbWJlZGRlZCBhbmQgY2FsbGVkIGJ5IEJ1aWxkZXIuZXZhbHVhdGUuXG4gIHRoaXMuX2lzU3VwZXIgPSAodGhpcy5fZGVmLnR5cGUgIT09IEMuR1JPVVApOyBcbiAgdGhpcy5fZW5jb2RlciA9IG5ldyBFbmNvZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcbiAgdGhpcy5fYm91bmRlciA9IG5ldyBCb3VuZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcblxuICBpZih0aGlzLl9kcykgeyB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5EQVRBLCB0aGlzLl9mcm9tKTsgfVxuXG4gIC8vIFNpbmNlIEJ1aWxkZXJzIGFyZSBzdXBlciBub2RlcywgY29weSBvdmVyIGVuY29kZXIgZGVwZW5kZW5jaWVzXG4gIC8vIChib3VuZGVyIGhhcyBubyByZWdpc3RlcmVkIGRlcGVuZGVuY2llcykuXG4gIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLkRBVEEpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0NBTEVTLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5TQ0FMRVMpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0lHTkFMUykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKHApIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuXG4gIC8vIElmIHdlJ3ZlIG5vdCBuZWVkZWQgcHJldiBpbiB0aGUgcGFzdCwgYnV0IGEgbmV3IGlubGluZSBkcyBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIGl0ZW1zIGhhdmUgcHJldiBzZXQuXG4gIGlmKCF0aGlzLl9yZXZpc2VzICYmIHApIHtcbiAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfSk7XG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJlYWN0aXZlIGdlb21ldHJ5IGFuZCBtYXJrLWxldmVsIHRyYW5zZm9ybWF0aW9ucyBhcmUgaGFuZGxlZCBoZXJlIFxuLy8gYmVjYXVzZSB0aGV5IG5lZWQgdGhlaXIgZ3JvdXAncyBkYXRhLWpvaW5lZCBjb250ZXh0LiBcbmZ1bmN0aW9uIGlubGluZURzKCkge1xuICB2YXIgZnJvbSA9IHRoaXMuX2RlZi5mcm9tLFxuICAgICAgZ2VvbSA9IGZyb20ubWFyayxcbiAgICAgIHNyYywgbmFtZSwgc3BlYywgc2libGluZywgb3V0cHV0O1xuXG4gIGlmKGdlb20pIHtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fcGFyZW50X2lkLCBnZW9tXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sIFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3JjID0gdGhpcy5fZ3JhcGguZGF0YSh0aGlzLl9mcm9tKTtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGUsIHNyYy5saXN0ZW5lcnModHJ1ZSkubGVuZ3RoXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHNvdXJjZTogdGhpcy5fZnJvbSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sXG4gICAgICBtb2RpZnk6IGZyb20ubW9kaWZ5XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuX2Zyb20gPSBuYW1lO1xuICB0aGlzLl9kcyA9IHBhcnNlRGF0YS5kYXRhc291cmNlKHRoaXMuX2dyYXBoLCBzcGVjKTtcbiAgdmFyIHJldmlzZXMgPSB0aGlzLl9kcy5yZXZpc2VzKCk7XG5cbiAgaWYoZ2VvbSkge1xuICAgIHNpYmxpbmcgPSB0aGlzLnNpYmxpbmcoZ2VvbSkucmV2aXNlcyhyZXZpc2VzKTtcbiAgICBpZihzaWJsaW5nLl9pc1N1cGVyKSBzaWJsaW5nLmFkZExpc3RlbmVyKHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICAgIGVsc2Ugc2libGluZy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9kcy5saXN0ZW5lcigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGEgbmV3IGRhdGFzb3VyY2UgYnV0IGl0IGlzIGVtcHR5IGFzXG4gICAgLy8gdGhlIHByb3BhZ2F0aW9uIGN5Y2xlIGhhcyBhbHJlYWR5IGNyb3NzZWQgdGhlIGRhdGFzb3VyY2VzLiBcbiAgICAvLyBTbywgd2UgcmVwdWxzZSBqdXN0IHRoaXMgZGF0YXNvdXJjZS4gVGhpcyBzaG91bGQgYmUgc2FmZVxuICAgIC8vIGFzIHRoZSBkcyBpc24ndCBjb25uZWN0ZWQgdG8gdGhlIHNjZW5lZ3JhcGggeWV0LlxuICAgIFxuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9kcy5zb3VyY2UoKS5yZXZpc2VzKHJldmlzZXMpLmxhc3QoKTtcbiAgICAgICAgaW5wdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShvdXRwdXQpO1xuXG4gICAgaW5wdXQuYWRkID0gb3V0cHV0LmFkZDtcbiAgICBpbnB1dC5tb2QgPSBvdXRwdXQubW9kO1xuICAgIGlucHV0LnJlbSA9IG91dHB1dC5yZW07XG4gICAgaW5wdXQuc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShpbnB1dCwgdGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gIH1cbn1cblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QodGhpcy5waXBlbGluZSgpKTtcbiAgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0NBTEVTKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBidWlsZGVyLl9wYXJlbnQuc2NhbGUocykuYWRkTGlzdGVuZXIoYnVpbGRlcik7XG4gIH0pO1xuXG4gIGlmKHRoaXMuX3BhcmVudCkge1xuICAgIGlmKHRoaXMuX2lzU3VwZXIpIHRoaXMuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICAgIGVsc2UgdGhpcy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQuX2NvbGxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBpZighdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xuICB0aGlzLl9ncmFwaC5kaXNjb25uZWN0KHRoaXMucGlwZWxpbmUoKSk7XG4gIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNDQUxFUykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgYnVpbGRlci5fcGFyZW50LnNjYWxlKHMpLnJlbW92ZUxpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5zaWJsaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50LmNoaWxkKG5hbWUsIHRoaXMuX3BhcmVudF9pZCk7XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZ1wiLCB0aGlzLl9mcm9tLCB0aGlzLl9kZWYudHlwZV0pO1xuXG4gIHZhciBvdXRwdXQsIGZ1bGxVcGRhdGUsIGZjcywgZGF0YTtcblxuICBpZih0aGlzLl9kcykge1xuICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYW55IGVuY29kZXIgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBlbmNvZGVyJ3MgZGF0YSBzb3VyY2Ugd2lsbCBsaWtlbHkgYmUgdXBkYXRlZCwgYW5kIHNob3VsZG4ndFxuICAgIC8vIHRyaWdnZXIgYWxsIGl0ZW1zIHRvIG1vZC5cbiAgICBkYXRhID0gZGwuZHVwbGljYXRlKG91dHB1dC5kYXRhKTtcbiAgICBkZWxldGUgb3V0cHV0LmRhdGFbdGhpcy5fZHMubmFtZSgpXTtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LmRhdGEgPSBkYXRhO1xuXG4gICAgLy8gSWYgYSBzY2FsZSBvciBzaWduYWwgaW4gdGhlIHVwZGF0ZSBwcm9wc2V0IGhhcyBiZWVuIHVwZGF0ZWQsIFxuICAgIC8vIHNlbmQgZm9yd2FyZCBhbGwgaXRlbXMgZm9yIHJlZW5jb2RpbmcgaWYgd2UgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgIGlmKGZ1bGxVcGRhdGUpIG91dHB1dC5tb2QgPSB0aGlzLl9tYXJrLml0ZW1zLnNsaWNlKCk7XG5cbiAgICBmY3MgPSB0aGlzLl9kcy5sYXN0KCk7XG4gICAgaWYoIWZjcykge1xuICAgICAgb3V0cHV0LnJlZmxvdyA9IHRydWVcbiAgICB9IGVsc2UgaWYoZmNzLnN0YW1wID4gdGhpcy5fc3RhbXApIHtcbiAgICAgIG91dHB1dCA9IGpvaW5EYXRhc291cmNlLmNhbGwodGhpcywgZmNzLCB0aGlzLl9kcy52YWx1ZXMoKSwgZnVsbFVwZGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZ1bGxVcGRhdGUgPSB0aGlzLl9lbmNvZGVyLnJlZXZhbHVhdGUoaW5wdXQpO1xuICAgIGRhdGEgPSBkbC5pc0Z1bmN0aW9uKHRoaXMuX2RlZi5mcm9tKSA/IHRoaXMuX2RlZi5mcm9tKCkgOiBbQy5TRU5USU5FTF07XG4gICAgb3V0cHV0ID0gam9pblZhbHVlcy5jYWxsKHRoaXMsIGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKTtcbiAgfVxuXG4gIG91dHB1dCA9IHRoaXMuX2dyYXBoLmV2YWx1YXRlKG91dHB1dCwgdGhpcy5fZW5jb2Rlcik7XG4gIHJldHVybiB0aGlzLl9pc1N1cGVyID8gdGhpcy5fZ3JhcGguZXZhbHVhdGUob3V0cHV0LCB0aGlzLl9ib3VuZGVyKSA6IG91dHB1dDtcbn07XG5cbmZ1bmN0aW9uIG5ld0l0ZW0oKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQsXG4gICAgICBpdGVtID0gdHVwbGUuaW5nZXN0KG5ldyBJdGVtKHRoaXMuX21hcmspLCBwcmV2KTtcblxuICAvLyBGb3IgdGhlIHJvb3Qgbm9kZSdzIGl0ZW1cbiAgaWYodGhpcy5fZGVmLndpZHRoKSAgdHVwbGUuc2V0KGl0ZW0sIFwid2lkdGhcIiwgIHRoaXMuX2RlZi53aWR0aCk7XG4gIGlmKHRoaXMuX2RlZi5oZWlnaHQpIHR1cGxlLnNldChpdGVtLCBcImhlaWdodFwiLCB0aGlzLl9kZWYuaGVpZ2h0KTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBqb2luKGRhdGEsIGtleWYsIG5leHQsIG91dHB1dCwgcHJldiwgbW9kKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvcihpPTAsIGxlbj1kYXRhLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcbiAgICBpdGVtICA9IGtleWYgPyB0aGlzLl9tYXBba2V5ID0ga2V5ZihkYXR1bSldIDogcHJldltpXTtcbiAgICBlbnRlciA9IGl0ZW0gPyBmYWxzZSA6IChpdGVtID0gbmV3SXRlbS5jYWxsKHRoaXMpLCB0cnVlKTtcbiAgICBpdGVtLnN0YXR1cyA9IGVudGVyID8gQy5FTlRFUiA6IEMuVVBEQVRFO1xuICAgIGl0ZW0uZGF0dW0gPSBkYXR1bTtcbiAgICB0dXBsZS5zZXQoaXRlbSwgXCJrZXlcIiwga2V5KTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IGl0ZW07XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIGlmKGVudGVyKSBvdXRwdXQuYWRkLnB1c2goaXRlbSk7XG4gICAgZWxzZSBpZighbW9kIHx8IChtb2QgJiYgbW9kW2RhdHVtLl9pZF0pKSBvdXRwdXQubW9kLnB1c2goaXRlbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gam9pbkRhdGFzb3VyY2UoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkgfHwgXCJfaWRcIiksXG4gICAgICBhZGQgPSBpbnB1dC5hZGQsIFxuICAgICAgbW9kID0gaW5wdXQubW9kLCBcbiAgICAgIHJlbSA9IGlucHV0LnJlbSxcbiAgICAgIG5leHQgPSBbXSxcbiAgICAgIGksIGtleSwgbGVuLCBpdGVtLCBkYXR1bSwgZW50ZXI7XG5cbiAgLy8gQnVpbGQgcmVtcyBmaXJzdCwgYW5kIHB1dCB0aGVtIGF0IHRoZSBoZWFkIG9mIHRoZSBuZXh0IGl0ZW1zXG4gIC8vIFRoZW4gYnVpbGQgdGhlIHJlc3Qgb2YgdGhlIGRhdGEgdmFsdWVzICh3aGljaCB3b24ndCBjb250YWluIHJlbSkuXG4gIC8vIFRoaXMgd2lsbCBwcmVzZXJ2ZSB0aGUgc29ydCBvcmRlciB3aXRob3V0IG5lZWRpbmcgYW55dGhpbmcgZXh0cmEuXG5cbiAgZm9yKGk9MCwgbGVuPXJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gdGhpcy5fbWFwW2tleSA9IGtleWYocmVtW2ldKV07XG4gICAgaXRlbS5zdGF0dXMgPSBDLkVYSVQ7XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIG91dHB1dC5yZW0ucHVzaChpdGVtKTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IG51bGw7XG4gIH1cblxuICBqb2luLmNhbGwodGhpcywgZGF0YSwga2V5ZiwgbmV4dCwgb3V0cHV0LCBudWxsLCB0dXBsZS5pZE1hcChmdWxsVXBkYXRlID8gZGF0YSA6IG1vZCkpO1xuXG4gIHJldHVybiAodGhpcy5fbWFyay5pdGVtcyA9IG5leHQsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGpvaW5WYWx1ZXMoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkpLFxuICAgICAgcHJldiA9IHRoaXMuX21hcmsuaXRlbXMgfHwgW10sXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuRVhJVDtcbiAgICBpZiAoa2V5ZikgdGhpcy5fbWFwW2l0ZW0ua2V5XSA9IGl0ZW07XG4gIH1cbiAgXG4gIGpvaW4uY2FsbCh0aGlzLCBkYXRhLCBrZXlmLCBuZXh0LCBvdXRwdXQsIHByZXYsIGZ1bGxVcGRhdGUgPyB0dXBsZS5pZE1hcChkYXRhKSA6IG51bGwpO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkge1xuICAgICAgdHVwbGUuc2V0KGl0ZW0sIFwia2V5XCIsIGtleWYgPyBpdGVtLmtleSA6IHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICBuZXh0LnNwbGljZSgwLCAwLCBpdGVtKTsgIC8vIEtlZXAgaXRlbSBhcm91bmQgZm9yIFwiZXhpdFwiIHRyYW5zaXRpb24uXG4gICAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gKHRoaXMuX21hcmsuaXRlbXMgPSBuZXh0LCBvdXRwdXQpO1xufTtcblxuZnVuY3Rpb24ga2V5RnVuY3Rpb24oa2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBmID0gZGwuYXJyYXkoa2V5KS5tYXAoZGwuYWNjZXNzb3IpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIGZvciAodmFyIHM9XCJcIiwgaT0wLCBuPWYubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKGk+MCkgcyArPSBcInxcIjtcbiAgICAgIHMgKz0gU3RyaW5nKGZbaV0oZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEVNUFRZID0ge307XG5cbmZ1bmN0aW9uIEVuY29kZXIoZ3JhcGgsIG1hcmspIHtcbiAgdmFyIHByb3BzID0gbWFyay5kZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIHVwZGF0ZSA9IHByb3BzLnVwZGF0ZTtcblxuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpXG5cbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuXG4gIGlmKHVwZGF0ZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHVwZGF0ZS5kYXRhKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHVwZGF0ZS5zY2FsZXMpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIHVwZGF0ZS5zaWduYWxzKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5GSUVMRFMsIHVwZGF0ZS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChFbmNvZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJlbmNvZGluZ1wiLCB0aGlzLl9tYXJrLmRlZi50eXBlXSk7XG4gIHZhciBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgaXRlbXMgPSB0aGlzLl9tYXJrLml0ZW1zLFxuICAgICAgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgZW50ZXIgID0gcHJvcHMuZW50ZXIsXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUsXG4gICAgICBleGl0ICAgPSBwcm9wcy5leGl0LFxuICAgICAgcHJlZHMgID0gdGhpcy5fZ3JhcGgucHJlZGljYXRlcygpLFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSwgIC8vIEZvciBleHBlZGllbmN5LCBnZXQgYWxsIHNpZ25hbCB2YWx1ZXNcbiAgICAgIGRiID0gZ3JhcGguZGF0YVZhbHVlcygpLCBcbiAgICAgIHJlcSA9IGlucHV0LnJlcXVlc3QsXG4gICAgICBpLCBsZW4sIGl0ZW0sIHByb3A7XG5cbiAgaWYocmVxKSB7XG4gICAgaWYocHJvcCA9IHByb3BzW3JlcV0pIHtcbiAgICAgIGZvcihpPTAsIGxlbj1pbnB1dC5tb2QubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICAgIGVuY29kZS5jYWxsKHRoaXMsIHByb3AsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7IC8vIGV4aXQgZWFybHkgaWYgZ2l2ZW4gcmVxdWVzdFxuICB9XG5cbiAgLy8gSXRlbXMgbWFya2VkIGZvciByZW1vdmFsIGFyZSBhdCB0aGUgaGVhZCBvZiBpdGVtcy4gUHJvY2VzcyB0aGVtIGZpcnN0LlxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5yZW1baV07XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpZihleGl0KSAgIGVuY29kZS5jYWxsKHRoaXMsIGV4aXQsICAgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpOyBcbiAgICBpZihpbnB1dC50cmFucyAmJiAhZXhpdCkgaW5wdXQudHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgRU1QVFkpO1xuICAgIGVsc2UgaWYoIWlucHV0LnRyYW5zKSBpdGVtLnJlbW92ZSgpO1xuICB9XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmKGVudGVyKSAgZW5jb2RlLmNhbGwodGhpcywgZW50ZXIsICBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcyk7XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuVVBEQVRFO1xuICB9XG5cbiAgaWYodXBkYXRlKSB7XG4gICAgZm9yKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGUocHJvcCwgaXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMpIHtcbiAgdmFyIGVuYyA9IHByb3AuZW5jb2RlO1xuICBlbmMuY2FsbChlbmMsIGl0ZW0sIGl0ZW0ubWFyay5ncm91cHx8aXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMpO1xufVxuXG4vLyBJZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBzZXQgY2FsbGVkLCBvciB1cGRhdGUgcHJvcGVydHkgc2V0IFxuLy8gdXNlcyBuZXN0ZWQgZmllbGRyZWZzLCByZWV2YWx1YXRlIGFsbCBpdGVtcy5cbnByb3RvLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlO1xuXG4gIHJldHVybiBwdWxzZS5yZXF1ZXN0IHx8IFxuICAgIE5vZGUucHJvdG90eXBlLnJlZXZhbHVhdGUuY2FsbCh0aGlzLCBwdWxzZSkgfHwgXG4gICAgKHVwZGF0ZSA/IHVwZGF0ZS5yZWZsb3cgOiBmYWxzZSk7XG59O1xuXG4vLyBTaG9ydC1jaXJjdWl0IGVuY29kZXIgaWYgdXNlciBzcGVjaWZpZXMgaXRlbXNcbkVuY29kZXIudXBkYXRlID0gZnVuY3Rpb24oZ3JhcGgsIHRyYW5zLCByZXF1ZXN0LCBpdGVtcykge1xuICBpdGVtcyA9IGRsLmFycmF5KGl0ZW1zKTtcbiAgdmFyIHByZWRzID0gZ3JhcGgucHJlZGljYXRlcygpLCBcbiAgICAgIGRiID0gZ3JhcGguZGF0YVZhbHVlcygpLFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSxcbiAgICAgIGksIGxlbiwgaXRlbSwgcHJvcHMsIHByb3A7XG5cbiAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgcHJvcHMgPSBpdGVtLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gICAgcHJvcCA9IHByb3BzICYmIHByb3BzW3JlcXVlc3RdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBlbmNvZGUuY2FsbChudWxsLCBwcm9wLCBpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcyk7XG4gICAgICBib3VuZHMuaXRlbShpdGVtKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKSxcbiAgICBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBwYXJzZUF4ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9heGVzJyksXG4gICAgcGFyc2VMZWdlbmRzID0gcmVxdWlyZSgnLi4vcGFyc2UvbGVnZW5kcycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBHcm91cEJ1aWxkZXIoKSB7XG4gIHRoaXMuX2NoaWxkcmVuID0ge307XG4gIHRoaXMuX3NjYWxlciA9IG51bGw7XG4gIHRoaXMuX3JlY3Vyc29yID0gbnVsbDtcblxuICB0aGlzLl9zY2FsZXMgPSB7fTtcbiAgdGhpcy5zY2FsZSA9IHNjYWxlLmJpbmQodGhpcyk7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoR3JvdXBCdWlsZGVyLnByb3RvdHlwZSA9IG5ldyBCdWlsZGVyKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgsIGRlZiwgbWFyaywgcGFyZW50LCBwYXJlbnRfaWQsIGluaGVyaXRGcm9tKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcblxuICB0aGlzLl9zY2FsZXIgPSBuZXcgTm9kZShncmFwaCk7XG5cbiAgKGRlZi5zY2FsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgXG4gICAgcyA9IGJ1aWxkZXIuc2NhbGUocy5uYW1lLCBuZXcgU2NhbGUoZ3JhcGgsIHMsIGJ1aWxkZXIpKTtcbiAgICBidWlsZGVyLl9zY2FsZXIuYWRkTGlzdGVuZXIocyk7ICAvLyBTY2FsZXMgc2hvdWxkIGJlIGNvbXB1dGVkIGFmdGVyIGdyb3VwIGlzIGVuY29kZWRcbiAgfSk7XG5cbiAgdGhpcy5fcmVjdXJzb3IgPSBuZXcgTm9kZShncmFwaCk7XG4gIHRoaXMuX3JlY3Vyc29yLmV2YWx1YXRlID0gcmVjdXJzZS5iaW5kKHRoaXMpO1xuXG4gIHZhciBzY2FsZXMgPSAoZGVmLmF4ZXN8fFtdKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KSB7XG4gICAgcmV0dXJuIChhY2NbeC5zY2FsZV0gPSAxLCBhY2MpO1xuICB9LCB7fSk7XG5cbiAgc2NhbGVzID0gKGRlZi5sZWdlbmRzfHxbXSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiAoYWNjW3guc2l6ZSB8fCB4LnNoYXBlIHx8IHguZmlsbCB8fCB4LnN0cm9rZV0sIGFjYyk7XG4gIH0sIHNjYWxlcyk7XG5cbiAgdGhpcy5fcmVjdXJzb3IuZGVwZW5kZW5jeShDLlNDQUxFUywgZGwua2V5cyhzY2FsZXMpKTtcblxuICAvLyBXZSBvbmx5IG5lZWQgYSBjb2xsZWN0b3IgZm9yIHVwLXByb3BhZ2F0aW9uIG9mIGJvdW5kcyBjYWxjdWxhdGlvbixcbiAgLy8gc28gb25seSBHcm91cEJ1aWxkZXJzLCBhbmQgbm90IHJlZ3VsYXIgQnVpbGRlcnMsIGhhdmUgY29sbGVjdG9ycy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG5cbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IEJ1aWxkZXIucHJvdG90eXBlLmV2YWx1YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgYnVpbGRHcm91cC5jYWxsKGJ1aWxkZXIsIG91dHB1dCwgZ3JvdXApOyB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcywgdGhpcy5fc2NhbGVyLCB0aGlzLl9yZWN1cnNvciwgdGhpcy5fY29sbGVjdG9yLCB0aGlzLl9ib3VuZGVyXTtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBkbC5rZXlzKGJ1aWxkZXIuX2NoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwX2lkKSB7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXBfaWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7XG4gICAgfSlcbiAgfSk7XG5cbiAgYnVpbGRlci5fY2hpbGRyZW4gPSB7fTtcbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLmNoaWxkID0gZnVuY3Rpb24obmFtZSwgZ3JvdXBfaWQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bZ3JvdXBfaWRdLFxuICAgICAgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGNoaWxkO1xuXG4gIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmKGNoaWxkLnR5cGUgPT0gQy5NQVJLICYmIGNoaWxkLmJ1aWxkZXIuX2RlZi5uYW1lID09IG5hbWUpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkLmJ1aWxkZXI7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNlKGlucHV0KSB7XG4gIHZhciBidWlsZGVyID0gdGhpcyxcbiAgICAgIGhhc01hcmtzID0gZGwuYXJyYXkodGhpcy5fZGVmLm1hcmtzKS5sZW5ndGggPiAwLFxuICAgICAgaGFzQXhlcyA9IGRsLmFycmF5KHRoaXMuX2RlZi5heGVzKS5sZW5ndGggPiAwLFxuICAgICAgaGFzTGVnZW5kcyA9IGRsLmFycmF5KHRoaXMuX2RlZi5sZWdlbmRzKS5sZW5ndGggPiAwLFxuICAgICAgaSwgbGVuLCBncm91cCwgcGlwZWxpbmUsIGRlZiwgaW5saW5lID0gZmFsc2U7XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0LmFkZFtpXTtcbiAgICBpZihoYXNNYXJrcykgYnVpbGRNYXJrcy5jYWxsKHRoaXMsIGlucHV0LCBncm91cCk7XG4gICAgaWYoaGFzQXhlcykgIGJ1aWxkQXhlcy5jYWxsKHRoaXMsIGlucHV0LCBncm91cCk7XG4gICAgaWYoaGFzTGVnZW5kcykgYnVpbGRMZWdlbmRzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIFdpcmUgdXAgbmV3IGNoaWxkcmVuIGJ1aWxkZXJzIGluIHJldmVyc2UgdG8gbWluaW1pemUgZ3JhcGggcmV3cml0ZXMuXG4gIGZvciAoaT1pbnB1dC5hZGQubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGZvciAoaj10aGlzLl9jaGlsZHJlbltncm91cC5faWRdLmxlbmd0aC0xOyBqPj0wOyAtLWopIHtcbiAgICAgIGMgPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdW2pdO1xuICAgICAgYy5idWlsZGVyLmNvbm5lY3QoKTtcbiAgICAgIHBpcGVsaW5lID0gYy5idWlsZGVyLnBpcGVsaW5lKCk7XG4gICAgICBkZWYgPSBjLmJ1aWxkZXIuX2RlZjtcblxuICAgICAgLy8gVGhpcyBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYnVpbHQgZHVyaW5nIHRoaXMgcHJvcGFnYXRpb24gY3ljbGUuXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgaXRzIGJ1aWxkZXIgYXMgYSBsaXN0ZW5lciBvZmYgdGhlIF9yZWN1cnNvciBub2RlLCBcbiAgICAgIC8vIGJ1dCB0cnkgdG8gaW5saW5lIGl0IGlmIHdlIGNhbiB0byBtaW5pbWl6ZSBncmFwaCBkaXNwYXRjaGVzLlxuICAgICAgaW5saW5lID0gKGRlZi50eXBlICE9PSBDLkdST1VQKTtcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAodGhpcy5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQpOyBcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAocGlwZWxpbmVbcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpLmxlbmd0aCA9PSAxKTsgLy8gUmVhY3RpdmUgZ2VvbVxuICAgICAgYy5pbmxpbmUgPSBpbmxpbmU7XG5cbiAgICAgIGlmKGlubGluZSkgYy5idWlsZGVyLmV2YWx1YXRlKGlucHV0KTtcbiAgICAgIGVsc2UgdGhpcy5fcmVjdXJzb3IuYWRkTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQubW9kW2ldO1xuICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY29ubmVjdGlvbiBmb3IgbWFya3MgdGhhdCBkcmF3IGZyb20gYSBzb3VyY2VcbiAgICBpZihoYXNNYXJrcykge1xuICAgICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYoYy50eXBlID09IEMuTUFSSyAmJiAhYy5pbmxpbmUgJiYgYnVpbGRlci5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGF4ZXMgZGF0YSBkZWZzXG4gICAgaWYoaGFzQXhlcykge1xuICAgICAgcGFyc2VBeGVzKGJ1aWxkZXIuX2dyYXBoLCBidWlsZGVyLl9kZWYuYXhlcywgZ3JvdXAuYXhlcywgZ3JvdXApO1xuICAgICAgZ3JvdXAuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHsgYS5kZWYoKSB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbGVnZW5kIGRhdGEgZGVmc1xuICAgIGlmKGhhc0xlZ2VuZHMpIHtcbiAgICAgIHBhcnNlTGVnZW5kcyhidWlsZGVyLl9ncmFwaCwgYnVpbGRlci5fZGVmLmxlZ2VuZHMsIGdyb3VwLmxlZ2VuZHMsIGdyb3VwKTtcbiAgICAgIGdyb3VwLmxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbihsLCBpKSB7IGwuZGVmKCkgfSk7XG4gICAgfSAgIFxuICB9XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LnJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0LnJlbVtpXTtcbiAgICAvLyBGb3IgZGVsZXRlZCBncm91cHMsIGRpc2Nvbm5lY3QgdGhlaXIgY2hpbGRyZW5cbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLmZvckVhY2goZnVuY3Rpb24oYykgeyBcbiAgICAgIGJ1aWxkZXIuX3JlY3Vyc29yLnJlbW92ZUxpc3RlbmVyKGMuYnVpbGRlcik7XG4gICAgICBjLmJ1aWxkZXIuZGlzY29ubmVjdCgpOyBcbiAgICB9KTtcbiAgICBkZWxldGUgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmZ1bmN0aW9uIHNjYWxlKG5hbWUsIHNjYWxlKSB7XG4gIHZhciBncm91cCA9IHRoaXM7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHJldHVybiAoZ3JvdXAuX3NjYWxlc1tuYW1lXSA9IHNjYWxlLCBzY2FsZSk7XG4gIHdoaWxlKHNjYWxlID09IG51bGwpIHtcbiAgICBzY2FsZSA9IGdyb3VwLl9zY2FsZXNbbmFtZV07XG4gICAgZ3JvdXAgPSBncm91cC5tYXJrID8gZ3JvdXAubWFyay5ncm91cCA6IGdyb3VwLl9wYXJlbnQ7XG4gICAgaWYoIWdyb3VwKSBicmVhaztcbiAgfVxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkR3JvdXAoaW5wdXQsIGdyb3VwKSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZyBncm91cFwiLCBncm91cC5faWRdKTtcblxuICBncm91cC5fc2NhbGVzID0gZ3JvdXAuX3NjYWxlcyB8fCB7fTsgICAgXG4gIGdyb3VwLnNjYWxlICA9IHNjYWxlLmJpbmQoZ3JvdXApO1xuXG4gIGdyb3VwLml0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgW107XG4gIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdIHx8IFtdO1xuXG4gIGdyb3VwLmF4ZXMgPSBncm91cC5heGVzIHx8IFtdO1xuICBncm91cC5heGlzSXRlbXMgPSBncm91cC5heGlzSXRlbXMgfHwgW107XG5cbiAgZ3JvdXAubGVnZW5kcyA9IGdyb3VwLmxlZ2VuZHMgfHwgW107XG4gIGdyb3VwLmxlZ2VuZEl0ZW1zID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW107XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWFya3MoaW5wdXQsIGdyb3VwKSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZyBtYXJrc1wiLCBncm91cC5faWRdKTtcbiAgdmFyIG1hcmtzID0gdGhpcy5fZGVmLm1hcmtzLFxuICAgICAgbGlzdGVuZXJzID0gW10sXG4gICAgICBtYXJrLCBmcm9tLCBpbmhlcml0LCBpLCBsZW4sIG0sIGI7XG5cbiAgZm9yKGk9MCwgbGVuPW1hcmtzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG1hcmsgPSBtYXJrc1tpXTtcbiAgICBmcm9tID0gbWFyay5mcm9tIHx8IHt9O1xuICAgIGluaGVyaXQgPSBcInZnX1wiK2dyb3VwLmRhdHVtLl9pZDtcbiAgICBncm91cC5pdGVtc1tpXSA9IHtncm91cDogZ3JvdXB9O1xuICAgIGIgPSAobWFyay50eXBlID09PSBDLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KHRoaXMuX2dyYXBoLCBtYXJrLCBncm91cC5pdGVtc1tpXSwgdGhpcywgZ3JvdXAuX2lkLCBpbmhlcml0KTtcbiAgICB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBcbiAgICAgIGJ1aWxkZXI6IGIsIFxuICAgICAgZnJvbTogZnJvbS5kYXRhIHx8IChmcm9tLm1hcmsgPyAoXCJ2Z19cIiArIGdyb3VwLl9pZCArIFwiX1wiICsgZnJvbS5tYXJrKSA6IGluaGVyaXQpLCBcbiAgICAgIHR5cGU6IEMuTUFSSyBcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEF4ZXMoaW5wdXQsIGdyb3VwKSB7XG4gIHZhciBheGVzID0gZ3JvdXAuYXhlcyxcbiAgICAgIGF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHBhcnNlQXhlcyh0aGlzLl9ncmFwaCwgdGhpcy5fZGVmLmF4ZXMsIGF4ZXMsIGdyb3VwKTtcbiAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHtcbiAgICB2YXIgc2NhbGUgPSBidWlsZGVyLl9kZWYuYXhlc1tpXS5zY2FsZSxcbiAgICAgICAgZGVmID0gYS5kZWYoKSxcbiAgICAgICAgYiA9IG51bGw7XG5cbiAgICBheGlzSXRlbXNbaV0gPSB7Z3JvdXA6IGdyb3VwLCBheGlzRGVmOiBkZWZ9O1xuICAgIGIgPSAoZGVmLnR5cGUgPT09IEMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQoYnVpbGRlci5fZ3JhcGgsIGRlZiwgYXhpc0l0ZW1zW2ldLCBidWlsZGVyKVxuICAgICAgLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHNjYWxlKTtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBidWlsZGVyOiBiLCB0eXBlOiBDLkFYSVMsIHNjYWxlOiBzY2FsZSB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGVnZW5kcyhpbnB1dCwgZ3JvdXApIHtcbiAgdmFyIGxlZ2VuZHMgPSBncm91cC5sZWdlbmRzLFxuICAgICAgbGVnZW5kSXRlbXMgPSBncm91cC5sZWdlbmRJdGVtcyxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHBhcnNlTGVnZW5kcyh0aGlzLl9ncmFwaCwgdGhpcy5fZGVmLmxlZ2VuZHMsIGxlZ2VuZHMsIGdyb3VwKTtcbiAgbGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGwsIGkpIHtcbiAgICB2YXIgc2NhbGUgPSBsLnNpemUoKSB8fCBsLnNoYXBlKCkgfHwgbC5maWxsKCkgfHwgbC5zdHJva2UoKSxcbiAgICAgICAgZGVmID0gbC5kZWYoKSxcbiAgICAgICAgYiA9IG51bGw7XG5cbiAgICBsZWdlbmRJdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIGxlZ2VuZERlZjogZGVmfTtcbiAgICBiID0gKGRlZi50eXBlID09PSBDLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KGJ1aWxkZXIuX2dyYXBoLCBkZWYsIGxlZ2VuZEl0ZW1zW2ldLCBidWlsZGVyKVxuICAgICAgLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHNjYWxlKTtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBidWlsZGVyOiBiLCB0eXBlOiBDLkxFR0VORCwgc2NhbGU6IHNjYWxlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ1aWxkZXI7IiwiZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG59XG5cbnZhciBwcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmhhc1Byb3BlcnR5U2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gIHJldHVybiBwcm9wcyAmJiBwcm9wc1tuYW1lXSAhPSBudWxsO1xufTtcblxucHJvdG90eXBlLmNvdXNpbiA9IGZ1bmN0aW9uKG9mZnNldCwgaW5kZXgpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBncm91cCA9IG1hcmsuZ3JvdXAsXG4gICAgICBpaWR4ID0gaW5kZXg9PW51bGwgPyBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgOiBpbmRleCxcbiAgICAgIG1pZHggPSBncm91cC5pdGVtcy5pbmRleE9mKG1hcmspICsgb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXAuaXRlbXNbbWlkeF0uaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGlpZHggPSBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgKyBvZmZzZXQ7XG4gIHJldHVybiBtYXJrLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IHRoaXMsXG4gICAgICBsaXN0ID0gaXRlbS5tYXJrLml0ZW1zLFxuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGkgPj0gMCkgKGk9PT1saXN0Lmxlbmd0aC0xKSA/IGxpc3QucG9wKCkgOiBsaXN0LnNwbGljZShpLCAxKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGF0aENhY2hlKSB0aGlzLnBhdGhDYWNoZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hcmsucGF0aENhY2hlKSB0aGlzLm1hcmsucGF0aENhY2hlID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvQWdncmVnYXRlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIEdST1VQX1BST1BFUlRZID0ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9O1xuXG5mdW5jdGlvbiBTY2FsZShncmFwaCwgZGVmLCBwYXJlbnQpIHtcbiAgdGhpcy5fZGVmICAgICA9IGRlZjtcbiAgdGhpcy5fcGFyZW50ICA9IHBhcmVudDtcbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbn1cblxudmFyIHByb3RvID0gKFNjYWxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZuID0gZnVuY3Rpb24oZ3JvdXApIHsgc2NhbGUuY2FsbChzZWxmLCBncm91cCk7IH07XG5cbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICBpbnB1dC5hZGQuZm9yRWFjaChmbik7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZuKTtcblxuICAvLyBTY2FsZXMgYXJlIGF0IHRoZSBlbmQgb2YgYW4gZW5jb2RpbmcgcGlwZWxpbmUsIHNvIHRoZXkgc2hvdWxkIGZvcndhcmQgYVxuICAvLyByZWZsb3cgcHVsc2UuIFRodXMsIGlmIG11bHRpcGxlIHNjYWxlcyB1cGRhdGUgaW4gdGhlIHBhcmVudCBncm91cCwgd2UgZG9uJ3RcbiAgLy8gcmVldmFsdWF0ZSBjaGlsZCBtYXJrcyBtdWx0aXBsZSB0aW1lcy4gXG4gIGlmICh0aGlzLl91cGRhdGVkKSBpbnB1dC5zY2FsZXNbdGhpcy5fZGVmLm5hbWVdID0gMTtcbiAgcmV0dXJuIGNoYW5nZXNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xufTtcblxuLy8gQWxsIG9mIGEgc2NhbGUncyBkZXBlbmRlbmNpZXMgYXJlIHJlZ2lzdGVyZWQgZHVyaW5nIHByb3BhZ2F0aW9uIGFzIHdlIHBhcnNlXG4vLyBkYXRhUmVmcy4gU28gYSBzY2FsZSBtdXN0IGJlIHJlc3BvbnNpYmxlIGZvciBjb25uZWN0aW5nIGl0c2VsZiB0byBkZXBlbmRlbnRzLlxucHJvdG8uZGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHR5cGUsIGRlcHMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgIGRlcHMgPSBkbC5hcnJheShkZXBzKTtcbiAgICBmb3IodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9ncmFwaFt0eXBlID09IEMuREFUQSA/IEMuREFUQSA6IEMuU0lHTkFMXShkZXBzW2ldKVxuICAgICAgICAuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuZGVwZW5kZW5jeS5jYWxsKHRoaXMsIHR5cGUsIGRlcHMpO1xufTtcblxuZnVuY3Rpb24gc2NhbGUoZ3JvdXApIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9kZWYubmFtZSxcbiAgICAgIHByZXYgPSBuYW1lICsgXCI6cHJldlwiLFxuICAgICAgcyA9IGluc3RhbmNlLmNhbGwodGhpcywgZ3JvdXAuc2NhbGUobmFtZSkpLFxuICAgICAgbSA9IHMudHlwZT09PUMuT1JESU5BTCA/IG9yZGluYWwgOiBxdWFudGl0YXRpdmUsXG4gICAgICBybmcgPSByYW5nZS5jYWxsKHRoaXMsIGdyb3VwKTtcblxuICBtLmNhbGwodGhpcywgcywgcm5nLCBncm91cCk7XG5cbiAgZ3JvdXAuc2NhbGUobmFtZSwgcyk7XG4gIGdyb3VwLnNjYWxlKHByZXYsIGdyb3VwLnNjYWxlKHByZXYpIHx8IHMpO1xuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZShzY2FsZSkge1xuICB2YXIgdHlwZSA9IHRoaXMuX2RlZi50eXBlIHx8IEMuTElORUFSO1xuICBpZiAoIXNjYWxlIHx8IHR5cGUgIT09IHNjYWxlLnR5cGUpIHtcbiAgICB2YXIgY3RvciA9IGNvbmZpZy5zY2FsZVt0eXBlXSB8fCBkMy5zY2FsZVt0eXBlXTtcbiAgICBpZiAoIWN0b3IpIGRsLmVycm9yKFwiVW5yZWNvZ25pemVkIHNjYWxlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgKHNjYWxlID0gY3RvcigpKS50eXBlID0gc2NhbGUudHlwZSB8fCB0eXBlO1xuICAgIHNjYWxlLnNjYWxlTmFtZSA9IHRoaXMuX2RlZi5uYW1lO1xuICAgIHNjYWxlLl9wcmV2ID0ge307XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkb21haW4sIHNvcnQsIHN0ciwgcmVmcywgZGF0YURyaXZlblJhbmdlID0gZmFsc2U7XG4gIFxuICAvLyByYW5nZSBwcmUtcHJvY2Vzc2luZyBmb3IgZGF0YS1kcml2ZW4gcmFuZ2VzXG4gIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpICYmICFkbC5pc0FycmF5KGRlZi5yYW5nZSkpIHtcbiAgICBkYXRhRHJpdmVuUmFuZ2UgPSB0cnVlO1xuICAgIHJuZyA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLlJBTkdFLCBkZWYucmFuZ2UsIHNjYWxlLCBncm91cCk7XG4gIH1cbiAgXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcblxuICBzdHIgPSB0eXBlb2Ygcm5nWzBdID09PSAnc3RyaW5nJztcbiAgaWYgKHN0ciB8fCBybmcubGVuZ3RoID4gMiB8fCBybmcubGVuZ3RoPT09MSB8fCBkYXRhRHJpdmVuUmFuZ2UpIHtcbiAgICBzY2FsZS5yYW5nZShybmcpOyAvLyBjb2xvciBvciBzaGFwZSB2YWx1ZXNcbiAgfSBlbHNlIGlmIChkZWYucG9pbnRzKSB7XG4gICAgc2NhbGUucmFuZ2VQb2ludHMocm5nLCBkZWYucGFkZGluZ3x8MCk7XG4gIH0gZWxzZSBpZiAoZGVmLnJvdW5kIHx8IGRlZi5yb3VuZD09PXVuZGVmaW5lZCkge1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyhybmcsIGRlZi5wYWRkaW5nfHwwKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZS5yYW5nZUJhbmRzKHJuZywgZGVmLnBhZGRpbmd8fDApO1xuICB9XG5cbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXRhdGl2ZShzY2FsZSwgcm5nLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgcHJldiA9IHNjYWxlLl9wcmV2LFxuICAgICAgZG9tYWluLCBpbnRlcnZhbDtcblxuICAvLyBkb21haW5cbiAgZG9tYWluID0gKGRlZi50eXBlID09PSBDLlFVQU5USUxFKVxuICAgID8gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOLCBkZWYuZG9tYWluLCBzY2FsZSwgZ3JvdXApXG4gICAgOiBkb21haW5NaW5NYXguY2FsbCh0aGlzLCBzY2FsZSwgZ3JvdXApO1xuICBpZiAoZG9tYWluICYmICFkbC5lcXVhbChwcmV2LmRvbWFpbiwgZG9tYWluKSkge1xuICAgIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgIHByZXYuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICB9IFxuXG4gIC8vIHJhbmdlXG4gIC8vIHZlcnRpY2FsIHNjYWxlcyBzaG91bGQgZmxpcCBieSBkZWZhdWx0LCBzbyB1c2UgWE9SIGhlcmVcbiAgaWYgKGRlZi5yYW5nZSA9PT0gXCJoZWlnaHRcIikgcm5nID0gcm5nLnJldmVyc2UoKTtcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcbiAgc2NhbGVbZGVmLnJvdW5kICYmIHNjYWxlLnJhbmdlUm91bmQgPyBcInJhbmdlUm91bmRcIiA6IFwicmFuZ2VcIl0ocm5nKTtcbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG5cbiAgLy8gVE9ETzogU3VwcG9ydCBzaWduYWxzIGZvciB0aGVzZSBwcm9wZXJ0aWVzLiBVbnRpbCB0aGVuLCBvbmx5IGV2YWxcbiAgLy8gdGhlbSBvbmNlLlxuICBpZiAodGhpcy5fc3RhbXAgPiAwKSByZXR1cm47XG4gIGlmIChkZWYuZXhwb25lbnQgJiYgZGVmLnR5cGU9PT1DLlBPV0VSKSBzY2FsZS5leHBvbmVudChkZWYuZXhwb25lbnQpO1xuICBpZiAoZGVmLmNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGRlZi5uaWNlKSB7XG4gICAgaWYgKGRlZi50eXBlID09PSBDLlRJTUUpIHtcbiAgICAgIGludGVydmFsID0gZDMudGltZVtkZWYubmljZV07XG4gICAgICBpZiAoIWludGVydmFsKSBkbC5lcnJvcihcIlVucmVjb2duaXplZCBpbnRlcnZhbDogXCIgKyBpbnRlcnZhbCk7XG4gICAgICBzY2FsZS5uaWNlKGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUubmljZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhUmVmKHdoaWNoLCBkZWYsIHNjYWxlLCBncm91cCkge1xuICBpZiAoZGVmID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG4gIGlmIChkbC5pc0FycmF5KGRlZikpIHJldHVybiBkZWYubWFwKHNpZ25hbC5iaW5kKHRoaXMpKTtcblxuICB2YXIgc2VsZiA9IHRoaXMsIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICByZWZzID0gZGVmLmZpZWxkcyB8fCBkbC5hcnJheShkZWYpLFxuICAgICAgdW5pcXVlcyA9IHNjYWxlLnR5cGUgPT09IEMuT1JESU5BTCB8fCBzY2FsZS50eXBlID09PSBDLlFVQU5USUxFLFxuICAgICAgY2sgPSBcIl9cIit3aGljaCxcbiAgICAgIGNhY2hlID0gc2NhbGVbY2tdLFxuICAgICAgY2FjaGVGaWVsZCA9IHtvcHM6IFtdfSwgIC8vIHRoZSBmaWVsZCBhbmQgbWVhc3VyZXMgaW4gdGhlIGFnZ3JlZ2F0b3JcbiAgICAgIHNvcnQgPSBkZWYuc29ydCxcbiAgICAgIGksIHJsZW4sIGosIGZsZW4sIHIsIGZpZWxkcywgZnJvbSwgZGF0YSwga2V5cztcblxuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBzY2FsZVtja10gPSBuZXcgQWdncmVnYXRlKGdyYXBoKTtcbiAgICBjYWNoZUZpZWxkLm9wcyA9IFtdO1xuICAgIGNhY2hlLnNpbmdsZXRvbih0cnVlKTtcbiAgICBpZiAodW5pcXVlcyAmJiBzb3J0KSBjYWNoZUZpZWxkLm9wcy5wdXNoKHNvcnQuc3RhdCk7XG4gIH1cblxuICBmb3IoaT0wLCBybGVuPXJlZnMubGVuZ3RoOyBpPHJsZW47ICsraSkge1xuICAgIHIgPSByZWZzW2ldO1xuICAgIGZyb20gPSByLmRhdGEgfHwgXCJ2Z19cIitncm91cC5kYXR1bS5faWQ7XG4gICAgZGF0YSA9IGdyYXBoLmRhdGEoZnJvbSlcbiAgICAgIC5yZXZpc2VzKHRydWUpXG4gICAgICAubGFzdCgpO1xuXG4gICAgaWYgKGRhdGEuc3RhbXAgPD0gdGhpcy5fc3RhbXApIGNvbnRpbnVlO1xuXG4gICAgZmllbGRzID0gZGwuYXJyYXkoci5maWVsZCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIGlmIChmLnBhcmVudCkgcmV0dXJuIGRsLmFjY2Vzc29yKGYucGFyZW50KShncm91cC5kYXR1bSlcbiAgICAgIHJldHVybiBmOyAvLyBTdHJpbmcgb3Ige1wic2lnbmFsXCJ9XG4gICAgfSk7XG5cbiAgICBpZiAodW5pcXVlcykge1xuICAgICAgY2FjaGVGaWVsZC5uYW1lID0gc29ydCA/IHNvcnQuZmllbGQgOiBcIl9pZFwiO1xuICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKTtcbiAgICAgIGZvciAoaj0wLCBmbGVuPWZpZWxkcy5sZW5ndGg7IGo8ZmxlbjsgKytqKSB7XG4gICAgICAgIGNhY2hlLmdyb3VwX2J5LnNldChjYWNoZSwgZmllbGRzW2pdKVxuICAgICAgICAgIC5ldmFsdWF0ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqPTAsIGZsZW49ZmllbGRzLmxlbmd0aDsgajxmbGVuOyArK2opIHtcbiAgICAgICAgY2FjaGVGaWVsZC5uYW1lID0gZmllbGRzW2pdO1xuICAgICAgICBjYWNoZUZpZWxkLm9wcyAgPSBbQy5NSU4sIEMuTUFYXTtcbiAgICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKSAvLyBUcmVhdCBhcyBmbGF0IGRhdGFzb3VyY2VcbiAgICAgICAgICAuZXZhbHVhdGUoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuREFUQSwgZnJvbSk7XG4gICAgY2FjaGUuZGVwZW5kZW5jeShDLlNJR05BTFMpLmZvckVhY2goZnVuY3Rpb24ocykgeyBzZWxmLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzKSB9KTtcbiAgfVxuXG4gIGRhdGEgPSBjYWNoZS5kYXRhKCk7XG4gIGlmICh1bmlxdWVzKSB7XG4gICAga2V5cyA9IGRsLmtleXMoZGF0YSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaykgeyByZXR1cm4gZGF0YVtrXSAhPSBudWxsOyB9KTtcblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBzb3J0ID0gc29ydC5vcmRlci5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoc29ydC5vcmRlci5zaWduYWwpIDogc29ydC5vcmRlcjtcbiAgICAgIHNvcnQgPSAoc29ydCA9PSBDLkRFU0MgPyBcIi1cIiA6IFwiK1wiKSArIFwidHBsLlwiICsgY2FjaGVGaWVsZC5uYW1lO1xuICAgICAgc29ydCA9IGRsLmNvbXBhcmF0b3Ioc29ydCk7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4geyBrZXk6IGssIHRwbDogZGF0YVtrXS50cGwgfX0pXG4gICAgICAgIC5zb3J0KHNvcnQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gay5rZXk7IH0pO1xuICAgIC8vIH0gZWxzZSB7ICAvLyBcIkZpcnN0IHNlZW5cIiBvcmRlclxuICAgIC8vICAgc29ydCA9IGRsLmNvbXBhcmF0b3IoXCJ0cGwuX2lkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBkYXRhW1wiXCJdOyAvLyBVbnBhY2sgZmxhdCBhZ2dyZWdhdGlvblxuICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCkgPyBbXSA6IFtkYXRhW0MuU0lOR0xFVE9OXS5taW4sIGRhdGFbQy5TSU5HTEVUT05dLm1heF07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lnbmFsKHYpIHtcbiAgdmFyIHMgPSB2LnNpZ25hbCwgcmVmO1xuICBpZiAoIXMpIHJldHVybiB2O1xuICB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTLCAocmVmID0gZGwuZmllbGQocykpWzBdKTtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoLnNpZ25hbFJlZihyZWYpO1xufVxuXG5mdW5jdGlvbiBkb21haW5NaW5NYXgoc2NhbGUsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBkb21haW4gPSBbbnVsbCwgbnVsbF0sIHJlZnMsIHo7XG5cbiAgaWYgKGRlZi5kb21haW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGRvbWFpbiA9ICghZGwuaXNPYmplY3QoZGVmLmRvbWFpbikpID8gZG9tYWluIDpcbiAgICAgIGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuXG4gIHogPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgaWYgKGRlZi5kb21haW5NaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5pc09iamVjdChkZWYuZG9tYWluTWluKSkge1xuICAgICAgaWYgKGRlZi5kb21haW5NaW4uc2lnbmFsKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5kb21haW5NaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluWzBdID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOK0MuTUlOLCBkZWYuZG9tYWluTWluLCBzY2FsZSwgZ3JvdXApWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW5bMF0gPSBkZWYuZG9tYWluTWluO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLmRvbWFpbk1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NYXgpKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1heC5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluW3pdID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1heCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bel0gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4rQy5NQVgsIGRlZi5kb21haW5NYXgsIHNjYWxlLCBncm91cClbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblt6XSA9IGRlZi5kb21haW5NYXg7XG4gICAgfVxuICB9XG4gIGlmIChkZWYudHlwZSAhPT0gQy5MT0cgJiYgZGVmLnR5cGUgIT09IEMuVElNRSAmJiAoZGVmLnplcm8gfHwgZGVmLnplcm89PT11bmRlZmluZWQpKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oMCwgZG9tYWluWzBdKTtcbiAgICBkb21haW5bel0gPSBNYXRoLm1heCgwLCBkb21haW5bel0pO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHJhbmdlKGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBybmcgPSBbbnVsbCwgbnVsbF07XG5cbiAgaWYgKGRlZi5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYucmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoR1JPVVBfUFJPUEVSVFlbZGVmLnJhbmdlXSkge1xuICAgICAgICBybmcgPSBbMCwgZ3JvdXBbZGVmLnJhbmdlXV07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdKSB7XG4gICAgICAgIHJuZyA9IGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGwuZXJyb3IoXCJVbnJlY29naXplZCByYW5nZTogXCIrZGVmLnJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgICAgcm5nID0gZGVmLnJhbmdlLm1hcChzaWduYWwuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZWFybHkgZXhpdFxuICAgIH0gZWxzZSB7XG4gICAgICBybmcgPSBbMCwgZGVmLnJhbmdlXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nWzBdID0gZGVmLnJhbmdlTWluLnNpZ25hbCA/IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZU1pbikgOiBkZWYucmFuZ2VNaW47XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nW3JuZy5sZW5ndGgtMV0gPSBkZWYucmFuZ2VNYXguc2lnbmFsID8gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWF4KSA6IGRlZi5yYW5nZU1heDtcbiAgfVxuICBcbiAgaWYgKGRlZi5yZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmV2ID0gZGVmLnJldmVyc2U7XG4gICAgaWYgKGRsLmlzT2JqZWN0KHJldikpIHtcbiAgICAgIHJldiA9IGRsLmFjY2Vzc29yKHJldi5maWVsZCkoZ3JvdXAuZGF0dW0pO1xuICAgIH1cbiAgICBpZiAocmV2KSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICB9XG4gIFxuICByZXR1cm4gcm5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlOyIsInZhciB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgYm91bmRzQ2FsYyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGR1cmF0aW9uLCBlYXNlKSB7XG4gIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbiB8fCA1MDA7XG4gIHRoaXMuZWFzZSA9IGVhc2UgJiYgZDMuZWFzZShlYXNlKSB8fCBkMy5lYXNlKFwiY3ViaWMtaW4tb3V0XCIpO1xuICB0aGlzLnVwZGF0ZXMgPSB7bmV4dDogbnVsbH07XG59XG5cbnZhciBwcm90b3R5cGUgPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxudmFyIHNraXAgPSB7XG4gIFwidGV4dFwiOiAxLFxuICBcInVybFwiOiAgMVxufTtcblxucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oaXRlbSwgdmFsdWVzLCBzdGFtcCkge1xuICB2YXIga2V5LCBjdXJyLCBuZXh0LCBpbnRlcnAsIGxpc3QgPSBudWxsO1xuXG4gIGZvciAoa2V5IGluIHZhbHVlcykge1xuICAgIGN1cnIgPSBpdGVtW2tleV07XG4gICAgbmV4dCA9IHZhbHVlc1trZXldOyAgICAgIFxuICAgIGlmIChjdXJyICE9PSBuZXh0KSB7XG4gICAgICBpZiAoc2tpcFtrZXldIHx8IGN1cnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBza2lwIGludGVycG9sYXRpb24gZm9yIHNwZWNpZmljIGtleXMgb3IgdW5kZWZpbmVkIHN0YXJ0IHZhbHVlc1xuICAgICAgICB0dXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnIgPT09IFwibnVtYmVyXCIgJiYgIWlzRmluaXRlKGN1cnIpKSB7XG4gICAgICAgIC8vIGZvciBOYU4gb3IgaW5maW5pdGUgbnVtZXJpYyB2YWx1ZXMsIHNraXAgdG8gZmluYWwgdmFsdWVcbiAgICAgICAgdHVwbGUuc2V0KGl0ZW0sIGtleSwgbmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgbG9va3VwIGludGVycG9sYXRvclxuICAgICAgICBpbnRlcnAgPSBkMy5pbnRlcnBvbGF0ZShjdXJyLCBuZXh0KTtcbiAgICAgICAgaW50ZXJwLnByb3BlcnR5ID0ga2V5O1xuICAgICAgICAobGlzdCB8fCAobGlzdD1bXSkpLnB1c2goaW50ZXJwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGlzdCA9PT0gbnVsbCAmJiBpdGVtLnN0YXR1cyA9PT0gQy5FWElUKSB7XG4gICAgbGlzdCA9IFtdOyAvLyBlbnN1cmUgZXhpdGluZyBpdGVtcyBhcmUgaW5jbHVkZWRcbiAgfVxuXG4gIGlmIChsaXN0ICE9IG51bGwpIHtcbiAgICBsaXN0Lml0ZW0gPSBpdGVtO1xuICAgIGxpc3QuZWFzZSA9IGl0ZW0ubWFyay5lYXNlIHx8IHRoaXMuZWFzZTtcbiAgICBsaXN0Lm5leHQgPSB0aGlzLnVwZGF0ZXMubmV4dDtcbiAgICB0aGlzLnVwZGF0ZXMubmV4dCA9IGxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdCA9IHRoaXMsIHByZXYgPSB0LnVwZGF0ZXMsIGN1cnIgPSBwcmV2Lm5leHQ7XG4gIGZvciAoOyBjdXJyIT1udWxsOyBwcmV2PWN1cnIsIGN1cnI9cHJldi5uZXh0KSB7XG4gICAgaWYgKGN1cnIuaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkgY3Vyci5yZW1vdmUgPSB0cnVlO1xuICB9XG4gIHQuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgZDMudGltZXIoZnVuY3Rpb24oZWxhcHNlZCkgeyByZXR1cm4gc3RlcC5jYWxsKHQsIGVsYXBzZWQpOyB9KTtcbn07XG5cbmZ1bmN0aW9uIHN0ZXAoZWxhcHNlZCkge1xuICB2YXIgbGlzdCA9IHRoaXMudXBkYXRlcywgcHJldiA9IGxpc3QsIGN1cnIgPSBwcmV2Lm5leHQsXG4gICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24sXG4gICAgICBpdGVtLCBkZWxheSwgZiwgZSwgaSwgbiwgc3RvcCA9IHRydWU7XG5cbiAgZm9yICg7IGN1cnIhPW51bGw7IHByZXY9Y3VyciwgY3Vycj1wcmV2Lm5leHQpIHtcbiAgICBpdGVtID0gY3Vyci5pdGVtO1xuICAgIGRlbGF5ID0gaXRlbS5kZWxheSB8fCAwO1xuXG4gICAgZiA9IChlbGFwc2VkIC0gZGVsYXkpIC8gZHVyYXRpb247XG4gICAgaWYgKGYgPCAwKSB7IHN0b3AgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBpZiAoZiA+IDEpIGYgPSAxO1xuICAgIGUgPSBjdXJyLmVhc2UoZik7XG5cbiAgICBmb3IgKGk9MCwgbj1jdXJyLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGl0ZW1bY3VycltpXS5wcm9wZXJ0eV0gPSBjdXJyW2ldKGUpO1xuICAgIH1cbiAgICBpdGVtLnRvdWNoKCk7XG4gICAgYm91bmRzQ2FsYy5pdGVtKGl0ZW0pO1xuXG4gICAgaWYgKGYgPT09IDEpIHtcbiAgICAgIGlmIChjdXJyLnJlbW92ZSkgaXRlbS5yZW1vdmUoKTtcbiAgICAgIHByZXYubmV4dCA9IGN1cnIubmV4dDtcbiAgICAgIGN1cnIgPSBwcmV2O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWxsYmFjaygpO1xuICByZXR1cm4gc3RvcDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbjsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIHRwbCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgcGFyc2VNYXJrID0gcmVxdWlyZSgnLi4vcGFyc2UvbWFyaycpO1xuXG5mdW5jdGlvbiBheHMobW9kZWwpIHtcbiAgdmFyIHNjYWxlLFxuICAgICAgb3JpZW50ID0gY29uZmlnLmF4aXMub3JpZW50LFxuICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgIHRpdGxlT2Zmc2V0ID0gY29uZmlnLmF4aXMudGl0bGVPZmZzZXQsXG4gICAgICBheGlzRGVmID0ge30sXG4gICAgICBsYXllciA9IFwiZnJvbnRcIixcbiAgICAgIGdyaWQgPSBmYWxzZSxcbiAgICAgIHRpdGxlID0gbnVsbCxcbiAgICAgIHRpY2tNYWpvclNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tNaW5vclNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tFbmRTaXplID0gY29uZmlnLmF4aXMudGlja1NpemUsXG4gICAgICB0aWNrUGFkZGluZyA9IGNvbmZpZy5heGlzLnBhZGRpbmcsXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXRTdHJpbmcgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXG4gICAgICB0aWNrU3ViZGl2aWRlID0gMCxcbiAgICAgIHRpY2tBcmd1bWVudHMgPSBbY29uZmlnLmF4aXMudGlja3NdLFxuICAgICAgZ3JpZExpbmVTdHlsZSA9IHt9LFxuICAgICAgdGlja0xhYmVsU3R5bGUgPSB7fSxcbiAgICAgIG1ham9yVGlja1N0eWxlID0ge30sXG4gICAgICBtaW5vclRpY2tTdHlsZSA9IHt9LFxuICAgICAgdGl0bGVTdHlsZSA9IHt9LFxuICAgICAgZG9tYWluU3R5bGUgPSB7fSxcbiAgICAgIG0gPSB7IC8vIEF4aXMgbWFya3MgYXMgcmVmZXJlbmNlcyBmb3IgdXBkYXRlc1xuICAgICAgICBncmlkTGluZXM6ICBudWxsLFxuICAgICAgICBtYWpvclRpY2tzOiBudWxsLFxuICAgICAgICBtaW5vclRpY2tzOiBudWxsLFxuICAgICAgICB0aWNrTGFiZWxzOiBudWxsLFxuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIHRpdGxlOiAgbnVsbFxuICAgICAgfTtcblxuICB2YXIgYXhpcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGF4aXNEZWYudHlwZSA9IG51bGw7XG4gIH07XG5cbiAgYXhpcy5kZWYgPSBmdW5jdGlvbigpIHtcbiAgICBpZighYXhpc0RlZi50eXBlKSBheGlzX2RlZihzY2FsZSk7XG5cbiAgICAvLyB0aWNrIGZvcm1hdFxuICAgIHRpY2tGb3JtYXQgPSAhdGlja0Zvcm1hdFN0cmluZyA/IG51bGwgOiAoKHNjYWxlLnR5cGUgPT09ICd0aW1lJylcbiAgICAgID8gZDMudGltZS5mb3JtYXQodGlja0Zvcm1hdFN0cmluZylcbiAgICAgIDogZDMuZm9ybWF0KHRpY2tGb3JtYXRTdHJpbmcpKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICAvLyBXZSBkb24ndCBfcmVhbGx5XyBuZWVkIHRvIG1vZGVsIHRoZXNlIGFzIHR1cGxlcyBhcyBubyBmdXJ0aGVyXG4gICAgLy8gZGF0YSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLiBTbyB3ZSBvcHRpbWl6ZSBmb3IgYSBoaWdoIGNodXJuIHJhdGUuIFxuICAgIHZhciBpbmplc3QgPSBmdW5jdGlvbihkKSB7IHJldHVybiB7ZGF0YTogZH07IH07XG4gICAgdmFyIG1ham9yID0gdGlja1ZhbHVlcyA9PSBudWxsXG4gICAgICA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKVxuICAgICAgOiB0aWNrVmFsdWVzO1xuICAgIHZhciBtaW5vciA9IHZnX2F4aXNTdWJkaXZpZGUoc2NhbGUsIG1ham9yLCB0aWNrU3ViZGl2aWRlKS5tYXAoaW5qZXN0KTtcbiAgICBtYWpvciA9IG1ham9yLm1hcChpbmplc3QpO1xuICAgIHZhciBmbXQgPSB0aWNrRm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiB0aWNrRm9ybWF0O1xuICAgIG1ham9yLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkLmxhYmVsID0gZm10KGQuZGF0YSk7IH0pO1xuICAgIHZhciB0ZGF0YSA9IHRpdGxlID8gW3RpdGxlXS5tYXAoaW5qZXN0KSA6IFtdO1xuXG4gICAgYXhpc0RlZi5tYXJrc1swXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBncmlkID8gbWFqb3IgOiBbXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1ham9yOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWlub3I7IH07XG4gICAgYXhpc0RlZi5tYXJrc1szXS5mcm9tID0gYXhpc0RlZi5tYXJrc1sxXS5mcm9tO1xuICAgIGF4aXNEZWYubWFya3NbNF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gWzFdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbNV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgYXhpc0RlZi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgYXhpc0RlZi5vcmllbnQgPSBvcmllbnQ7XG4gICAgYXhpc0RlZi5sYXllciA9IGxheWVyO1xuICAgIHJldHVybiBheGlzRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGF4aXNfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgc2NhbGUgbWFwcGluZ1xuICAgIHZhciBuZXdTY2FsZSwgb2xkU2NhbGUsIHJhbmdlO1xuICAgIGlmIChzY2FsZS50eXBlID09PSBcIm9yZGluYWxcIikge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjUgKyBzY2FsZS5yYW5nZUJhbmQoKS8yfTtcbiAgICAgIG9sZFNjYWxlID0gbmV3U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUsIG9mZnNldDogMC41fTtcbiAgICAgIG9sZFNjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUrXCI6cHJldlwiLCBvZmZzZXQ6IDAuNX07XG4gICAgfVxuICAgIHJhbmdlID0gdmdfYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpO1xuXG4gICAgLy8gc2V0dXAgYXhpcyBtYXJrc1xuICAgIGlmICghbS5ncmlkTGluZXMpICBtLmdyaWRMaW5lcyAgPSB2Z19heGlzVGlja3MoKTtcbiAgICBpZiAoIW0ubWFqb3JUaWNrcykgbS5tYWpvclRpY2tzID0gdmdfYXhpc1RpY2tzKCk7XG4gICAgaWYgKCFtLm1pbm9yVGlja3MpIG0ubWlub3JUaWNrcyA9IHZnX2F4aXNUaWNrcygpO1xuICAgIGlmICghbS50aWNrTGFiZWxzKSBtLnRpY2tMYWJlbHMgPSB2Z19heGlzVGlja0xhYmVscygpO1xuICAgIGlmICghbS5kb21haW4pIG0uZG9tYWluID0gdmdfYXhpc0RvbWFpbigpO1xuICAgIGlmICghbS50aXRsZSkgIG0udGl0bGUgID0gdmdfYXhpc1RpdGxlKCk7XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2UgPSB7dmFsdWU6IGNvbmZpZy5heGlzLmdyaWRDb2xvcn07XG5cbiAgICAvLyBleHRlbmQgYXhpcyBtYXJrcyBiYXNlZCBvbiBheGlzIG9yaWVudGF0aW9uXG4gICAgdmdfYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5ncmlkTGluZXMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgSW5maW5pdHkpO1xuICAgIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWFqb3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplKTtcbiAgICB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1pbm9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01pbm9yU2l6ZSk7XG4gICAgdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbS50aWNrTGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUsIHRpY2tQYWRkaW5nKTtcblxuICAgIHZnX2F4aXNEb21haW5FeHRlbmQob3JpZW50LCBtLmRvbWFpbiwgcmFuZ2UsIHRpY2tFbmRTaXplKTtcbiAgICB2Z19heGlzVGl0bGVFeHRlbmQob3JpZW50LCBtLnRpdGxlLCByYW5nZSwgdGl0bGVPZmZzZXQpOyAvLyBUT0RPIGdldCBvZmZzZXRcbiAgICBcbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JpZExpbmVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWFqb3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWFqb3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1pbm9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1pbm9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aWNrTGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB0aWNrTGFiZWxTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLCBkb21haW5TdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGl0bGUucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuXG4gICAgdmFyIG1hcmtzID0gW20uZ3JpZExpbmVzLCBtLm1ham9yVGlja3MsIG0ubWlub3JUaWNrcywgbS50aWNrTGFiZWxzLCBtLmRvbWFpbiwgbS50aXRsZV07XG4gICAgZGwuZXh0ZW5kKGF4aXNEZWYsIHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHsgXG4gICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19heGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGVuY29kZTogdmdfYXhpc1VwZGF0ZSxcbiAgICAgICAgICBzY2FsZXM6IFtzY2FsZS5zY2FsZU5hbWVdLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBkYXRhOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBheGlzRGVmLm1hcmtzID0gbWFya3MubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pO1xuICB9O1xuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgaWYgKHNjYWxlICE9PSB4KSB7IHNjYWxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSB4KSB7XG4gICAgICBvcmllbnQgPSB4IGluIHZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBjb25maWcuYXhpcy5vcmllbnQ7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIGlmICh0aXRsZSAhPT0geCkgeyB0aXRsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50cztcbiAgICB0aWNrQXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0U3RyaW5nO1xuICAgIGlmICh0aWNrRm9ybWF0U3RyaW5nICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrTWFqb3JTaXplO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgIG1ham9yID0gK3gsXG4gICAgICAgIG1pbm9yID0gbiA+IDEgPyAreSA6IHRpY2tNYWpvclNpemUsXG4gICAgICAgIGVuZCAgID0gbiA+IDAgPyArYXJndW1lbnRzW25dIDogdGlja01ham9yU2l6ZTtcblxuICAgIGlmICh0aWNrTWFqb3JTaXplICE9PSBtYWpvciB8fFxuICAgICAgICB0aWNrTWlub3JTaXplICE9PSBtaW5vciB8fFxuICAgICAgICB0aWNrRW5kU2l6ZSAhPT0gZW5kKSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHRpY2tNYWpvclNpemUgPSBtYWpvcjtcbiAgICB0aWNrTWlub3JTaXplID0gbWlub3I7XG4gICAgdGlja0VuZFNpemUgPSBlbmQ7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tTdWJkaXZpZGU7XG4gICAgdGlja1N1YmRpdmlkZSA9ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGRsLmlzT2JqZWN0KHgpID8geCA6ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgaWYgKHRpY2tQYWRkaW5nICE9PSAreCkgeyB0aWNrUGFkZGluZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZU9mZnNldDtcbiAgICBpZiAodGl0bGVPZmZzZXQgIT09ICt4KSB7IHRpdGxlT2Zmc2V0ID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmxheWVyID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxheWVyO1xuICAgIGlmIChsYXllciAhPT0geCkgeyBsYXllciA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmdyaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZDtcbiAgICBpZiAoZ3JpZCAhPT0geCkgeyBncmlkID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyaWRMaW5lU3R5bGU7XG4gICAgaWYgKGdyaWRMaW5lU3R5bGUgIT09IHgpIHsgZ3JpZExpbmVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFqb3JUaWNrU3R5bGU7XG4gICAgaWYgKG1ham9yVGlja1N0eWxlICE9PSB4KSB7IG1ham9yVGlja1N0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW5vclRpY2tTdHlsZTtcbiAgICBpZiAobWlub3JUaWNrU3R5bGUgIT09IHgpIHsgbWlub3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tMYWJlbFN0eWxlO1xuICAgIGlmICh0aWNrTGFiZWxTdHlsZSAhPT0geCkgeyB0aWNrTGFiZWxTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVN0eWxlO1xuICAgIGlmICh0aXRsZVN0eWxlICE9PSB4KSB7IHRpdGxlU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpblN0eWxlO1xuICAgIGlmIChkb21haW5TdHlsZSAhPT0geCkgeyBkb21haW5TdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgXG4gIGF4aXMucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gYXhpcztcbn07XG5cbnZhciB2Z19heGlzT3JpZW50cyA9IHt0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19heGlzU3ViZGl2aWRlKHNjYWxlLCB0aWNrcywgbSkge1xuICBzdWJ0aWNrcyA9IFtdO1xuICBpZiAobSAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGV4dGVudCA9IHZnX2F4aXNTY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksXG4gICAgICAgIHN1YnRpY2tzLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0aWNrcy5sZW5ndGgsXG4gICAgICAgIGQgPSAodGlja3NbMV0gLSB0aWNrc1swXSkgLyArK20sXG4gICAgICAgIGosXG4gICAgICAgIHY7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGZvciAoaiA9IG07IC0taiA+IDA7KSB7XG4gICAgICAgIGlmICgodiA9ICt0aWNrc1tpXSAtIGogKiBkKSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICBzdWJ0aWNrcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoLS1pLCBqID0gMDsgKytqIDwgbSAmJiAodiA9ICt0aWNrc1tpXSArIGogKiBkKSA8IGV4dGVudFsxXTspIHtcbiAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJ0aWNrcztcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1NjYWxlRXh0ZW50KGRvbWFpbikge1xuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNTY2FsZVJhbmdlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudFxuICAgID8gc2NhbGUucmFuZ2VFeHRlbnQoKVxuICAgIDogdmdfYXhpc1NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xufVxuXG52YXIgdmdfYXhpc0FsaWduID0ge1xuICBib3R0b206IFwiY2VudGVyXCIsXG4gIHRvcDogXCJjZW50ZXJcIixcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCJcbn07XG5cbnZhciB2Z19heGlzQmFzZWxpbmUgPSB7XG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiLFxuICBsZWZ0OiBcIm1pZGRsZVwiLFxuICByaWdodDogXCJtaWRkbGVcIlxufTtcblxuZnVuY3Rpb24gdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUsIHBhZCkge1xuICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCkgKyBwYWQ7XG4gIGlmIChvcmllbnQgPT09IFwibGVmdFwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIHNpemUgKj0gLTE7XG4gIH0gIFxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogb2xkU2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IG5ld1NjYWxlLFxuICAgICAgeToge3ZhbHVlOiBzaXplfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6IFwiY2VudGVyXCJ9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogdmdfYXhpc0Jhc2VsaW5lW29yaWVudF19XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogb2xkU2NhbGUsXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG5ld1NjYWxlLFxuICAgICAgYWxpZ246IHt2YWx1ZTogdmdfYXhpc0FsaWduW29yaWVudF19LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCB0aWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCBzaXplKSB7XG4gIHZhciBzaWduID0gKG9yaWVudCA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSA/IC0xIDogMTtcbiAgaWYgKHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgc2l6ZSA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKVxuICAgICAgPyB7ZmllbGQ6IHtncm91cDogXCJoZWlnaHRcIiwgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn1cbiAgICAgIDoge2ZpZWxkOiB7Z3JvdXA6IFwid2lkdGhcIiwgIGxldmVsOiAyfSwgbXVsdDogLXNpZ259O1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB7dmFsdWU6IHNpZ24gKiBzaXplfTtcbiAgfVxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAgb2xkU2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAgbmV3U2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgIH0pOyAgICAgICAgXG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgb2xkU2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgbmV3U2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5leGl0LCB7XG4gICAgICB5OiAgbmV3U2NhbGUsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlRXh0ZW5kKG9yaWVudCwgdGl0bGUsIHJhbmdlLCBvZmZzZXQpIHtcbiAgdmFyIG1pZCA9IH5+KChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDIpLFxuICAgICAgc2lnbiA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikgPyAtMSA6IDE7XG4gIFxuICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBtaWR9LFxuICAgICAgeToge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICB5OiB7dmFsdWU6IG1pZH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAtOTB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc0RvbWFpbkV4dGVuZChvcmllbnQsIGRvbWFpbiwgcmFuZ2UsIHNpemUpIHtcbiAgdmFyIHBhdGg7XG4gIGlmIChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikge1xuICAgIHNpemUgPSAtMSAqIHNpemU7XG4gIH1cbiAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICBwYXRoID0gXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2l6ZSArIFwiVjBIXCIgKyByYW5nZVsxXSArIFwiVlwiICsgc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gXCJNXCIgKyBzaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2l6ZTtcbiAgfVxuICBkb21haW4ucHJvcGVydGllcy51cGRhdGUucGF0aCA9IHt2YWx1ZTogcGF0aH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNVcGRhdGUoaXRlbSwgZ3JvdXAsIHRyYW5zLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykge1xuICB2YXIgbyA9IHRyYW5zID8ge30gOiBpdGVtLFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHdpZHRoICA9IGdyb3VwLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZ3JvdXAuaGVpZ2h0OyAvLyBUT0RPIGZhbGxiYWNrIHRvIGdsb2JhbCB3LGg/XG5cbiAgaWYgKGRsLmlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSAtZ3JvdXAuc2NhbGUob2Zmc2V0LnNjYWxlKShvZmZzZXQudmFsdWUpO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFwibGVmdFwiOiAgIHsgdHBsLnNldChvLCAneCcsIC1vZmZzZXQpOyB0cGwuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgY2FzZSBcInJpZ2h0XCI6ICB7IHRwbC5zZXQobywgJ3gnLCB3aWR0aCArIG9mZnNldCk7IHRwbC5zZXQobywgJ3knLCAwKTsgYnJlYWs7IH1cbiAgICBjYXNlIFwiYm90dG9tXCI6IHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgaGVpZ2h0ICsgb2Zmc2V0KTsgYnJlYWs7IH1cbiAgICBjYXNlIFwidG9wXCI6ICAgIHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgLW9mZnNldCk7IGJyZWFrOyB9XG4gICAgZGVmYXVsdDogICAgICAgeyB0cGwuc2V0KG8sICd4JywgMCk7IHRwbC5zZXQobywgJ3knLCAwKTsgfVxuICB9XG5cbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpY2tzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicnVsZVwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHN0cm9rZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrV2lkdGh9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja0xhYmVscygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbEZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250U2l6ZX0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJsYWJlbFwifVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250V2VpZ2h0fSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUNvbG9yfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogXCJjZW50ZXJcIn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IFwibWlkZGxlXCJ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwiZGF0YVwifVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNEb21haW4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwYXRoXCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgeToge3ZhbHVlOiAwLjV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc1dpZHRofVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhzO1xuIiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgcGFyc2VQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vcGFyc2UvcHJvcGVydGllcycpLFxuICAgIHBhcnNlTWFyayA9IHJlcXVpcmUoJy4uL3BhcnNlL21hcmsnKSxcbiAgICBHcmFkaWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvR3JhZGllbnQnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpO1xuXG5mdW5jdGlvbiBsZ25kKG1vZGVsKSB7XG4gIHZhciBzaXplID0gbnVsbCxcbiAgICAgIHNoYXBlID0gbnVsbCxcbiAgICAgIGZpbGwgPSBudWxsLFxuICAgICAgc3Ryb2tlID0gbnVsbCxcbiAgICAgIHNwYWNpbmcgPSBudWxsLFxuICAgICAgdmFsdWVzID0gbnVsbCxcbiAgICAgIGZvcm1hdCA9IG51bGwsXG4gICAgICBmb3JtYXRTdHJpbmcgPSBudWxsLFxuICAgICAgdGl0bGUgPSB1bmRlZmluZWQsXG4gICAgICBvcmllbnQgPSBcInJpZ2h0XCIsXG4gICAgICBvZmZzZXQgPSBjb25maWcubGVnZW5kLm9mZnNldCxcbiAgICAgIHBhZGRpbmcgPSBjb25maWcubGVnZW5kLnBhZGRpbmcsXG4gICAgICBsZWdlbmREZWYsXG4gICAgICB0aWNrQXJndW1lbnRzID0gWzVdLFxuICAgICAgbGVnZW5kU3R5bGUgPSB7fSxcbiAgICAgIHN5bWJvbFN0eWxlID0ge30sXG4gICAgICBncmFkaWVudFN0eWxlID0ge30sXG4gICAgICB0aXRsZVN0eWxlID0ge30sXG4gICAgICBsYWJlbFN0eWxlID0ge30sXG4gICAgICBtID0geyAvLyBMZWdlbmQgbWFya3MgYXMgcmVmZXJlbmNlcyBmb3IgdXBkYXRlc1xuICAgICAgICB0aXRsZXM6ICBudWxsLFxuICAgICAgICBzeW1ib2xzOiBudWxsLFxuICAgICAgICBsYWJlbHM6ICBudWxsLFxuICAgICAgICBncmFkaWVudDogbnVsbFxuICAgICAgfTtcblxuICB2YXIgbGVnZW5kID0ge30sXG4gICAgICBsZWdlbmREZWYgPSB7fTtcblxuICBmdW5jdGlvbiByZXNldCgpIHsgbGVnZW5kRGVmLnR5cGUgPSBudWxsOyB9XG4gIGZ1bmN0aW9uIGluZ2VzdChkLCBpKSB7IHJldHVybiB7ZGF0YTogZCwgaW5kZXg6IGl9IH1cblxuICBsZWdlbmQuZGVmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gc2l6ZSB8fCBzaGFwZSB8fCBmaWxsIHx8IHN0cm9rZTtcbiAgICBcbiAgICBmb3JtYXQgPSAhZm9ybWF0U3RyaW5nID8gbnVsbCA6ICgoc2NhbGUudHlwZSA9PT0gJ3RpbWUnKVxuICAgICAgPyBkMy50aW1lLmZvcm1hdChmb3JtYXRTdHJpbmcpXG4gICAgICA6IGQzLmZvcm1hdChmb3JtYXRTdHJpbmcpKTtcbiAgICBcbiAgICBpZiAoIWxlZ2VuZERlZi50eXBlKSB7XG4gICAgICBsZWdlbmREZWYgPSAoc2NhbGU9PT1maWxsIHx8IHNjYWxlPT09c3Ryb2tlKSAmJiAhZGlzY3JldGUoc2NhbGUudHlwZSlcbiAgICAgICAgPyBxdWFudERlZihzY2FsZSlcbiAgICAgICAgOiBvcmRpbmFsRGVmKHNjYWxlKTsgICAgICBcbiAgICB9XG4gICAgbGVnZW5kRGVmLm9yaWVudCA9IG9yaWVudDtcbiAgICBsZWdlbmREZWYub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxlZ2VuZERlZi5wYWRkaW5nID0gcGFkZGluZztcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpc2NyZXRlKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZT09PVwib3JkaW5hbFwiIHx8IHR5cGU9PT1cInF1YW50aXplXCJcbiAgICAgIHx8IHR5cGU9PT1cInF1YW50aWxlXCIgfHwgdHlwZT09PVwidGhyZXNob2xkXCI7XG4gIH1cblxuICBmdW5jdGlvbiBvcmRpbmFsRGVmKHNjYWxlKSB7XG4gICAgdmFyIGRlZiA9IG9fbGVnZW5kX2RlZihzaXplLCBzaGFwZSwgZmlsbCwgc3Ryb2tlKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICB2YXIgZGF0YSA9ICh2YWx1ZXMgPT0gbnVsbFxuICAgICAgPyAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcy5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBzY2FsZS5kb21haW4oKSlcbiAgICAgIDogdmFsdWVzKS5tYXAoaW5nZXN0KTtcbiAgICB2YXIgZm10ID0gZm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiBmb3JtYXQ7XG4gICAgXG4gICAgLy8gZGV0ZXJtaW5lIHNwYWNpbmcgYmV0d2VlbiBsZWdlbmQgZW50cmllc1xuICAgIHZhciBmcywgcmFuZ2UsIG9mZnNldCwgcGFkPTUsIGRvbWFpbiA9IGQzLnJhbmdlKGRhdGEubGVuZ3RoKTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgcmFuZ2UgPSBkYXRhLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnNxcnQoc2l6ZSh4LmRhdGEpKTsgfSk7XG4gICAgICBvZmZzZXQgPSBkMy5tYXgocmFuZ2UpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5yZWR1Y2UoZnVuY3Rpb24oYSxiLGkseikge1xuICAgICAgICAgIGlmIChpID4gMCkgYVtpXSA9IGFbaS0xXSArIHpbaS0xXS8yICsgcGFkO1xuICAgICAgICAgIHJldHVybiAoYVtpXSArPSBiLzIsIGEpOyB9LCBbMF0pLm1hcChNYXRoLnJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoY29uZmlnLmxlZ2VuZC5zeW1ib2xTaXplKSk7XG4gICAgICByYW5nZSA9IHNwYWNpbmdcbiAgICAgICAgfHwgKGZzID0gbGFiZWxTdHlsZS5mb250U2l6ZSkgJiYgKGZzLnZhbHVlICsgcGFkKVxuICAgICAgICB8fCAoY29uZmlnLmxlZ2VuZC5sYWJlbEZvbnRTaXplICsgcGFkKTtcbiAgICAgIHJhbmdlID0gZG9tYWluLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQob2Zmc2V0LzIgKyBpKnJhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFjY291bnQgZm9yIHBhZGRpbmcgYW5kIHRpdGxlIHNpemVcbiAgICB2YXIgc3ogPSBwYWRkaW5nLCB0cztcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHRzID0gdGl0bGVTdHlsZS5mb250U2l6ZTtcbiAgICAgIHN6ICs9IDUgKyAoKHRzICYmIHRzLnZhbHVlKSB8fCBjb25maWcubGVnZW5kLnRpdGxlRm9udFNpemUpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpPTAsIG49cmFuZ2UubGVuZ3RoOyBpPG47ICsraSkgcmFuZ2VbaV0gKz0gc3o7XG4gICAgXG4gICAgLy8gYnVpbGQgc2NhbGUgZm9yIGxhYmVsIGxheW91dFxuICAgIHZhciBzY2FsZSA9IHtcbiAgICAgIG5hbWU6IFwibGVnZW5kXCIsXG4gICAgICB0eXBlOiBcIm9yZGluYWxcIixcbiAgICAgIHBvaW50czogdHJ1ZSxcbiAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbiAgICBcbiAgICAvLyB1cGRhdGUgbGVnZW5kIGRlZlxuICAgIHZhciB0ZGF0YSA9ICh0aXRsZSA/IFt0aXRsZV0gOiBbXSkubWFwKGluZ2VzdCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGQubGFiZWwgPSBmbXQoZC5kYXRhKTtcbiAgICAgIGQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH0pO1xuICAgIGRlZi5zY2FsZXMgPSBbIHNjYWxlIF07XG4gICAgZGVmLm1hcmtzWzBdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRkYXRhOyB9O1xuICAgIGRlZi5tYXJrc1sxXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBkYXRhOyB9O1xuICAgIGRlZi5tYXJrc1syXS5mcm9tID0gZGVmLm1hcmtzWzFdLmZyb207XG5cbiAgICByZXR1cm4gZGVmO1xuICB9XG5cbiAgZnVuY3Rpb24gb19sZWdlbmRfZGVmKHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpIHtcbiAgICAvLyBzZXR1cCBsZWdlbmQgbWFya3NcbiAgICB2YXIgdGl0bGVzICA9IG0udGl0bGVzICB8fCAobS50aXRsZXMgID0gdmdfbGVnZW5kVGl0bGUoKSksXG4gICAgICAgIHN5bWJvbHMgPSBtLnN5bWJvbHMgfHwgKG0uc3ltYm9scyA9IHZnX2xlZ2VuZFN5bWJvbHMoKSksXG4gICAgICAgIGxhYmVscyAgPSBtLmxhYmVscyAgfHwgKG0ubGFiZWxzICA9IHZnX3ZMZWdlbmRMYWJlbHMoKSk7XG5cbiAgICAvLyBleHRlbmQgbGVnZW5kIG1hcmtzXG4gICAgdmdfbGVnZW5kU3ltYm9sRXh0ZW5kKHN5bWJvbHMsIHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpO1xuICAgIFxuICAgIC8vIGFkZCAvIG92ZXJyaWRlIGN1c3RvbSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgZGwuZXh0ZW5kKHRpdGxlcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgIHRpdGxlU3R5bGUpO1xuICAgIGRsLmV4dGVuZChzeW1ib2xzLnByb3BlcnRpZXMudXBkYXRlLCBzeW1ib2xTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwgIGxhYmVsU3R5bGUpO1xuXG4gICAgLy8gcGFkZGluZyBmcm9tIGxlZ2VuZCBib3JkZXJcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgdGl0bGVzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLngub2Zmc2V0ICs9IHBhZGRpbmcgKyAxO1xuICAgIHN5bWJvbHMucHJvcGVydGllcy5lbnRlci54Lm9mZnNldCA9IHBhZGRpbmcgKyAxO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS54Lm9mZnNldCArPSBwYWRkaW5nICsgMTtcbiAgICBzeW1ib2xzLnByb3BlcnRpZXMudXBkYXRlLngub2Zmc2V0ID0gcGFkZGluZyArIDE7XG5cbiAgICBkbC5leHRlbmQobGVnZW5kRGVmLCB7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVudGVyOiBwYXJzZVByb3BlcnRpZXMobW9kZWwsIFwiZ3JvdXBcIiwgbGVnZW5kU3R5bGUpLFxuICAgICAgICB2Z19sZWdlbmRQb3NpdGlvbjoge1xuICAgICAgICAgIGVuY29kZTogdmdfbGVnZW5kUG9zaXRpb24sXG4gICAgICAgICAgc2lnbmFsczogW10sIHNjYWxlczpbXSwgZGF0YTogW10sIGZpZWxkczogW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGVnZW5kRGVmLm1hcmtzID0gW3RpdGxlcywgc3ltYm9scywgbGFiZWxzXS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSk7XG4gICAgcmV0dXJuIGxlZ2VuZERlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50RGVmKHNjYWxlKSB7XG4gICAgdmFyIGRlZiA9IHFfbGVnZW5kX2RlZihzY2FsZSksXG4gICAgICAgIGRvbSA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICBkYXRhID0gZG9tLm1hcChpbmdlc3QpLFxuICAgICAgICB3aWR0aCA9IChncmFkaWVudFN0eWxlLndpZHRoICYmIGdyYWRpZW50U3R5bGUud2lkdGgudmFsdWUpIHx8IGNvbmZpZy5sZWdlbmQuZ3JhZGllbnRXaWR0aCxcbiAgICAgICAgZm10ID0gZm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiBmb3JtYXQ7XG5cbiAgICAvLyBidWlsZCBzY2FsZSBmb3IgbGFiZWwgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHtcbiAgICAgIG5hbWU6IFwibGVnZW5kXCIsXG4gICAgICB0eXBlOiBzY2FsZS50eXBlLFxuICAgICAgcm91bmQ6IHRydWUsXG4gICAgICB6ZXJvOiBmYWxzZSxcbiAgICAgIGRvbWFpbjogW2RvbVswXSwgZG9tW2RvbS5sZW5ndGgtMV1dLFxuICAgICAgcmFuZ2U6IFtwYWRkaW5nLCB3aWR0aCtwYWRkaW5nXVxuICAgIH07XG4gICAgaWYgKHNjYWxlLnR5cGU9PT1cInBvd1wiKSBsYXlvdXQuZXhwb25lbnQgPSBzY2FsZS5leHBvbmVudCgpO1xuICAgIFxuICAgIC8vIHVwZGF0ZSBsZWdlbmQgZGVmXG4gICAgdmFyIHRkYXRhID0gKHRpdGxlID8gW3RpdGxlXSA6IFtdKS5tYXAoaW5nZXN0KTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICBkLmxhYmVsID0gZm10KGQuZGF0YSk7XG4gICAgICBkLmFsaWduID0gaT09KGRhdGEubGVuZ3RoLTEpID8gXCJyaWdodFwiIDogaT09MCA/IFwibGVmdFwiIDogXCJjZW50ZXJcIjtcbiAgICB9KTtcbiAgICBkZWYuc2NhbGVzID0gWyBsYXlvdXQgXTtcbiAgICBkZWYubWFya3NbMF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgZGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIFsxXTsgfTtcbiAgICBkZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICByZXR1cm4gZGVmO1xuICB9XG4gIFxuICBmdW5jdGlvbiBxX2xlZ2VuZF9kZWYoc2NhbGUpIHtcbiAgICAvLyBzZXR1cCBsZWdlbmQgbWFya3NcbiAgICB2YXIgdGl0bGVzID0gbS50aXRsZSB8fCAobS50aXRsZSA9IHZnX2xlZ2VuZFRpdGxlKCkpLFxuICAgICAgICBncmFkaWVudCA9IG0uZ3JhZGllbnQgfHwgKG0uZ3JhZGllbnQgPSB2Z19sZWdlbmRHcmFkaWVudCgpKSxcbiAgICAgICAgbGFiZWxzID0gbS5sYWJlbHMgfHwgKG0ubGFiZWxzID0gdmdfaExlZ2VuZExhYmVscygpKSxcbiAgICAgICAgZ3JhZCA9IG5ldyBHcmFkaWVudCgpO1xuXG4gICAgLy8gc2V0dXAgY29sb3IgZ3JhZGllbnRcbiAgICB2YXIgZG9tID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIG1pbiA9IGRvbVswXSxcbiAgICAgICAgbWF4ID0gZG9tW2RvbS5sZW5ndGgtMV0sXG4gICAgICAgIGYgPSBzY2FsZS5jb3B5KCkuZG9tYWluKFttaW4sIG1heF0pLnJhbmdlKFswLDFdKTtcbiAgICAgICAgXG4gICAgdmFyIHN0b3BzID0gKHNjYWxlLnR5cGUgIT09IFwibGluZWFyXCIgJiYgc2NhbGUudGlja3MpXG4gICAgICA/IHNjYWxlLnRpY2tzLmNhbGwoc2NhbGUsIDE1KSA6IGRvbTtcbiAgICBpZiAobWluICE9PSBzdG9wc1swXSkgc3RvcHMudW5zaGlmdChtaW4pO1xuICAgIGlmIChtYXggIT09IHN0b3BzW3N0b3BzLmxlbmd0aC0xXSkgc3RvcHMucHVzaChtYXgpO1xuXG4gICAgZm9yICh2YXIgaT0wLCBuPXN0b3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGdyYWQuc3RvcChmKHN0b3BzW2ldKSwgc2NhbGUoc3RvcHNbaV0pKTtcbiAgICB9XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy5lbnRlci5maWxsID0ge3ZhbHVlOiBncmFkfTtcblxuICAgIC8vIGFkZCAvIG92ZXJyaWRlIGN1c3RvbSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgZGwuZXh0ZW5kKHRpdGxlcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgdGl0bGVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKGdyYWRpZW50LnByb3BlcnRpZXMudXBkYXRlLCBncmFkaWVudFN0eWxlKTtcbiAgICBkbC5leHRlbmQobGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCBsYWJlbFN0eWxlKTtcblxuICAgIC8vIGFjY291bnQgZm9yIGdyYWRpZW50IHNpemVcbiAgICB2YXIgZ3AgPSBncmFkaWVudC5wcm9wZXJ0aWVzLCBnaCA9IGdyYWRpZW50U3R5bGUuaGVpZ2h0LFxuICAgICAgICBoaCA9IChnaCAmJiBnaC52YWx1ZSkgfHwgZ3AuZW50ZXIuaGVpZ2h0LnZhbHVlO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgPSBoaDtcbiAgICBsYWJlbHMucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSA9IGhoO1xuXG4gICAgLy8gYWNjb3VudCBmb3IgdGl0bGUgc2l6ZSBhcyBuZWVkZWRcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHZhciB0cCA9IHRpdGxlcy5wcm9wZXJ0aWVzLCBmcyA9IHRpdGxlU3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgc3ogPSA0ICsgKChmcyAmJiBmcy52YWx1ZSkgfHwgdHAuZW50ZXIuZm9udFNpemUudmFsdWUpO1xuICAgICAgZ3JhZGllbnQucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHN6O1xuICAgICAgbGFiZWxzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBzejtcbiAgICAgIGdyYWRpZW50LnByb3BlcnRpZXMudXBkYXRlLnkudmFsdWUgKz0gc3o7XG4gICAgICBsYWJlbHMucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSArPSBzejtcbiAgICB9XG4gICAgXG4gICAgLy8gcGFkZGluZyBmcm9tIGxlZ2VuZCBib3JkZXJcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgdGl0bGVzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGdyYWRpZW50LnByb3BlcnRpZXMuZW50ZXIueC52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGdyYWRpZW50LnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgKz0gcGFkZGluZztcbiAgICBncmFkaWVudC5wcm9wZXJ0aWVzLnVwZGF0ZS54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS55LnZhbHVlICs9IHBhZGRpbmc7XG5cbiAgICBkbC5leHRlbmQobGVnZW5kRGVmLCB7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVudGVyOiBwYXJzZVByb3BlcnRpZXMobW9kZWwsIFwiZ3JvdXBcIiwgbGVnZW5kU3R5bGUpLFxuICAgICAgICB2Z19sZWdlbmRQb3NpdGlvbjoge1xuICAgICAgICAgIGVuY29kZTogdmdfbGVnZW5kUG9zaXRpb24sXG4gICAgICAgICAgc2lnbmFsczogW10sIHNjYWxlczogW10sIGRhdGE6IFtdLCBmaWVsZHM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxlZ2VuZERlZi5tYXJrcyA9IFt0aXRsZXMsIGdyYWRpZW50LCBsYWJlbHNdLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KTtcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9XG5cbiAgbGVnZW5kLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0geCkgeyBzaXplID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgIGlmIChzaGFwZSAhPT0geCkgeyBzaGFwZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5maWxsID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZpbGw7XG4gICAgaWYgKGZpbGwgIT09IHgpIHsgZmlsbCA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuICBcbiAgbGVnZW5kLnN0cm9rZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdHJva2U7XG4gICAgaWYgKHN0cm9rZSAhPT0geCkgeyBzdHJva2UgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgaWYgKHRpdGxlICE9PSB4KSB7IHRpdGxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmZvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb3JtYXRTdHJpbmc7XG4gICAgaWYgKGZvcm1hdFN0cmluZyAhPT0geCkge1xuICAgICAgZm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNwYWNpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3BhY2luZztcbiAgICBpZiAoc3BhY2luZyAhPT0gK3gpIHsgc3BhY2luZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBvcmllbnQgPSB4IGluIHZnX2xlZ2VuZE9yaWVudHMgPyB4ICsgXCJcIiA6IGNvbmZpZy5sZWdlbmQub3JpZW50O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gK3g7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlcztcbiAgICB2YWx1ZXMgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxlZ2VuZFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGVnZW5kU3R5bGU7XG4gICAgbGVnZW5kU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnN5bWJvbFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3ltYm9sU3R5bGU7XG4gICAgc3ltYm9sU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmdyYWRpZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmFkaWVudFN0eWxlO1xuICAgIGdyYWRpZW50U3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbFN0eWxlO1xuICAgIGxhYmVsU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG4gIFxuICBsZWdlbmQudGl0bGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlU3R5bGU7XG4gICAgdGl0bGVTdHlsZSA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gbGVnZW5kO1xufTtcblxudmFyIHZnX2xlZ2VuZE9yaWVudHMgPSB7cmlnaHQ6IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19sZWdlbmRQb3NpdGlvbihpdGVtLCBncm91cCwgdHJhbnMsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSB7XG4gIHZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW0sIGd4LFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHBhZCAgICA9IGl0ZW0ubWFyay5kZWYucGFkZGluZyAqIDIsXG4gICAgICBsdyAgICAgPSB+fml0ZW0uYm91bmRzLndpZHRoKCkgKyAoaXRlbS53aWR0aCA/IDAgOiBwYWQpLFxuICAgICAgbGggICAgID0gfn5pdGVtLmJvdW5kcy5oZWlnaHQoKSArIChpdGVtLmhlaWdodCA/IDAgOiBwYWQpLFxuICAgICAgcG9zID0gZ3JvdXAuX2xlZ2VuZFBvc2l0aW9ucyB8fCBcbiAgICAgICAgKGdyb3VwLl9sZWdlbmRQb3NpdGlvbnMgPSB7cmlnaHQ6IDAuNSwgbGVmdDogMC41fSk7XG5cbiAgby54ID0gMC41O1xuICBvLndpZHRoID0gbHc7XG4gIG8ueSA9IHBvc1tvcmllbnRdO1xuICBwb3Nbb3JpZW50XSArPSAoby5oZWlnaHQgPSBsaCk7XG5cbiAgLy8gSEFDSzogdXNlIHRvIGVzdGltYXRlIGdyb3VwIGJvdW5kcyBkdXJpbmcgYW5pbWF0ZWQgdHJhbnNpdGlvblxuICBpZiAoIXRyYW5zICYmIGdyb3VwLmJvdW5kcykge1xuICAgIGdyb3VwLmJvdW5kcy5kZWx0YSA9IGdyb3VwLmJvdW5kcy54MiAtIGdyb3VwLndpZHRoO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFwibGVmdFwiOiAge1xuICAgICAgZ3ggPSBncm91cC5ib3VuZHMgPyBncm91cC5ib3VuZHMueDEgOiAwO1xuICAgICAgby54ICs9IGd4IC0gb2Zmc2V0IC0gbHc7XG4gICAgICBicmVhaztcbiAgICB9O1xuICAgIGNhc2UgXCJyaWdodFwiOiB7XG4gICAgICBneCA9IGdyb3VwLndpZHRoO1xuICAgICAgaWYgKGdyb3VwLmJvdW5kcykgZ3ggPSB0cmFuc1xuICAgICAgICA/IGdyb3VwLndpZHRoICsgZ3JvdXAuYm91bmRzLmRlbHRhXG4gICAgICAgIDogZ3JvdXAuYm91bmRzLngyO1xuICAgICAgby54ICs9IGd4ICsgb2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgfTtcbiAgfVxuICBcbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbiAgdmFyIGVuYyA9IGl0ZW0ubWFyay5kZWYucHJvcGVydGllcy5lbnRlci5lbmNvZGU7XG4gIGVuYy5jYWxsKGVuYywgaXRlbSwgZ3JvdXAsIHRyYW5zKTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kU3ltYm9sRXh0ZW5kKG1hcmssIHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpIHtcbiAgdmFyIGUgPSBtYXJrLnByb3BlcnRpZXMuZW50ZXIsXG4gICAgICB1ID0gbWFyay5wcm9wZXJ0aWVzLnVwZGF0ZTtcbiAgaWYgKHNpemUpICAgZS5zaXplICAgPSB1LnNpemUgICA9IHtzY2FsZTogc2l6ZS5zY2FsZU5hbWUsICAgZmllbGQ6IFwiZGF0YVwifTtcbiAgaWYgKHNoYXBlKSAgZS5zaGFwZSAgPSB1LnNoYXBlICA9IHtzY2FsZTogc2hhcGUuc2NhbGVOYW1lLCAgZmllbGQ6IFwiZGF0YVwifTtcbiAgaWYgKGZpbGwpICAgZS5maWxsICAgPSB1LmZpbGwgICA9IHtzY2FsZTogZmlsbC5zY2FsZU5hbWUsICAgZmllbGQ6IFwiZGF0YVwifTtcbiAgaWYgKHN0cm9rZSkgZS5zdHJva2UgPSB1LnN0cm9rZSA9IHtzY2FsZTogc3Ryb2tlLnNjYWxlTmFtZSwgZmllbGQ6IFwiZGF0YVwifTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kVGl0bGUoKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY2ZnLnRpdGxlQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNmZy50aXRsZUZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjZmcudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY2ZnLnRpdGxlRm9udFdlaWdodH0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IFwidG9wXCJ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwiZGF0YVwifSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kU3ltYm9scygpIHtcbiAgdmFyIGNmZyA9IGNvbmZpZy5sZWdlbmQ7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiBcImRhdGFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7ZmllbGQ6IFwib2Zmc2V0XCIsIG11bHQ6IDAuNX0sXG4gICAgICAgIHk6IHtzY2FsZTogXCJsZWdlbmRcIiwgZmllbGQ6IFwiaW5kZXhcIn0sXG4gICAgICAgIHNoYXBlOiB7dmFsdWU6IGNmZy5zeW1ib2xTaGFwZX0sXG4gICAgICAgIHNpemU6IHt2YWx1ZTogY2ZnLnN5bWJvbFNpemV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY2ZnLnN5bWJvbENvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY2ZnLnN5bWJvbFN0cm9rZVdpZHRofSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHtmaWVsZDogXCJvZmZzZXRcIiwgbXVsdDogMC41fSxcbiAgICAgICAgeToge3NjYWxlOiBcImxlZ2VuZFwiLCBmaWVsZDogXCJpbmRleFwifSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfdkxlZ2VuZExhYmVscygpIHtcbiAgdmFyIGNmZyA9IGNvbmZpZy5sZWdlbmQ7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIGtleTogXCJkYXRhXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge2ZpZWxkOiBcIm9mZnNldFwiLCBvZmZzZXQ6IDV9LFxuICAgICAgICB5OiB7c2NhbGU6IFwibGVnZW5kXCIsIGZpZWxkOiBcImluZGV4XCJ9LFxuICAgICAgICBmaWxsOiB7dmFsdWU6IGNmZy5sYWJlbENvbG9yfSxcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjZmcubGFiZWxGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udFNpemV9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiBjZmcubGFiZWxBbGlnbn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IGNmZy5sYWJlbEJhc2VsaW5lfSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiBcImxhYmVsXCJ9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgICAgeDoge2ZpZWxkOiBcIm9mZnNldFwiLCBvZmZzZXQ6IDV9LFxuICAgICAgICB5OiB7c2NhbGU6IFwibGVnZW5kXCIsIGZpZWxkOiBcImluZGV4XCJ9LFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kR3JhZGllbnQoKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVjdFwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgICB3aWR0aDoge3ZhbHVlOiBjZmcuZ3JhZGllbnRXaWR0aH0sXG4gICAgICAgIGhlaWdodDoge3ZhbHVlOiBjZmcuZ3JhZGllbnRIZWlnaHR9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY2ZnLmdyYWRpZW50U3Ryb2tlQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjZmcuZ3JhZGllbnRTdHJva2VXaWR0aH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDF9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19oTGVnZW5kTGFiZWxzKCkge1xuICB2YXIgY2ZnID0gY29uZmlnLmxlZ2VuZDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiBcImRhdGFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7c2NhbGU6IFwibGVnZW5kXCIsIGZpZWxkOiBcImRhdGFcIn0sXG4gICAgICAgIHk6IHt2YWx1ZTogMjB9LFxuICAgICAgICBkeToge3ZhbHVlOiAyfSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjZmcubGFiZWxDb2xvcn0sXG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udH0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IGNmZy5sYWJlbEZvbnRTaXplfSxcbiAgICAgICAgYWxpZ246IHtmaWVsZDogXCJhbGlnblwifSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJ0b3BcIn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJsYWJlbFwifSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHtzY2FsZTogXCJsZWdlbmRcIiwgZmllbGQ6IFwiZGF0YVwifSxcbiAgICAgICAgeToge3ZhbHVlOiAyMH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMX1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGduZDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgbWVhcyA9IHJlcXVpcmUoJy4vbWVhc3VyZXMnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gQWdncmVnYXRlKGdyYXBoKSB7XG4gIEdyb3VwQnkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cF9ieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcImNvdW50XCI6ICAgIFwiY291bnRcIixcbiAgICBcImF2Z1wiOiAgICAgIFwiYXZnXCIsXG4gICAgXCJtaW5cIjogICAgICBcIm1pblwiLFxuICAgIFwibWF4XCI6ICAgICAgXCJtYXhcIixcbiAgICBcInN1bVwiOiAgICAgIFwic3VtXCIsXG4gICAgXCJtZWFuXCI6ICAgICBcIm1lYW5cIixcbiAgICBcInZhclwiOiAgICAgIFwidmFyXCIsXG4gICAgXCJzdGRldlwiOiAgICBcInN0ZGV2XCIsXG4gICAgXCJ2YXJwXCI6ICAgICBcInZhcnBcIixcbiAgICBcInN0ZGV2cFwiOiAgIFwic3RkZXZwXCIsXG4gICAgXCJtZWRpYW5cIjogICBcIm1lZGlhblwiXG4gIH07XG5cbiAgLy8gQWdncmVnYXRvcnMgcGFyYW1ldGVyIGhhbmRsZWQgbWFudWFsbHkuXG4gIHRoaXMuX2ZpZWxkc0RlZiAgID0gbnVsbDtcbiAgdGhpcy5fQWdncmVnYXRvcnMgPSBudWxsO1xuICB0aGlzLl9zaW5nbGV0b24gICA9IGZhbHNlOyAgLy8gSWYgdHJ1ZSwgYWxsIGZpZWxkcyBhZ2dyZWdhdGVkIHdpdGhpbiBhIHNpbmdsZSBtb25vaWRcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEFnZ3JlZ2F0ZS5wcm90b3R5cGUgPSBuZXcgR3JvdXBCeSgpKTtcblxucHJvdG8uZmllbGRzID0ge1xuICBzZXQ6IGZ1bmN0aW9uKHRyYW5zZm9ybSwgZmllbGRzKSB7XG4gICAgdmFyIGksIGxlbiwgZiwgc2lnbmFscyA9IHt9O1xuICAgIGZvcihpPTAsIGxlbj1maWVsZHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBmID0gZmllbGRzW2ldO1xuICAgICAgaWYoZi5uYW1lLnNpZ25hbCkgc2lnbmFsc1tmLm5hbWUuc2lnbmFsXSA9IDE7XG4gICAgICBkbC5hcnJheShmLm9wcykuZm9yRWFjaChmdW5jdGlvbihvKXsgaWYoby5zaWduYWwpIHNpZ25hbHNbby5zaWduYWxdID0gMSB9KTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0uX2ZpZWxkc0RlZiA9IGZpZWxkcztcbiAgICB0cmFuc2Zvcm0uX0FnZ3JlZ2F0b3JzID0gbnVsbDtcbiAgICB0cmFuc2Zvcm0uYWdncygpO1xuICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgZGwua2V5cyhzaWduYWxzKSk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfVxufTtcblxucHJvdG8uc2luZ2xldG9uID0gZnVuY3Rpb24oYykge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NpbmdsZXRvbjtcbiAgdGhpcy5fc2luZ2xldG9uID0gYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hZ2dzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLFxuICAgICAgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIGZpZWxkcyA9IHRoaXMuX2ZpZWxkc0RlZixcbiAgICAgIGFnZ3MgPSB0aGlzLl9BZ2dyZWdhdG9ycyxcbiAgICAgIGYsIGksIGssIG5hbWUsIG9wcywgbWVhc3VyZXM7XG5cbiAgaWYoYWdncykgcmV0dXJuIGFnZ3M7XG4gIGVsc2UgYWdncyA9IHRoaXMuX0FnZ3JlZ2F0b3JzID0gW107IFxuXG4gIGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmID0gZmllbGRzW2ldO1xuICAgIGlmIChmLm9wcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgbmFtZSA9IGYubmFtZS5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoZi5uYW1lLnNpZ25hbCkgOiBmLm5hbWU7XG4gICAgb3BzICA9IGRsLmFycmF5KGYub3BzLnNpZ25hbCA/IGdyYXBoLnNpZ25hbFJlZihmLm9wcy5zaWduYWwpIDogZi5vcHMpO1xuICAgIG1lYXN1cmVzID0gb3BzLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICBhID0gYS5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoYS5zaWduYWwpIDogYTtcbiAgICAgIHJldHVybiBtZWFzW2FdKG5hbWUgKyAnXycgKyB0cmFuc2Zvcm0uX291dHB1dFthXSk7XG4gICAgfSk7XG4gICAgYWdncy5wdXNoKHtcbiAgICAgIGFjY2Vzc29yOiBkbC5hY2Nlc3NvcihuYW1lKSxcbiAgICAgIGZpZWxkOiB0aGlzLl9zaW5nbGV0b24gPyBDLlNJTkdMRVRPTiA6IG5hbWUsXG4gICAgICBtZWFzdXJlczogbWVhcy5jcmVhdGUobWVhc3VyZXMpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYWdncztcbn07XG5cbnByb3RvLl9yZXNldCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgdGhpcy5fQWdncmVnYXRvcnMgPSBudWxsOyAvLyByZWJ1aWxkIGFnZ3JlZ2F0b3JzXG4gIHRoaXMuYWdncygpO1xuICByZXR1cm4gR3JvdXBCeS5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcywgaW5wdXQsIG91dHB1dCk7XG59O1xuXG5wcm90by5fa2V5cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHRoaXMuX2diLmZpZWxkcy5sZW5ndGggPyBcbiAgICBHcm91cEJ5LnByb3RvdHlwZS5fa2V5cy5jYWxsKHRoaXMsIHgpIDoge2tleXM6IFtdLCBrZXk6IFwiXCJ9O1xufTtcblxucHJvdG8uX25ld19jZWxsID0gZnVuY3Rpb24oeCwgaykge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9uZXdfY2VsbC5jYWxsKHRoaXMsIHgsIGspLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgaSA9IDAsIGxlbiA9IGFnZ3MubGVuZ3RoLCBcbiAgICAgIGFnZztcblxuICBmb3IoOyBpPGxlbjsgaSsrKSB7XG4gICAgYWdnID0gYWdnc1tpXTtcbiAgICBjZWxsW2FnZy5maWVsZF0gPSBuZXcgYWdnLm1lYXN1cmVzKGNlbGwsIGNlbGwudHBsKTtcbiAgfVxuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGMgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgaSA9IDAsIGxlbiA9IGFnZ3MubGVuZ3RoLFxuICAgICAgYWdnO1xuXG4gIGMuY250Kys7XG4gIGZvcig7IGk8bGVuOyBpKyspIHtcbiAgICBhZ2cgPSBhZ2dzW2ldO1xuICAgIGNbYWdnLmZpZWxkXS5hZGQoYWdnLmFjY2Vzc29yKHgpKTtcbiAgfVxuICBjLmZsZyB8PSBDLk1PRF9DRUxMO1xufTtcblxucHJvdG8uX3JlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGMgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgaSA9IDAsIGxlbiA9IGFnZ3MubGVuZ3RoLFxuICAgICAgYWdnO1xuXG4gIGMuY250LS07XG4gIGZvcig7IGk8bGVuOyBpKyspIHtcbiAgICBhZ2cgPSBhZ2dzW2ldO1xuICAgIGNbYWdnLmZpZWxkXS5yZW0oYWdnLmFjY2Vzc29yKHgpKTtcbiAgfVxuICBjLmZsZyB8PSBDLk1PRF9DRUxMO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJhZ2dyZWdhdGVcIl0pO1xuXG4gIHRoaXMuX2diID0gdGhpcy5ncm91cF9ieS5nZXQodGhpcy5fZ3JhcGgpO1xuXG4gIHZhciBvdXRwdXQgPSBHcm91cEJ5LnByb3RvdHlwZS50cmFuc2Zvcm0uY2FsbCh0aGlzLCBpbnB1dCwgcmVzZXQpLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgbGVuID0gYWdncy5sZW5ndGgsXG4gICAgICBpLCBrLCBjO1xuXG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKCFjKSBjb250aW51ZTtcbiAgICBmb3IoaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBjW2FnZ3NbaV0uZmllbGRdLnNldCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQmF0Y2hUcmFuc2Zvcm0oKSB7XG59XG5cbnZhciBwcm90byA9IChCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLlxuICAvLyBUT0RPOiBlZmZpY2llbnRseSBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG4gIHZhciBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKTtcbiAgcmV0dXJuIHRoaXMuYmF0Y2hUcmFuc2Zvcm0oaW5wdXQsIGRhdGEpO1xufTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFRyYW5zZm9ybTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gQmluKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBtaW46IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIG1heDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgc3RlcDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgbWF4Ymluczoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMjB9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcImJpblwiOiBcImJpblwifTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChCaW4ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQuYmluO1xuICAgICAgXG4gIHZhciBiID0gZGwuYmlucyh7XG4gICAgbWluOiB0aGlzLm1pbi5nZXQoKSxcbiAgICBtYXg6IHRoaXMubWF4LmdldCgpLFxuICAgIHN0ZXA6IHRoaXMuc3RlcC5nZXQoKSxcbiAgICBtYXhiaW5zOiB0aGlzLm1heGJpbnMuZ2V0KClcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGQpIHtcbiAgICB2YXIgdiA9IHRyYW5zZm9ybS5maWVsZC5nZXQoKS5hY2Nlc3NvcihkKTtcbiAgICB2ID0gdiA9PSBudWxsID8gbnVsbFxuICAgICAgOiBiLnN0YXJ0ICsgYi5zdGVwICogfn4oKHYgLSBiLnN0YXJ0KSAvIGIuc3RlcCk7XG4gICAgdHVwbGUuc2V0KGQsIG91dHB1dCwgdiwgaW5wdXQuc3RhbXApO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW47XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIENyb3NzKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgZGlhZ29uYWw6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwidHJ1ZVwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XCJsZWZ0XCI6IFwiYVwiLCBcInJpZ2h0XCI6IFwiYlwifTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHRoaXMuX2xhc3RSZW0gID0gbnVsbDsgLy8gTW9zdCByZWNlbnQgc3RhbXAgdGhhdCByZW0gb2NjdXJlZC4gXG4gIHRoaXMuX2xhc3RXaXRoID0gbnVsbDsgLy8gTGFzdCB0aW1lIHdlIGNyb3NzZWQgdy93aXRoZHMuXG4gIHRoaXMuX2lkcyAgID0ge307XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQ3Jvc3MucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuLy8gRWFjaCBjYWNoZWQgaW5jb21pbmcgdHVwbGUgYWxzbyBoYXMgYSBzdGFtcCB0byB0cmFjayBpZiB3ZSBuZWVkIHRvIGRvXG4vLyBsYXp5IGZpbHRlcmluZyBvZiByZW1vdmVkIHR1cGxlcy5cbmZ1bmN0aW9uIGNhY2hlKHgsIHQpIHtcbiAgdmFyIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwge2M6IFtdLCBzOiB0aGlzLl9zdGFtcH07XG4gIGMuYy5wdXNoKHQpO1xufVxuXG5mdW5jdGlvbiBhZGQob3V0cHV0LCBsZWZ0LCB3ZGF0YSwgZGlhZywgeCkge1xuICB2YXIgZGF0YSA9IGxlZnQgPyB3ZGF0YSA6IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksIC8vIExlZnQgdHVwbGVzIGNyb3NzIHcvcmlnaHQuXG4gICAgICBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBwcmV2ICA9IHguX3ByZXYgIT09IHVuZGVmaW5lZCA/IG51bGwgOiB1bmRlZmluZWQsIFxuICAgICAgdCwgeSwgaWQ7XG5cbiAgZm9yKDsgaTxsZW47ICsraSkge1xuICAgIHkgPSBkYXRhW2ldO1xuICAgIGlkID0gbGVmdCA/IHguX2lkK1wiX1wiK3kuX2lkIDogeS5faWQrXCJfXCIreC5faWQ7XG4gICAgaWYodGhpcy5faWRzW2lkXSkgY29udGludWU7XG4gICAgaWYoeC5faWQgPT0geS5faWQgJiYgIWRpYWcpIGNvbnRpbnVlO1xuXG4gICAgdCA9IHR1cGxlLmluZ2VzdCh7fSwgcHJldik7XG4gICAgdFt0aGlzLl9vdXRwdXQubGVmdF0gID0gbGVmdCA/IHggOiB5O1xuICAgIHRbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IGxlZnQgPyB5IDogeDtcbiAgICBvdXRwdXQuYWRkLnB1c2godCk7XG4gICAgY2FjaGUuY2FsbCh0aGlzLCB4LCB0KTtcbiAgICBjYWNoZS5jYWxsKHRoaXMsIHksIHQpO1xuICAgIHRoaXMuX2lkc1tpZF0gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vZChvdXRwdXQsIGxlZnQsIHgpIHtcbiAgdmFyIGNyb3NzID0gdGhpcyxcbiAgICAgIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF07XG5cbiAgaWYodGhpcy5fbGFzdFJlbSA+IGMucykgeyAgLy8gUmVtb3ZlZCB0dXBsZXMgaGF2ZW4ndCBiZWVuIGZpbHRlcmVkIHlldFxuICAgIGMuYyA9IGMuYy5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIHQgPSB5W2Nyb3NzLl9vdXRwdXRbbGVmdCA/IFwicmlnaHRcIiA6IFwibGVmdFwiXV07XG4gICAgICByZXR1cm4gY3Jvc3MuX2NhY2hlW3QuX2lkXSAhPT0gbnVsbDtcbiAgICB9KTtcbiAgICBjLnMgPSB0aGlzLl9sYXN0UmVtO1xuICB9XG5cbiAgb3V0cHV0Lm1vZC5wdXNoLmFwcGx5KG91dHB1dC5tb2QsIGMuYyk7XG59XG5cbmZ1bmN0aW9uIHJlbShvdXRwdXQsIHgpIHtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW3guX2lkXS5jKTtcbiAgdGhpcy5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgdGhpcy5fbGFzdFJlbSA9IHRoaXMuX3N0YW1wO1xufVxuXG5mdW5jdGlvbiB1cEZpZWxkcyhpbnB1dCwgb3V0cHV0KSB7XG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmxlZnRdICA9IDE7IFxuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IDE7XG4gIH1cbn1cblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImNyb3NzaW5nXCJdKTtcblxuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLiBUT0RPOiBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG5cbiAgdmFyIHcgPSB0aGlzLndpdGguZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGRpYWcgPSB0aGlzLmRpYWdvbmFsLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBzZWxmQ3Jvc3MgPSAoIXcubmFtZSksXG4gICAgICBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSxcbiAgICAgIHdvdXRwdXQgPSBzZWxmQ3Jvc3MgPyBpbnB1dCA6IHcuc291cmNlLmxhc3QoKSxcbiAgICAgIHdkYXRhICAgPSBzZWxmQ3Jvc3MgPyBkYXRhIDogdy5zb3VyY2UudmFsdWVzKCksXG4gICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICByID0gcmVtLmJpbmQodGhpcywgb3V0cHV0KTsgXG5cbiAgaW5wdXQucmVtLmZvckVhY2gocik7XG4gIGlucHV0LmFkZC5mb3JFYWNoKGFkZC5iaW5kKHRoaXMsIG91dHB1dCwgdHJ1ZSwgd2RhdGEsIGRpYWcpKTtcblxuICBpZighc2VsZkNyb3NzICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0V2l0aCkge1xuICAgIHdvdXRwdXQucmVtLmZvckVhY2gocik7XG4gICAgd291dHB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlLCBkYXRhLCBkaWFnKSk7XG4gICAgd291dHB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlKSk7XG4gICAgdXBGaWVsZHMuY2FsbCh0aGlzLCB3b3V0cHV0LCBvdXRwdXQpO1xuICAgIHRoaXMuX2xhc3RXaXRoID0gd291dHB1dC5zdGFtcDtcbiAgfVxuXG4gIC8vIE1vZHMgbmVlZCB0byBjb21lIGFmdGVyIGFsbCByZW1vdmFscyBoYXZlIGJlZW4gcnVuLlxuICBpbnB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUpKTtcbiAgdXBGaWVsZHMuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcm9zczsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmFjZXQoZ3JhcGgpIHtcbiAgR3JvdXBCeS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge2tleXM6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSB9KTtcblxuICB0aGlzLl9waXBlbGluZSA9IFtdO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZhY2V0LnByb3RvdHlwZSA9IG5ldyBHcm91cEJ5KCkpO1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG4gIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB2YXIgaywgYztcbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoIWMpIGNvbnRpbnVlO1xuICAgIG91dHB1dC5yZW0ucHVzaChjLnRwbCk7XG4gICAgYy5kZWxldGUoKTtcbiAgfVxuICB0aGlzLl9jZWxscyA9IHt9O1xufTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgcmV0dXJuIHR1cGxlLmluZ2VzdChrLCBudWxsKTtcbn07XG5cbnByb3RvLl9uZXdfY2VsbCA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgLy8gUmF0aGVyIHRoYW4gc2hhcmluZyB0aGUgcGlwZWxpbmUgYmV0d2VlbiBhbGwgbm9kZXMsXG4gIC8vIGdpdmUgZWFjaCBjZWxsIGl0cyBpbmRpdmlkdWFsIHBpcGVsaW5lLiBUaGlzIGFsbG93c1xuICAvLyBkeW5hbWljYWxseSBhZGRlZCBjb2xsZWN0b3JzIHRvIGRvIHRoZSByaWdodCB0aGluZ1xuICAvLyB3aGVuIHdpcmluZyB1cCB0aGUgcGlwZWxpbmVzLlxuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9uZXdfY2VsbC5jYWxsKHRoaXMsIHgsIGspLFxuICAgICAgcGlwZWxpbmUgPSB0aGlzLl9waXBlbGluZS5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbi5jbG9uZSgpOyB9KSxcbiAgICAgIGZhY2V0ID0gdGhpcyxcbiAgICAgIHQgPSBjZWxsLnRwbDtcblxuICBjZWxsLmRzID0gdGhpcy5fZ3JhcGguZGF0YShcInZnX1wiK3QuX2lkLCBwaXBlbGluZSwgdCk7XG4gIGNlbGwuZGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoe30sIFtcImRlbGV0aW5nIGNlbGxcIiwgay5rZXldKTtcbiAgICBmYWNldC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gICAgZmFjZXQuX2dyYXBoLmRpc2Nvbm5lY3QocGlwZWxpbmUpO1xuICB9O1xuXG4gIHRoaXMuYWRkTGlzdGVuZXIocGlwZWxpbmVbMF0pO1xuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fYWRkLmNhbGwodGhpcywgeCk7XG4gIGNlbGwuZHMuX2lucHV0LmFkZC5wdXNoKHgpO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9tb2QgPSBmdW5jdGlvbih4LCByZXNldCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9tb2QuY2FsbCh0aGlzLCB4LCByZXNldCk7XG4gIGlmKCEoY2VsbC5mbGcgJiBDLkFERF9DRUxMKSkgY2VsbC5kcy5faW5wdXQubW9kLnB1c2goeCk7IC8vIFByb3BhZ2F0ZSB0dXBsZXNcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9yZW0uY2FsbCh0aGlzLCB4KTtcbiAgY2VsbC5kcy5faW5wdXQucmVtLnB1c2goeCk7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmYWNldGluZ1wiXSk7XG5cbiAgdGhpcy5fZ2IgPSB0aGlzLmtleXMuZ2V0KHRoaXMuX2dyYXBoKTtcblxuICB2YXIgb3V0cHV0ID0gR3JvdXBCeS5wcm90b3R5cGUudHJhbnNmb3JtLmNhbGwodGhpcywgaW5wdXQsIHJlc2V0KSxcbiAgICAgIGssIGM7XG5cbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoYyA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZihjLmNudCA9PT0gMCkge1xuICAgICAgYy5kZWxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvcGFnYXRlIHNvcnQsIHNpZ25hbHMsIGZpZWxkcywgZXRjLlxuICAgICAgY2hhbmdlc2V0LmNvcHkoaW5wdXQsIGMuZHMuX2lucHV0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNldDsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmlsdGVyKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge3Rlc3Q6IHt0eXBlOiBcImV4cHJcIn0gfSk7XG5cbiAgdGhpcy5fc2tpcCA9IHt9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZpbHRlci5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiB0ZXN0KHgpIHtcbiAgcmV0dXJuIGV4cHIuZXZhbCh0aGlzLl9ncmFwaCwgdGhpcy50ZXN0LmdldCh0aGlzLl9ncmFwaCksIFxuICAgIHgsIG51bGwsIG51bGwsIG51bGwsIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMpKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmaWx0ZXJpbmdcIl0pO1xuICB2YXIgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBza2lwID0gdGhpcy5fc2tpcCxcbiAgICAgIGYgPSB0aGlzO1xuXG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoc2tpcFt4Ll9pZF0gIT09IDEpIG91dHB1dC5yZW0ucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMDtcbiAgfSk7XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmICh0ZXN0LmNhbGwoZiwgeCkpIG91dHB1dC5hZGQucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMTtcbiAgfSk7XG5cbiAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciBiID0gdGVzdC5jYWxsKGYsIHgpLFxuICAgICAgICBzID0gKHNraXBbeC5faWRdID09PSAxKTtcbiAgICBpZiAoYiAmJiBzKSB7XG4gICAgICBza2lwW3guX2lkXSA9IDA7XG4gICAgICBvdXRwdXQuYWRkLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmIChiICYmICFzKSB7XG4gICAgICBvdXRwdXQubW9kLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmICghYiAmJiBzKSB7XG4gICAgICAvLyBkbyBub3RoaW5nLCBrZWVwIHNraXAgdHJ1ZVxuICAgIH0gZWxzZSB7IC8vICFiICYmICFzXG4gICAgICBvdXRwdXQucmVtLnB1c2goeCk7XG4gICAgICBza2lwW3guX2lkXSA9IDE7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksIFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIEZvbGQoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGRzOiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0gXG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtrZXk6IFwia2V5XCIsIHZhbHVlOiBcInZhbHVlXCJ9O1xuICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKS5yZXZpc2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoRm9sZC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiByc3QoaW5wdXQsIG91dHB1dCkgeyBcbiAgZm9yKHZhciBpZCBpbiB0aGlzLl9jYWNoZSkgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW2lkXSk7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuXG5mdW5jdGlvbiBnZXRfdHVwbGUoeCwgaSwgbGVuKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5fY2FjaGVbeC5faWRdIHx8ICh0aGlzLl9jYWNoZVt4Ll9pZF0gPSBBcnJheShsZW4pKTtcbiAgcmV0dXJuIGxpc3RbaV0gfHwgKGxpc3RbaV0gPSB0dXBsZS5kZXJpdmUoeCwgeC5fcHJldikpO1xufTtcblxuZnVuY3Rpb24gZm4oZGF0YSwgZmllbGRzLCBhY2Nlc3NvcnMsIG91dCwgc3RhbXApIHtcbiAgdmFyIGkgPSAwLCBkbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBqLCBmbGVuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgIGQsIHQ7XG5cbiAgZm9yKDsgaTxkbGVuOyArK2kpIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBmb3Ioaj0wOyBqPGZsZW47ICsraikge1xuICAgICAgdCA9IGdldF90dXBsZS5jYWxsKHRoaXMsIGQsIGosIGZsZW4pOyAgXG4gICAgICB0dXBsZS5zZXQodCwgdGhpcy5fb3V0cHV0LmtleSwgZmllbGRzW2pdKTtcbiAgICAgIHR1cGxlLnNldCh0LCB0aGlzLl9vdXRwdXQudmFsdWUsIGFjY2Vzc29yc1tqXShkKSk7XG4gICAgICBvdXQucHVzaCh0KTtcbiAgICB9ICAgICAgXG4gIH1cbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiZm9sZGluZ1wiXSk7XG5cbiAgdmFyIGZvbGQgPSB0aGlzLFxuICAgICAgb24gPSB0aGlzLmZpZWxkcy5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgZmllbGRzID0gb24uZmllbGRzLCBhY2Nlc3NvcnMgPSBvbi5hY2Nlc3NvcnMsXG4gICAgICBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICBpZihyZXNldCkgcnN0LmNhbGwodGhpcywgaW5wdXQsIG91dHB1dCk7XG5cbiAgZm4uY2FsbCh0aGlzLCBpbnB1dC5hZGQsIGZpZWxkcywgYWNjZXNzb3JzLCBvdXRwdXQuYWRkLCBpbnB1dC5zdGFtcCk7XG4gIGZuLmNhbGwodGhpcywgaW5wdXQubW9kLCBmaWVsZHMsIGFjY2Vzc29ycywgcmVzZXQgPyBvdXRwdXQuYWRkIDogb3V0cHV0Lm1vZCwgaW5wdXQuc3RhbXApO1xuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIGZvbGQuX2NhY2hlW3guX2lkXSk7XG4gICAgZm9sZC5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgfSk7XG5cbiAgLy8gSWYgd2UncmUgb25seSBwcm9wYWdhdGluZyB2YWx1ZXMsIGRvbid0IG1hcmsga2V5L3ZhbHVlIGFzIHVwZGF0ZWQuXG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCB8fCBcbiAgICBmaWVsZHMuc29tZShmdW5jdGlvbihmKSB7IHJldHVybiAhIWlucHV0LmZpZWxkc1tmXTsgfSkpXG4gICAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5rZXldID0gMSwgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQudmFsdWVdID0gMTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9sZDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gRm9yY2UoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc2l6ZToge3R5cGU6IFwiYXJyYXk8dmFsdWU+XCIsIGRlZmF1bHQ6IFs1MDAsIDUwMF19LFxuICAgIGxpbmtzOiB7dHlwZTogXCJkYXRhXCJ9LFxuICAgIGxpbmtEaXN0YW5jZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMjB9LFxuICAgIGxpbmtTdHJlbmd0aDoge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMX0sXG4gICAgY2hhcmdlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAzMH0sXG4gICAgY2hhcmdlRGlzdGFuY2U6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IEluZmluaXR5fSxcbiAgICBpdGVyYXRpb25zOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiA1MDB9LFxuICAgIGZyaWN0aW9uOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjl9LFxuICAgIHRoZXRhOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjh9LFxuICAgIGdyYXZpdHk6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMX0sXG4gICAgYWxwaGE6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMX1cbiAgfSk7XG5cbiAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgdGhpcy5fbGlua3MgPSBbXTtcbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LmZvcmNlKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiBcImxheW91dDp4XCIsXG4gICAgXCJ5XCI6IFwibGF5b3V0OnlcIixcbiAgICBcInNvdXJjZVwiOiBcIl9zb3VyY2VcIixcbiAgICBcInRhcmdldFwiOiBcIl90YXJnZXRcIlxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRm9yY2UucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gZ2V0KHRyYW5zZm9ybSwgbmFtZSkge1xuICB2YXIgdiA9IHRyYW5zZm9ybVtuYW1lXS5nZXQodHJhbnNmb3JtLl9ncmFwaCk7XG4gIHJldHVybiB2LmFjY2Vzc29yXG4gICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiB2LmFjY2Vzc29yKHgudHVwbGUpOyB9XG4gICAgOiB2LmZpZWxkO1xufVxuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlSW5wdXQpIHtcbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgbGlua0lucHV0ID0gdGhpcy5saW5rcy5nZXQoZykuc291cmNlLmxhc3QoKSxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICBsaW5rcyA9IHRoaXMuX2xpbmtzLFxuICAgICAgaXRlciA9IHRoaXMuaXRlcmF0aW9ucy5nZXQoZyk7XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBub2Rlc1xuICBub2RlSW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIG5vZGVzLnB1c2goe3R1cGxlOiBufSk7XG4gIH0pO1xuXG4gIC8vIHByb2Nlc3MgYWRkZWQgZWRnZXNcbiAgbGlua0lucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgbGluayA9IHtcbiAgICAgIHR1cGxlOiBsLFxuICAgICAgc291cmNlOiBub2Rlc1tsLnNvdXJjZV0sXG4gICAgICB0YXJnZXQ6IG5vZGVzW2wudGFyZ2V0XVxuICAgIH07XG4gICAgdHVwbGUuc2V0KGwsIG91dHB1dC5zb3VyY2UsIGxpbmsuc291cmNlLnR1cGxlKTtcbiAgICB0dXBsZS5zZXQobCwgb3V0cHV0LnRhcmdldCwgbGluay50YXJnZXQudHVwbGUpO1xuICAgIGxpbmtzLnB1c2gobGluayk7XG4gIH0pO1xuXG4gIC8vIFRPRE8gcHJvY2VzcyBcIm1vZFwiIG9mIGVkZ2Ugc291cmNlIG9yIHRhcmdldD9cblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zaXplKHRoaXMuc2l6ZS5nZXQoZykpXG4gICAgLmxpbmtEaXN0YW5jZShnZXQodGhpcywgXCJsaW5rRGlzdGFuY2VcIikpXG4gICAgLmxpbmtTdHJlbmd0aChnZXQodGhpcywgXCJsaW5rU3RyZW5ndGhcIikpXG4gICAgLmNoYXJnZShnZXQodGhpcywgXCJjaGFyZ2VcIikpXG4gICAgLmNoYXJnZURpc3RhbmNlKGdldCh0aGlzLCBcImNoYXJnZURpc3RhbmNlXCIpKVxuICAgIC5mcmljdGlvbih0aGlzLmZyaWN0aW9uLmdldChnKSlcbiAgICAudGhldGEodGhpcy50aGV0YS5nZXQoZykpXG4gICAgLmdyYXZpdHkodGhpcy5ncmF2aXR5LmdldChnKSlcbiAgICAuYWxwaGEodGhpcy5hbHBoYS5nZXQoZykpXG4gICAgLm5vZGVzKG5vZGVzKVxuICAgIC5saW5rcyhsaW5rcyk7XG5cbiAgLy8gcnVuIGxheW91dFxuICBsYXlvdXQuc3RhcnQoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGl0ZXI7ICsraSkge1xuICAgIGxheW91dC50aWNrKCk7XG4gIH1cbiAgbGF5b3V0LnN0b3AoKTtcblxuICAvLyBjb3B5IGxheW91dCB2YWx1ZXMgdG8gbm9kZXNcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdHVwbGUuc2V0KG4udHVwbGUsIG91dHB1dC54LCBuLngpO1xuICAgIHR1cGxlLnNldChuLnR1cGxlLCBvdXRwdXQueSwgbi55KTtcbiAgfSk7XG5cbiAgLy8gcHJvY2VzcyByZW1vdmVkIG5vZGVzXG4gIGlmIChub2RlSW5wdXQucmVtLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbm9kZUlkcyA9IHR1cGxlLmlkTWFwKG5vZGVJbnB1dC5yZW0pO1xuICAgIHRoaXMuX25vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuICFub2RlSWRzW24udHVwbGUuX2lkXTsgfSk7XG4gIH1cblxuICAvLyBwcm9jZXNzIHJlbW92ZWQgZWRnZXNcbiAgaWYgKGxpbmtJbnB1dC5yZW0ubGVuZ3RoID4gMCkge1xuICAgIHZhciBsaW5rSWRzID0gdHVwbGUuaWRNYXAobGlua0lucHV0LnJlbSk7XG4gICAgdGhpcy5fbGlua3MgPSBsaW5rcy5maWx0ZXIoZnVuY3Rpb24obCkgeyByZXR1cm4gIWxpbmtJZHNbbC50dXBsZS5faWRdOyB9KTtcbiAgfVxuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgbm9kZUlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBub2RlSW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBub2RlSW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgZXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRm9ybXVsYShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgZXhwcjogIHt0eXBlOiBcImV4cHJcIn1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGb3JtdWxhLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmb3JtdWxhdGluZ1wiXSk7XG4gIHZhciB0ID0gdGhpcywgXG4gICAgICBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBmaWVsZCA9IHRoaXMuZmllbGQuZ2V0KGcpLFxuICAgICAgZXhwciA9IHRoaXMuZXhwci5nZXQoZyksXG4gICAgICBkZXBzID0gdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG4gIFxuICBmdW5jdGlvbiBzZXQoeCkge1xuICAgIHZhciB2YWwgPSBleHByZXNzaW9uLmV2YWwoZywgZXhwciwgeCwgbnVsbCwgbnVsbCwgbnVsbCwgZGVwcyk7XG4gICAgdHVwbGUuc2V0KHgsIGZpZWxkLCB2YWwpO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgXG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tmaWVsZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm11bGE7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIEdlbyhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGxvbjoge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgbGF0OiB7dHlwZTogXCJmaWVsZFwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6IFwiZ2VvOnhcIixcbiAgICBcInlcIjogXCJnZW86eVwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgTm9uZVxuXG5HZW8uUGFyYW1ldGVycyA9IHtcbiAgcHJvamVjdGlvbjoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJtZXJjYXRvclwifSxcbiAgY2VudGVyOiAgICAge3R5cGU6IFwiYXJyYXlbdmFsdWVdXCJ9LFxuICB0cmFuc2xhdGU6ICB7dHlwZTogXCJhcnJheVt2YWx1ZV1cIn0sXG4gIHJvdGF0ZTogICAgIHt0eXBlOiBcImFycmF5W3ZhbHVlXVwifSxcbiAgc2NhbGU6ICAgICAge3R5cGU6IFwidmFsdWVcIn0sXG4gIHByZWNpc2lvbjogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICBjbGlwQW5nbGU6ICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgY2xpcEV4dGVudDoge3R5cGU6IFwidmFsdWVcIn1cbn07XG5cbkdlby5kM1Byb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIHAgPSB0aGlzLnByb2plY3Rpb24uZ2V0KGcpLFxuICAgICAgcGFyYW0gPSBHZW8uUGFyYW1ldGVycyxcbiAgICAgIHByb2osIG5hbWUsIHZhbHVlO1xuXG4gIGlmIChwICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgdGhpcy5fbW9kZSA9IHA7XG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IGQzLmdlb1twXSgpO1xuICB9XG4gIHByb2ogPSB0aGlzLl9wcm9qZWN0aW9uO1xuXG4gIGZvciAobmFtZSBpbiBwYXJhbSkge1xuICAgIGlmIChuYW1lID09PSBcInByb2plY3Rpb25cIiB8fCAhcHJvaltuYW1lXSkgY29udGludWU7XG4gICAgdmFsdWUgPSB0aGlzW25hbWVdLmdldChnKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCAoZGwuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gcHJvaltuYW1lXSgpKSB7XG4gICAgICBwcm9qW25hbWVdKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvajtcbn07XG5cbnZhciBwcm90byA9IChHZW8ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGxvbiA9IHRoaXMubG9uLmdldChnKS5hY2Nlc3NvcixcbiAgICAgIGxhdCA9IHRoaXMubGF0LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHByb2ogPSBHZW8uZDNQcm9qZWN0aW9uLmNhbGwodGhpcyk7XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgbGwgPSBbbG9uKHQpLCBsYXQodCldO1xuICAgIHZhciB4eSA9IHByb2oobGwpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQueCwgeHlbMF0pO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQueSwgeHlbMV0pO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgR2VvID0gcmVxdWlyZSgnLi9HZW8nKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gR2VvUGF0aChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHZhbHVlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBudWxsfSxcbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwicGF0aFwiOiBcImdlbzpwYXRoXCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHZW9QYXRoLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBnZW9qc29uID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IgfHwgZGwuaWRlbnRpdHksXG4gICAgICBwcm9qID0gR2VvLmQzUHJvamVjdGlvbi5jYWxsKHRoaXMpLFxuICAgICAgcGF0aCA9IGQzLmdlby5wYXRoKCkucHJvamVjdGlvbihwcm9qKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aChnZW9qc29uKHQpKSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQucGF0aF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb1BhdGg7XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnkoZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIHRoaXMuaW5pdChncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoR3JvdXBCeS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5fZ2IgPSBudWxsOyAvLyBmaWVsZHMrYWNjZXNzb3JzIHRvIGdyb3VwYnkgZmllbGRzXG4gIHRoaXMuX2NlbGxzID0ge307XG4gIHJldHVybiBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpLnJldmlzZXModHJ1ZSk7XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jZWxsczsgfTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB2YXIgaywgYztcbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBpZighKGMgPSB0aGlzLl9jZWxsc1trXSkpIGNvbnRpbnVlO1xuICAgIG91dHB1dC5yZW0ucHVzaChjLnRwbCk7XG4gIH1cbiAgdGhpcy5fY2VsbHMgPSB7fTtcbn07XG5cbnByb3RvLl9rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYWNjID0gdGhpcy5fZ2IuYWNjZXNzb3JzIHx8IFt0aGlzLl9nYi5hY2Nlc3Nvcl07XG4gIHZhciBrZXlzID0gYWNjLnJlZHVjZShmdW5jdGlvbihnLCBmKSB7XG4gICAgcmV0dXJuICgodiA9IGYoeCkpICE9PSB1bmRlZmluZWQpID8gKGcucHVzaCh2KSwgZykgOiBnO1xuICB9LCBbXSksIGsgPSBrZXlzLmpvaW4oXCJ8XCIpLCB2O1xuICByZXR1cm4ga2V5cy5sZW5ndGggPiAwID8ge2tleXM6IGtleXMsIGtleToga30gOiB1bmRlZmluZWQ7XG59O1xuXG5wcm90by5fY2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGsgPSB0aGlzLl9rZXlzKHgpO1xuICByZXR1cm4gdGhpcy5fY2VsbHNbay5rZXldIHx8ICh0aGlzLl9jZWxsc1trLmtleV0gPSB0aGlzLl9uZXdfY2VsbCh4LCBrKSk7XG59O1xuXG5wcm90by5fbmV3X2NlbGwgPSBmdW5jdGlvbih4LCBrKSB7XG4gIHJldHVybiB7XG4gICAgY250OiAwLFxuICAgIHRwbDogdGhpcy5fbmV3X3R1cGxlKHgsIGspLFxuICAgIGZsZzogQy5BRERfQ0VMTFxuICB9O1xufTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgdmFyIGdiID0gdGhpcy5fZ2IsXG4gICAgICBmaWVsZHMgPSBnYi5maWVsZHMgfHwgW2diLmZpZWxkXSxcbiAgICAgIGFjYyA9IGdiLmFjY2Vzc29ycyB8fCBbZ2IuYWNjZXNzb3JdLFxuICAgICAgdCA9IHt9LCBpLCBsZW47XG5cbiAgZm9yKGk9MCwgbGVuPWZpZWxkcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB0W2ZpZWxkc1tpXV0gPSBhY2NbaV0oeCk7XG4gIH0gXG5cbiAgcmV0dXJuIHR1cGxlLmluZ2VzdCh0LCBudWxsKTtcbn07XG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KTtcbiAgY2VsbC5jbnQgKz0gMTtcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCk7XG4gIGNlbGwuY250IC09IDE7XG4gIGNlbGwuZmxnIHw9IEMuTU9EX0NFTEw7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX21vZCA9IGZ1bmN0aW9uKHgsIHJlc2V0KSB7XG4gIGlmKHguX3ByZXYgJiYgeC5fcHJldiAhPT0gQy5TRU5USU5FTCAmJiB0aGlzLl9rZXlzKHguX3ByZXYpICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9yZW0oeC5fcHJldik7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh4KTtcbiAgfSBlbHNlIGlmKHJlc2V0KSB7IC8vIFNpZ25hbCBjaGFuZ2UgdHJpZ2dlcmVkIHJlZmxvd1xuICAgIHJldHVybiB0aGlzLl9hZGQoeCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2NlbGwoeCk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgdmFyIGdyb3VwQnkgPSB0aGlzLFxuICAgICAgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBrLCBjLCBmLCB0O1xuXG4gIGlmKHJlc2V0KSB0aGlzLl9yZXNldChpbnB1dCwgb3V0cHV0KTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7IGdyb3VwQnkuX2FkZCh4KTsgfSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgZ3JvdXBCeS5fbW9kKHgsIHJlc2V0KTsgfSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZih4Ll9wcmV2ICYmIHguX3ByZXYgIT09IEMuU0VOVElORUwgJiYgZ3JvdXBCeS5fa2V5cyh4Ll9wcmV2KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBncm91cEJ5Ll9yZW0oeC5fcHJldik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwQnkuX3JlbSh4KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKCFjKSBjb250aW51ZTtcbiAgICBmID0gYy5mbGc7XG4gICAgdCA9IGMudHBsO1xuXG4gICAgaWYoYy5jbnQgPT09IDApIHtcbiAgICAgIGlmKGYgPT09IEMuTU9EX0NFTEwpIG91dHB1dC5yZW0ucHVzaCh0KTtcbiAgICAgIHRoaXMuX2NlbGxzW2tdID0gbnVsbDtcbiAgICB9IGVsc2UgaWYoZiAmIEMuQUREX0NFTEwpIHtcbiAgICAgIG91dHB1dC5hZGQucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYoZiAmIEMuTU9EX0NFTEwpIHtcbiAgICAgIG91dHB1dC5tb2QucHVzaCh0KTtcbiAgICB9XG4gICAgYy5mbGcgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBCeTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIExpbmtQYXRoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHNvdXJjZTogIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiX3NvdXJjZVwifSxcbiAgICB0YXJnZXQ6ICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcIl90YXJnZXRcIn0sXG4gICAgeDogICAgICAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJsYXlvdXQ6eFwifSxcbiAgICB5OiAgICAgICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImxheW91dDp5XCJ9LFxuICAgIHRlbnNpb246IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMn0sXG4gICAgc2hhcGU6ICAge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJsaW5lXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcInBhdGhcIjogXCJsaW5rOnBhdGhcIn07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoTGlua1BhdGgucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gbGluZShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KTtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkxcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxuZnVuY3Rpb24gY3VydmUoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBkeCA9IHR4IC0gc3gsXG4gICAgICBkeSA9IHR5IC0gc3ksXG4gICAgICBpeCA9IHRlbnNpb24gKiAoZHggKyBkeSksXG4gICAgICBpeSA9IHRlbnNpb24gKiAoZHkgLSBkeCk7XG4gIHJldHVybiBcIk1cIiArIHN4ICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCJDXCIgKyAoc3graXgpICsgXCIsXCIgKyAoc3kraXkpXG4gICAgICAgKyBcIiBcIiArICh0eCtpeSkgKyBcIixcIiArICh0eS1peClcbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFgoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBtID0gKHN4ICsgdHgpIC8gMjtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIG0gICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCIgXCIgKyBtICArIFwiLFwiICsgdHlcbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFkoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBtID0gKHN5ICsgdHkpIC8gMjtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIHN4ICsgXCIsXCIgKyBtXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyBtXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxudmFyIHNoYXBlcyA9IHtcbiAgbGluZTogICAgICBsaW5lLFxuICBjdXJ2ZTogICAgIGN1cnZlLFxuICBkaWFnb25hbDogIGRpYWdvbmFsWCxcbiAgZGlhZ29uYWxYOiBkaWFnb25hbFgsXG4gIGRpYWdvbmFsWTogZGlhZ29uYWxZXG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgc2hhcGUgPSBzaGFwZXNbdGhpcy5zaGFwZS5nZXQoZyldIHx8IHNoYXBlcy5saW5lLFxuICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgeCA9IHRoaXMueC5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB5ID0gdGhpcy55LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHRlbnNpb24gPSB0aGlzLnRlbnNpb24uZ2V0KGcpO1xuICBcbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgcGF0aCA9IHNoYXBlKHQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKVxuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aCk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnBhdGhdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rUGF0aDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIGFycmF5VHlwZSA9IC9hcnJheS9pLFxuICAgIGRhdGFUeXBlICA9IC9kYXRhL2ksXG4gICAgZmllbGRUeXBlID0gL2ZpZWxkL2ksXG4gICAgZXhwclR5cGUgID0gL2V4cHIvaTtcblxuZnVuY3Rpb24gUGFyYW1ldGVyKG5hbWUsIHR5cGUpIHtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuXG4gIC8vIElmIHBhcmFtZXRlciBpcyBkZWZpbmVkIHcvc2lnbmFscywgaXQgbXVzdCBiZSByZXNvbHZlZFxuICAvLyBvbiBldmVyeSBwdWxzZS5cbiAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gIHRoaXMuX3Jlc29sdXRpb24gPSBmYWxzZTtcbiAgdGhpcy5fc2lnbmFscyA9IHt9O1xufVxuXG52YXIgcHJvdG8gPSBQYXJhbWV0ZXIucHJvdG90eXBlO1xuXG5wcm90by5fZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc0FycmF5ID0gYXJyYXlUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICBpZiAoaXNEYXRhKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB7IG5hbWVzOiB0aGlzLl92YWx1ZSwgc291cmNlczogdGhpcy5fYWNjZXNzb3JzIH0gOlxuICAgICAgeyBuYW1lOiB0aGlzLl92YWx1ZVswXSwgc291cmNlOiB0aGlzLl9hY2Nlc3NvcnNbMF0gfTtcbiAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB7IGZpZWxkczogdGhpcy5fdmFsdWUsIGFjY2Vzc29yczogdGhpcy5fYWNjZXNzb3JzIH0gOlxuICAgICAgeyBmaWVsZDogdGhpcy5fdmFsdWVbMF0sIGFjY2Vzc29yOiB0aGlzLl9hY2Nlc3NvcnNbMF0gfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHRoaXMuX3ZhbHVlIDogdGhpcy5fdmFsdWVbMF07XG4gIH1cbn07XG5cbnByb3RvLmdldCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIHMsIGlkeCwgdmFsO1xuXG4gIC8vIElmIHdlIGRvbid0IHJlcXVpcmUgcmVzb2x1dGlvbiwgcmV0dXJuIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgaWYgKCF0aGlzLl9yZXNvbHV0aW9uKSByZXR1cm4gdGhpcy5fZ2V0KCk7XG5cbiAgaWYgKGlzRGF0YSkge1xuICAgIHRoaXMuX2FjY2Vzc29ycyA9IHRoaXMuX3ZhbHVlLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBncmFwaC5kYXRhKHYpOyB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCk7IC8vIFRPRE86IHN1cHBvcnQgc2lnbmFsIGFzIGRhdGFUeXBlc1xuICB9XG5cbiAgZm9yKHMgaW4gdGhpcy5fc2lnbmFscykge1xuICAgIGlkeCAgPSB0aGlzLl9zaWduYWxzW3NdO1xuICAgIHZhbCAgPSBncmFwaC5zaWduYWxSZWYocyk7XG5cbiAgICBpZiAoaXNGaWVsZCkge1xuICAgICAgdGhpcy5fYWNjZXNzb3JzW2lkeF0gPSB0aGlzLl92YWx1ZVtpZHhdICE9IHZhbCA/IFxuICAgICAgICBkbC5hY2Nlc3Nvcih2YWwpIDogdGhpcy5fYWNjZXNzb3JzW2lkeF07XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWVbaWR4XSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9nZXQoKTtcbn07XG5cbnByb3RvLnNldCA9IGZ1bmN0aW9uKHRyYW5zZm9ybSwgdmFsdWUpIHtcbiAgdmFyIHBhcmFtID0gdGhpcywgXG4gICAgICBpc0V4cHIgPSBleHByVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSk7XG5cbiAgdGhpcy5fdmFsdWUgPSBkbC5hcnJheSh2YWx1ZSkubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcodikpIHtcbiAgICAgIGlmIChpc0V4cHIpIHtcbiAgICAgICAgdmFyIGUgPSBleHByKHYpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgIGUuZmllbGRzKTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBlLnNpZ25hbHMpO1xuICAgICAgICByZXR1cm4gZS5mbjtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaWVsZCkgeyAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgcGFyYW0uX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgdik7XG4gICAgICB9IGVsc2UgaWYgKGlzRGF0YSkge1xuICAgICAgICBwYXJhbS5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuREFUQSwgdik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9IGVsc2UgaWYgKHYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHYudmFsdWU7XG4gICAgfSBlbHNlIGlmICh2LmZpZWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtLl9hY2Nlc3NvcnNbaV0gPSBkbC5hY2Nlc3Nvcih2LmZpZWxkKTtcbiAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCB2LmZpZWxkKTtcbiAgICAgIHJldHVybiB2LmZpZWxkO1xuICAgIH0gZWxzZSBpZiAodi5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW0uX3Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgcGFyYW0uX3NpZ25hbHNbdi5zaWduYWxdID0gaTtcbiAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdi5zaWduYWwpO1xuICAgICAgcmV0dXJuIHYuc2lnbmFsO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbWV0ZXI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIFBpZShncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHZhbHVlOiAgICAgIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIHN0YXJ0QW5nbGU6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDB9LFxuICAgIGVuZEFuZ2xlOiAgIHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDIgKiBNYXRoLlBJfSxcbiAgICBzb3J0OiAgICAgICB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBmYWxzZX1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwic3RhcnRcIjogXCJsYXlvdXQ6c3RhcnRcIixcbiAgICBcInN0b3BcIjogIFwibGF5b3V0OnN0b3BcIixcbiAgICBcIm1pZFwiOiAgIFwibGF5b3V0Om1pZFwiXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChQaWUucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBvbmVzKCkgeyByZXR1cm4gMTsgfVxuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWUuZ2V0KGcpLmFjY2Vzc29yIHx8IG9uZXMsXG4gICAgICBzdGFydCA9IHRoaXMuc3RhcnRBbmdsZS5nZXQoZyksXG4gICAgICBzdG9wID0gdGhpcy5lbmRBbmdsZS5nZXQoZyksXG4gICAgICBzb3J0ID0gdGhpcy5zb3J0LmdldChnKTtcblxuICB2YXIgdmFsdWVzID0gZGF0YS5tYXAodmFsdWUpLFxuICAgICAgYSA9IHN0YXJ0LFxuICAgICAgayA9IChzdG9wIC0gc3RhcnQpIC8gZDMuc3VtKHZhbHVlcyksXG4gICAgICBpbmRleCA9IGRsLnJhbmdlKGRhdGEubGVuZ3RoKSxcbiAgICAgIGksIHQsIHY7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZXNbYV0gLSB2YWx1ZXNbYl07XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxpbmRleC5sZW5ndGg7ICsraSkge1xuICAgIHQgPSBkYXRhW2luZGV4W2ldXTtcbiAgICB2ID0gdmFsdWVzW2luZGV4W2ldXTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnN0YXJ0LCBhKTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0Lm1pZCwgKGEgKyAwLjUgKiB2ICogaykpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQuc3RvcCwgKGEgKz0gdiAqIGspKTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdG9wXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQubWlkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGllO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxuZnVuY3Rpb24gU29ydChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9IH0pO1xuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChTb3J0LnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJzb3J0aW5nXCJdKTtcblxuICBpZihpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0Lm1vZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIGlucHV0LnNvcnQgPSBkbC5jb21wYXJhdG9yKHRoaXMuYnkuZ2V0KHRoaXMuX2dyYXBoKS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb3J0OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gU3RhY2soZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0sXG4gICAgc29ydGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0sXG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCJ9LFxuICAgIG9mZnNldDoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJ6ZXJvXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInN0YXJ0XCI6IFwibGF5b3V0OnN0YXJ0XCIsXG4gICAgXCJzdG9wXCI6ICBcImxheW91dDpzdG9wXCIsXG4gICAgXCJtaWRcIjogICBcImxheW91dDptaWRcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFN0YWNrLnByb3RvdHlwZSA9IG5ldyBCYXRjaFRyYW5zZm9ybSgpKTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgZ3JvdXBieSA9IHRoaXMuZ3JvdXBieS5nZXQoZykuYWNjZXNzb3JzLFxuICAgICAgc29ydGJ5ID0gZGwuY29tcGFyYXRvcih0aGlzLnNvcnRieS5nZXQoZykuZmllbGRzKSxcbiAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IsXG4gICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldC5nZXQoZyksXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQ7XG5cbiAgLy8gcGFydGl0aW9uLCBzdW0sIGFuZCBzb3J0IHRoZSBzdGFjayBncm91cHNcbiAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBzb3J0YnksIHZhbHVlKTtcblxuICAvLyBjb21wdXRlIHN0YWNrIGxheW91dHMgcGVyIGdyb3VwXG4gIGZvciAodmFyIGk9MCwgbWF4PWdyb3Vwcy5tYXg7IGk8Z3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldLFxuICAgICAgICBzdW0gPSBncm91cC5zdW0sXG4gICAgICAgIG9mZiA9IG9mZnNldD09PVwiY2VudGVyXCIgPyAobWF4IC0gc3VtKS8yIDogMCxcbiAgICAgICAgc2NhbGUgPSBvZmZzZXQ9PT1cIm5vcm1hbGl6ZVwiID8gKDEvc3VtKSA6IDEsXG4gICAgICAgIGksIHgsIGEsIGIgPSBvZmYsIHYgPSAwO1xuXG4gICAgLy8gc2V0IHN0YWNrIGNvb3JkaW5hdGVzIGZvciBlYWNoIGRhdHVtIGluIGdyb3VwXG4gICAgZm9yIChqPTA7IGo8Z3JvdXAubGVuZ3RoOyArK2opIHtcbiAgICAgIHggPSBncm91cFtqXTtcbiAgICAgIGEgPSBiOyAvLyB1c2UgcHJldmlvdXMgdmFsdWUgZm9yIHN0YXJ0IHBvaW50XG4gICAgICB2ICs9IHZhbHVlKHgpO1xuICAgICAgYiA9IHNjYWxlICogdiArIG9mZjsgLy8gY29tcHV0ZSBlbmQgcG9pbnRcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5zdG9wLCBiKTtcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQubWlkLCAwLjUgKiAoYSArIGIpKTtcbiAgICB9XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0YXJ0XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RvcF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0Lm1pZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydGJ5LCB2YWx1ZSkge1xuICB2YXIgZ3JvdXBzID0gW10sXG4gICAgICBtYXAsIGksIHgsIGssIGcsIHMsIG1heDtcblxuICAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBzdGFjayBncm91cHNcbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEuc2xpY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXA9e30sIGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB4ID0gZGF0YVtpXTtcbiAgICAgIGsgPSAoZ3JvdXBieS5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gZih4KTsgfSkpO1xuICAgICAgZyA9IG1hcFtrXSB8fCAoZ3JvdXBzLnB1c2gobWFwW2tdID0gW10pLCBtYXBba10pO1xuICAgICAgZy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbXB1dGUgc3VtcyBvZiBncm91cHMsIHNvcnQgZ3JvdXBzIGFzIG5lZWRlZFxuICBmb3IgKGs9MCwgbWF4PTA7IGs8Z3JvdXBzLmxlbmd0aDsgKytrKSB7XG4gICAgZyA9IGdyb3Vwc1trXTtcbiAgICBmb3IgKGk9MCwgcz0wOyBpPGcubGVuZ3RoOyArK2kpIHtcbiAgICAgIHMgKz0gdmFsdWUoZ1tpXSk7XG4gICAgfVxuICAgIGcuc3VtID0gcztcbiAgICBpZiAocyA+IG1heCkgbWF4ID0gcztcbiAgICBpZiAoc29ydGJ5ICE9IG51bGwpIGcuc29ydChzb3J0YnkpO1xuICB9XG4gIGdyb3Vwcy5tYXggPSBtYXg7XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjazsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBQYXJhbWV0ZXIgPSByZXF1aXJlKCcuL1BhcmFtZXRlcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5UcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHByb3RvLCBwYXJhbXMpIHtcbiAgdmFyIHA7XG4gIGZvciAodmFyIG5hbWUgaW4gcGFyYW1zKSB7XG4gICAgcCA9IHBhcmFtc1tuYW1lXTtcbiAgICBwcm90b1tuYW1lXSA9IG5ldyBQYXJhbWV0ZXIobmFtZSwgcC50eXBlKTtcbiAgICBpZiAocC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSBwcm90b1tuYW1lXS5zZXQocHJvdG8sIHAuZGVmYXVsdCk7XG4gIH1cbiAgcHJvdG8uX3BhcmFtZXRlcnMgPSBwYXJhbXM7XG59O1xuXG52YXIgcHJvdG8gPSAoVHJhbnNmb3JtLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IE5vZGUucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gIG4udHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gIG4uX3BhcmFtZXRlcnMgPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICBmb3IodmFyIGsgaW4gdGhpcykgeyBcbiAgICBpZihuW2tdKSBjb250aW51ZTtcbiAgICBuW2tdID0gdGhpc1trXTsgXG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHsgcmV0dXJuIGlucHV0OyB9O1xucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYW55IHRyYW5zZm9ybXMgc3RvcmUgY2FjaGVzIHRoYXQgbXVzdCBiZSBpbnZhbGlkYXRlZCBpZlxuICAvLyBhIHNpZ25hbCB2YWx1ZSBoYXMgY2hhbmdlZC4gXG4gIHZhciByZXNldCA9IHRoaXMuX3N0YW1wIDwgaW5wdXQuc3RhbXAgJiYgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUykuc29tZShmdW5jdGlvbihzKSB7IFxuICAgIHJldHVybiAhIWlucHV0LnNpZ25hbHNbc10gXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybShpbnB1dCwgcmVzZXQpO1xufTtcblxucHJvdG8ub3V0cHV0ID0gZnVuY3Rpb24obWFwKSB7XG4gIGZvciAodmFyIGtleSBpbiB0aGlzLl9vdXRwdXQpIHtcbiAgICBpZiAobWFwW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fb3V0cHV0W2tleV0gPSBtYXBba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gVHJlZW1hcChncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIC8vIGhpZXJhcmNoeSBwYXJhbWV0ZXJzXG4gICAgc29ydDoge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCIsIGRlZmF1bHQ6IFtcIi12YWx1ZVwiXX0sXG4gICAgY2hpbGRyZW46IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiY2hpbGRyZW5cIn0sXG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwidmFsdWVcIn0sXG4gICAgLy8gdHJlZW1hcCBwYXJhbWV0ZXJzXG4gICAgc2l6ZToge3R5cGU6IFwiYXJyYXk8dmFsdWU+XCIsIGRlZmF1bHQ6IFs1MDAsIDUwMF19LFxuICAgIHJvdW5kOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiB0cnVlfSxcbiAgICBzdGlja3k6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICByYXRpbzoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC41ICogKDEgKyBNYXRoLnNxcnQoNSkpfSxcbiAgICBwYWRkaW5nOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBudWxsfSxcbiAgICBtb2RlOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcInNxdWFyaWZ5XCJ9XG4gIH0pO1xuXG4gIHRoaXMuX2xheW91dCA9IGQzLmxheW91dC50cmVlbWFwKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiAgICAgIFwibGF5b3V0OnhcIixcbiAgICBcInlcIjogICAgICBcImxheW91dDp5XCIsXG4gICAgXCJ3aWR0aFwiOiAgXCJsYXlvdXQ6d2lkdGhcIixcbiAgICBcImhlaWdodFwiOiBcImxheW91dDpoZWlnaHRcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFRyZWVtYXAucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dDtcblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zb3J0KGRsLmNvbXBhcmF0b3IodGhpcy5zb3J0LmdldChnKS5maWVsZHMpKVxuICAgIC5jaGlsZHJlbih0aGlzLmNoaWxkcmVuLmdldChnKS5hY2Nlc3NvcilcbiAgICAudmFsdWUodGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IpXG4gICAgLnNpemUodGhpcy5zaXplLmdldChnKSlcbiAgICAucm91bmQodGhpcy5yb3VuZC5nZXQoZykpXG4gICAgLnN0aWNreSh0aGlzLnN0aWNreS5nZXQoZykpXG4gICAgLnJhdGlvKHRoaXMucmF0aW8uZ2V0KGcpKVxuICAgIC5wYWRkaW5nKHRoaXMucGFkZGluZy5nZXQoZykpXG4gICAgLm1vZGUodGhpcy5tb2RlLmdldChnKSlcbiAgICAubm9kZXMoZGF0YVswXSk7XG5cbiAgLy8gY29weSBsYXlvdXQgdmFsdWVzIHRvIG5vZGVzXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC54LCBuLngpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQueSwgbi55KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LndpZHRoLCBuLmR4KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LmhlaWdodCwgbi5keSk7XG4gIH0pO1xuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgaW5wdXQuZmllbGRzW291dHB1dC54XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueV0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LndpZHRoXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuaGVpZ2h0XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZW1hcDsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBVbmlxdWUoZ3JhcGgpIHtcbiAgR3JvdXBCeS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBhczoge3R5cGU6IFwidmFsdWVcIn1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChVbmlxdWUucHJvdG90eXBlID0gbmV3IEdyb3VwQnkoKSk7XG5cbnByb3RvLl9uZXdfdHVwbGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBvICA9IHt9LFxuICAgICAgb24gPSB0aGlzLmZpZWxkLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBhcyA9IHRoaXMuYXMuZ2V0KHRoaXMuX2dyYXBoKTtcblxuICBvW2FzXSA9IG9uLmFjY2Vzc29yKHgpO1xuICByZXR1cm4gdHVwbGUuaW5nZXN0KG8sIG51bGwpO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJ1bmlxdWVzXCJdKTtcbiAgdGhpcy5fZ2IgPSB0aGlzLmZpZWxkLmdldCh0aGlzLl9ncmFwaCk7XG4gIHJldHVybiBHcm91cEJ5LnByb3RvdHlwZS50cmFuc2Zvcm0uY2FsbCh0aGlzLCBpbnB1dCwgcmVzZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlxdWU7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvQ29sbGVjdG9yJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbmZ1bmN0aW9uIFppcChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICB3aXRoOiB7dHlwZTogXCJkYXRhXCJ9LFxuICAgIGFzOiAge3R5cGU6IFwidmFsdWVcIn0sXG4gICAga2V5OiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImRhdGFcIn0sXG4gICAgd2l0aEtleToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogbnVsbH0sXG4gICAgZGVmYXVsdDoge3R5cGU6IFwidmFsdWVcIn1cbiAgfSk7XG5cbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpO1xuICB0aGlzLl9sYXN0Sm9pbiA9IDA7XG5cbiAgcmV0dXJuIHRoaXMucmV2aXNlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKFppcC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBtcChrKSB7XG4gIHJldHVybiB0aGlzLl9tYXBba10gfHwgKHRoaXMuX21hcFtrXSA9IFtdKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB3ID0gdGhpcy53aXRoLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICB3ZHMgPSB3LnNvdXJjZSxcbiAgICAgIHdvdXRwdXQgPSB3ZHMubGFzdCgpLFxuICAgICAgd2RhdGEgPSB3ZHMudmFsdWVzKCksXG4gICAgICBrZXkgPSB0aGlzLmtleS5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgd2l0aEtleSA9IHRoaXMud2l0aEtleS5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgYXMgPSB0aGlzLmFzLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBkZmx0ID0gdGhpcy5kZWZhdWx0LmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBtYXAgPSBtcC5iaW5kKHRoaXMpLFxuICAgICAgcmVtID0ge307XG5cbiAgZGVidWcoaW5wdXQsIFtcInppcHBpbmdcIiwgdy5uYW1lXSk7XG5cbiAgaWYod2l0aEtleS5maWVsZCkge1xuICAgIGlmKHdvdXRwdXQgJiYgd291dHB1dC5zdGFtcCA+IHRoaXMuX2xhc3RKb2luKSB7XG4gICAgICB3b3V0cHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIG0gPSBtYXAod2l0aEtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgIGlmKG1bMF0pIG1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0gZGZsdCB9KTtcbiAgICAgICAgbVsxXSA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgd291dHB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7IFxuICAgICAgICB2YXIgbSA9IG1hcCh3aXRoS2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgaWYobVswXSkgbVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSB4IH0pO1xuICAgICAgICBtWzFdID0geDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHByb2Nlc3Mgd291dHB1dC5tb2QgdHVwbGVzIGlmIHRoZSBqb2luIGtleSBoYXMgY2hhbmdlZC5cbiAgICAgIC8vIE90aGVyIGZpZWxkIHVwZGF0ZXMgd2lsbCBhdXRvLXByb3BhZ2F0ZSB2aWEgcHJvdG90eXBlLlxuICAgICAgaWYod291dHB1dC5maWVsZHNbd2l0aEtleS5maWVsZF0pIHtcbiAgICAgICAgd291dHB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdmFyIHByZXY7XG4gICAgICAgICAgaWYoIXguX3ByZXYgfHwgKHByZXYgPSB3aXRoS2V5LmFjY2Vzc29yKHguX3ByZXYpKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgdmFyIHByZXZtID0gbWFwKHByZXYpO1xuICAgICAgICAgIGlmKHByZXZtWzBdKSBwcmV2bVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSBkZmx0IH0pO1xuICAgICAgICAgIHByZXZtWzFdID0gbnVsbDtcblxuICAgICAgICAgIHZhciBtID0gbWFwKHdpdGhLZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICAgIGlmKG1bMF0pIG1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0geCB9KTtcbiAgICAgICAgICBtWzFdID0geDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhc3RKb2luID0gd291dHB1dC5zdGFtcDtcbiAgICB9XG4gIFxuICAgIGlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBtID0gbWFwKGtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICB4W2FzXSA9IG1bMV0gfHwgZGZsdDtcbiAgICAgIChtWzBdPW1bMF18fFtdKS5wdXNoKHgpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkgeyBcbiAgICAgIHZhciBrID0ga2V5LmFjY2Vzc29yKHgpO1xuICAgICAgKHJlbVtrXT1yZW1ba118fHt9KVt4Ll9pZF0gPSAxO1xuICAgIH0pO1xuXG4gICAgaWYoaW5wdXQuZmllbGRzW2tleS5maWVsZF0pIHtcbiAgICAgIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGlmKCF4Ll9wcmV2IHx8IChwcmV2ID0ga2V5LmFjY2Vzc29yKHguX3ByZXYpKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgdmFyIG0gPSBtYXAoa2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgeFthc10gPSBtWzFdIHx8IGRmbHQ7XG4gICAgICAgIChtWzBdPW1bMF18fFtdKS5wdXNoKHgpO1xuICAgICAgICAocmVtW3ByZXZdPXJlbVtwcmV2XXx8e30pW3guX2lkXSA9IDE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkbC5rZXlzKHJlbSkuZm9yRWFjaChmdW5jdGlvbihrKSB7IFxuICAgICAgdmFyIG0gPSBtYXAoayk7XG4gICAgICBpZighbVswXSkgcmV0dXJuO1xuICAgICAgbVswXSA9IG1bMF0uZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbVtrXVt4Ll9pZF0gIT09IDEgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIHJ1biBhIG5vbi1rZXktam9pbiBhZ2FpbiBpZiB3ZSd2ZSBnb3QgYW55IGFkZC9yZW1cbiAgICAvLyBvbiBpbnB1dCBvciB3b3V0cHV0XG4gICAgaWYoaW5wdXQuYWRkLmxlbmd0aCA9PSAwICYmIGlucHV0LnJlbS5sZW5ndGggPT0gMCAmJiBcbiAgICAgICAgd291dHB1dC5hZGQubGVuZ3RoID09IDAgJiYgd291dHB1dC5yZW0ubGVuZ3RoID09IDApIHJldHVybiBpbnB1dDtcblxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBrZXktam9pbiwgdGhlbiB3ZSBuZWVkIHRvIG1hdGVyaWFsaXplIGJvdGhcbiAgICAvLyBkYXRhIHNvdXJjZXMgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZW0uIFxuICAgIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksIFxuICAgICAgICB3bGVuID0gd2RhdGEubGVuZ3RoLCBpO1xuXG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykgeyBkYXRhW2ldW2FzXSA9IHdkYXRhW2kld2xlbl07IH1cbiAgfVxuXG4gIGlucHV0LmZpZWxkc1thc10gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcDsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWdncmVnYXRlOiAgcmVxdWlyZSgnLi9BZ2dyZWdhdGUnKSxcbiAgYmluOiAgICAgICAgcmVxdWlyZSgnLi9CaW4nKSxcbiAgY3Jvc3M6ICAgICAgcmVxdWlyZSgnLi9Dcm9zcycpLFxuICBsaW5rcGF0aDogICByZXF1aXJlKCcuL0xpbmtQYXRoJyksXG4gIGZhY2V0OiAgICAgIHJlcXVpcmUoJy4vRmFjZXQnKSxcbiAgZmlsdGVyOiAgICAgcmVxdWlyZSgnLi9GaWx0ZXInKSxcbiAgZm9sZDogICAgICAgcmVxdWlyZSgnLi9Gb2xkJyksXG4gIGZvcmNlOiAgICAgIHJlcXVpcmUoJy4vRm9yY2UnKSxcbiAgZm9ybXVsYTogICAgcmVxdWlyZSgnLi9Gb3JtdWxhJyksXG4gIGdlbzogICAgICAgIHJlcXVpcmUoJy4vR2VvJyksXG4gIGdlb3BhdGg6ICAgIHJlcXVpcmUoJy4vR2VvUGF0aCcpLFxuICBwaWU6ICAgICAgICByZXF1aXJlKCcuL1BpZScpLFxuICBzb3J0OiAgICAgICByZXF1aXJlKCcuL1NvcnQnKSxcbiAgc3RhY2s6ICAgICAgcmVxdWlyZSgnLi9TdGFjaycpLFxuICB0cmVlbWFwOiAgICByZXF1aXJlKCcuL1RyZWVtYXAnKSxcbiAgdW5pcXVlOiAgICAgcmVxdWlyZSgnLi9VbmlxdWUnKSxcbiAgemlwOiAgICAgICAgcmVxdWlyZSgnLi9aaXAnKVxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIHF1aWNrc2VsZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9xdWlja3NlbGVjdCcpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgdHlwZXMgPSB7XG4gIFwiY291bnRcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJjb3VudFwiLFxuICAgIGluaXQ6IFwiXCIsXG4gICAgYWRkOiAgXCJcIixcbiAgICByZW06ICBcIlwiLFxuICAgIHNldDogIFwidGhpcy5jZWxsLmNudFwiXG4gIH0pLFxuICBcIl9jb3VudHNcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJfY291bnRzXCIsXG4gICAgaW5pdDogXCJ0aGlzLmNudHMgPSB7fTtcIixcbiAgICBhZGQ6ICBcInRoaXMuY250c1t2XSA9ICsrdGhpcy5jbnRzW3ZdIHx8IDE7XCIsXG4gICAgcmVtOiAgXCJ0aGlzLmNudHNbdl0gPSAtLXRoaXMuY250c1t2XSA8IDAgPyAwIDogdGhpcy5jbnRzW3ZdO1wiLFxuICAgIHNldDogIFwiXCIsXG4gICAgcmVxOiAgW1wiY291bnRcIl1cbiAgfSksXG4gIFwic3VtXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwic3VtXCIsXG4gICAgaW5pdDogXCJ0aGlzLnN1bSA9IDA7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLnN1bSArPSB2O1wiLFxuICAgIHJlbTogIFwidGhpcy5zdW0gLT0gdjtcIixcbiAgICBzZXQ6ICBcInRoaXMuc3VtXCJcbiAgfSksXG4gIFwiYXZnXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwiYXZnXCIsXG4gICAgaW5pdDogXCJ0aGlzLmF2ZyA9IDA7XCIsXG4gICAgYWRkOiAgXCJ2YXIgZCA9IHYgLSB0aGlzLmF2ZzsgdGhpcy5hdmcgKz0gZCAvIHRoaXMuY2VsbC5jbnQ7XCIsXG4gICAgcmVtOiAgXCJ2YXIgZCA9IHYgLSB0aGlzLmF2ZzsgdGhpcy5hdmcgLT0gZCAvIHRoaXMuY2VsbC5jbnQ7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLmF2Z1wiLFxuICAgIHJlcTogIFtcImNvdW50XCJdLCBpZHg6IDFcbiAgfSksXG4gIFwidmFyXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwidmFyXCIsXG4gICAgaW5pdDogXCJ0aGlzLmRldiA9IDA7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLmRldiArPSBkICogKHYgLSB0aGlzLmF2Zyk7XCIsXG4gICAgcmVtOiAgXCJ0aGlzLmRldiAtPSBkICogKHYgLSB0aGlzLmF2Zyk7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLmRldiAvICh0aGlzLmNlbGwuY250LTEpXCIsXG4gICAgcmVxOiAgW1wiYXZnXCJdLCBpZHg6IDJcbiAgfSksXG4gIFwidmFycFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInZhcnBcIixcbiAgICBpbml0OiBcIlwiLFxuICAgIGFkZDogIFwiXCIsXG4gICAgcmVtOiAgXCJcIixcbiAgICBzZXQ6ICBcInRoaXMuZGV2IC8gdGhpcy5jZWxsLmNudFwiLFxuICAgIHJlcTogIFtcInZhclwiXSwgaWR4OiAzXG4gIH0pLFxuICBcInN0ZGV2XCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwic3RkZXZcIixcbiAgICBpbml0OiBcIlwiLFxuICAgIGFkZDogIFwiXCIsXG4gICAgcmVtOiAgXCJcIixcbiAgICBzZXQ6ICBcIk1hdGguc3FydCh0aGlzLmRldiAvICh0aGlzLmNlbGwuY250LTEpKVwiLFxuICAgIHJlcTogIFtcInZhclwiXSwgaWR4OiA0XG4gIH0pLFxuICBcInN0ZGV2cFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInN0ZGV2cFwiLFxuICAgIGluaXQ6IFwiXCIsXG4gICAgYWRkOiAgXCJcIixcbiAgICByZW06ICBcIlwiLFxuICAgIHNldDogIFwiTWF0aC5zcXJ0KHRoaXMuZGV2IC8gdGhpcy5jZWxsLmNudClcIixcbiAgICByZXE6ICBbXCJ2YXJcIl0sIGlkeDogNVxuICB9KSxcbiAgXCJtaW5cIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJtaW5cIixcbiAgICBpbml0OiBcInRoaXMubWluID0gK0luZmluaXR5O1wiLFxuICAgIGFkZDogIFwidGhpcy5taW4gPSB2IDwgdGhpcy5taW4gPyB2IDogdGhpcy5taW47XCIsXG4gICAgcmVtOiAgXCJ2YXIgc2VsZiA9IHRoaXM7IHRoaXMubWluID0gdiA9PSB0aGlzLm1pbiBcIiArXG4gICAgICAgICAgXCI/IHRoaXMua2V5cyh0aGlzLmNudHMpLnJlZHVjZShmdW5jdGlvbihtLCB2KSB7IFwiICtcbiAgICAgICAgICBcIiAgIHJldHVybiBzZWxmLmNudHNbKHYgPSArdildID4gMCAmJiB2IDwgbSA/IHYgOiBtIH0sICtJbmZpbml0eSkgXCIgKyBcbiAgICAgICAgICBcIjogdGhpcy5taW47XCIsXG4gICAgc2V0OiAgXCJ0aGlzLm1pblwiLFxuICAgIHJlcTogW1wiX2NvdW50c1wiXSwgaWR4OiA2XG4gIH0pLFxuICBcIm1heFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcIm1heFwiLFxuICAgIGluaXQ6IFwidGhpcy5tYXggPSAtSW5maW5pdHk7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLm1heCA9IHYgPiB0aGlzLm1heCA/IHYgOiB0aGlzLm1heDtcIixcbiAgICByZW06ICBcInZhciBzZWxmID0gdGhpczsgdGhpcy5tYXggPSB2ID09IHRoaXMubWF4IFwiICtcbiAgICAgICAgICBcIj8gdGhpcy5rZXlzKHRoaXMuY250cykucmVkdWNlKGZ1bmN0aW9uKG0sIHYpIHsgXCIgK1xuICAgICAgICAgIFwiICAgcmV0dXJuIHNlbGYuY250c1sodiA9ICt2KV0gPiAwICYmIHYgPiBtID8gdiA6IG0gfSwgLUluZmluaXR5KSBcIiArIFxuICAgICAgICAgIFwiOiB0aGlzLm1heDtcIixcbiAgICBzZXQ6ICBcInRoaXMubWF4XCIsXG4gICAgcmVxOiBbXCJfY291bnRzXCJdLCBpZHg6IDdcbiAgfSksXG4gIFwibWVkaWFuXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwibWVkaWFuXCIsXG4gICAgaW5pdDogXCJ0aGlzLnZhbHMgPSBbXTsgXCIsXG4gICAgYWRkOiAgXCJpZih0aGlzLnZhbHMpIHRoaXMudmFscy5wdXNoKHYpOyBcIixcbiAgICByZW06ICBcInRoaXMudmFscyA9IG51bGw7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLmNlbGwuY250ICUgMiA/IHRoaXMuc2VsKH5+KHRoaXMuY2VsbC5jbnQvMiksIHRoaXMudmFscywgdGhpcy5jbnRzKSA6IFwiK1xuICAgICAgICAgIFwiMC41ICogKHRoaXMuc2VsKH5+KHRoaXMuY2VsbC5jbnQvMiktMSwgdGhpcy52YWxzLCB0aGlzLmNudHMpICsgdGhpcy5zZWwofn4odGhpcy5jZWxsLmNudC8yKSwgdGhpcy52YWxzLCB0aGlzLmNudHMpKVwiLFxuICAgIHJlcTogW1wiX2NvdW50c1wiXSwgaWR4OiA4XG4gIH0pXG59O1xuXG5mdW5jdGlvbiBtZWFzdXJlKGJhc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCkge1xuICAgIHZhciBtID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICBtLm91dCA9IG91dCB8fCBiYXNlLm5hbWU7XG4gICAgaWYgKCFtLmlkeCkgbS5pZHggPSAwO1xuICAgIHJldHVybiBtO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGFnZykge1xuICBmdW5jdGlvbiBjb2xsZWN0KG0sIGEpIHtcbiAgICAoYS5yZXEgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgaWYgKCFtW3JdKSBjb2xsZWN0KG0sIG1bcl0gPSB0eXBlc1tyXSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICB2YXIgbWFwID0gYWdnLnJlZHVjZShjb2xsZWN0LFxuICAgIGFnZy5yZWR1Y2UoZnVuY3Rpb24obSwgYSkgeyByZXR1cm4gKG1bYS5uYW1lXSA9IGEsIG0pOyB9LCB7fSkpO1xuICB2YXIgYWxsID0gW107XG4gIGZvciAodmFyIGsgaW4gbWFwKSBhbGwucHVzaChtYXBba10pO1xuICBhbGwuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pO1xuICByZXR1cm4gYWxsO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKGFnZykge1xuICB2YXIgYWxsID0gcmVzb2x2ZShhZ2cpLFxuICAgICAgY3RyID0gXCJ0aGlzLnRwbCA9IHQ7IHRoaXMuY2VsbCA9IGM7XCIsXG4gICAgICBhZGQgPSBcIlwiLFxuICAgICAgcmVtID0gXCJcIixcbiAgICAgIHNldCA9IFwidmFyIHQgPSB0aGlzLnRwbDtcIjtcblxuICBhbGwuZm9yRWFjaChmdW5jdGlvbihhKSB7IGN0ciArPSBhLmluaXQ7IGFkZCArPSBhLmFkZDsgcmVtICs9IGEucmVtOyB9KTtcbiAgYWdnLmZvckVhY2goZnVuY3Rpb24oYSkgeyBzZXQgKz0gXCJ0aGlzLnR1cGxlLnNldCh0LCdcIithLm91dCtcIicsXCIrYS5zZXQrXCIpO1wiOyB9KTtcbiAgc2V0ICs9IFwicmV0dXJuIHQ7XCI7XG5cbiAgY3RyID0gRnVuY3Rpb24oXCJjXCIsIFwidFwiLCBjdHIpO1xuICBjdHIucHJvdG90eXBlLmFkZCA9IEZ1bmN0aW9uKFwidlwiLCBhZGQpO1xuICBjdHIucHJvdG90eXBlLnJlbSA9IEZ1bmN0aW9uKFwidlwiLCByZW0pO1xuICBjdHIucHJvdG90eXBlLnNldCA9IEZ1bmN0aW9uKFwic3RhbXBcIiwgc2V0KTtcbiAgY3RyLnByb3RvdHlwZS5tb2QgPSBtb2Q7XG4gIGN0ci5wcm90b3R5cGUua2V5cyA9IGRsLmtleXM7XG4gIGN0ci5wcm90b3R5cGUuc2VsID0gcXVpY2tzZWxlY3Q7XG4gIGN0ci5wcm90b3R5cGUudHVwbGUgPSB0dXBsZTtcbiAgcmV0dXJuIGN0cjtcbn1cblxuZnVuY3Rpb24gbW9kKHZfbmV3LCB2X29sZCkge1xuICBpZiAodl9vbGQgPT09IHVuZGVmaW5lZCB8fCB2X29sZCA9PT0gdl9uZXcpIHJldHVybjtcbiAgdGhpcy5yZW0odl9vbGQpO1xuICB0aGlzLmFkZCh2X25ldyk7XG59O1xuXG50eXBlcy5jcmVhdGUgICA9IGNvbXBpbGU7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzOyIsInZhciBib3VuZHMgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59O1xuXG52YXIgcHJvdG90eXBlID0gYm91bmRzLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLngyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueTIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG4gIHRoaXMueDIgPSB4MjtcbiAgdGhpcy55MiA9IHkyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gIGlmICh5IDwgdGhpcy55MSkgdGhpcy55MSA9IHk7XG4gIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgdGhpcy54MSAtPSBkO1xuICB0aGlzLnkxIC09IGQ7XG4gIHRoaXMueDIgKz0gZDtcbiAgdGhpcy55MiArPSBkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLngxID0gTWF0aC5mbG9vcih0aGlzLngxKTtcbiAgdGhpcy55MSA9IE1hdGguZmxvb3IodGhpcy55MSk7XG4gIHRoaXMueDIgPSBNYXRoLmNlaWwodGhpcy54Mik7XG4gIHRoaXMueTIgPSBNYXRoLmNlaWwodGhpcy55Mik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICB0aGlzLngxICs9IGR4O1xuICB0aGlzLngyICs9IGR4O1xuICB0aGlzLnkxICs9IGR5O1xuICB0aGlzLnkyICs9IGR5O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgeCwgeSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgY3ggPSB4IC0geCpjb3MgKyB5KnNpbixcbiAgICAgIGN5ID0geSAtIHgqc2luIC0geSpjb3MsXG4gICAgICB4MSA9IHRoaXMueDEsIHgyID0gdGhpcy54MixcbiAgICAgIHkxID0gdGhpcy55MSwgeTIgPSB0aGlzLnkyO1xuXG4gIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MSArIGN4LCAgc2luKngxICsgY29zKnkxICsgY3kpXG4gICAgLmFkZChjb3MqeDEgLSBzaW4qeTIgKyBjeCwgIHNpbip4MSArIGNvcyp5MiArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkxICsgY3gsICBzaW4qeDIgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MiAtIHNpbip5MiArIGN4LCAgc2luKngyICsgY29zKnkyICsgY3kpO1xufVxuXG5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihiKSB7XG4gIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmVuY2xvc2VzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAoXG4gICAgdGhpcy54MSA8PSBiLngxICYmXG4gICAgdGhpcy54MiA+PSBiLngyICYmXG4gICAgdGhpcy55MSA8PSBiLnkxICYmXG4gICAgdGhpcy55MiA+PSBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIGIgJiYgIShcbiAgICB0aGlzLngyIDwgYi54MSB8fFxuICAgIHRoaXMueDEgPiBiLngyIHx8XG4gICAgdGhpcy55MiA8IGIueTEgfHxcbiAgICB0aGlzLnkxID4gYi55MlxuICApO1xufTtcblxucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gIShcbiAgICB4IDwgdGhpcy54MSB8fFxuICAgIHggPiB0aGlzLngyIHx8XG4gICAgeSA8IHRoaXMueTEgfHxcbiAgICB5ID4gdGhpcy55MlxuICApO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZHM7IiwidmFyIHZnX2dyYWRpZW50X2lkID0gMDtcblxuZnVuY3Rpb24gZ3JhZGllbnQodHlwZSkge1xuICB0aGlzLmlkID0gXCJncmFkX1wiICsgKHZnX2dyYWRpZW50X2lkKyspO1xuICB0aGlzLnR5cGUgPSB0eXBlIHx8IFwibGluZWFyXCI7XG4gIHRoaXMuc3RvcHMgPSBbXTtcbiAgdGhpcy54MSA9IDA7XG4gIHRoaXMueDIgPSAxO1xuICB0aGlzLnkxID0gMDtcbiAgdGhpcy55MiA9IDA7XG59O1xuXG52YXIgcHJvdG90eXBlID0gZ3JhZGllbnQucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKG9mZnNldCwgY29sb3IpIHtcbiAgdGhpcy5zdG9wcy5wdXNoKHtcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBjb2xvcjogY29sb3JcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBncmFkaWVudDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi91dGlsL0JvdW5kcycpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvcGF0aCcpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBwYXJzZSA9IGNhbnZhcy5wYXJzZSxcbiAgICBib3VuZFBhdGggPSBjYW52YXMuYm91bmRzLFxuICAgIGFyZWFQYXRoID0gY2FudmFzLmFyZWEsXG4gICAgbGluZVBhdGggPSBjYW52YXMubGluZSxcbiAgICBoYWxmcGkgPSBNYXRoLlBJIC8gMixcbiAgICBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCksXG4gICAgZ2Z4ID0gbnVsbDtcblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG5mdW5jdGlvbiBjb250ZXh0KCkge1xuICAvLyBUT0RPOiBob3cgdG8gY2hlY2sgaWYgbm9kZUpTIGluIHJlcXVpcmVKUz9cbiAgcmV0dXJuIGdmeCB8fCAoZ2Z4ID0gKC8qY29uZmlnLmlzTm9kZVxuICAgID8gbmV3IChyZXF1aXJlKFwiY2FudmFzXCIpKSgxLDEpXG4gICAgOiAqL2QzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwiY2FudmFzXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ2ZWdhX2hpZGRlblwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIDEpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDEpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgIC5ub2RlKCkpXG4gICAgLmdldENvbnRleHQoXCIyZFwiKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhCb3VuZHMobywgcGF0aCwgYm91bmRzKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kUGF0aChwYXRoLCBib3VuZHMpO1xuICAgIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHBhdGgobywgYm91bmRzKSB7XG4gIHZhciBwID0gby5wYXRoXG4gICAgPyBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShvLnBhdGgpKVxuICAgIDogbnVsbDtcbiAgcmV0dXJuIHBhdGhCb3VuZHMobywgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gYXJlYShvLCBib3VuZHMpIHtcbiAgdmFyIGl0ZW1zID0gby5tYXJrLml0ZW1zLCBvID0gaXRlbXNbMF07XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2UoYXJlYVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW1zWzBdLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBsaW5lKG8sIGJvdW5kcykge1xuICB2YXIgaXRlbXMgPSBvLm1hcmsuaXRlbXMsIG8gPSBpdGVtc1swXTtcbiAgdmFyIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShsaW5lUGF0aChpdGVtcykpKTtcbiAgcmV0dXJuIHBhdGhCb3VuZHMoaXRlbXNbMF0sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIHJlY3QobywgYm91bmRzKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICB3ID0gKHggKyBvLndpZHRoKSB8fCAwLFxuICAgICAgaCA9ICh5ICsgby5oZWlnaHQpIHx8IDA7XG4gIGJvdW5kcy5zZXQoeCwgeSwgdywgaCk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8sIGJvdW5kcykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwLFxuICAgICAgeCA9IChvLnh8fDApIC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IChvLnl8fDApIC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKTtcbiAgcmV0dXJuIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xufVxuXG5mdW5jdGlvbiBydWxlKG8sIGJvdW5kcykge1xuICB2YXIgeDEsIHkxO1xuICBib3VuZHMuc2V0KFxuICAgIHgxID0gby54IHx8IDAsXG4gICAgeTEgPSBvLnkgfHwgMCxcbiAgICBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgby55MiAhPSBudWxsID8gby55MiA6IHkxXG4gICk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGFyYyhvLCBib3VuZHMpIHtcbiAgdmFyIGN4ID0gby54IHx8IDAsXG4gICAgICBjeSA9IG8ueSB8fCAwLFxuICAgICAgaXIgPSBvLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IG8ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIHNhID0gKG8uc3RhcnRBbmdsZSB8fCAwKSAtIGhhbGZwaSxcbiAgICAgIGVhID0gKG8uZW5kQW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICB4bWluID0gSW5maW5pdHksIHhtYXggPSAtSW5maW5pdHksXG4gICAgICB5bWluID0gSW5maW5pdHksIHltYXggPSAtSW5maW5pdHksXG4gICAgICBhLCBpLCBuLCB4LCB5LCBpeCwgaXksIG94LCBveTtcblxuICB2YXIgYW5nbGVzID0gW3NhLCBlYV0sXG4gICAgICBzID0gc2EgLSAoc2ElaGFsZnBpKTtcbiAgZm9yIChpPTA7IGk8NCAmJiBzPGVhOyArK2ksIHMrPWhhbGZwaSkge1xuICAgIGFuZ2xlcy5wdXNoKHMpO1xuICB9XG5cbiAgZm9yIChpPTAsIG49YW5nbGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBhID0gYW5nbGVzW2ldO1xuICAgIHggPSBNYXRoLmNvcyhhKTsgaXggPSBpcip4OyBveCA9IG9yKng7XG4gICAgeSA9IE1hdGguc2luKGEpOyBpeSA9IGlyKnk7IG95ID0gb3IqeTtcbiAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgaXgsIG94KTtcbiAgICB4bWF4ID0gTWF0aC5tYXgoeG1heCwgaXgsIG94KTtcbiAgICB5bWluID0gTWF0aC5taW4oeW1pbiwgaXksIG95KTtcbiAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgaXksIG95KTtcbiAgfVxuXG4gIGJvdW5kcy5zZXQoY3greG1pbiwgY3kreW1pbiwgY3greG1heCwgY3kreW1heCk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvLCBib3VuZHMpIHtcbiAgdmFyIHNpemUgPSBvLnNpemUgIT0gbnVsbCA/IG8uc2l6ZSA6IDEwMCxcbiAgICAgIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIHIsIHQsIHJ4LCByeTtcblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlIFwiY3Jvc3NcIjpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBib3VuZHMuc2V0KHgtdCwgeS1yLCB4K3QsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiB0YW4zMCkpO1xuICAgICAgcnggPSByeSAqIHRhbjMwO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yLCB5LXIsIHgrciwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLWRvd25cIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLXVwXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUvTWF0aC5QSSk7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gIH1cbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gdGV4dChvLCBib3VuZHMsIG5vUm90YXRlKSB7XG4gIHZhciB4ID0gKG8ueCB8fCAwKSArIChvLmR4IHx8IDApLFxuICAgICAgeSA9IChvLnkgfHwgMCkgKyAoby5keSB8fCAwKSxcbiAgICAgIGggPSBvLmZvbnRTaXplIHx8IGNvbmZpZy5yZW5kZXIuZm9udFNpemUsXG4gICAgICBhID0gby5hbGlnbixcbiAgICAgIGIgPSBvLmJhc2VsaW5lLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBnID0gY29udGV4dCgpLCB3LCB0O1xuXG4gIGcuZm9udCA9IGZvbnRTdHJpbmcobyk7XG4gIGcudGV4dEFsaWduID0gYSB8fCBcImxlZnRcIjtcbiAgZy50ZXh0QmFzZWxpbmUgPSBiIHx8IFwiYWxwaGFiZXRpY1wiO1xuICB3ID0gZy5tZWFzdXJlVGV4dChvLnRleHQgfHwgXCJcIikud2lkdGg7XG5cbiAgaWYgKHIpIHtcbiAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICAvLyBob3Jpem9udGFsXG4gIGlmIChhID09PSBcImNlbnRlclwiKSB7XG4gICAgeCA9IHggLSAodyAvIDIpO1xuICB9IGVsc2UgaWYgKGEgPT09IFwicmlnaHRcIikge1xuICAgIHggPSB4IC0gdztcbiAgfSBlbHNlIHtcbiAgICAvLyBsZWZ0IGJ5IGRlZmF1bHQsIGRvIG5vdGhpbmdcbiAgfVxuXG4gIC8vLyBUT0RPIGZpbmQgYSByb2J1c3Qgc29sdXRpb24gZm9yIGhlaWdodHMuXG4gIC8vLyBUaGVzZSBvZmZzZXRzIHdvcmsgZm9yIHNvbWUgYnV0IG5vdCBhbGwgZm9udHMuXG5cbiAgLy8gdmVydGljYWxcbiAgaWYgKGIgPT09IFwidG9wXCIpIHtcbiAgICB5ID0geSArIChoLzUpO1xuICB9IGVsc2UgaWYgKGIgPT09IFwiYm90dG9tXCIpIHtcbiAgICB5ID0geSAtIGg7XG4gIH0gZWxzZSBpZiAoYiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHkgPSB5IC0gKGgvMikgKyAoaC8xMCk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IHkgLSA0KmgvNTsgLy8gYWxwaGFiZXRpYyBieSBkZWZhdWx0XG4gIH1cbiAgXG4gIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xuICBpZiAoby5hbmdsZSAmJiAhbm9Sb3RhdGUpIHtcbiAgICBib3VuZHMucm90YXRlKG8uYW5nbGUqTWF0aC5QSS8xODAsIG8ueHx8MCwgby55fHwwKTtcbiAgfVxuICByZXR1cm4gYm91bmRzLmV4cGFuZChub1JvdGF0ZSA/IDAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAoZywgYm91bmRzLCBpbmNsdWRlTGVnZW5kcykge1xuICB2YXIgYXhlcyA9IGcuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgbGVnZW5kcyA9IGcubGVnZW5kSXRlbXMgfHwgW10sIGosIG07XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgYm91bmRzLnVuaW9uKGF4ZXNbal0uYm91bmRzKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1nLml0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBib3VuZHMudW5pb24oZy5pdGVtc1tqXS5ib3VuZHMpO1xuICB9XG4gIGlmIChpbmNsdWRlTGVnZW5kcykge1xuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgYm91bmRzLnVuaW9uKGxlZ2VuZHNbal0uYm91bmRzKTtcbiAgICB9XG4gICAgaWYgKGcud2lkdGggIT0gbnVsbCAmJiBnLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICBib3VuZHMuYWRkKGcud2lkdGgsIGcuaGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGcueCAhPSBudWxsICYmIGcueSAhPSBudWxsKSB7XG4gICAgICBib3VuZHMuYWRkKDAsIDApO1xuICAgIH1cbiAgfVxuICBib3VuZHMudHJhbnNsYXRlKGcueHx8MCwgZy55fHwwKTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxudmFyIG1ldGhvZHMgPSB7XG4gIGdyb3VwOiAgZ3JvdXAsXG4gIHN5bWJvbDogc3ltYm9sLFxuICBpbWFnZTogIGltYWdlLFxuICByZWN0OiAgIHJlY3QsXG4gIHJ1bGU6ICAgcnVsZSxcbiAgYXJjOiAgICBhcmMsXG4gIHRleHQ6ICAgdGV4dCxcbiAgcGF0aDogICBwYXRoLFxuICBhcmVhOiAgIGFyZWEsXG4gIGxpbmU6ICAgbGluZVxufTtcblxuZnVuY3Rpb24gaXRlbUJvdW5kcyhpdGVtLCBmdW5jLCBvcHQpIHtcbiAgZnVuYyA9IGZ1bmMgfHwgbWV0aG9kc1tpdGVtLm1hcmsubWFya3R5cGVdO1xuICBpZiAoIWl0ZW0uYm91bmRzX3ByZXYpIGl0ZW1bJ2JvdW5kczpwcmV2J10gPSBuZXcgQm91bmRzKCk7XG4gIHZhciBiID0gaXRlbS5ib3VuZHMsIHBiID0gaXRlbVsnYm91bmRzOnByZXYnXTtcbiAgaWYgKGIpIHBiLmNsZWFyKCkudW5pb24oYik7XG4gIGl0ZW0uYm91bmRzID0gZnVuYyhpdGVtLCBiID8gYi5jbGVhcigpIDogbmV3IEJvdW5kcygpLCBvcHQpO1xuICBpZiAoIWIpIHBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpO1xuICByZXR1cm4gaXRlbS5ib3VuZHM7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3VuZHMobWFyaywgYm91bmRzLCBvcHQpIHtcbiAgYm91bmRzID0gYm91bmRzIHx8IG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNsZWFyKCkgfHwgbmV3IEJvdW5kcygpO1xuICB2YXIgdHlwZSAgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgZnVuYyAgPSBtZXRob2RzW3R5cGVdLFxuICAgICAgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaXRlbSwgaSwgbGVuO1xuICAgICAgXG4gIGlmICh0eXBlPT09XCJhcmVhXCIgfHwgdHlwZT09PVwibGluZVwiKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgaXRlbXNbMF0uYm91bmRzID0gZnVuYyhpdGVtc1swXSwgYm91bmRzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGJvdW5kcy51bmlvbihpdGVtQm91bmRzKGl0ZW1zW2ldLCBmdW5jLCBvcHQpKTtcbiAgICB9XG4gIH1cbiAgbWFyay5ib3VuZHMgPSBib3VuZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXJrOiAgbWFya0JvdW5kcyxcbiAgaXRlbTogIGl0ZW1Cb3VuZHMsXG4gIHRleHQ6ICB0ZXh0LFxuICBncm91cDogZ3JvdXBcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgY29uZmlnID0ge307XG5cbmNvbmZpZy5kZWJ1ZyA9IGZhbHNlO1xuXG5jb25maWcubG9hZCA9IHtcbiAgLy8gYmFzZSB1cmwgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZGF0YSBmaWxlc1xuICAvLyB1c2VkIG9ubHkgZm9yIHNlcnZlci1zaWRlIG9wZXJhdGlvblxuICBiYXNlVVJMOiBcIlwiLFxuICAvLyBBbGxvd3MgZG9tYWluIHJlc3RyaWN0aW9uIHdoZW4gdXNpbmcgZGF0YSBsb2FkaW5nIHZpYSBYSFIuXG4gIC8vIFRvIGVuYWJsZSwgc2V0IGl0IHRvIGEgbGlzdCBvZiBhbGxvd2VkIGRvbWFpbnNcbiAgLy8gZS5nLiwgWyd3aWtpcGVkaWEub3JnJywgJ2VmZi5vcmcnXVxuICBkb21haW5XaGl0ZUxpc3Q6IGZhbHNlXG59O1xuXG4vLyB2ZXJzaW9uIGFuZCBuYW1lcHNhY2VzIGZvciBleHBvcnRlZCBzdmdcbmNvbmZpZy5zdmdOYW1lc3BhY2UgPVxuICAndmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICtcbiAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJztcblxuLy8gaW5zZXQgcGFkZGluZyBmb3IgYXV0b21hdGljIHBhZGRpbmcgY2FsY3VsYXRpb25cbmNvbmZpZy5hdXRvcGFkSW5zZXQgPSA1O1xuXG4vLyBleHRlbnNpYmxlIHNjYWxlIGxvb2t1cCB0YWJsZVxuLy8gYWxsIGQzLnNjYWxlLiogaW5zdGFuY2VzIGFsc28gc3VwcG9ydGVkXG5jb25maWcuc2NhbGUgPSB7XG4gIHRpbWU6IGQzLnRpbWUuc2NhbGUsXG4gIHV0YzogIGQzLnRpbWUuc2NhbGUudXRjXG59O1xuXG4vLyBkZWZhdWx0IHJlbmRlcmluZyBzZXR0aW5nc1xuY29uZmlnLnJlbmRlciA9IHtcbiAgbGluZVdpZHRoOiAxLFxuICBsaW5lQ2FwOiAgIFwiYnV0dFwiLFxuICBmb250OiAgICAgIFwic2Fucy1zZXJpZlwiLFxuICBmb250U2l6ZTogIDExXG59O1xuXG4vLyBkZWZhdWx0IGF4aXMgcHJvcGVydGllc1xuY29uZmlnLmF4aXMgPSB7XG4gIG9yaWVudDogXCJib3R0b21cIixcbiAgdGlja3M6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBheGlzQ29sb3I6IFwiIzAwMFwiLFxuICBncmlkQ29sb3I6IFwiI2Q4ZDhkOFwiLFxuICB0aWNrQ29sb3I6IFwiIzAwMFwiLFxuICB0aWNrTGFiZWxDb2xvcjogXCIjMDAwXCIsXG4gIGF4aXNXaWR0aDogMSxcbiAgdGlja1dpZHRoOiAxLFxuICB0aWNrU2l6ZTogNixcbiAgdGlja0xhYmVsRm9udFNpemU6IDExLFxuICB0aWNrTGFiZWxGb250OiBcInNhbnMtc2VyaWZcIixcbiAgdGl0bGVDb2xvcjogXCIjMDAwXCIsXG4gIHRpdGxlRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIHRpdGxlRm9udFNpemU6IDExLFxuICB0aXRsZUZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICB0aXRsZU9mZnNldDogMzVcbn07XG5cbi8vIGRlZmF1bHQgbGVnZW5kIHByb3BlcnRpZXNcbmNvbmZpZy5sZWdlbmQgPSB7XG4gIG9yaWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBncmFkaWVudFN0cm9rZUNvbG9yOiBcIiM4ODhcIixcbiAgZ3JhZGllbnRTdHJva2VXaWR0aDogMSxcbiAgZ3JhZGllbnRIZWlnaHQ6IDE2LFxuICBncmFkaWVudFdpZHRoOiAxMDAsXG4gIGxhYmVsQ29sb3I6IFwiIzAwMFwiLFxuICBsYWJlbEZvbnRTaXplOiAxMCxcbiAgbGFiZWxGb250OiBcInNhbnMtc2VyaWZcIixcbiAgbGFiZWxBbGlnbjogXCJsZWZ0XCIsXG4gIGxhYmVsQmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gIGxhYmVsT2Zmc2V0OiA4LFxuICBzeW1ib2xTaGFwZTogXCJjaXJjbGVcIixcbiAgc3ltYm9sU2l6ZTogNTAsXG4gIHN5bWJvbENvbG9yOiBcIiM4ODhcIixcbiAgc3ltYm9sU3Ryb2tlV2lkdGg6IDEsXG4gIHRpdGxlQ29sb3I6IFwiIzAwMFwiLFxuICB0aXRsZUZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiBcImJvbGRcIlxufTtcblxuLy8gZGVmYXVsdCBjb2xvciB2YWx1ZXNcbmNvbmZpZy5jb2xvciA9IHtcbiAgcmdiOiBbMTI4LCAxMjgsIDEyOF0sXG4gIGxhYjogWzUwLCAwLCAwXSxcbiAgaGNsOiBbMCwgMCwgNTBdLFxuICBoc2w6IFswLCAwLCAwLjVdXG59O1xuXG4vLyBkZWZhdWx0IHNjYWxlIHJhbmdlc1xuY29uZmlnLnJhbmdlID0ge1xuICBjYXRlZ29yeTEwOiBbXG4gICAgXCIjMWY3N2I0XCIsXG4gICAgXCIjZmY3ZjBlXCIsXG4gICAgXCIjMmNhMDJjXCIsXG4gICAgXCIjZDYyNzI4XCIsXG4gICAgXCIjOTQ2N2JkXCIsXG4gICAgXCIjOGM1NjRiXCIsXG4gICAgXCIjZTM3N2MyXCIsXG4gICAgXCIjN2Y3ZjdmXCIsXG4gICAgXCIjYmNiZDIyXCIsXG4gICAgXCIjMTdiZWNmXCJcbiAgXSxcbiAgY2F0ZWdvcnkyMDogW1xuICAgIFwiIzFmNzdiNFwiLFxuICAgIFwiI2FlYzdlOFwiLFxuICAgIFwiI2ZmN2YwZVwiLFxuICAgIFwiI2ZmYmI3OFwiLFxuICAgIFwiIzJjYTAyY1wiLFxuICAgIFwiIzk4ZGY4YVwiLFxuICAgIFwiI2Q2MjcyOFwiLFxuICAgIFwiI2ZmOTg5NlwiLFxuICAgIFwiIzk0NjdiZFwiLFxuICAgIFwiI2M1YjBkNVwiLFxuICAgIFwiIzhjNTY0YlwiLFxuICAgIFwiI2M0OWM5NFwiLFxuICAgIFwiI2UzNzdjMlwiLFxuICAgIFwiI2Y3YjZkMlwiLFxuICAgIFwiIzdmN2Y3ZlwiLFxuICAgIFwiI2M3YzdjN1wiLFxuICAgIFwiI2JjYmQyMlwiLFxuICAgIFwiI2RiZGI4ZFwiLFxuICAgIFwiIzE3YmVjZlwiLFxuICAgIFwiIzllZGFlNVwiXG4gIF0sXG4gIHNoYXBlczogW1xuICAgIFwiY2lyY2xlXCIsXG4gICAgXCJjcm9zc1wiLFxuICAgIFwiZGlhbW9uZFwiLFxuICAgIFwic3F1YXJlXCIsXG4gICAgXCJ0cmlhbmdsZS1kb3duXCIsXG4gICAgXCJ0cmlhbmdsZS11cFwiXG4gIF1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBRERfQ0VMTDogMSxcbiAgTU9EX0NFTEw6IDIsXG5cbiAgREFUQTogXCJkYXRhXCIsXG4gIEZJRUxEUzogIFwiZmllbGRzXCIsXG4gIFNDQUxFUzogIFwic2NhbGVzXCIsXG4gIFNJR05BTDogIFwic2lnbmFsXCIsXG4gIFNJR05BTFM6IFwic2lnbmFsc1wiLFxuXG4gIEdST1VQOiBcImdyb3VwXCIsXG5cbiAgRU5URVI6IFwiZW50ZXJcIixcbiAgVVBEQVRFOiBcInVwZGF0ZVwiLFxuICBFWElUOiBcImV4aXRcIixcblxuICBTRU5USU5FTDoge1wic2VudGluZWxcIjogMX0sXG4gIFNJTkdMRVRPTjogXCJfc2luZ2xldG9uXCIsXG5cbiAgQUREOiBcImFkZFwiLFxuICBSRU1PVkU6IFwicmVtb3ZlXCIsXG4gIFRPR0dMRTogXCJ0b2dnbGVcIixcbiAgQ0xFQVI6IFwiY2xlYXJcIixcblxuICBMSU5FQVI6IFwibGluZWFyXCIsXG4gIE9SRElOQUw6IFwib3JkaW5hbFwiLFxuICBMT0c6IFwibG9nXCIsXG4gIFBPV0VSOiBcInBvd1wiLFxuICBUSU1FOiBcInRpbWVcIixcbiAgUVVBTlRJTEU6IFwicXVhbnRpbGVcIixcblxuICBET01BSU46IFwiZG9tYWluXCIsXG4gIFJBTkdFOiBcInJhbmdlXCIsXG5cbiAgTUFSSzogXCJtYXJrXCIsXG4gIEFYSVM6IFwiYXhpc1wiLFxuICBMRUdFTkQ6IFwibGVnZW5kXCIsXG5cbiAgQ09VTlQ6IFwiY291bnRcIixcbiAgTUlOOiBcIm1pblwiLFxuICBNQVg6IFwibWF4XCIsXG5cbiAgQVNDOiBcImFzY1wiLFxuICBERVNDOiBcImRlc2NcIlxufTsiLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciB0cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbnB1dCwgYXJncykge1xuICBpZiAoIWNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuICB2YXIgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gIGFyZ3MudW5zaGlmdChpbnB1dC5zdGFtcHx8LTEpO1xuICBhcmdzLnVuc2hpZnQoRGF0ZS5ub3coKSAtIHRzKTtcbiAgaWYoaW5wdXQuYWRkKSBhcmdzLnB1c2goaW5wdXQuYWRkLmxlbmd0aCwgaW5wdXQubW9kLmxlbmd0aCwgaW5wdXQucmVtLmxlbmd0aCwgISFpbnB1dC5yZWZsb3cpO1xuICBsb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIHRzID0gRGF0ZS5ub3coKTtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHF1aWNrc2VsZWN0KGssIHgsIGMpIHtcbiAgZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgdmFyIHQgPSB4W2FdO1xuICAgIHhbYV0gPSB4W2JdO1xuICAgIHhbYl0gPSB0O1xuICB9XG5cbiAgLy8geCBtYXkgYmUgbnVsbCwgaW4gd2hpY2ggY2FzZSBhc3NlbWJsZSBhbiBhcnJheSBmcm9tIGMgKGNvdW50cylcbiAgaWYoeCA9PT0gbnVsbCkge1xuICAgIHggPSBbXTtcbiAgICBkbC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGkgPSAwLCBsZW4gPSBjW2tdO1xuICAgICAgayA9ICtrIHx8IGs7XG4gICAgICBmb3IoOyBpPGxlbjsgKytpKSB4LnB1c2goayk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIHZhciBsZWZ0ID0gMCxcbiAgICAgIHJpZ2h0ID0geC5sZW5ndGggLSAxLFxuICAgICAgcG9zLCBpLCBwaXZvdDtcbiAgXG4gIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICBwaXZvdCA9IHhba107XG4gICAgc3dhcChrLCByaWdodCk7XG4gICAgZm9yIChpID0gcG9zID0gbGVmdDsgaSA8IHJpZ2h0OyArK2kpIHtcbiAgICAgIGlmICh4W2ldIDwgcGl2b3QpIHsgc3dhcChpLCBwb3MrKyk7IH1cbiAgICB9XG4gICAgc3dhcChyaWdodCwgcG9zKTtcbiAgICBpZiAocG9zID09PSBrKSBicmVhaztcbiAgICBpZiAocG9zIDwgaykgbGVmdCA9IHBvcyArIDE7XG4gICAgZWxzZSByaWdodCA9IHBvcyAtIDE7XG4gIH1cbiAgcmV0dXJuIHhba107XG59OyJdfQ==\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x));\n};\n\nproto._newcell = function(x) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      if (cell.collect) {\n        cell.data.values();\n      }\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      result.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function() {\n  var changes = {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === Flags.MOD_CELL) {\n        changes.rem.push(cell.tuple);\n      }\n      delete this._cells[k];\n    } else if (flag & Flags.ADD_CELL) {\n      changes.add.push(cell.tuple);\n    } else if (flag & Flags.MOD_CELL) {\n      changes.mod.push(cell.tuple);\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;","var util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '$!_rem_!#';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return this._add;\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n;\n\n  if (k) {\n    // has unique key field, use that\n    var lut = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!lut.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else if (!util.isObject(r[0])) {\n    // process collection of raw values\n    var m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  this._f = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._f !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._f = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(f) {\n  return this.extent(f)[0];\n};\n\nproto.argmax = function(f) {\n  return this.extent(f)[1];\n};\n\nproto.min = function(f) {\n  var m = this.extent(f)[0];\n  return m ? f(m) : +Infinity;\n};\nproto.max = function(f) {\n  var m = this.extent(f)[1];\n  return m ? f(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._f !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._f = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(f) {\n  return this.quartile(f)[0];\n};\n\nproto.q2 = function(f) {\n  return this.quartile(f)[1];\n};\n\nproto.q3 = function(f) {\n  return this.quartile(f)[2];\n};\n\nmodule.exports = Collector;","var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n","var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;","var util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;","var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;","var util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\ntemplate.source = source;\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n","var STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","var dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n","var Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n","var Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;","var dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;","var dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;","var Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;","var C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};","var dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};","var dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};","module.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};","var datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;","var dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n","/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};","var dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;","var dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}","var lgnd = require('../scene/legend'),\n    config = require('../util/config');\n\nfunction legends(model, spec, legends, group) {\n  (spec || []).forEach(function(def, index) {\n    legends[index] = legends[index] || lgnd(model);\n    legend(def, index, legends[index], group);\n  });\n};\n\nfunction legend(def, index, legend, group) {\n  // legend scales\n  legend.size  (def.size   ? group.scale(def.size)   : null);\n  legend.shape (def.shape  ? group.scale(def.shape)  : null);\n  legend.fill  (def.fill   ? group.scale(def.fill)   : null);\n  legend.stroke(def.stroke ? group.scale(def.stroke) : null);\n\n  // legend orientation\n  if (def.orient) legend.orient(def.orient);\n\n  // legend offset\n  if (def.offset != null) legend.offset(def.offset);\n\n  // legend title\n  legend.title(def.title || null);\n\n  // legend values\n  legend.values(def.values || null);\n\n  // legend label formatting\n  legend.format(def.format !== undefined ? def.format : null);\n\n  // style properties\n  var p = def.properties;\n  legend.titleProperties(p && p.title || {});\n  legend.labelProperties(p && p.labels || {});\n  legend.legendProperties(p && p.legend || {});\n  legend.symbolProperties(p && p.symbols || {});\n  legend.gradientProperties(p && p.gradient || {});\n}\n\nmodule.exports = legends;","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};","var parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}","var dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}","var dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;","var expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};","var dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../util/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;","module.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};","var Bounds = require('../../util/Bounds'),\n    boundsCalc = require('../../util/boundscalc'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../util/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n","module.exports = {\n  Renderer: require('./Renderer')\n};\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n","var dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder = require('./Encoder'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n  var i, ilen, j, jlen, group, legend;\n      hasLegends = this._mark.marktype == C.GROUP \n        && dl.array(this._mark.def.legends).length > 0;\n\n  bounds.mark(this._mark, null, !hasLegends);\n\n  if(hasLegends) {\n    for(i=0, ilen=this._mark.items.length; i<ilen; ++i) {\n      group = this._mark.items[i];\n      group._legendPositions = null;\n      for(j=0, jlen=group.legendItems.length; j<jlen; ++j) {\n        legend = group.legendItems[j];\n        Encoder.update(this._graph, input.trans, \"vg_legendPosition\", legend.items);\n        bounds.mark(legend, null, true);\n      }\n    }\n\n    bounds.mark(this._mark, null, true);\n  }\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    parseLegends = require('../parse/legends'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n\n  scales = (def.legends||[]).reduce(function(acc, x) {\n    return (acc[x.size || x.shape || x.fill || x.stroke], acc);\n  }, scales);\n\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = dl.array(this._def.marks).length > 0,\n      hasAxes = dl.array(this._def.axes).length > 0,\n      hasLegends = dl.array(this._def.legends).length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n    if(hasLegends) buildLegends.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }\n\n    // Update legend data defs\n    if(hasLegends) {\n      parseLegends(builder._graph, builder._def.legends, group.legends, group);\n      group.legends.forEach(function(l, i) { l.def() });\n    }   \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n\n  group.legends = group.legends || [];\n  group.legendItems = group.legendItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nfunction buildLegends(input, group) {\n  var legends = group.legends,\n      legendItems = group.legendItems,\n      builder = this;\n\n  parseLegends(this._graph, this._def.legends, legends, group);\n  legends.forEach(function(l, i) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke(),\n        def = l.def(),\n        b = null;\n\n    legendItems[i] = {group: group, legendDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, legendItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.LEGEND, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;","var tuple = require('../dataflow/tuple'),\n    boundsCalc = require('../util/boundscalc'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    boundsCalc.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines:  null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title:  null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    parseProperties = require('../parse/properties'),\n    parseMark = require('../parse/mark'),\n    Gradient = require('../util/Gradient'),\n    config = require('../util/config');\n\nfunction lgnd(model) {\n  var size = null,\n      shape = null,\n      fill = null,\n      stroke = null,\n      spacing = null,\n      values = null,\n      format = null,\n      formatString = null,\n      title = undefined,\n      orient = \"right\",\n      offset = config.legend.offset,\n      padding = config.legend.padding,\n      legendDef,\n      tickArguments = [5],\n      legendStyle = {},\n      symbolStyle = {},\n      gradientStyle = {},\n      titleStyle = {},\n      labelStyle = {},\n      m = { // Legend marks as references for updates\n        titles:  null,\n        symbols: null,\n        labels:  null,\n        gradient: null\n      };\n\n  var legend = {},\n      legendDef = {};\n\n  function reset() { legendDef.type = null; }\n  function ingest(d, i) { return {data: d, index: i} }\n\n  legend.def = function() {\n    var scale = size || shape || fill || stroke;\n    \n    format = !formatString ? null : ((scale.type === 'time')\n      ? d3.time.format(formatString)\n      : d3.format(formatString));\n    \n    if (!legendDef.type) {\n      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type)\n        ? quantDef(scale)\n        : ordinalDef(scale);      \n    }\n    legendDef.orient = orient;\n    legendDef.offset = offset;\n    legendDef.padding = padding;\n    return legendDef;\n  };\n\n  function discrete(type) {\n    return type===\"ordinal\" || type===\"quantize\"\n      || type===\"quantile\" || type===\"threshold\";\n  }\n\n  function ordinalDef(scale) {\n    var def = o_legend_def(size, shape, fill, stroke);\n\n    // generate data\n    var data = (values == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : values).map(ingest);\n    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n    \n    // determine spacing between legend entries\n    var fs, range, offset, pad=5, domain = d3.range(data.length);\n    if (size) {\n      range = data.map(function(x) { return Math.sqrt(size(x.data)); });\n      offset = d3.max(range);\n      range = range.reduce(function(a,b,i,z) {\n          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;\n          return (a[i] += b/2, a); }, [0]).map(Math.round);\n    } else {\n      offset = Math.round(Math.sqrt(config.legend.symbolSize));\n      range = spacing\n        || (fs = labelStyle.fontSize) && (fs.value + pad)\n        || (config.legend.labelFontSize + pad);\n      range = domain.map(function(d,i) {\n        return Math.round(offset/2 + i*range);\n      });\n    }\n\n    // account for padding and title size\n    var sz = padding, ts;\n    if (title) {\n      ts = titleStyle.fontSize;\n      sz += 5 + ((ts && ts.value) || config.legend.titleFontSize);\n    }\n    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;\n    \n    // build scale for label layout\n    var scale = {\n      name: \"legend\",\n      type: \"ordinal\",\n      points: true,\n      domain: domain,\n      range: range\n    };\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d) {\n      d.label = fmt(d.data);\n      d.offset = offset;\n    });\n    def.scales = [ scale ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return data; };\n    def.marks[2].from = def.marks[1].from;\n\n    return def;\n  }\n\n  function o_legend_def(size, shape, fill, stroke) {\n    // setup legend marks\n    var titles  = m.titles  || (m.titles  = vg_legendTitle()),\n        symbols = m.symbols || (m.symbols = vg_legendSymbols()),\n        labels  = m.labels  || (m.labels  = vg_vLegendLabels());\n\n    // extend legend marks\n    vg_legendSymbolExtend(symbols, size, shape, fill, stroke);\n    \n    // add / override custom style properties\n    dl.extend(titles.properties.update,  titleStyle);\n    dl.extend(symbols.properties.update, symbolStyle);\n    dl.extend(labels.properties.update,  labelStyle);\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    labels.properties.enter.x.offset += padding + 1;\n    symbols.properties.enter.x.offset = padding + 1;\n    labels.properties.update.x.offset += padding + 1;\n    symbols.properties.update.x.offset = padding + 1;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales:[], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  function quantDef(scale) {\n    var def = q_legend_def(scale),\n        dom = scale.domain(),\n        data = dom.map(ingest),\n        width = (gradientStyle.width && gradientStyle.width.value) || config.legend.gradientWidth,\n        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n\n    // build scale for label layout\n    var layout = {\n      name: \"legend\",\n      type: scale.type,\n      round: true,\n      zero: false,\n      domain: [dom[0], dom[dom.length-1]],\n      range: [padding, width+padding]\n    };\n    if (scale.type===\"pow\") layout.exponent = scale.exponent();\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d,i) {\n      d.label = fmt(d.data);\n      d.align = i==(data.length-1) ? \"right\" : i==0 ? \"left\" : \"center\";\n    });\n    def.scales = [ layout ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return [1]; };\n    def.marks[2].from = function() { return data; };\n    return def;\n  }\n  \n  function q_legend_def(scale) {\n    // setup legend marks\n    var titles = m.title || (m.title = vg_legendTitle()),\n        gradient = m.gradient || (m.gradient = vg_legendGradient()),\n        labels = m.labels || (m.labels = vg_hLegendLabels()),\n        grad = new Gradient();\n\n    // setup color gradient\n    var dom = scale.domain(),\n        min = dom[0],\n        max = dom[dom.length-1],\n        f = scale.copy().domain([min, max]).range([0,1]);\n        \n    var stops = (scale.type !== \"linear\" && scale.ticks)\n      ? scale.ticks.call(scale, 15) : dom;\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== stops[stops.length-1]) stops.push(max);\n\n    for (var i=0, n=stops.length; i<n; ++i) {\n      grad.stop(f(stops[i]), scale(stops[i]));\n    }\n    gradient.properties.enter.fill = {value: grad};\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update, titleStyle);\n    dl.extend(gradient.properties.update, gradientStyle);\n    dl.extend(labels.properties.update, labelStyle);\n\n    // account for gradient size\n    var gp = gradient.properties, gh = gradientStyle.height,\n        hh = (gh && gh.value) || gp.enter.height.value;\n    labels.properties.enter.y.value = hh;\n    labels.properties.update.y.value = hh;\n\n    // account for title size as needed\n    if (title) {\n      var tp = titles.properties, fs = titleStyle.fontSize,\n          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);\n      gradient.properties.enter.y.value += sz;\n      labels.properties.enter.y.value += sz;\n      gradient.properties.update.y.value += sz;\n      labels.properties.update.y.value += sz;\n    }\n    \n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    gradient.properties.enter.x.value += padding;\n    gradient.properties.enter.y.value += padding;\n    labels.properties.enter.y.value += padding;\n    gradient.properties.update.x.value += padding;\n    gradient.properties.update.y.value += padding;\n    labels.properties.update.y.value += padding;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales: [], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  legend.size = function(x) {\n    if (!arguments.length) return size;\n    if (size !== x) { size = x; reset(); }\n    return legend;\n  };\n\n  legend.shape = function(x) {\n    if (!arguments.length) return shape;\n    if (shape !== x) { shape = x; reset(); }\n    return legend;\n  };\n\n  legend.fill = function(x) {\n    if (!arguments.length) return fill;\n    if (fill !== x) { fill = x; reset(); }\n    return legend;\n  };\n  \n  legend.stroke = function(x) {\n    if (!arguments.length) return stroke;\n    if (stroke !== x) { stroke = x; reset(); }\n    return legend;\n  };\n\n  legend.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return legend;\n  };\n\n  legend.format = function(x) {\n    if (!arguments.length) return formatString;\n    if (formatString !== x) {\n      formatString = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.spacing = function(x) {\n    if (!arguments.length) return spacing;\n    if (spacing !== +x) { spacing = +x; reset(); }\n    return legend;\n  };\n\n  legend.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x in vg_legendOrients ? x + \"\" : config.legend.orient;\n    return legend;\n  };\n\n  legend.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = +x;\n    return legend;\n  };\n\n  legend.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return legend;\n  };\n\n  legend.legendProperties = function(x) {\n    if (!arguments.length) return legendStyle;\n    legendStyle = x;\n    return legend;\n  };\n\n  legend.symbolProperties = function(x) {\n    if (!arguments.length) return symbolStyle;\n    symbolStyle = x;\n    return legend;\n  };\n\n  legend.gradientProperties = function(x) {\n    if (!arguments.length) return gradientStyle;\n    gradientStyle = x;\n    return legend;\n  };\n\n  legend.labelProperties = function(x) {\n    if (!arguments.length) return labelStyle;\n    labelStyle = x;\n    return legend;\n  };\n  \n  legend.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    titleStyle = x;\n    return legend;\n  };\n\n  legend.reset = function() { reset(); };\n\n  return legend;\n};\n\nvar vg_legendOrients = {right: 1, left: 1};\n\nfunction vg_legendPosition(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item, gx,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      pad    = item.mark.def.padding * 2,\n      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),\n      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),\n      pos = group._legendPositions || \n        (group._legendPositions = {right: 0.5, left: 0.5});\n\n  o.x = 0.5;\n  o.width = lw;\n  o.y = pos[orient];\n  pos[orient] += (o.height = lh);\n\n  // HACK: use to estimate group bounds during animated transition\n  if (!trans && group.bounds) {\n    group.bounds.delta = group.bounds.x2 - group.width;\n  }\n\n  switch (orient) {\n    case \"left\":  {\n      gx = group.bounds ? group.bounds.x1 : 0;\n      o.x += gx - offset - lw;\n      break;\n    };\n    case \"right\": {\n      gx = group.width;\n      if (group.bounds) gx = trans\n        ? group.width + group.bounds.delta\n        : group.bounds.x2;\n      o.x += gx + offset;\n      break;\n    };\n  }\n  \n  if (trans) trans.interpolate(item, o);\n  var enc = item.mark.def.properties.enter.encode;\n  enc.call(enc, item, group, trans);\n}\n\nfunction vg_legendSymbolExtend(mark, size, shape, fill, stroke) {\n  var e = mark.properties.enter,\n      u = mark.properties.update;\n  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: \"data\"};\n  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: \"data\"};\n  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: \"data\"};\n  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: \"data\"};\n}\n\nfunction vg_legendTitle() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        fill: {value: cfg.titleColor},\n        font: {value: cfg.titleFont},\n        fontSize: {value: cfg.titleFontSize},\n        fontWeight: {value: cfg.titleFontWeight},\n        baseline: {value: \"top\"},\n        text: {field: \"data\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_legendSymbols() {\n  var cfg = config.legend;\n  return {\n    type: \"symbol\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        shape: {value: cfg.symbolShape},\n        size: {value: cfg.symbolSize},\n        stroke: {value: cfg.symbolColor},\n        strokeWidth: {value: cfg.symbolStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_vLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {value: cfg.labelAlign},\n        baseline: {value: cfg.labelBaseline},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        opacity: {value: 1},\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n      }\n    }\n  };\n}\n\nfunction vg_legendGradient() {\n  var cfg = config.legend;\n  return {\n    type: \"rect\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        width: {value: cfg.gradientWidth},\n        height: {value: cfg.gradientHeight},\n        stroke: {value: cfg.gradientStrokeColor},\n        strokeWidth: {value: cfg.gradientStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {value: 0},\n        y: {value: 0},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_hLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        dy: {value: 2},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {field: \"align\"},\n        baseline: {value: \"top\"},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nmodule.exports = lgnd;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;","var Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;","var Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;","var dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;","var Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;","module.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};","var dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;","var bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;","var vg_gradient_id = 0;\n\nfunction gradient(type) {\n  this.id = \"grad_\" + (vg_gradient_id++);\n  this.type = type || \"linear\";\n  this.stops = [];\n  this.x1 = 0;\n  this.x2 = 1;\n  this.y1 = 0;\n  this.y2 = 0;\n};\n\nvar prototype = gradient.prototype;\n\nprototype.stop = function(offset, color) {\n  this.stops.push({\n    offset: offset,\n    color: color\n  });\n  return this;\n};\n\nmodule.exports = gradient;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../util/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;","module.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n  LEGEND: \"legend\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};","var config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};","var dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};"],"sourceRoot":"/source/"}