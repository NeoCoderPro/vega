{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index","vega2.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/aggregate/aggregator.js","node_modules/datalib/src/aggregate/collector.js","node_modules/datalib/src/aggregate/groupby.js","node_modules/datalib/src/aggregate/measures.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/bins/histogram.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/formats/dsv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/import/readers.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/index.js","node_modules/datalib/src/print.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/template.js","node_modules/datalib/src/time-units.js","node_modules/datalib/src/util.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","src/core/HeadlessView.js","src/core/Model.js","src/core/View.js","src/dataflow/Collector.js","src/dataflow/Datasource.js","src/dataflow/Graph.js","src/dataflow/Node.js","src/dataflow/Signal.js","src/dataflow/changeset.js","src/dataflow/tuple.js","src/expression/codegen.js","src/expression/constants.js","src/expression/functions.js","src/expression/index.js","src/expression/parser.js","src/parse/axes.js","src/parse/data.js","src/parse/events.js","src/parse/expr.js","src/parse/interactors.js","src/parse/legends.js","src/parse/mark.js","src/parse/marks.js","src/parse/modify.js","src/parse/padding.js","src/parse/predicates.js","src/parse/properties.js","src/parse/signals.js","src/parse/spec.js","src/parse/streams.js","src/parse/transforms.js","src/render/canvas/Handler.js","src/render/canvas/Renderer.js","src/render/canvas/index.js","src/render/canvas/marks.js","src/render/canvas/path.js","src/render/svg-headless/Renderer.js","src/render/svg-headless/index.js","src/render/svg-headless/svg.js","src/render/svg/Handler.js","src/render/svg/Renderer.js","src/render/svg/marks.js","src/scene/Bounder.js","src/scene/Builder.js","src/scene/Encoder.js","src/scene/GroupBuilder.js","src/scene/Item.js","src/scene/Scale.js","src/scene/Transition.js","src/scene/axis.js","src/scene/legend.js","src/transforms/Aggregate.js","src/transforms/BatchTransform.js","src/transforms/Bin.js","src/transforms/Cross.js","src/transforms/Facet.js","src/transforms/Filter.js","src/transforms/Fold.js","src/transforms/Force.js","src/transforms/Formula.js","src/transforms/Geo.js","src/transforms/GeoPath.js","src/transforms/GroupBy.js","src/transforms/LinkPath.js","src/transforms/Parameter.js","src/transforms/Pie.js","src/transforms/Sort.js","src/transforms/Stack.js","src/transforms/Transform.js","src/transforms/Treemap.js","src/transforms/Unique.js","src/transforms/Zip.js","src/transforms/index.js","src/transforms/measures.js","src/util/Bounds.js","src/util/Gradient.js","src/util/boundscalc.js","src/util/config.js","src/util/constants.js","src/util/debug.js","src/util/quickselect.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vg","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"core","View","dataflow","changeset","Datasource","Graph","Node","parse","spec","scene","Builder","GroupBuilder","transforms","config","util","./src/core/View","./src/dataflow/Datasource","./src/dataflow/Graph","./src/dataflow/Node","./src/dataflow/changeset","./src/parse/spec","./src/scene/Builder","./src/scene/GroupBuilder","./src/transforms/index","./src/util/config","datalib",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"Aggregator","_cells","_aggr","_stream","summarize_args","fields","isArray","ops","array","Measures","Collector","Flags","ADD_CELL","MOD_CELL","proto","prototype","stream","v","key","_key","$","groupby","dims","_dims","map","d","isString","get","isFunction","clear","summarize","_count","m","j","op","as","aggr","identity","measures","create","_assign","count","*","object","value","_cellkey","x","k","String","_cell","_newcell","cell","num","tuple","_newtuple","flag","aggs","collect","data","_ingest","_add","add","_rem","rem","_mod","curr","prev","cell0","cell1","isObject","result","values","set","_rems","changes","mod","execute","input","insert","_consolidate","remove","../util","./collector","./measures",5,"_last","stats","REM","_get","Array","toMap","hasOwnProperty","extent","_ext","index","argmin","argmax","min","Infinity","max","quartile","_q","q1","q2","q3","../stats",6,"args","reduce","arguments","concat","./aggregator",7,"measure","base","out","extend","init","idx","resolve","agg","helper","types","req","forEach","str","vals","sort","b","accessor","mutator","all","ctr","slice","Function","assign","distinct","isValid","v_new","v_old","undefined","missing","valid","sum","mean","average","variance","variancep","stdev","stdevp","median","modeskew",8,"bins","opt","step","level","minstep","precision","eps","maxb","maxbins","logb","Math","log","div","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","lo","hi","mid","cmp","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","raw","../time-units",9,"$bin","options","$func","histogram","numerical","categorical","type","qtype","ext","h","gen","range","isFinite","unique","c","comparator","integer","number","../generate","../import/type","./bins",10,"repeat","val","zeros","random","uniform","samples","normal","next","rds","y","sqrt",11,"dsv","format","header","join","delimiter","d3","delim","fmt","../../util",12,"json","topojson","treejson","csv","tsv","./dsv","./json","./topojson","./treejson",13,"isBuffer","JSON","property",14,"obj","feature","objects","features","mesh",15,"toTable","root","childrenField","visit","node","table","children",16,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","test","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","lastIndexOf","load","callback","error","err","indexOf","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","filename","fs","readFile","readFileSync","body","statusCode","getBody","sync-request",17,"read","formats","cols","parsers","clen","inferAll","duplicate","keys","annotation","./formats","./type",18,"./load","./read",19,"TYPES","isDate","isNumber","isBoolean","typeAll","infer","TESTS","splice","PARSERS","boolean","string","isNaN","Date",20,"dl","print","template","timeunits","./aggregate/groupby","./bins/bins","./bins/histogram","./generate","./import/load","./import/read","./import/readers","./import/type","./print","./stats","./template","./time-units","./util",21,"printQuantitativeProfile","p","printCategoricalProfile","list","top","FMT","POS","separator","minwidth","maxwidth","limit","lens","head","truncate","pad","tmpl","summary","__summary__","field",22,"results","filter","quantile","q","H","delta","M2","avg","med","std","dot","Number","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","L2","abs","R","M","entropy","counts","LN2","mutual","z","px","py","I","info","profile","sd",23,"text","src","source","bind","context","variable","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","stringCast","filters","split","prop","shift","trim","pidx","template_format","time","template_escapes","pattern","format_map","clearFormatCache","'","\\","\r","\n"," "," ",24,"STEPS","entries","UTC","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",25,"util_escape_str","escape_str_re","strrep","truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","Buffer","stderr","FNAME","namedfunc","stringify","equal","keystr","toString","Object","apply","$valid","$length","$year","$month","$date","$day","$hour","$minute","$in","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","searchString","pos","padchar","word","ellipsis","l1","l2","_process","buffer",26,"./lib/heap",27,"Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","item","lastelt","returnitem","pop","_ref","_i","_len","_ref1","_results","_results1","_j","elem","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","pushpop","peek","contains","empty","size","clone","heap","toArray","front","has","copy","factory",28,"canvas","svg","HeadlessView","width","height","model","_el","_type","_renderers","_canvas","renderer","canvasAsync","wait","pendingImages","view","render","_renderer","initialize","_width","_height","_padding","_viewport","left","right","bottom","_io","Renderer","initSVG","initCanvas","Canvas","tw","th","ctx","getContext","setAttribute","setTransform","resize","../render/canvas/index","../render/svg-headless/index","../util/debug","./View",29,"Model","_defs","_predicates","_scene","_node","_builder","predicates","defs","pipeline","predicate","disconnect","marks","connect","fire","cs","propagate","../dataflow/Graph","../dataflow/Node","../dataflow/changeset","../scene/GroupBuilder",30,"streaming","ds","_model","listener","streamer","_streamer","_changeset","api","signals","_api","update","build","_renderNode","router","evaluate","debug","trans","items","revises","finalize","last","parseStreams","Encoder","Transition","el","__width","__height","_autopad","_handler","dataValues","signal","setter","signalValues","reflow","_strict","padding","autopad","bounds","inset","autopadInset","x1","y1","x2","y2","viewport","_build","prevHandler","parentNode","select","append","attr","style","Handler","handlers","handler","duration","ease","props","listeners","onSignal","offSignal","../parse/streams","../render/svg/index","../scene/Encoder","../scene/Transition","../util/config","./HeadlessView",31,"graph","_data","collector","ids","_id","../util/constants","./Node","./changeset",32,"facet","_graph","_name","_source","_facet","_input","_output","_pipeline","_collector","_revises","set_prev","_prev","C","SENTINEL","ingest","where","func","idMap","unshift","output","dest","_srcMap","derive","./Collector","./tuple",33,"_signals","forEachNode","branch","Signal","_stamp","_rank","doNotPropagate","db","names","sg","signalRef","ref","schedule","pulse","reflowed","pq","stamp","_listeners","dependency","DATA","SIGNALS","reevaluate","run","./Datasource","./Signal",34,"REEVAL","FIELDS","SCALES","node_id","_registered","_deps","scales","_isRouter","_isCollector","deps","bool","cur","foundSending","reeval",35,"_value","_handlers",36,"reset_prev",37,"datum","tuple_id","reset",38,"codegen_wrap","ast","retval","codegen","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","DATUM","SIGNAL_PREFIX","Literal","Identifier","id","Program","MemberExpression","computed","CallExpression","callee","ArrayExpression","elements","BinaryExpression","operator","UnaryExpression","argument","UpdateExpression","prefix","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","Property","ExpressionStatement","expression","./constants","./functions",39,"E","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2",40,"fncall","cast","DATE","STRING","REGEXP","acos","asin","atan","atan2","cos","sin","tan","now","datetime","hours","minutes","seconds","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseFloat","parseInt","upper","lower","substring","if",41,"parser","./codegen","./parser",42,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","charCodeAt","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","token","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","EOF","collectToken","entry","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","msg","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","expr","state","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",43,"axes","group","def","axs","axis","scale","orient","ORIENT","layer","grid","titleOffset","tickValues","tickFormat","tickSubdivide","subdivide","tickPadding","tickSize","ts","tickSizeMajor","tickSizeMinor","tickSizeEnd","ticks","majorTickProperties","majorTicks","minorTickProperties","minorTicks","tickLabelProperties","labels","titleProperties","gridLineProperties","domainProperties","../scene/axis",44,"parseTransforms","parseModify","parseData","loaded","datasource","transform","modify","./modify","./transforms",45,"peg$subclass","child","ctor","constructor","SyntaxError","expected","peg$computePosDetails","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","buildMessage","stringEscape","hex","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","peg$parsemerged","s1","s2","s3","s4","s5","peg$parseordered","peg$FAILED","peg$parsesep","peg$c1","peg$silentFails","peg$c2","peg$reportedPos","peg$c3","peg$c0","peg$c4","s6","s7","s8","s9","s10","s11","s12","s13","peg$c5","peg$c6","peg$parsefiltered","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$parsestream","peg$parsefilter","peg$c13","peg$c14","peg$parseclass","peg$parseid","peg$c15","peg$parseeventType","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$parsevalue","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$result","peg$startRuleFunctions","peg$startRuleFunction","f1","f2","middle","event","target","startRule",46,"eval","../expression",47,"defFactory","interactor","inject","pd","nsSignals","nsPredicates","nsMarks","mk","injectMarks","from","ENTER","UPDATE","EXIT","ns","streams","operands","nsOperand","nsProperties","enter","exit","propset","rule","interactors",48,"legends","lgnd","legend","shape","fill","stroke","labelProperties","legendProperties","symbolProperties","symbols","gradientProperties","gradient","../scene/legend",49,"parseProperties","parseMark","mark","delay","./properties",50,"./mark",51,"signalName","ADD","REMOVE","TOGGLE","CLEAR","../dataflow/tuple",52,53,"parseSignal","parseOperands","decl","arg","pred","parseComparator","parseLogical","parseIn","parseScale","scope","invert","=","==","!=",">",">=","<","<=","and","&&","or","||","in",54,"compile","vars","valueRef","DEPS","hasPath","encoder","tpl","encode","path","tension","rules","inputs","predName","colorRef","sgRef","fRef","sRef","fieldRef","scaleRef","band","mult","xx","color","yy","zz","nested","fr",55,"parseSignals","exprVal","dep","./expr",56,"parsePadding","parseMarks","parsePredicates","parseInteractors","viewFactory","../core/Model","../core/View","../parse/data","../parse/interactors","../parse/marks","../parse/padding","../parse/predicates","../parse/signals",57,"changset","selector","START","MIDDLE","END","sig","register","orderedStream","trueFn","sp","mergedStream","sel","evt","filtered","preventDefault","mouse","./events","./signals",58,"tx","../transforms/index",59,"eventName","_active","_obj","that","events","addEventListener","touchmove","mousemove","getBoundingClientRect","clientX","clientY","pick","touchend","mouseout","DOMMouseScroll","gx","gy","marktype","picker","./marks",60,"scaleCanvas","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","initializeLineDash","vgLineDash","NODASH","setLineDash","dash","vgLineDashOffset","lineDashOffset","webkitLineDash","webkitLineDashOffset","mozDash","translatedBounds","Bounds","translate","getBounds","union","setBounds","bbox","beginPath","rect","clip","_ctx","_imgload","selectAll","_ratio","element","bb2","save","clearRect","draw","encloses","renderAsync","_async_id","clearTimeout","loadImage","uri","image","Image","../../util/Bounds","../../util/config",61,"./Handler","./Renderer",62,"fontString","fontStyle","fontVariant","fontWeight","fontSize","font","arcPath","ir","innerRadius","outerRadius","startAngle","ea","endAngle","moveTo","arc","closePath","areaPath","pathCache","parsePath","area","renderPath","linePath","pathPath","symbolPath","rx","ry","lineTo","tan30","sqrt3","lineStroke","lw","strokeWidth","lc","strokeCap","lineWidth","lineCap","ruleStroke","drawPathOne","opac","opacity","globalAlpha","fillOpacity","fillStyle","strokeOpacity","strokeStyle","strokeDash","strokeDashOffset","drawPathAll","intersects","drawRect","fillRect","strokeRect","drawRule","drawImage","align","baseline","drawText","textAlign","textBaseline","radius","theta","angle","rotate","dx","dy","fillText","strokeText","drawAll","pathFunc","drawOne","drawGroup","axisItems","legendItems","grad","createLinearGradient","stops","addColorStop","pickGroup","subscene","hit","interactive","pickAll","hitTests","pickArea","pickLine","textHit","boundsCalc","tmpBounds","isPointInStroke","isPointInPath","symbol","../../util/boundscalc","./path",63,"currentPath","chunks","parsed","re","chunksParsed","jlen","command","commandLength","cmdLength","klen","drawArc","coords","rot","large","sweep","ex","ey","segs","arcToSegments","bez","segmentToBezier","bezierCurveTo","boundArc","rotateX","ox","oy","argsStr","arcToSegmentsCache","sin_th","cos_th","pl","a00","a01","a10","a11","x0","y0","sfactor_sq","sfactor","xc","yc","th0","th1","th_arc","segments","th2","th3","cx","cy","segmentToBezierCache","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","current","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","quadraticCurveTo",64,"SVGBuilder","./svg",65,66,"tag","close","escape_text","escape_font","group_bg","styl","class","clip_id","clipping","arc_path","area_path_h","area_path_v","line_path","symbol_path","xlink:href","text-anchor","cssClass","cls","xw","yh","styleProps","styles","_gid","_text","foot","svgNamespace","buildDefs","dgrad","dclip","stop-color","meta","MARKS","sty","nest","center",67,"svgHandler","__data__","_svg","dom","removeEventListener",68,"updateDefs","each","grd","cr","renderItems",69,"dup",70,"setProperty","removeProperty","area_path","setAttributeNS","removeAttribute","textContent","drawMark","evts","grps","childNodes","notG","mark_id",71,"Bounder","_mark","ilen","hasLegends","GROUP","_legendPositions","../util/boundscalc","./Encoder",72,"inlineDs","sibling","_def","geom","_parent_id","_from","_ds","_isSuper","_bounder","newItem","Item","keyf","_map","joinDatasource","fullUpdate","keyFunction","joinValues","_items","parent_id","inheritFrom","_parent","_encoder","builder","fcs","./Bounder","./Item",73,"preds","enc","EMPTY",74,"_children","_scaler","_recursor","_scales","recurse","hasMarks","hasAxes","inline","buildMarks","buildAxes","buildLegends","MARK","parseAxes","parseLegends","buildGroup","inherit","axisDef","AXIS","legendDef","LEGEND","Scale","acc","group_id","../dataflow/Collector","../parse/axes","../parse/legends","./Builder","./Scale",75,"hasPropertySet","cousin","iidx","midx","touch",76,"_updated","instance","ORDINAL","ordinal","quantitative","rng","LINEAR","scaleName","dataDrivenRange","dataRef","RANGE","DOMAIN","points","rangePoints","rangeRoundBands","rangeBands","interval","QUANTILE","domainMinMax","rangeRound","exponent","POWER","clamp","nice","TIME","which","rlen","flen","refs","uniques","ck","cache","cacheField","Aggregate","singleton","stat","group_by","MIN","MAX","order","DESC","SINGLETON","domainMin","domainMax","LOG","zero","GROUP_PROPERTY","rangeMin","rangeMax","SIGNAL","../transforms/Aggregate",77,"updates","elapsed","skip","interp","timer",78,"axis_def","newScale","oldScale","rangeBand","vg_axisScaleRange","gridLines","vg_axisTicks","tickLabels","vg_axisTickLabels","vg_axisDomain","vg_axisTitle","gridColor","vg_axisTicksExtend","tickMajorSize","tickMinorSize","vg_axisLabelExtend","vg_axisDomainExtend","tickEndSize","vg_axisTitleExtend","gridLineStyle","majorTickStyle","minorTickStyle","tickLabelStyle","domainStyle","titleStyle","vg_axisUpdate","tickFormatString","tickArguments","injest","major","minor","vg_axisSubdivide","label","tdata","vg_axisOrients","subticks","vg_axisScaleExtent","rangeExtent","vg_axisBaseline","vg_axisAlign","tickColor","tickWidth","tickLabelColor","tickLabelFont","tickLabelFontSize","titleFont","titleFontSize","titleFontWeight","titleColor","axisColor","axisWidth","../parse/mark",79,"discrete","ordinalDef","o_legend_def","symbolSize","spacing","labelStyle","labelFontSize","sz","titles","vg_legendTitle","vg_legendSymbols","vg_vLegendLabels","vg_legendSymbolExtend","symbolStyle","legendStyle","vg_legendPosition","quantDef","q_legend_def","gradientStyle","gradientWidth","layout","vg_legendGradient","vg_hLegendLabels","Gradient","gp","gh","hh","tp","formatString","vg_legendOrients","lh","cfg","symbolShape","symbolColor","symbolStrokeWidth","labelColor","labelFont","labelAlign","labelBaseline","gradientHeight","gradientStrokeColor","gradientStrokeWidth","../parse/properties","../util/Gradient",80,"GroupBy","Transform","addParameters","var","varp","_fieldsDef","_Aggregators","_singleton","meas","_reset","_keys","_gb","_new_cell","flg","./GroupBy","./Transform",81,"BatchTransform","batchTransform",82,"Bin","default","bin",83,"Cross","with","diagonal","_lastRem","_lastWith","_ids","_cache","wdata","diag","cross","upFields","selfCross","woutput",84,"Facet","_new_tuple",85,"Filter","_skip","../parse/expr",86,"Fold","rst","get_tuple","accessors","dlen","fold",87,"Force","links","linkDistance","linkStrength","charge","chargeDistance","iterations","friction","gravity","alpha","_nodes","_links","_layout","force","nodeInput","linkInput","iter","link","tick","nodeIds","linkIds",88,"Formula",89,"Geo","Parameters","lon","lat","projection","clipAngle","clipExtent","d3Projection","proj","param","_mode","_projection","geo","ll","xy",90,"GeoPath","geojson","./Geo",91,"gb","groupBy",92,"LinkPath","sx","sy","ty","curve","ix","iy","diagonalX","diagonalY","shapes",93,"Parameter","_accessors","_resolution","arrayType","dataType","fieldType","exprType","isData","isField","sources","isExpr",94,"Pie","ones","./BatchTransform",95,"Sort","by",96,"Stack","sortby","partition","groups",97,"params","_parameters","./Parameter",98,"Treemap","sticky","mode","treemap",99,"Unique",100,"Zip","withKey","_lastJoin","mp","wds","dflt","prevm","wlen",101,"aggregate","linkpath","formula","geopath","pie","zip","./Aggregate","./Bin","./Cross","./Facet","./Filter","./Fold","./Force","./Formula","./GeoPath","./LinkPath","./Pie","./Sort","./Stack","./Treemap","./Unique","./Zip",102,"quickselect","_counts","../util/quickselect",103,"MAX_VALUE","expand",104,"vg_gradient_id",105,"gfx","pathBounds","boundPath","halfpi","xmin","xmax","ymin","ymax","angles","noRotate","measureText","includeLegends","itemBounds","methods","bounds_prev","pb","markBounds","../render/canvas/path","../util/Bounds","./config",106,"utc","labelOffset","rgb","lab","hcl","hsl","category10","category20",107,"sentinel","COUNT","ASC",108,"console",109,"swap","pivot"],"mappings":"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","file":"vega2.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};\n},{\"./src/core/View\":30,\"./src/dataflow/Datasource\":32,\"./src/dataflow/Graph\":33,\"./src/dataflow/Node\":34,\"./src/dataflow/changeset\":36,\"./src/parse/spec\":56,\"./src/scene/Builder\":72,\"./src/scene/GroupBuilder\":74,\"./src/transforms/index\":101,\"./src/util/config\":106,\"datalib\":20}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x));\n};\n\nproto._newcell = function(x) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      if (cell.collect) {\n        cell.data.values();\n      }\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      result.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function() {\n  var changes = {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === Flags.MOD_CELL) {\n        changes.rem.push(cell.tuple);\n      }\n      delete this._cells[k];\n    } else if (flag & Flags.ADD_CELL) {\n      changes.add.push(cell.tuple);\n    } else if (flag & Flags.MOD_CELL) {\n      changes.mod.push(cell.tuple);\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;\n},{\"../util\":25,\"./collector\":5,\"./measures\":7}],5:[function(require,module,exports){\nvar util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return (this._get = null, this._add);\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  this._get = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m ? get(m) : +Infinity;\n};\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;\n},{\"../stats\":22,\"../util\":25}],6:[function(require,module,exports){\nvar util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n\n},{\"../util\":25,\"./aggregator\":4}],7:[function(require,module,exports){\nvar util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;\n},{\"../stats\":22,\"../util\":25}],8:[function(require,module,exports){\nvar util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time-units\":24,\"../util\":25}],9:[function(require,module,exports){\nvar stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n},{\"../generate\":10,\"../import/type\":19,\"../stats\":22,\"../util\":25,\"./bins\":8}],10:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],11:[function(require,module,exports){\n(function (global){\nvar util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util\":25}],12:[function(require,module,exports){\nvar dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n},{\"./dsv\":11,\"./json\":13,\"./topojson\":14,\"./treejson\":15}],13:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":25}],14:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":13}],15:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":13}],16:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":25,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],17:[function(require,module,exports){\nvar util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n\n},{\"../util\":25,\"./formats\":12,\"./type\":19}],18:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":25,\"./load\":16,\"./read\":17}],19:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":25}],20:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;\n},{\"./aggregate/groupby\":6,\"./bins/bins\":8,\"./bins/histogram\":9,\"./generate\":10,\"./import/load\":16,\"./import/read\":17,\"./import/readers\":18,\"./import/type\":19,\"./print\":21,\"./stats\":22,\"./template\":23,\"./time-units\":24,\"./util\":25}],21:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}\n},{\"./import/type\":19,\"./stats\":22,\"./template\":23,\"./util\":25}],22:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":10,\"./import/type\":19,\"./util\":25}],23:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\ntemplate.source = source;\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util\":25}],24:[function(require,module,exports){\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{}],25:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"./time-units\":24,\"_process\":3,\"buffer\":2}],26:[function(require,module,exports){\nmodule.exports = require('./lib/heap');\n\n},{\"./lib/heap\":27}],27:[function(require,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n},{}],28:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/index\":61,\"../render/svg-headless/index\":65,\"../util/debug\":108,\"./View\":30,\"datalib\":20}],29:[function(require,module,exports){\nvar Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;\n},{\"../dataflow/Graph\":33,\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../scene/GroupBuilder\":74,\"datalib\":20}],30:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../parse/streams\":57,\"../render/canvas/index\":61,\"../render/svg/index\":69,\"../scene/Encoder\":73,\"../scene/Transition\":77,\"../util/config\":106,\"../util/debug\":108,\"./HeadlessView\":28,\"datalib\":20}],31:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"../util/constants\":107,\"../util/debug\":108,\"./Node\":34,\"./changeset\":36}],32:[function(require,module,exports){\nvar dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;\n},{\"../util/constants\":107,\"../util/debug\":108,\"./Collector\":31,\"./Node\":34,\"./changeset\":36,\"./tuple\":37,\"datalib\":20}],33:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;\n},{\"../util/constants\":107,\"../util/debug\":108,\"./Datasource\":32,\"./Signal\":35,\"./changeset\":36,\"datalib\":20,\"heap\":26}],34:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;\n},{\"../util/constants\":107,\"datalib\":20}],35:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;\n},{\"./Node\":34,\"./changeset\":36}],36:[function(require,module,exports){\nvar C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};\n},{\"../util/constants\":107}],37:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};\n},{\"../util/constants\":107,\"datalib\":20}],38:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};\n},{\"./constants\":39,\"./functions\":40,\"datalib\":20}],39:[function(require,module,exports){\nmodule.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};\n},{}],40:[function(require,module,exports){\nvar datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};\n},{\"datalib\":20}],41:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n\n},{\"./codegen\":38,\"./parser\":42}],42:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],43:[function(require,module,exports){\nvar dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;\n},{\"../scene/axis\":78,\"../util/config\":106,\"datalib\":20}],44:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n\n},{\"../util/config\":106,\"./modify\":51,\"./transforms\":58,\"datalib\":20}],45:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};\n},{}],46:[function(require,module,exports){\nvar dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;\n},{\"../expression\":41,\"datalib\":20}],47:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}\n},{\"../util/config\":106,\"../util/constants\":107,\"datalib\":20}],48:[function(require,module,exports){\nvar lgnd = require('../scene/legend'),\n    config = require('../util/config');\n\nfunction legends(model, spec, legends, group) {\n  (spec || []).forEach(function(def, index) {\n    legends[index] = legends[index] || lgnd(model);\n    legend(def, index, legends[index], group);\n  });\n};\n\nfunction legend(def, index, legend, group) {\n  // legend scales\n  legend.size  (def.size   ? group.scale(def.size)   : null);\n  legend.shape (def.shape  ? group.scale(def.shape)  : null);\n  legend.fill  (def.fill   ? group.scale(def.fill)   : null);\n  legend.stroke(def.stroke ? group.scale(def.stroke) : null);\n\n  // legend orientation\n  if (def.orient) legend.orient(def.orient);\n\n  // legend offset\n  if (def.offset != null) legend.offset(def.offset);\n\n  // legend title\n  legend.title(def.title || null);\n\n  // legend values\n  legend.values(def.values || null);\n\n  // legend label formatting\n  legend.format(def.format !== undefined ? def.format : null);\n\n  // style properties\n  var p = def.properties;\n  legend.titleProperties(p && p.title || {});\n  legend.labelProperties(p && p.labels || {});\n  legend.legendProperties(p && p.legend || {});\n  legend.symbolProperties(p && p.symbols || {});\n  legend.gradientProperties(p && p.gradient || {});\n}\n\nmodule.exports = legends;\n},{\"../scene/legend\":79,\"../util/config\":106}],49:[function(require,module,exports){\nvar dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};\n},{\"./properties\":54,\"datalib\":20}],50:[function(require,module,exports){\nvar parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};\n},{\"./mark\":49}],51:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}\n},{\"../dataflow/Node\":34,\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/debug\":108,\"datalib\":20}],52:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}\n},{\"datalib\":20}],53:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n},{\"datalib\":20}],54:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"../util/config\":106,\"datalib\":20}],55:[function(require,module,exports){\nvar expr = require('./expr'),\n    C = require('../util/constants');\n\nfunction parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init);\n\n    if(s.init && s.init.expr) {\n      s.init.expr = expr(s.init.expr);\n      signal.value(exprVal(model, s.init));\n    }\n\n    if(s.expr) {\n      s.expr = expr(s.expr);\n      signal.evaluate = function(input) {\n        signal.value(exprVal(model, s));\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, s.expr.signals);\n      s.expr.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n\nfunction exprVal(model, spec) {\n  var e = spec.expr,\n      val = expr.eval(model, e.fn, null, null, null, null, e.signals);\n  return spec.scale ? scale(model, spec, val) : val;\n}\n\nparseSignals.scale = function scale(model, spec, value) {\n  var def = spec.scale,\n      name  = def.name || def.signal || def,\n      scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n  if(!scope || !scope.scale) {\n    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n  }\n\n  var scale = scope.scale(name);\n  if(!scale) return value;\n  return def.invert ? scale.invert(value) : scale(value);\n}\n\nmodule.exports = parseSignals;\n},{\"../util/constants\":107,\"./expr\":46}],56:[function(require,module,exports){\nvar dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n\n},{\"../core/Model\":29,\"../core/View\":30,\"../parse/data\":44,\"../parse/interactors\":47,\"../parse/marks\":50,\"../parse/padding\":52,\"../parse/predicates\":53,\"../parse/signals\":55,\"datalib\":20}],57:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    parseSignals = require('./signals'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = parseSignals.scale(model, spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = parseSignals.scale(model, h.spec, val);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../util/constants\":107,\"./events\":45,\"./expr\":46,\"./signals\":55,\"datalib\":20}],58:[function(require,module,exports){\nvar dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};\n},{\"../transforms/index\":101,\"datalib\":20}],59:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":62,\"datalib\":20}],60:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../util/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/Bounds\":103,\"../../util/config\":106,\"./marks\":62,\"datalib\":20}],61:[function(require,module,exports){\nmodule.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};\n},{\"./Handler\":59,\"./Renderer\":60}],62:[function(require,module,exports){\nvar Bounds = require('../../util/Bounds'),\n    boundsCalc = require('../../util/boundscalc'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};\n},{\"../../util/Bounds\":103,\"../../util/boundscalc\":105,\"../../util/config\":106,\"./path\":63}],63:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../util/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/Bounds\":103}],64:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":106,\"./svg\":66,\"datalib\":20}],65:[function(require,module,exports){\nmodule.exports = {\n  Renderer: require('./Renderer')\n};\n\n},{\"./Renderer\":64}],66:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":106,\"datalib\":20}],67:[function(require,module,exports){\nvar dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;\n},{\"datalib\":20}],68:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":70,\"datalib\":20}],69:[function(require,module,exports){\narguments[4][61][0].apply(exports,arguments)\n},{\"./Handler\":67,\"./Renderer\":68,\"dup\":61}],70:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":106,\"datalib\":20}],71:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder = require('./Encoder'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n  var i, ilen, j, jlen, group, legend;\n      hasLegends = this._mark.marktype == C.GROUP \n        && dl.array(this._mark.def.legends).length > 0;\n\n  bounds.mark(this._mark, null, !hasLegends);\n\n  if(hasLegends) {\n    for(i=0, ilen=this._mark.items.length; i<ilen; ++i) {\n      group = this._mark.items[i];\n      group._legendPositions = null;\n      for(j=0, jlen=group.legendItems.length; j<jlen; ++j) {\n        legend = group.legendItems[j];\n        Encoder.update(this._graph, input.trans, \"vg_legendPosition\", legend.items);\n        bounds.mark(legend, null, true);\n      }\n    }\n\n    bounds.mark(this._mark, null, true);\n  }\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;\n},{\"../dataflow/Node\":34,\"../util/boundscalc\":105,\"../util/constants\":107,\"../util/debug\":108,\"./Encoder\":73,\"datalib\":20}],72:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../parse/data\":44,\"../util/constants\":107,\"../util/debug\":108,\"./Bounder\":71,\"./Encoder\":73,\"./Item\":75,\"datalib\":20}],73:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;\n},{\"../dataflow/Node\":34,\"../util/boundscalc\":105,\"../util/constants\":107,\"../util/debug\":108,\"datalib\":20}],74:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    parseLegends = require('../parse/legends'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n\n  scales = (def.legends||[]).reduce(function(acc, x) {\n    return (acc[x.size || x.shape || x.fill || x.stroke], acc);\n  }, scales);\n\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = dl.array(this._def.marks).length > 0,\n      hasAxes = dl.array(this._def.axes).length > 0,\n      hasLegends = dl.array(this._def.legends).length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n    if(hasLegends) buildLegends.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }\n\n    // Update legend data defs\n    if(hasLegends) {\n      parseLegends(builder._graph, builder._def.legends, group.legends, group);\n      group.legends.forEach(function(l, i) { l.def() });\n    }   \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n\n  group.legends = group.legends || [];\n  group.legendItems = group.legendItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nfunction buildLegends(input, group) {\n  var legends = group.legends,\n      legendItems = group.legendItems,\n      builder = this;\n\n  parseLegends(this._graph, this._def.legends, legends, group);\n  legends.forEach(function(l, i) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke(),\n        def = l.def(),\n        b = null;\n\n    legendItems[i] = {group: group, legendDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, legendItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.LEGEND, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n},{\"../dataflow/Collector\":31,\"../dataflow/Node\":34,\"../parse/axes\":43,\"../parse/legends\":48,\"../util/constants\":107,\"../util/debug\":108,\"./Builder\":72,\"./Scale\":76,\"datalib\":20}],75:[function(require,module,exports){\nfunction Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;\n},{}],76:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":34,\"../dataflow/changeset\":36,\"../transforms/Aggregate\":80,\"../util/config\":106,\"../util/constants\":107,\"../util/debug\":108,\"datalib\":20}],77:[function(require,module,exports){\nvar tuple = require('../dataflow/tuple'),\n    boundsCalc = require('../util/boundscalc'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    boundsCalc.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;\n},{\"../dataflow/tuple\":37,\"../util/boundscalc\":105,\"../util/constants\":107}],78:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines:  null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title:  null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"../parse/mark\":49,\"../util/config\":106,\"datalib\":20}],79:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    parseProperties = require('../parse/properties'),\n    parseMark = require('../parse/mark'),\n    Gradient = require('../util/Gradient'),\n    config = require('../util/config');\n\nfunction lgnd(model) {\n  var size = null,\n      shape = null,\n      fill = null,\n      stroke = null,\n      spacing = null,\n      values = null,\n      format = null,\n      formatString = null,\n      title = undefined,\n      orient = \"right\",\n      offset = config.legend.offset,\n      padding = config.legend.padding,\n      legendDef,\n      tickArguments = [5],\n      legendStyle = {},\n      symbolStyle = {},\n      gradientStyle = {},\n      titleStyle = {},\n      labelStyle = {},\n      m = { // Legend marks as references for updates\n        titles:  null,\n        symbols: null,\n        labels:  null,\n        gradient: null\n      };\n\n  var legend = {},\n      legendDef = {};\n\n  function reset() { legendDef.type = null; }\n  function ingest(d, i) { return {data: d, index: i} }\n\n  legend.def = function() {\n    var scale = size || shape || fill || stroke;\n    \n    format = !formatString ? null : ((scale.type === 'time')\n      ? d3.time.format(formatString)\n      : d3.format(formatString));\n    \n    if (!legendDef.type) {\n      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type)\n        ? quantDef(scale)\n        : ordinalDef(scale);      \n    }\n    legendDef.orient = orient;\n    legendDef.offset = offset;\n    legendDef.padding = padding;\n    return legendDef;\n  };\n\n  function discrete(type) {\n    return type===\"ordinal\" || type===\"quantize\"\n      || type===\"quantile\" || type===\"threshold\";\n  }\n\n  function ordinalDef(scale) {\n    var def = o_legend_def(size, shape, fill, stroke);\n\n    // generate data\n    var data = (values == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : values).map(ingest);\n    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n    \n    // determine spacing between legend entries\n    var fs, range, offset, pad=5, domain = d3.range(data.length);\n    if (size) {\n      range = data.map(function(x) { return Math.sqrt(size(x.data)); });\n      offset = d3.max(range);\n      range = range.reduce(function(a,b,i,z) {\n          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;\n          return (a[i] += b/2, a); }, [0]).map(Math.round);\n    } else {\n      offset = Math.round(Math.sqrt(config.legend.symbolSize));\n      range = spacing\n        || (fs = labelStyle.fontSize) && (fs.value + pad)\n        || (config.legend.labelFontSize + pad);\n      range = domain.map(function(d,i) {\n        return Math.round(offset/2 + i*range);\n      });\n    }\n\n    // account for padding and title size\n    var sz = padding, ts;\n    if (title) {\n      ts = titleStyle.fontSize;\n      sz += 5 + ((ts && ts.value) || config.legend.titleFontSize);\n    }\n    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;\n    \n    // build scale for label layout\n    var scale = {\n      name: \"legend\",\n      type: \"ordinal\",\n      points: true,\n      domain: domain,\n      range: range\n    };\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d) {\n      d.label = fmt(d.data);\n      d.offset = offset;\n    });\n    def.scales = [ scale ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return data; };\n    def.marks[2].from = def.marks[1].from;\n\n    return def;\n  }\n\n  function o_legend_def(size, shape, fill, stroke) {\n    // setup legend marks\n    var titles  = m.titles  || (m.titles  = vg_legendTitle()),\n        symbols = m.symbols || (m.symbols = vg_legendSymbols()),\n        labels  = m.labels  || (m.labels  = vg_vLegendLabels());\n\n    // extend legend marks\n    vg_legendSymbolExtend(symbols, size, shape, fill, stroke);\n    \n    // add / override custom style properties\n    dl.extend(titles.properties.update,  titleStyle);\n    dl.extend(symbols.properties.update, symbolStyle);\n    dl.extend(labels.properties.update,  labelStyle);\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    labels.properties.enter.x.offset += padding + 1;\n    symbols.properties.enter.x.offset = padding + 1;\n    labels.properties.update.x.offset += padding + 1;\n    symbols.properties.update.x.offset = padding + 1;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales:[], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  function quantDef(scale) {\n    var def = q_legend_def(scale),\n        dom = scale.domain(),\n        data = dom.map(ingest),\n        width = (gradientStyle.width && gradientStyle.width.value) || config.legend.gradientWidth,\n        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n\n    // build scale for label layout\n    var layout = {\n      name: \"legend\",\n      type: scale.type,\n      round: true,\n      zero: false,\n      domain: [dom[0], dom[dom.length-1]],\n      range: [padding, width+padding]\n    };\n    if (scale.type===\"pow\") layout.exponent = scale.exponent();\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d,i) {\n      d.label = fmt(d.data);\n      d.align = i==(data.length-1) ? \"right\" : i==0 ? \"left\" : \"center\";\n    });\n    def.scales = [ layout ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return [1]; };\n    def.marks[2].from = function() { return data; };\n    return def;\n  }\n  \n  function q_legend_def(scale) {\n    // setup legend marks\n    var titles = m.title || (m.title = vg_legendTitle()),\n        gradient = m.gradient || (m.gradient = vg_legendGradient()),\n        labels = m.labels || (m.labels = vg_hLegendLabels()),\n        grad = new Gradient();\n\n    // setup color gradient\n    var dom = scale.domain(),\n        min = dom[0],\n        max = dom[dom.length-1],\n        f = scale.copy().domain([min, max]).range([0,1]);\n        \n    var stops = (scale.type !== \"linear\" && scale.ticks)\n      ? scale.ticks.call(scale, 15) : dom;\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== stops[stops.length-1]) stops.push(max);\n\n    for (var i=0, n=stops.length; i<n; ++i) {\n      grad.stop(f(stops[i]), scale(stops[i]));\n    }\n    gradient.properties.enter.fill = {value: grad};\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update, titleStyle);\n    dl.extend(gradient.properties.update, gradientStyle);\n    dl.extend(labels.properties.update, labelStyle);\n\n    // account for gradient size\n    var gp = gradient.properties, gh = gradientStyle.height,\n        hh = (gh && gh.value) || gp.enter.height.value;\n    labels.properties.enter.y.value = hh;\n    labels.properties.update.y.value = hh;\n\n    // account for title size as needed\n    if (title) {\n      var tp = titles.properties, fs = titleStyle.fontSize,\n          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);\n      gradient.properties.enter.y.value += sz;\n      labels.properties.enter.y.value += sz;\n      gradient.properties.update.y.value += sz;\n      labels.properties.update.y.value += sz;\n    }\n    \n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    gradient.properties.enter.x.value += padding;\n    gradient.properties.enter.y.value += padding;\n    labels.properties.enter.y.value += padding;\n    gradient.properties.update.x.value += padding;\n    gradient.properties.update.y.value += padding;\n    labels.properties.update.y.value += padding;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales: [], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  legend.size = function(x) {\n    if (!arguments.length) return size;\n    if (size !== x) { size = x; reset(); }\n    return legend;\n  };\n\n  legend.shape = function(x) {\n    if (!arguments.length) return shape;\n    if (shape !== x) { shape = x; reset(); }\n    return legend;\n  };\n\n  legend.fill = function(x) {\n    if (!arguments.length) return fill;\n    if (fill !== x) { fill = x; reset(); }\n    return legend;\n  };\n  \n  legend.stroke = function(x) {\n    if (!arguments.length) return stroke;\n    if (stroke !== x) { stroke = x; reset(); }\n    return legend;\n  };\n\n  legend.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return legend;\n  };\n\n  legend.format = function(x) {\n    if (!arguments.length) return formatString;\n    if (formatString !== x) {\n      formatString = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.spacing = function(x) {\n    if (!arguments.length) return spacing;\n    if (spacing !== +x) { spacing = +x; reset(); }\n    return legend;\n  };\n\n  legend.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x in vg_legendOrients ? x + \"\" : config.legend.orient;\n    return legend;\n  };\n\n  legend.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = +x;\n    return legend;\n  };\n\n  legend.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return legend;\n  };\n\n  legend.legendProperties = function(x) {\n    if (!arguments.length) return legendStyle;\n    legendStyle = x;\n    return legend;\n  };\n\n  legend.symbolProperties = function(x) {\n    if (!arguments.length) return symbolStyle;\n    symbolStyle = x;\n    return legend;\n  };\n\n  legend.gradientProperties = function(x) {\n    if (!arguments.length) return gradientStyle;\n    gradientStyle = x;\n    return legend;\n  };\n\n  legend.labelProperties = function(x) {\n    if (!arguments.length) return labelStyle;\n    labelStyle = x;\n    return legend;\n  };\n  \n  legend.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    titleStyle = x;\n    return legend;\n  };\n\n  legend.reset = function() { reset(); };\n\n  return legend;\n};\n\nvar vg_legendOrients = {right: 1, left: 1};\n\nfunction vg_legendPosition(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item, gx,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      pad    = item.mark.def.padding * 2,\n      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),\n      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),\n      pos = group._legendPositions || \n        (group._legendPositions = {right: 0.5, left: 0.5});\n\n  o.x = 0.5;\n  o.width = lw;\n  o.y = pos[orient];\n  pos[orient] += (o.height = lh);\n\n  // HACK: use to estimate group bounds during animated transition\n  if (!trans && group.bounds) {\n    group.bounds.delta = group.bounds.x2 - group.width;\n  }\n\n  switch (orient) {\n    case \"left\":  {\n      gx = group.bounds ? group.bounds.x1 : 0;\n      o.x += gx - offset - lw;\n      break;\n    };\n    case \"right\": {\n      gx = group.width;\n      if (group.bounds) gx = trans\n        ? group.width + group.bounds.delta\n        : group.bounds.x2;\n      o.x += gx + offset;\n      break;\n    };\n  }\n  \n  if (trans) trans.interpolate(item, o);\n  var enc = item.mark.def.properties.enter.encode;\n  enc.call(enc, item, group, trans);\n}\n\nfunction vg_legendSymbolExtend(mark, size, shape, fill, stroke) {\n  var e = mark.properties.enter,\n      u = mark.properties.update;\n  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: \"data\"};\n  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: \"data\"};\n  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: \"data\"};\n  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: \"data\"};\n}\n\nfunction vg_legendTitle() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        fill: {value: cfg.titleColor},\n        font: {value: cfg.titleFont},\n        fontSize: {value: cfg.titleFontSize},\n        fontWeight: {value: cfg.titleFontWeight},\n        baseline: {value: \"top\"},\n        text: {field: \"data\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_legendSymbols() {\n  var cfg = config.legend;\n  return {\n    type: \"symbol\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        shape: {value: cfg.symbolShape},\n        size: {value: cfg.symbolSize},\n        stroke: {value: cfg.symbolColor},\n        strokeWidth: {value: cfg.symbolStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_vLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {value: cfg.labelAlign},\n        baseline: {value: cfg.labelBaseline},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        opacity: {value: 1},\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n      }\n    }\n  };\n}\n\nfunction vg_legendGradient() {\n  var cfg = config.legend;\n  return {\n    type: \"rect\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        width: {value: cfg.gradientWidth},\n        height: {value: cfg.gradientHeight},\n        stroke: {value: cfg.gradientStrokeColor},\n        strokeWidth: {value: cfg.gradientStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {value: 0},\n        y: {value: 0},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_hLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        dy: {value: 2},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {field: \"align\"},\n        baseline: {value: \"top\"},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nmodule.exports = lgnd;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../parse/mark\":49,\"../parse/properties\":54,\"../util/Gradient\":104,\"../util/config\":106,\"datalib\":20}],80:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/debug\":108,\"./GroupBy\":91,\"./Transform\":97,\"./measures\":102,\"datalib\":20}],81:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n\n},{\"../dataflow/Collector\":31,\"./Transform\":97}],82:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n\n},{\"../dataflow/tuple\":37,\"./Transform\":97,\"datalib\":20}],83:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;\n},{\"../dataflow/Collector\":31,\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/debug\":108,\"./Transform\":97}],84:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/debug\":108,\"./GroupBy\":91,\"./Transform\":97}],85:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n},{\"../dataflow/changeset\":36,\"../parse/expr\":46,\"../util/constants\":107,\"../util/debug\":108,\"./Transform\":97}],86:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/debug\":108,\"./Transform\":97}],87:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./Transform\":97}],88:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n},{\"../dataflow/tuple\":37,\"../parse/expr\":46,\"../util/constants\":107,\"../util/debug\":108,\"./Transform\":97}],89:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./Transform\":97,\"datalib\":20}],90:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./Geo\":89,\"./Transform\":97,\"datalib\":20}],91:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;\n},{\"../dataflow/changeset\":36,\"../dataflow/tuple\":37,\"../util/constants\":107,\"./Transform\":97}],92:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n},{\"../dataflow/tuple\":37,\"./Transform\":97}],93:[function(require,module,exports){\nvar dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":46,\"../util/constants\":107,\"datalib\":20}],94:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./BatchTransform\":81,\"./Transform\":97,\"datalib\":20}],95:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;\n},{\"../parse/expr\":46,\"../util/debug\":108,\"./Transform\":97,\"datalib\":20}],96:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n},{\"../dataflow/tuple\":37,\"./BatchTransform\":81,\"./Transform\":97,\"datalib\":20}],97:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"../dataflow/Node\":34,\"../util/constants\":107,\"./Parameter\":93}],98:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":37,\"./BatchTransform\":81,\"./Transform\":97,\"datalib\":20}],99:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;\n},{\"../dataflow/tuple\":37,\"../util/debug\":108,\"./GroupBy\":91,\"./Transform\":97}],100:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;\n},{\"../dataflow/Collector\":31,\"../util/debug\":108,\"./Transform\":97,\"datalib\":20}],101:[function(require,module,exports){\nmodule.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};\n},{\"./Aggregate\":80,\"./Bin\":82,\"./Cross\":83,\"./Facet\":84,\"./Filter\":85,\"./Fold\":86,\"./Force\":87,\"./Formula\":88,\"./Geo\":89,\"./GeoPath\":90,\"./LinkPath\":92,\"./Pie\":94,\"./Sort\":95,\"./Stack\":96,\"./Treemap\":98,\"./Unique\":99,\"./Zip\":100}],102:[function(require,module,exports){\nvar dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;\n},{\"../dataflow/tuple\":37,\"../util/constants\":107,\"../util/quickselect\":109,\"datalib\":20}],103:[function(require,module,exports){\nvar bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;\n},{}],104:[function(require,module,exports){\nvar vg_gradient_id = 0;\n\nfunction gradient(type) {\n  this.id = \"grad_\" + (vg_gradient_id++);\n  this.type = type || \"linear\";\n  this.stops = [];\n  this.x1 = 0;\n  this.x2 = 1;\n  this.y1 = 0;\n  this.y2 = 0;\n};\n\nvar prototype = gradient.prototype;\n\nprototype.stop = function(offset, color) {\n  this.stops.push({\n    offset: offset,\n    color: color\n  });\n  return this;\n};\n\nmodule.exports = gradient;\n},{}],105:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../util/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/path\":63,\"../util/Bounds\":103,\"./config\":106}],106:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],107:[function(require,module,exports){\nmodule.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n  LEGEND: \"legend\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};\n},{}],108:[function(require,module,exports){\nvar config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};\n},{\"./config\":106}],109:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};\n},{\"datalib\":20}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleCIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9jb2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2dyb3VwYnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL21lYXN1cmVzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9kc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90cmVlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90aW1lLXVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwic3JjL2NvcmUvSGVhZGxlc3NWaWV3LmpzIiwic3JjL2NvcmUvTW9kZWwuanMiLCJzcmMvY29yZS9WaWV3LmpzIiwic3JjL2RhdGFmbG93L0NvbGxlY3Rvci5qcyIsInNyYy9kYXRhZmxvdy9EYXRhc291cmNlLmpzIiwic3JjL2RhdGFmbG93L0dyYXBoLmpzIiwic3JjL2RhdGFmbG93L05vZGUuanMiLCJzcmMvZGF0YWZsb3cvU2lnbmFsLmpzIiwic3JjL2RhdGFmbG93L2NoYW5nZXNldC5qcyIsInNyYy9kYXRhZmxvdy90dXBsZS5qcyIsInNyYy9leHByZXNzaW9uL2NvZGVnZW4uanMiLCJzcmMvZXhwcmVzc2lvbi9jb25zdGFudHMuanMiLCJzcmMvZXhwcmVzc2lvbi9mdW5jdGlvbnMuanMiLCJzcmMvZXhwcmVzc2lvbi9pbmRleC5qcyIsInNyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsInNyYy9wYXJzZS9heGVzLmpzIiwic3JjL3BhcnNlL2RhdGEuanMiLCJzcmMvcGFyc2UvZXZlbnRzLmpzIiwic3JjL3BhcnNlL2V4cHIuanMiLCJzcmMvcGFyc2UvaW50ZXJhY3RvcnMuanMiLCJzcmMvcGFyc2UvbGVnZW5kcy5qcyIsInNyYy9wYXJzZS9tYXJrLmpzIiwic3JjL3BhcnNlL21hcmtzLmpzIiwic3JjL3BhcnNlL21vZGlmeS5qcyIsInNyYy9wYXJzZS9wYWRkaW5nLmpzIiwic3JjL3BhcnNlL3ByZWRpY2F0ZXMuanMiLCJzcmMvcGFyc2UvcHJvcGVydGllcy5qcyIsInNyYy9wYXJzZS9zaWduYWxzLmpzIiwic3JjL3BhcnNlL3NwZWMuanMiLCJzcmMvcGFyc2Uvc3RyZWFtcy5qcyIsInNyYy9wYXJzZS90cmFuc2Zvcm1zLmpzIiwic3JjL3JlbmRlci9jYW52YXMvSGFuZGxlci5qcyIsInNyYy9yZW5kZXIvY2FudmFzL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9jYW52YXMvaW5kZXguanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy5qcyIsInNyYy9yZW5kZXIvY2FudmFzL3BhdGguanMiLCJzcmMvcmVuZGVyL3N2Zy1oZWFkbGVzcy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvc3ZnLWhlYWRsZXNzL2luZGV4LmpzIiwic3JjL3JlbmRlci9zdmctaGVhZGxlc3Mvc3ZnLmpzIiwic3JjL3JlbmRlci9zdmcvSGFuZGxlci5qcyIsInNyYy9yZW5kZXIvc3ZnL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9zdmcvbWFya3MuanMiLCJzcmMvc2NlbmUvQm91bmRlci5qcyIsInNyYy9zY2VuZS9CdWlsZGVyLmpzIiwic3JjL3NjZW5lL0VuY29kZXIuanMiLCJzcmMvc2NlbmUvR3JvdXBCdWlsZGVyLmpzIiwic3JjL3NjZW5lL0l0ZW0uanMiLCJzcmMvc2NlbmUvU2NhbGUuanMiLCJzcmMvc2NlbmUvVHJhbnNpdGlvbi5qcyIsInNyYy9zY2VuZS9heGlzLmpzIiwic3JjL3NjZW5lL2xlZ2VuZC5qcyIsInNyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsInNyYy90cmFuc2Zvcm1zL0JhdGNoVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvQmluLmpzIiwic3JjL3RyYW5zZm9ybXMvQ3Jvc3MuanMiLCJzcmMvdHJhbnNmb3Jtcy9GYWNldC5qcyIsInNyYy90cmFuc2Zvcm1zL0ZpbHRlci5qcyIsInNyYy90cmFuc2Zvcm1zL0ZvbGQuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb3JjZS5qcyIsInNyYy90cmFuc2Zvcm1zL0Zvcm11bGEuanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW8uanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW9QYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvR3JvdXBCeS5qcyIsInNyYy90cmFuc2Zvcm1zL0xpbmtQYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvUGFyYW1ldGVyLmpzIiwic3JjL3RyYW5zZm9ybXMvUGllLmpzIiwic3JjL3RyYW5zZm9ybXMvU29ydC5qcyIsInNyYy90cmFuc2Zvcm1zL1N0YWNrLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJlZW1hcC5qcyIsInNyYy90cmFuc2Zvcm1zL1VuaXF1ZS5qcyIsInNyYy90cmFuc2Zvcm1zL1ppcC5qcyIsInNyYy90cmFuc2Zvcm1zL2luZGV4LmpzIiwic3JjL3RyYW5zZm9ybXMvbWVhc3VyZXMuanMiLCJzcmMvdXRpbC9Cb3VuZHMuanMiLCJzcmMvdXRpbC9HcmFkaWVudC5qcyIsInNyYy91dGlsL2JvdW5kc2NhbGMuanMiLCJzcmMvdXRpbC9jb25maWcuanMiLCJzcmMvdXRpbC9jb25zdGFudHMuanMiLCJzcmMvdXRpbC9kZWJ1Zy5qcyIsInNyYy91dGlsL3F1aWNrc2VsZWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvVEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMxZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzloQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcmU6IHtcbiAgICBWaWV3OiByZXF1aXJlKCcuL3NyYy9jb3JlL1ZpZXcnKVxuICB9LFxuICBkYXRhZmxvdzoge1xuICAgIGNoYW5nZXNldDogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgRGF0YXNvdXJjZTogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvRGF0YXNvdXJjZScpLFxuICAgIEdyYXBoOiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9HcmFwaCcpLFxuICAgIE5vZGU6IHJlcXVpcmUoJy4vc3JjL2RhdGFmbG93L05vZGUnKVxuICB9LFxuICBwYXJzZToge1xuICAgIHNwZWM6IHJlcXVpcmUoJy4vc3JjL3BhcnNlL3NwZWMnKVxuICB9LFxuICBzY2VuZToge1xuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0J1aWxkZXInKSxcbiAgICBHcm91cEJ1aWxkZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0dyb3VwQnVpbGRlcicpXG4gIH0sXG4gIHRyYW5zZm9ybXM6IHJlcXVpcmUoJy4vc3JjL3RyYW5zZm9ybXMvaW5kZXgnKSxcbiAgY29uZmlnOiByZXF1aXJlKCcuL3NyYy91dGlsL2NvbmZpZycpLFxuICB1dGlsOiByZXF1aXJlKCdkYXRhbGliJylcbn07IixudWxsLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgTWVhc3VyZXMgPSByZXF1aXJlKCcuL21lYXN1cmVzJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9jb2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQWdncmVnYXRvcigpIHtcbiAgdGhpcy5fY2VsbHMgPSB7fTtcbiAgdGhpcy5fYWdnciA9IFtdO1xuICB0aGlzLl9zdHJlYW0gPSBmYWxzZTtcbn1cblxudmFyIEZsYWdzID0gQWdncmVnYXRvci5GbGFncyA9IHtcbiAgQUREX0NFTEw6IDEsXG4gIE1PRF9DRUxMOiAyXG59O1xuXG52YXIgcHJvdG8gPSBBZ2dyZWdhdG9yLnByb3RvdHlwZTtcblxuLy8gUGFyYW1ldGVyc1xuXG5wcm90by5zdHJlYW0gPSBmdW5jdGlvbih2KSB7XG4gIGlmICh2ID09IG51bGwpIHJldHVybiB0aGlzLl9zdHJlYW07XG4gIHRoaXMuX3N0cmVhbSA9ICEhdjtcbiAgdGhpcy5fYWdnciA9IFtdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGtleSBhY2Nlc3NvciB0byB1c2UgZm9yIHN0cmVhbWluZyByZW1vdmVzXG5wcm90by5rZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gdGhpcy5fa2V5O1xuICB0aGlzLl9rZXkgPSB1dGlsLiQoa2V5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgZ2V0OiBmdW5jdGlvbn1cbnByb3RvLmdyb3VwYnkgPSBmdW5jdGlvbihkaW1zKSB7XG4gIHRoaXMuX2RpbXMgPSB1dGlsLmFycmF5KGRpbXMpLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgZCA9IHV0aWwuaXNTdHJpbmcoZCkgPyB7bmFtZTogZCwgZ2V0OiB1dGlsLiQoZCl9XG4gICAgICA6IHV0aWwuaXNGdW5jdGlvbihkKSA/IHtuYW1lOiB1dGlsLm5hbWUoZCkgfHwgZC5uYW1lIHx8ICgnXycgKyBpKSwgZ2V0OiBkfVxuICAgICAgOiAoZC5uYW1lICYmIHV0aWwuaXNGdW5jdGlvbihkLmdldCkpID8gZCA6IG51bGw7XG4gICAgaWYgKGQgPT0gbnVsbCkgdGhyb3cgJ0ludmFsaWQgZ3JvdXBieSBhcmd1bWVudDogJyArIGQ7XG4gICAgcmV0dXJuIGQ7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5jbGVhcigpO1xufTtcblxuLy8gSW5wdXQ6IGFycmF5IG9mIG9iamVjdHMgb2YgdGhlIGZvcm1cbi8vIHtuYW1lOiBzdHJpbmcsIG9wczogW3N0cmluZywgLi4uXX1cbnByb3RvLnN1bW1hcml6ZSA9IGZ1bmN0aW9uKGZpZWxkcykge1xuICBmaWVsZHMgPSBzdW1tYXJpemVfYXJncyhmaWVsZHMpO1xuICB0aGlzLl9jb3VudCA9IHRydWU7XG4gIHZhciBhZ2dyID0gKHRoaXMuX2FnZ3IgPSBbXSksXG4gICAgICBtLCBmLCBpLCBqLCBvcCwgYXMsIGdldDtcblxuICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKGo9MCwgbT1bXSwgZj1maWVsZHNbaV07IGo8Zi5vcHMubGVuZ3RoOyArK2opIHtcbiAgICAgIG9wID0gZi5vcHNbal07XG4gICAgICBpZiAob3AgIT09ICdjb3VudCcpIHRoaXMuX2NvdW50ID0gZmFsc2U7XG4gICAgICBhcyA9IChmLmFzICYmIGYuYXNbal0pIHx8IChvcCArIChmLm5hbWU9PT0nKicgPyAnJyA6ICdfJytmLm5hbWUpKTtcbiAgICAgIG0ucHVzaChNZWFzdXJlc1tvcF0oYXMpKTtcbiAgICB9XG4gICAgZ2V0ID0gZi5nZXQgJiYgdXRpbC4kKGYuZ2V0KSB8fFxuICAgICAgKGYubmFtZSA9PT0gJyonID8gdXRpbC5pZGVudGl0eSA6IHV0aWwuJChmLm5hbWUpKTtcbiAgICBhZ2dyLnB1c2goe1xuICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgbWVhc3VyZXM6IE1lYXN1cmVzLmNyZWF0ZShcbiAgICAgICAgbSxcbiAgICAgICAgdGhpcy5fc3RyZWFtLCAvLyBzdHJlYW1pbmcgcmVtb3ZlIGZsYWdcbiAgICAgICAgZ2V0LCAgICAgICAgICAvLyBpbnB1dCB0dXBsZSBnZXR0ZXJcbiAgICAgICAgdGhpcy5fYXNzaWduKSAvLyBvdXRwdXQgdHVwbGUgc2V0dGVyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byBzdW1tYXJpemUgYnkgY291bnRcbnByb3RvLmNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN1bW1hcml6ZSh7JyonOidjb3VudCd9KTtcbn07XG5cbi8vIE92ZXJyaWRlIHRvIHBlcmZvcm0gY3VzdG9tIHR1cGxlIHZhbHVlIGFzc2lnbm1lbnRcbnByb3RvLl9hc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gc3VtbWFyaXplX2FyZ3MoZmllbGRzKSB7XG4gIGlmICh1dGlsLmlzQXJyYXkoZmllbGRzKSkgeyByZXR1cm4gZmllbGRzOyB9XG4gIGlmIChmaWVsZHMgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgdmFyIGEgPSBbXSwgbmFtZSwgb3BzO1xuICBmb3IgKG5hbWUgaW4gZmllbGRzKSB7XG4gICAgb3BzID0gdXRpbC5hcnJheShmaWVsZHNbbmFtZV0pO1xuICAgIGEucHVzaCh7bmFtZTogbmFtZSwgb3BzOiBvcHN9KTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy8gQ2VsbCBNYW5hZ2VtZW50XG5cbnByb3RvLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fY2VsbHMgPSB7fSwgdGhpcyk7XG59O1xuXG5wcm90by5fY2VsbGtleSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGQgPSB0aGlzLl9kaW1zLFxuICAgICAgbiA9IGQubGVuZ3RoLCBpLFxuICAgICAgayA9IFN0cmluZyhkWzBdLmdldCh4KSk7XG4gIGZvciAoaT0xOyBpPG47ICsraSkge1xuICAgIGsgKz0gJ3wnICsgZFtpXS5nZXQoeCk7XG4gIH1cbiAgcmV0dXJuIGs7XG59O1xuXG5wcm90by5fY2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGtleSA9IHRoaXMuX2RpbXMubGVuZ3RoID8gdGhpcy5fY2VsbGtleSh4KSA6ICcnO1xuICByZXR1cm4gdGhpcy5fY2VsbHNba2V5XSB8fCAodGhpcy5fY2VsbHNba2V5XSA9IHRoaXMuX25ld2NlbGwoeCkpO1xufTtcblxucHJvdG8uX25ld2NlbGwgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0ge1xuICAgIG51bTogICAwLFxuICAgIHR1cGxlOiB0aGlzLl9uZXd0dXBsZSh4KSxcbiAgICBmbGFnOiAgRmxhZ3MuQUREX0NFTEwsXG4gICAgYWdnczogIHt9XG4gIH07XG5cbiAgdmFyIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0gPSBuZXcgYWdncltpXS5tZWFzdXJlcyhjZWxsLCBjZWxsLnR1cGxlKTtcbiAgfVxuICBpZiAoY2VsbC5jb2xsZWN0KSB7XG4gICAgY2VsbC5kYXRhID0gbmV3IENvbGxlY3Rvcih0aGlzLl9rZXkpO1xuICB9XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX25ld3R1cGxlID0gZnVuY3Rpb24oeCkge1xuICB2YXIgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICB0ID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPWRpbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHRbZGltc1tpXS5uYW1lXSA9IGRpbXNbaV0uZ2V0KHgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbmdlc3QodCk7XG59O1xuXG4vLyBPdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSB0dXBsZSBpbmdlc3Rpb25cbnByb3RvLl9pbmdlc3QgPSB1dGlsLmlkZW50aXR5O1xuXG4vLyBQcm9jZXNzIFR1cGxlc1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSArPSAxO1xuICBpZiAoIXRoaXMuX2NvdW50KSB7IC8vIHNraXAgaWYgY291bnQtb25seVxuICAgIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5hZGQoeCk7XG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uYWRkKHgpO1xuICAgIH1cbiAgfVxuICBjZWxsLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSAtPSAxO1xuICBpZiAoIXRoaXMuX2NvdW50KSB7IC8vIHNraXAgaWYgY291bnQtb25seVxuICAgIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5yZW0oeCk7XG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0ucmVtKHgpO1xuICAgIH1cbiAgfVxuICBjZWxsLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oY3VyciwgcHJldikge1xuICB2YXIgY2VsbDAgPSB0aGlzLl9jZWxsKHByZXYpLFxuICAgICAgY2VsbDEgPSB0aGlzLl9jZWxsKGN1cnIpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgaWYgKGNlbGwwICE9PSBjZWxsMSkge1xuICAgIGNlbGwwLm51bSAtPSAxO1xuICAgIGNlbGwxLm51bSArPSAxO1xuICAgIGlmIChjZWxsMC5jb2xsZWN0KSBjZWxsMC5kYXRhLnJlbShwcmV2KTtcbiAgICBpZiAoY2VsbDEuY29sbGVjdCkgY2VsbDEuZGF0YS5hZGQoY3Vycik7XG4gIH0gZWxzZSBpZiAoY2VsbDAuY29sbGVjdCAmJiAhdXRpbC5pc09iamVjdChjdXJyKSkge1xuICAgIGNlbGwwLmRhdGEucmVtKHByZXYpO1xuICAgIGNlbGwwLmRhdGEuYWRkKGN1cnIpO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgIGNlbGwwLmFnZ3NbYWdncltpXS5uYW1lXS5yZW0ocHJldik7XG4gICAgY2VsbDEuYWdnc1thZ2dyW2ldLm5hbWVdLmFkZChjdXJyKTtcbiAgfVxuICBjZWxsMC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBjZWxsMS5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xufTtcblxucHJvdG8ucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLFxuICAgICAgY2VsbCwgaSwgaztcblxuICBmb3IgKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjZWxsID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYgKGNlbGwubnVtID4gMCkge1xuICAgICAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgICAgICBjZWxsLmRhdGEudmFsdWVzKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goY2VsbC50dXBsZSk7XG4gICAgfVxuICAgIGNlbGwuZmxhZyA9IDA7XG4gIH1cblxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5wcm90by5jaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGFuZ2VzID0ge2FkZDpbXSwgcmVtOltdLCBtb2Q6W119LFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBmbGFnLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBmbGFnID0gY2VsbC5mbGFnO1xuXG4gICAgLy8gY29uc29saWRhdGUgY29sbGVjdG9yIHZhbHVlc1xuICAgIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdHVwbGUgcHJvcGVydGllc1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgIH1cblxuICAgIC8vIG9yZ2FuaXplIG91dHB1dCB0dXBsZXNcbiAgICBpZiAoY2VsbC5udW0gPD0gMCkge1xuICAgICAgaWYgKGZsYWcgPT09IEZsYWdzLk1PRF9DRUxMKSB7XG4gICAgICAgIGNoYW5nZXMucmVtLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fY2VsbHNba107XG4gICAgfSBlbHNlIGlmIChmbGFnICYgRmxhZ3MuQUREX0NFTEwpIHtcbiAgICAgIGNoYW5nZXMuYWRkLnB1c2goY2VsbC50dXBsZSk7XG4gICAgfSBlbHNlIGlmIChmbGFnICYgRmxhZ3MuTU9EX0NFTEwpIHtcbiAgICAgIGNoYW5nZXMubW9kLnB1c2goY2VsbC50dXBsZSk7XG4gICAgfVxuXG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5wcm90by5leGVjdXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMuY2xlYXIoKS5pbnNlcnQoaW5wdXQpLnJlc3VsdCgpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdGhpcy5fY29uc29saWRhdGUoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fYWRkKGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmICghdGhpcy5fc3RyZWFtKSB7XG4gICAgdGhyb3cgJ0FnZ3JlZ2F0b3Igbm90IGNvbmZpZ3VyZWQgZm9yIHN0cmVhbWluZyByZW1vdmVzLicgK1xuICAgICAgJyBDYWxsIHN0cmVhbSh0cnVlKSBwcmlvciB0byBjYWxsaW5nIHN1bW1hcml6ZS4nO1xuICB9XG4gIGZvciAodmFyIGk9MDsgaTxpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX3JlbShpbnB1dFtpXSk7XG4gIH1cbiAgdGhpcy5fcmVtcyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gY29uc29saWRhdGUgcmVtb3ZhbHNcbnByb3RvLl9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbXMpIHJldHVybjtcbiAgZm9yICh2YXIgayBpbiB0aGlzLl9jZWxscykge1xuICAgIGlmICh0aGlzLl9jZWxsc1trXS5jb2xsZWN0KSB7XG4gICAgICB0aGlzLl9jZWxsc1trXS5kYXRhLnZhbHVlcygpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgUkVNID0gJ19fZGxfcmVtX18nO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3Ioa2V5KSB7XG4gIHRoaXMuX2FkZCA9IFtdO1xuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fa2V5ID0ga2V5IHx8IG51bGw7XG4gIHRoaXMuX2xhc3QgPSBudWxsO1xufVxuXG52YXIgcHJvdG8gPSBDb2xsZWN0b3IucHJvdG90eXBlO1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuX2FkZC5wdXNoKHYpO1xufTtcblxucHJvdG8ucmVtID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcmVtLmxlbmd0aCA9PT0gMCkgcmV0dXJuICh0aGlzLl9nZXQgPSBudWxsLCB0aGlzLl9hZGQpO1xuICB2YXIgYSA9IHRoaXMuX2FkZCxcbiAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICBrID0gdGhpcy5fa2V5LFxuICAgICAgeCA9IEFycmF5KGEubGVuZ3RoIC0gci5sZW5ndGgpLFxuICAgICAgaSwgaiwgbiwgbTtcblxuICBpZiAoIXV0aWwuaXNPYmplY3QoclswXSkpIHtcbiAgICAvLyBwcm9jZXNzaW5nIHJhdyB2YWx1ZXNcbiAgICBtID0gc3RhdHMuY291bnQubWFwKHIpO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAobVthW2ldXSA+IDApIHtcbiAgICAgICAgbVthW2ldXSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFtqKytdID0gYVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaykge1xuICAgIC8vIGhhcyB1bmlxdWUga2V5IGZpZWxkLCBzbyB1c2UgdGhhdFxuICAgIG0gPSB1dGlsLnRvTWFwKHIsIGspO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoayhhW2ldKSkpIHsgeFtqKytdID0gYVtpXTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyB1bmlxdWUga2V5LCBtYXJrIHR1cGxlcyBkaXJlY3RseVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgcltpXVtSRU1dID0gMTtcbiAgICB9XG4gICAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmICghYVtpXVtSRU1dKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gICAgZm9yIChpPTAsIG49ci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBkZWxldGUgcltpXVtSRU1dO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICByZXR1cm4gKHRoaXMuX2FkZCA9IHgpO1xufTtcblxuLy8gbWVtb2l6aW5nIHN0YXRpc3RpY3MgbWV0aG9kc1xuXG5wcm90by5leHRlbnQgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIGkgPSBzdGF0cy5leHRlbnQuaW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0OyAgICBcbiAgfVxuICByZXR1cm4gdGhpcy5fZXh0O1xufTtcblxucHJvdG8uYXJnbWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzBdO1xufTtcblxucHJvdG8uYXJnbWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdO1xufTtcblxucHJvdG8ubWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVswXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiArSW5maW5pdHk7XG59O1xucHJvdG8ubWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVsxXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiAtSW5maW5pdHk7XG59O1xuXG5wcm90by5xdWFydGlsZSA9IGZ1bmN0aW9uKGdldCkge1xuICBpZiAodGhpcy5fZ2V0ICE9PSBnZXQgfHwgIXRoaXMuX3EpIHtcbiAgICB0aGlzLl9xID0gc3RhdHMucXVhcnRpbGUodGhpcy52YWx1ZXMoKSwgZ2V0KTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7ICAgIFxuICB9XG4gIHJldHVybiB0aGlzLl9xO1xufTtcblxucHJvdG8ucTEgPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVswXTtcbn07XG5cbnByb3RvLnEyID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMV07XG59O1xuXG5wcm90by5xMyA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzJdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vYWdncmVnYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBmbGF0dGVuIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5XG4gIHZhciBhcmdzID0gW10ucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCB4KSB7XG4gICAgcmV0dXJuIGEuY29uY2F0KHV0aWwuYXJyYXkoeCkpO1xuICB9LCBbXSk7XG4gIC8vIGNyZWF0ZSBhbmQgcmV0dXJuIGFuIGFnZ3JlZ2F0b3JcbiAgcmV0dXJuIG5ldyBBZ2dyZWdhdG9yKClcbiAgICAuZ3JvdXBieShhcmdzKVxuICAgIC5zdW1tYXJpemUoeycqJzondmFsdWVzJ30pO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgdHlwZXMgPSB7XG4gICd2YWx1ZXMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFsdWVzJyxcbiAgICBpbml0OiAnY2VsbC5jb2xsZWN0ID0gdHJ1ZTsnLFxuICAgIHNldDogICdjZWxsLmRhdGEudmFsdWVzKCknLCBpZHg6IC0xXG4gIH0pLFxuICAnY291bnQnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnY291bnQnLFxuICAgIHNldDogICdjZWxsLm51bSdcbiAgfSksXG4gICdtaXNzaW5nJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21pc3NpbmcnLFxuICAgIHNldDogICd0aGlzLm1pc3NpbmcnXG4gIH0pLFxuICAndmFsaWQnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFsaWQnLFxuICAgIHNldDogICd0aGlzLnZhbGlkJ1xuICB9KSxcbiAgJ3N1bSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdW0nLFxuICAgIGluaXQ6ICd0aGlzLnN1bSA9IDA7JyxcbiAgICBhZGQ6ICAndGhpcy5zdW0gKz0gdjsnLFxuICAgIHJlbTogICd0aGlzLnN1bSAtPSB2OycsXG4gICAgc2V0OiAgJ3RoaXMuc3VtJ1xuICB9KSxcbiAgJ21lYW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWVhbicsXG4gICAgaW5pdDogJ3RoaXMubWVhbiA9IDA7JyxcbiAgICBhZGQ6ICAndmFyIGQgPSB2IC0gdGhpcy5tZWFuOyB0aGlzLm1lYW4gKz0gZCAvIHRoaXMudmFsaWQ7JyxcbiAgICByZW06ICAndmFyIGQgPSB2IC0gdGhpcy5tZWFuOyB0aGlzLm1lYW4gLT0gZCAvIHRoaXMudmFsaWQ7JyxcbiAgICBzZXQ6ICAndGhpcy5tZWFuJ1xuICB9KSxcbiAgJ2F2ZXJhZ2UnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXZlcmFnZScsXG4gICAgc2V0OiAgJ3RoaXMubWVhbicsXG4gICAgcmVxOiAgWydtZWFuJ10sIGlkeDogMVxuICB9KSxcbiAgJ3ZhcmlhbmNlJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhcmlhbmNlJyxcbiAgICBpbml0OiAndGhpcy5kZXYgPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuZGV2ICs9IGQgKiAodiAtIHRoaXMubWVhbik7JyxcbiAgICByZW06ICAndGhpcy5kZXYgLT0gZCAqICh2IC0gdGhpcy5tZWFuKTsnLFxuICAgIHNldDogICd0aGlzLmRldiAvICh0aGlzLnZhbGlkLTEpJyxcbiAgICByZXE6ICBbJ21lYW4nXSwgaWR4OiAxXG4gIH0pLFxuICAndmFyaWFuY2VwJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhcmlhbmNlcCcsXG4gICAgc2V0OiAgJ3RoaXMuZGV2IC8gdGhpcy52YWxpZCcsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdzdGRldic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdGRldicsXG4gICAgc2V0OiAgJ01hdGguc3FydCh0aGlzLmRldiAvICh0aGlzLnZhbGlkLTEpKScsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdzdGRldnAnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3RkZXZwJyxcbiAgICBzZXQ6ICAnTWF0aC5zcXJ0KHRoaXMuZGV2IC8gdGhpcy52YWxpZCknLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnbWVkaWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lZGlhbicsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMih0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ3ExJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ExJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnExKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAncTMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAncTMnLFxuICAgIHNldDogICdjZWxsLmRhdGEucTModGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdkaXN0aW5jdCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdkaXN0aW5jdCcsXG4gICAgc2V0OiAgJ3RoaXMuZGlzdGluY3QoY2VsbC5kYXRhLnZhbHVlcygpLCB0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtaW4nLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLmFyZ21pbiA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMuYXJnbWluID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21pbiA9IHRoaXMuYXJnbWluIHx8IGNlbGwuZGF0YS5hcmdtaW4odGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21pbiddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21heCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtYXgnLFxuICAgIGFkZDogICdpZiAodiA+IHRoaXMubWF4KSB0aGlzLmFyZ21heCA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPj0gdGhpcy5tYXgpIHRoaXMuYXJnbWF4ID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21heCA9IHRoaXMuYXJnbWF4IHx8IGNlbGwuZGF0YS5hcmdtYXgodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21heCddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaW4nLFxuICAgIGluaXQ6ICd0aGlzLm1pbiA9ICtJbmZpbml0eTsnLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLm1pbiA9IHY7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMubWluID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWluID0gKGlzTmFOKHRoaXMubWluKSA/IGNlbGwuZGF0YS5taW4odGhpcy5nZXQpIDogdGhpcy5taW4pJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtYXgnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWF4JyxcbiAgICBpbml0OiAndGhpcy5tYXggPSAtSW5maW5pdHk7JyxcbiAgICBhZGQ6ICAnaWYgKHYgPiB0aGlzLm1heCkgdGhpcy5tYXggPSB2OycsXG4gICAgcmVtOiAgJ2lmICh2ID49IHRoaXMubWF4KSB0aGlzLm1heCA9IE5hTjsnLFxuICAgIHNldDogICd0aGlzLm1heCA9IChpc05hTih0aGlzLm1heCkgPyBjZWxsLmRhdGEubWF4KHRoaXMuZ2V0KSA6IHRoaXMubWF4KScsXG4gICAgc3RyOiAgWyd2YWx1ZXMnXSwgaWR4OiA0XG4gIH0pLFxuICAnbW9kZXNrZXcnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbW9kZXNrZXcnLFxuICAgIHNldDogICd0aGlzLmRldj09PTAgPyAwIDogKHRoaXMubWVhbiAtIGNlbGwuZGF0YS5xMih0aGlzLmdldCkpIC8gTWF0aC5zcXJ0KHRoaXMuZGV2Lyh0aGlzLnZhbGlkLTEpKScsXG4gICAgcmVxOiAgWydtZWFuJywgJ3N0ZGV2JywgJ21lZGlhbiddLCBpZHg6IDVcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIG1lYXN1cmUoYmFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob3V0KSB7XG4gICAgdmFyIG0gPSB1dGlsLmV4dGVuZCh7aW5pdDonJywgYWRkOicnLCByZW06JycsIGlkeDowfSwgYmFzZSk7XG4gICAgbS5vdXQgPSBvdXQgfHwgYmFzZS5uYW1lO1xuICAgIHJldHVybiBtO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGFnZywgc3RyZWFtKSB7XG4gIGZ1bmN0aW9uIGNvbGxlY3QobSwgYSkge1xuICAgIGZ1bmN0aW9uIGhlbHBlcihyKSB7IGlmICghbVtyXSkgY29sbGVjdChtLCBtW3JdID0gdHlwZXNbcl0oKSk7IH1cbiAgICBpZiAoYS5yZXEpIGEucmVxLmZvckVhY2goaGVscGVyKTtcbiAgICBpZiAoc3RyZWFtICYmIGEuc3RyKSBhLnN0ci5mb3JFYWNoKGhlbHBlcik7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgdmFyIG1hcCA9IGFnZy5yZWR1Y2UoXG4gICAgY29sbGVjdCxcbiAgICBhZ2cucmVkdWNlKGZ1bmN0aW9uKG0sIGEpIHsgcmV0dXJuIChtW2EubmFtZV0gPSBhLCBtKTsgfSwge30pXG4gICk7XG4gIHJldHVybiB1dGlsLnZhbHMobWFwKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoYWdnLCBzdHJlYW0sIGFjY2Vzc29yLCBtdXRhdG9yKSB7XG4gIHZhciBhbGwgPSByZXNvbHZlKGFnZywgc3RyZWFtKSxcbiAgICAgIGN0ciA9ICd0aGlzLmNlbGwgPSBjZWxsOyB0aGlzLnR1cGxlID0gdDsgdGhpcy52YWxpZCA9IDA7IHRoaXMubWlzc2luZyA9IDA7JyxcbiAgICAgIGFkZCA9ICdpZiAodj09bnVsbCkgdGhpcy5taXNzaW5nKys7IGlmICghdGhpcy5pc1ZhbGlkKHYpKSByZXR1cm47IHRoaXMudmFsaWQrKzsnLFxuICAgICAgcmVtID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmctLTsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgdGhpcy52YWxpZC0tOycsXG4gICAgICBzZXQgPSAndmFyIHQgPSB0aGlzLnR1cGxlOyB2YXIgY2VsbCA9IHRoaXMuY2VsbDsnO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoYS5pZHggPCAwKSB7XG4gICAgICBjdHIgPSBhLmluaXQgKyBjdHI7XG4gICAgICBhZGQgPSBhLmFkZCArIGFkZDtcbiAgICAgIHJlbSA9IGEucmVtICsgcmVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHIgKz0gYS5pbml0O1xuICAgICAgYWRkICs9IGEuYWRkO1xuICAgICAgcmVtICs9IGEucmVtO1xuICAgIH1cbiAgfSk7XG4gIGFnZy5zbGljZSgpXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBzZXQgKz0gJ3RoaXMuYXNzaWduKHQsXFwnJythLm91dCsnXFwnLCcrYS5zZXQrJyk7JztcbiAgICB9KTtcbiAgc2V0ICs9ICdyZXR1cm4gdDsnO1xuXG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIGN0ciA9IEZ1bmN0aW9uKCdjZWxsJywgJ3QnLCBjdHIpO1xuICBjdHIucHJvdG90eXBlLmFzc2lnbiA9IG11dGF0b3I7XG4gIGN0ci5wcm90b3R5cGUuYWRkID0gRnVuY3Rpb24oJ3QnLCAndmFyIHYgPSB0aGlzLmdldCh0KTsnICsgYWRkKTtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyByZW0pO1xuICBjdHIucHJvdG90eXBlLnNldCA9IEZ1bmN0aW9uKHNldCk7XG4gIGN0ci5wcm90b3R5cGUuZ2V0ID0gYWNjZXNzb3I7XG4gIGN0ci5wcm90b3R5cGUubW9kID0gbW9kO1xuICBjdHIucHJvdG90eXBlLmRpc3RpbmN0ID0gcmVxdWlyZSgnLi4vc3RhdHMnKS5jb3VudC5kaXN0aW5jdDtcbiAgY3RyLnByb3RvdHlwZS5pc1ZhbGlkID0gdXRpbC5pc1ZhbGlkO1xuICByZXR1cm4gY3RyO1xufVxuXG5mdW5jdGlvbiBtb2Qodl9uZXcsIHZfb2xkKSB7XG4gIGlmICh2X29sZCA9PT0gdW5kZWZpbmVkIHx8IHZfb2xkID09PSB2X25ldykgcmV0dXJuO1xuICB0aGlzLnJlbSh2X29sZCk7XG4gIHRoaXMuYWRkKHZfbmV3KTtcbn1cblxudHlwZXMuY3JlYXRlID0gY3JlYXRlO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlczsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB1bml0cyA9IHJlcXVpcmUoJy4uL3RpbWUtdW5pdHMnKTtcbnZhciBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgdmFyIG1heGIgPSBvcHQubWF4YmlucyB8fCAxNSxcbiAgICAgIGJhc2UgPSBvcHQuYmFzZSB8fCAxMCxcbiAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgIGRpdiA9IG9wdC5kaXYgfHwgWzUsIDJdLCAgICAgIFxuICAgICAgbWluID0gb3B0Lm1pbixcbiAgICAgIG1heCA9IG9wdC5tYXgsXG4gICAgICBzcGFuID0gbWF4IC0gbWluLFxuICAgICAgc3RlcCwgbGV2ZWwsIG1pbnN0ZXAsIHByZWNpc2lvbiwgdiwgaSwgZXBzO1xuXG4gIGlmIChvcHQuc3RlcCkge1xuICAgIC8vIGlmIHN0ZXAgc2l6ZSBpcyBleHBsaWNpdGx5IGdpdmVuLCB1c2UgdGhhdFxuICAgIHN0ZXAgPSBvcHQuc3RlcDtcbiAgfSBlbHNlIGlmIChvcHQuc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHN0ZXAgPSBvcHQuc3RlcHNbTWF0aC5taW4oXG4gICAgICBvcHQuc3RlcHMubGVuZ3RoIC0gMSxcbiAgICAgIGJpc2VjdChvcHQuc3RlcHMsIHNwYW4vbWF4YiwgMCwgb3B0LnN0ZXBzLmxlbmd0aClcbiAgICApXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHVzZSBzcGFuIHRvIGRldGVybWluZSBzdGVwIHNpemVcbiAgICBsZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZyhtYXhiKSAvIGxvZ2IpO1xuICAgIG1pbnN0ZXAgPSBvcHQubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChcbiAgICAgIG1pbnN0ZXAsXG4gICAgICBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbClcbiAgICApO1xuICAgIFxuICAgIC8vIGluY3JlYXNlIHN0ZXAgc2l6ZSBpZiB0b28gbWFueSBiaW5zXG4gICAgZG8geyBzdGVwICo9IGJhc2U7IH0gd2hpbGUgKE1hdGguY2VpbChzcGFuL3N0ZXApID4gbWF4Yik7XG5cbiAgICAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuICAgIGZvciAoaT0wOyBpPGRpdi5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHN0ZXAgLyBkaXZbaV07XG4gICAgICBpZiAodiA+PSBtaW5zdGVwICYmIHNwYW4gLyB2IDw9IG1heGIpIHN0ZXAgPSB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcmVjaXNpb24sIG1pbiBhbmQgbWF4XG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxO1xuICBlcHMgPSBNYXRoLnBvdyhiYXNlLCAtcHJlY2lzaW9uIC0gMSk7XG4gIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5mbG9vcihtaW4gLyBzdGVwICsgZXBzKSAqIHN0ZXApO1xuICBtYXggPSBNYXRoLmNlaWwobWF4IC8gc3RlcCkgKiBzdGVwO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiAgbWF4LFxuICAgIHN0ZXA6ICBzdGVwLFxuICAgIHVuaXQ6ICB7cHJlY2lzaW9uOiBwcmVjaXNpb259LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpbmRleDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmlzZWN0KGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmICh1dGlsLmNtcChhW21pZF0sIHgpIDwgMCkgeyBsbyA9IG1pZCArIDE7IH1cbiAgICBlbHNlIHsgaGkgPSBtaWQ7IH1cbiAgfVxuICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIHZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMuc3RlcCAqIE1hdGguZmxvb3IodiAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBpbmRleCh2KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKCh2IC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV92YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnVuaXQuZGF0ZSh2YWx1ZS5jYWxsKHRoaXMsIHYpKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV9pbmRleCh2KSB7XG4gIHJldHVybiBpbmRleC5jYWxsKHRoaXMsIHRoaXMudW5pdC51bml0KHYpKTtcbn1cblxuYmlucy5kYXRlID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBmaW5kIHRpbWUgc3RlcCwgdGhlbiBiaW5cbiAgdmFyIGRtaW4gPSBvcHQubWluLFxuICAgICAgZG1heCA9IG9wdC5tYXgsXG4gICAgICBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMjAsXG4gICAgICBtaW5iID0gb3B0Lm1pbmJpbnMgfHwgNCxcbiAgICAgIHNwYW4gPSAoK2RtYXgpIC0gKCtkbWluKSxcbiAgICAgIHVuaXQgPSBvcHQudW5pdCA/IHVuaXRzW29wdC51bml0XSA6IHVuaXRzLmZpbmQoc3BhbiwgbWluYiwgbWF4YiksXG4gICAgICBzcGVjID0gYmlucyh7XG4gICAgICAgIG1pbjogICAgIHVuaXQubWluICE9IG51bGwgPyB1bml0Lm1pbiA6IHVuaXQudW5pdChkbWluKSxcbiAgICAgICAgbWF4OiAgICAgdW5pdC5tYXggIT0gbnVsbCA/IHVuaXQubWF4IDogdW5pdC51bml0KGRtYXgpLFxuICAgICAgICBtYXhiaW5zOiBtYXhiLFxuICAgICAgICBtaW5zdGVwOiB1bml0Lm1pbnN0ZXAsXG4gICAgICAgIHN0ZXBzOiAgIHVuaXQuc3RlcFxuICAgICAgfSk7XG5cbiAgc3BlYy51bml0ID0gdW5pdDtcbiAgc3BlYy5pbmRleCA9IGRhdGVfaW5kZXg7XG4gIGlmICghb3B0LnJhdykgc3BlYy52YWx1ZSA9IGRhdGVfdmFsdWU7XG4gIHJldHVybiBzcGVjO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5zO1xuIiwidmFyIHN0YXRzID0gcmVxdWlyZSgnLi4vc3RhdHMnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vaW1wb3J0L3R5cGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlJyk7XG52YXIgYmlucyA9IHJlcXVpcmUoJy4vYmlucycpO1xuXG52YXIgcXR5cGUgPSB7XG4gICdpbnRlZ2VyJzogMSxcbiAgJ251bWJlcic6IDEsXG4gICdkYXRlJzogMVxufTtcblxuZnVuY3Rpb24gJGJpbih2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiAhYiA/IChvcHQuYWNjZXNzb3IgfHwgdXRpbC5pZGVudGl0eSkgOlxuICAgIHV0aWwuJGZ1bmMoJ2JpbicsIGIudW5pdC51bml0ID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoYi51bml0LnVuaXQoeCkpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoeCk7IH1cbiAgICApKG9wdC5hY2Nlc3Nvcik7XG59XG5cbmZ1bmN0aW9uIGhpc3RvZ3JhbSh2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiBiID9cbiAgICBudW1lcmljYWwodmFsdWVzLCBvcHQuYWNjZXNzb3IsIGIpIDpcbiAgICBjYXRlZ29yaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3Nvciwgb3B0ICYmIG9wdC5zb3J0KTtcbn1cblxuZnVuY3Rpb24gc3BlYyhvcHQpIHtcbiAgdmFyIHQgPSBvcHQudHlwZSwgYiA9IG51bGw7XG4gIGlmICh0ID09IG51bGwgfHwgcXR5cGVbdF0pIHtcbiAgICBpZiAodCA9PT0gJ2ludGVnZXInICYmIG9wdC5taW5zdGVwID09IG51bGwpIG9wdC5taW5zdGVwID0gMTtcbiAgICBiID0gKHQgPT09ICdkYXRlJykgPyBiaW5zLmRhdGUob3B0KSA6IGJpbnMob3B0KTtcbiAgfVxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICBpID0gMCxcbiAgICAgIHZhbHVlcyA9IHV0aWwuaXNBcnJheShhW2ldKSA/IGFbaSsrXSA6IG51bGwsXG4gICAgICBmID0gdXRpbC5pc0Z1bmN0aW9uKGFbaV0pIHx8IHV0aWwuaXNTdHJpbmcoYVtpXSkgPyB1dGlsLiQoYVtpKytdKSA6IG51bGwsXG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7fSwgYVtpXSk7XG4gIFxuICBpZiAodmFsdWVzKSB7XG4gICAgb3B0LnR5cGUgPSBvcHQudHlwZSB8fCB0eXBlKHZhbHVlcywgZik7XG4gICAgaWYgKHF0eXBlW29wdC50eXBlXSkge1xuICAgICAgdmFyIGV4dCA9IHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpO1xuICAgICAgb3B0ID0gdXRpbC5leHRlbmQoe21pbjogZXh0WzBdLCBtYXg6IGV4dFsxXX0sIG9wdCk7XG4gICAgfVxuICB9XG4gIGlmIChmKSB7IG9wdC5hY2Nlc3NvciA9IGY7IH1cbiAgcmV0dXJuIG9wdDtcbn1cblxuZnVuY3Rpb24gbnVtZXJpY2FsKHZhbHVlcywgZiwgYikge1xuICB2YXIgaCA9IGdlbi5yYW5nZShiLnN0YXJ0LCBiLnN0b3AgKyBiLnN0ZXAvMiwgYi5zdGVwKVxuICAgIC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4ge3ZhbHVlOiBiLnZhbHVlKHYpLCBjb3VudDogMH07IH0pO1xuXG4gIGZvciAodmFyIGk9MCwgdiwgajsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBqID0gYi5pbmRleCh2KTtcbiAgICAgIGlmIChqIDwgMCB8fCBqID49IGgubGVuZ3RoIHx8ICFpc0Zpbml0ZShqKSkgY29udGludWU7XG4gICAgICBoW2pdLmNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIGguYmlucyA9IGI7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBjYXRlZ29yaWNhbCh2YWx1ZXMsIGYsIHNvcnQpIHtcbiAgdmFyIHUgPSBzdGF0cy51bmlxdWUodmFsdWVzLCBmKSxcbiAgICAgIGMgPSBzdGF0cy5jb3VudC5tYXAodmFsdWVzLCBmKTtcbiAgcmV0dXJuIHUubWFwKGZ1bmN0aW9uKGspIHsgcmV0dXJuIHt2YWx1ZTogaywgY291bnQ6IGNba119OyB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcihzb3J0ID8gJy1jb3VudCcgOiAnK3ZhbHVlJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJGJpbjogJGJpbixcbiAgaGlzdG9ncmFtOiBoaXN0b2dyYW1cbn07IiwidmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmdlbi5yZXBlYXQgPSBmdW5jdGlvbih2YWwsIG4pIHtcbiAgdmFyIGEgPSBBcnJheShuKSwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBhW2ldID0gdmFsO1xuICByZXR1cm4gYTtcbn07XG5cbmdlbi56ZXJvcyA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIGdlbi5yZXBlYXQoMCwgbik7XG59O1xuXG5nZW4ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBzdGVwID0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSByYW5nZScpO1xuICB2YXIgcmFuZ2UgPSBbXSwgaSA9IC0xLCBqO1xuICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGopO1xuICBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGopO1xuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5nZW4ucmFuZG9tID0ge307XG5cbmdlbi5yYW5kb20udW5pZm9ybSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgIG1heCA9IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG4gIHZhciBkID0gbWF4IC0gbWluO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtaW4gKyBkICogTWF0aC5yYW5kb20oKTtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLmludGVnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICBiID0gYTtcbiAgICBhID0gMDtcbiAgfVxuICB2YXIgZCA9IGIgLSBhO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhICsgTWF0aC5mbG9vcihkICogTWF0aC5yYW5kb20oKSk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5ub3JtYWwgPSBmdW5jdGlvbihtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2IHx8IDE7XG4gIHZhciBuZXh0O1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gMCwgeSA9IDAsIHJkcywgYztcbiAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4ID0gbmV4dDtcbiAgICAgIG5leHQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgeCA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgeSA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgcmRzID0geCp4ICsgeSp5O1xuICAgIH0gd2hpbGUgKHJkcyA9PT0gMCB8fCByZHMgPiAxKTtcbiAgICBjID0gTWF0aC5zcXJ0KC0yKk1hdGgubG9nKHJkcykvcmRzKTsgLy8gQm94LU11bGxlciB0cmFuc2Zvcm1cbiAgICBuZXh0ID0gbWVhbiArIHkqYypzdGRldjtcbiAgICByZXR1cm4gbWVhbiArIHgqYypzdGRldjtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCk7XG5cbmZ1bmN0aW9uIGRzdihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICB2YXIgaCA9IGZvcm1hdC5oZWFkZXI7XG4gICAgZGF0YSA9IChoID8gaC5qb2luKGZvcm1hdC5kZWxpbWl0ZXIpICsgJ1xcbicgOiAnJykgKyBkYXRhO1xuICB9XG4gIHJldHVybiBkMy5kc3YoZm9ybWF0LmRlbGltaXRlcikucGFyc2UoZGF0YSk7XG59XG5cbmRzdi5kZWxpbWl0ZXIgPSBmdW5jdGlvbihkZWxpbSkge1xuICB2YXIgZm10ID0ge2RlbGltaXRlcjogZGVsaW19O1xuICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGRzdihkYXRhLCBmb3JtYXQgPyB1dGlsLmV4dGVuZChmb3JtYXQsIGZtdCkgOiBmbXQpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkc3Y7IiwidmFyIGRzdiA9IHJlcXVpcmUoJy4vZHN2Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBqc29uOiByZXF1aXJlKCcuL2pzb24nKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKSxcbiAgZHN2OiBkc3YsXG4gIGNzdjogZHN2LmRlbGltaXRlcignLCcpLFxuICB0c3Y6IGRzdi5kZWxpbWl0ZXIoJ1xcdCcpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IHV0aWwuaXNPYmplY3QoZGF0YSkgJiYgIXV0aWwuaXNCdWZmZXIoZGF0YSkgP1xuICAgIGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5wcm9wZXJ0eSkge1xuICAgIGQgPSB1dGlsLmFjY2Vzc29yKGZvcm1hdC5wcm9wZXJ0eSkoZCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59O1xuIiwidmFyIGpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcbnZhciB0b3BvanNvbiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnRvcG9qc29uIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC50b3BvanNvbiA6IG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBpZiAodG9wb2pzb24gPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignVG9wb0pTT04gbGlicmFyeSBub3QgbG9hZGVkLicpOyB9XG5cbiAgdmFyIHQgPSBqc29uKGRhdGEsIGZvcm1hdCksIG9iajtcblxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5mZWF0dXJlKSB7XG4gICAgaWYgKChvYmogPSB0Lm9iamVjdHNbZm9ybWF0LmZlYXR1cmVdKSkge1xuICAgICAgcmV0dXJuIHRvcG9qc29uLmZlYXR1cmUodCwgb2JqKS5mZWF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnK2Zvcm1hdC5mZWF0dXJlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ICYmIGZvcm1hdC5tZXNoKSB7XG4gICAgaWYgKChvYmogPSB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKSkge1xuICAgICAgcmV0dXJuIFt0b3BvanNvbi5tZXNoKHQsIHQub2JqZWN0c1tmb3JtYXQubWVzaF0pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnICsgZm9ybWF0Lm1lc2gpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignTWlzc2luZyBUb3BvSlNPTiBmZWF0dXJlIG9yIG1lc2ggcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIGRhdGEgPSBqc29uKGRhdGEsIGZvcm1hdCk7XG4gIHJldHVybiB0b1RhYmxlKGRhdGEsIChmb3JtYXQgJiYgZm9ybWF0LmNoaWxkcmVuKSk7XG59O1xuXG5mdW5jdGlvbiB0b1RhYmxlKHJvb3QsIGNoaWxkcmVuRmllbGQpIHtcbiAgY2hpbGRyZW5GaWVsZCA9IGNoaWxkcmVuRmllbGQgfHwgJ2NoaWxkcmVuJztcbiAgdmFyIHRhYmxlID0gW107XG4gIFxuICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgdGFibGUucHVzaChub2RlKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlW2NoaWxkcmVuRmllbGRdO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkcmVuW2ldLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHZpc2l0KHJvb3QsIG51bGwpO1xuICByZXR1cm4gKHRhYmxlLnJvb3QgPSByb290LCB0YWJsZSk7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYWJzb2x1dGUgVVJMcyB3aXRoIG9wdGlvbmFsIHByb3RvY29sXG4vLyAgIGh0dHBzOi8vLi4uICAgIGZpbGU6Ly8uLi4gICAgLy8uLi5cbnZhciBwcm90b2NvbF9yZSA9IC9eKFtBLVphLXpdKzopP1xcL1xcLy87XG5cbi8vIFNwZWNpYWwgdHJlYXRtZW50IGluIG5vZGUuanMgZm9yIHRoZSBmaWxlOiBwcm90b2NvbFxudmFyIGZpbGVQcm90b2NvbCA9ICdmaWxlOi8vJztcblxuLy8gVmFsaWRhdGUgYW5kIGNsZWFudXAgVVJMIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGFsbG93ZWQgdG8gYmUgYWNjZXNzZWRcbi8vIFJldHVybnMgY2xlYW5lZCB1cCBVUkwsIG9yIGZhbHNlIGlmIGFjY2VzcyBpcyBub3QgYWxsb3dlZFxuZnVuY3Rpb24gc2FuaXRpemVVcmwob3B0KSB7XG4gIHZhciB1cmwgPSBvcHQudXJsO1xuICBpZiAoIXVybCAmJiBvcHQuZmlsZSkgeyByZXR1cm4gZmlsZVByb3RvY29sICsgb3B0LmZpbGU7IH1cblxuICAvLyBJbiBjYXNlIHRoaXMgaXMgYSByZWxhdGl2ZSB1cmwgKGhhcyBubyBob3N0KSwgcHJlcGVuZCBvcHQuYmFzZVVSTFxuICBpZiAob3B0LmJhc2VVUkwgJiYgIXByb3RvY29sX3JlLnRlc3QodXJsKSkge1xuICAgIGlmICghdXRpbC5zdGFydHNXaXRoKHVybCwgJy8nKSAmJiBvcHQuYmFzZVVSTFtvcHQuYmFzZVVSTC5sZW5ndGgtMV0gIT09ICcvJykge1xuICAgICAgdXJsID0gJy8nICsgdXJsOyAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhIHNsYXNoIGJldHdlZW4gdGhlIGJhc2VVUkwgKGUuZy4gaG9zdG5hbWUpIGFuZCB1cmxcbiAgICB9XG4gICAgdXJsID0gb3B0LmJhc2VVUkwgKyB1cmw7XG4gIH1cbiAgLy8gcmVsYXRpdmUgcHJvdG9jb2wsIHN0YXJ0cyB3aXRoICcvLydcbiAgaWYgKHV0aWwuaXNOb2RlICYmIHV0aWwuc3RhcnRzV2l0aCh1cmwsICcvLycpKSB7XG4gICAgdXJsID0gKG9wdC5kZWZhdWx0UHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6JyArIHVybDtcbiAgfVxuICAvLyBJZiBvcHQuZG9tYWluV2hpdGVMaXN0IGlzIHNldCwgb25seSBhbGxvd3MgdXJsLCB3aG9zZSBob3N0bmFtZVxuICAvLyAqIElzIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW4gKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSlcbiAgLy8gKiBFcXVhbHMgb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICAvLyAqIElzIGEgcHJvcGVyIHN1YmRvbWFpbiBvZiBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIGlmIChvcHQuZG9tYWluV2hpdGVMaXN0KSB7XG4gICAgdmFyIGRvbWFpbiwgb3JpZ2luO1xuICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgLy8gcmVsYXRpdmUgcHJvdG9jb2wgaXMgYnJva2VuOiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXVybC9pc3N1ZXMvNVxuICAgICAgdmFyIHBhcnRzID0gcmVxdWlyZSgndXJsJykucGFyc2UodXJsKTtcbiAgICAgIGRvbWFpbiA9IHBhcnRzLmhvc3RuYW1lO1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM2NTEzL2hvdy1kby1pLXBhcnNlLWEtdXJsLWludG8taG9zdG5hbWUtYW5kLXBhdGgtaW4tamF2YXNjcmlwdFxuICAgICAgLy8gSUUgZG9lc24ndCBwb3B1bGF0ZSBhbGwgbGluayBwcm9wZXJ0aWVzIHdoZW4gc2V0dGluZyAuaHJlZiB3aXRoIGEgcmVsYXRpdmUgVVJMLFxuICAgICAgLy8gaG93ZXZlciAuaHJlZiB3aWxsIHJldHVybiBhbiBhYnNvbHV0ZSBVUkwgd2hpY2ggdGhlbiBjYW4gYmUgdXNlZCBvbiBpdHNlbGZcbiAgICAgIC8vIHRvIHBvcHVsYXRlIHRoZXNlIGFkZGl0aW9uYWwgZmllbGRzLlxuICAgICAgaWYgKGEuaG9zdCA9PT0gJycpIHtcbiAgICAgICAgYS5ocmVmID0gYS5ocmVmO1xuICAgICAgfVxuICAgICAgZG9tYWluID0gYS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikge1xuICAgICAgdmFyIHdoaXRlTGlzdGVkID0gb3B0LmRvbWFpbldoaXRlTGlzdC5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGlkeCA9IGRvbWFpbi5sZW5ndGggLSBkLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGQgPT09IGRvbWFpbiB8fFxuICAgICAgICAgIChpZHggPiAxICYmIGRvbWFpbltpZHgtMV0gPT09ICcuJyAmJiBkb21haW4ubGFzdEluZGV4T2YoZCkgPT09IGlkeCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghd2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgJ1VSTCBpcyBub3Qgd2hpdGVsaXN0ZWQ6ICcgKyB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGxvYWQob3B0LCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlKSB7IHRocm93IGU7IH0sIHVybDtcblxuICB0cnkge1xuICAgIHVybCA9IGxvYWQuc2FuaXRpemVVcmwob3B0KTsgLy8gZW5hYmxlIG92ZXJyaWRlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICBlcnJvcignSW52YWxpZCBVUkw6ICcgKyB1cmwpO1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSkge1xuICAgIC8vIGluIGJyb3dzZXIsIHVzZSB4aHJcbiAgICByZXR1cm4geGhyKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHV0aWwuc3RhcnRzV2l0aCh1cmwsIGZpbGVQcm90b2NvbCkpIHtcbiAgICAvLyBpbiBub2RlLmpzLCBpZiB1cmwgc3RhcnRzIHdpdGggJ2ZpbGU6Ly8nLCBzdHJpcCBpdCBhbmQgbG9hZCBmcm9tIGZpbGVcbiAgICByZXR1cm4gZmlsZSh1cmwuc2xpY2UoZmlsZVByb3RvY29sLmxlbmd0aCksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh1cmwuaW5kZXhPZignOi8vJykgPCAwKSB7IC8vIFRPRE8gYmV0dGVyIHByb3RvY29sIGNoZWNrP1xuICAgIC8vIGlmIG5vZGUuanMsIGlmIG5vIHByb3RvY29sIGFzc3VtZSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZm9yIHJlZ3VsYXIgVVJMcyBpbiBub2RlLmpzXG4gICAgcmV0dXJuIGh0dHAodXJsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24geGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSAndGV4dCcgP1xuICAgIHJlcXVlc3QucmVzcG9uc2UgOiAvLyBudWxsIG9uIGVycm9yXG4gICAgcmVxdWVzdC5yZXNwb25zZVRleHQ7IC8vICcnIG9uIGVycm9yXG59XG5cbmZ1bmN0aW9uIHhocih1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIC8vIElmIElFIGRvZXMgbm90IHN1cHBvcnQgQ09SUywgdXNlIFhEb21haW5SZXF1ZXN0IChjb3BpZWQgZnJvbSBkMy54aHIpXG4gIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmXG4gICAgICAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cbiAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgaWYgKCFzdGF0dXMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVxdWVzdCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzeW5jKSB7XG4gICAgaWYgKCdvbmxvYWQnIGluIHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMpIHJlc3BvbmQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuICByZXF1ZXN0LnNlbmQoKTtcbiAgXG4gIGlmICghYXN5bmMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsZShmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XG4gIH1cbiAgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZShmaWxlbmFtZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBodHRwKHVybCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiByZXF1aXJlKCdzeW5jLXJlcXVlc3QnKSgnR0VUJywgdXJsKS5nZXRCb2R5KCk7XG4gIH1cbiAgcmVxdWlyZSgncmVxdWVzdCcpKHVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgaWYgKCFlcnJvciAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxubG9hZC5zYW5pdGl6ZVVybCA9IHNhbml0aXplVXJsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5mdW5jdGlvbiByZWFkKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgdHlwZSA9IChmb3JtYXQgJiYgZm9ybWF0LnR5cGUpIHx8ICdqc29uJztcbiAgZGF0YSA9IGZvcm1hdHNbdHlwZV0oZGF0YSwgZm9ybWF0KTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucGFyc2UpIHBhcnNlKGRhdGEsIGZvcm1hdC5wYXJzZSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcykge1xuICB2YXIgY29scywgcGFyc2VycywgZCwgaSwgaiwgY2xlbiwgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgdHlwZXMgPSAodHlwZXM9PT0nYXV0bycpID8gdHlwZS5pbmZlckFsbChkYXRhKSA6IHV0aWwuZHVwbGljYXRlKHR5cGVzKTtcbiAgY29scyA9IHV0aWwua2V5cyh0eXBlcyk7XG4gIHBhcnNlcnMgPSBjb2xzLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiB0eXBlLnBhcnNlcnNbdHlwZXNbY11dOyB9KTtcblxuICBmb3IgKGk9MCwgY2xlbj1jb2xzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvciAoaj0wOyBqPGNsZW47ICsraikge1xuICAgICAgZFtjb2xzW2pdXSA9IHBhcnNlcnNbal0oZFtjb2xzW2pdXSk7XG4gICAgfVxuICB9XG4gIHR5cGUuYW5ub3RhdGlvbihkYXRhLCB0eXBlcyk7XG59XG5cbnJlYWQuZm9ybWF0cyA9IGZvcm1hdHM7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsb2FkID0gcmVxdWlyZSgnLi9sb2FkJyk7XG52YXIgcmVhZCA9IHJlcXVpcmUoJy4vcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxcbiAgLmtleXMocmVhZC5mb3JtYXRzKVxuICAucmVkdWNlKGZ1bmN0aW9uKG91dCwgdHlwZSkge1xuICAgIG91dFt0eXBlXSA9IGZ1bmN0aW9uKG9wdCwgZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgLy8gcHJvY2VzcyBhcmd1bWVudHNcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9wdCkpIHsgb3B0ID0ge3VybDogb3B0fTsgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdXRpbC5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHJlYWQgZm9ybWF0XG4gICAgICBmb3JtYXQgPSB1dGlsLmV4dGVuZCh7cGFyc2U6ICdhdXRvJ30sIGZvcm1hdCk7XG4gICAgICBmb3JtYXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIGxvYWQgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBsb2FkKG9wdCwgY2FsbGJhY2sgPyBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChhc3luYylcbiAgICAgICAgICBkYXRhID0gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoc3luYylcbiAgICAgIGlmIChkYXRhKSByZXR1cm4gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbiAgfSwge30pO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBUWVBFUyA9ICdfX3R5cGVzX18nO1xuXG52YXIgUEFSU0VSUyA9IHtcbiAgYm9vbGVhbjogdXRpbC5ib29sZWFuLFxuICBpbnRlZ2VyOiB1dGlsLm51bWJlcixcbiAgbnVtYmVyOiAgdXRpbC5udW1iZXIsXG4gIGRhdGU6ICAgIHV0aWwuZGF0ZSxcbiAgc3RyaW5nOiAgZnVuY3Rpb24oeCkgeyByZXR1cm4geD09PScnID8gbnVsbCA6IHg7IH1cbn07XG5cbnZhciBURVNUUyA9IHtcbiAgYm9vbGVhbjogZnVuY3Rpb24oeCkgeyByZXR1cm4geD09PSd0cnVlJyB8fCB4PT09J2ZhbHNlJyB8fCB1dGlsLmlzQm9vbGVhbih4KTsgfSxcbiAgaW50ZWdlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gVEVTVFMubnVtYmVyKHgpICYmICh4PSt4KSA9PT0gfn54OyB9LFxuICBudW1iZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTigreCkgJiYgIXV0aWwuaXNEYXRlKHgpOyB9LFxuICBkYXRlOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oRGF0ZS5wYXJzZSh4KSk7IH1cbn07XG5cbmZ1bmN0aW9uIGFubm90YXRpb24oZGF0YSwgdHlwZXMpIHtcbiAgaWYgKCF0eXBlcykgcmV0dXJuIGRhdGEgJiYgZGF0YVtUWVBFU10gfHwgbnVsbDtcbiAgZGF0YVtUWVBFU10gPSB0eXBlcztcbn1cblxuZnVuY3Rpb24gdHlwZSh2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG47XG5cbiAgLy8gaWYgZGF0YSBhcnJheSBoYXMgdHlwZSBhbm5vdGF0aW9ucywgdXNlIHRoZW1cbiAgaWYgKHZhbHVlc1tUWVBFU10pIHtcbiAgICB2ID0gZih2YWx1ZXNbVFlQRVNdKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2KSkgcmV0dXJuIHY7XG4gIH1cblxuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyAhdXRpbC5pc1ZhbGlkKHYpICYmIGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gIH1cblxuICByZXR1cm4gdXRpbC5pc0RhdGUodikgPyAnZGF0ZScgOlxuICAgIHV0aWwuaXNOdW1iZXIodikgICAgPyAnbnVtYmVyJyA6XG4gICAgdXRpbC5pc0Jvb2xlYW4odikgICA/ICdib29sZWFuJyA6XG4gICAgdXRpbC5pc1N0cmluZyh2KSAgICA/ICdzdHJpbmcnIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdHlwZUFsbChkYXRhLCBmaWVsZHMpIHtcbiAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuO1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHJldHVybiAodHlwZXNbZl0gPSB0eXBlKGRhdGEsIGYpLCB0eXBlcyk7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gaW5mZXIodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBqLCB2O1xuXG4gIC8vIHR5cGVzIHRvIHRlc3QgZm9yLCBpbiBwcmVjZWRlbmNlIG9yZGVyXG4gIHZhciB0eXBlcyA9IFsnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlcicsICdkYXRlJ107XG5cbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IG5leHQgdmFsdWUgdG8gdGVzdFxuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIC8vIHRlc3QgdmFsdWUgYWdhaW5zdCByZW1haW5pbmcgdHlwZXNcbiAgICBmb3IgKGo9MDsgajx0eXBlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHV0aWwuaXNWYWxpZCh2KSAmJiAhVEVTVFNbdHlwZXNbal1dKHYpKSB7XG4gICAgICAgIHR5cGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgaiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBubyB0eXBlcyBsZWZ0LCByZXR1cm4gJ3N0cmluZydcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICByZXR1cm4gdHlwZXNbMF07XG59XG5cbmZ1bmN0aW9uIGluZmVyQWxsKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHZhciB0eXBlID0gaW5mZXIoZGF0YSwgZik7XG4gICAgaWYgKFBBUlNFUlNbdHlwZV0pIHR5cGVzW2ZdID0gdHlwZTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH0sIHt9KTtcbn1cblxudHlwZS5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbjtcbnR5cGUuYWxsID0gdHlwZUFsbDtcbnR5cGUuaW5mZXIgPSBpbmZlcjtcbnR5cGUuaW5mZXJBbGwgPSBpbmZlckFsbDtcbnR5cGUucGFyc2VycyA9IFBBUlNFUlM7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIGRsID0ge1xuICBsb2FkOiAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L2xvYWQnKSxcbiAgcmVhZDogICAgICByZXF1aXJlKCcuL2ltcG9ydC9yZWFkJyksXG4gIHR5cGU6ICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpLFxuICBiaW5zOiAgICAgIHJlcXVpcmUoJy4vYmlucy9iaW5zJyksXG4gICRiaW46ICAgICAgcmVxdWlyZSgnLi9iaW5zL2hpc3RvZ3JhbScpLiRiaW4sXG4gIGdyb3VwYnk6ICAgcmVxdWlyZSgnLi9hZ2dyZWdhdGUvZ3JvdXBieScpLFxuICBoaXN0b2dyYW06IHJlcXVpcmUoJy4vYmlucy9oaXN0b2dyYW0nKS5oaXN0b2dyYW0sXG4gIHByaW50OiAgICAgcmVxdWlyZSgnLi9wcmludCcpLFxuICB0ZW1wbGF0ZTogIHJlcXVpcmUoJy4vdGVtcGxhdGUnKSxcbiAgdGltZXVuaXRzOiByZXF1aXJlKCcuL3RpbWUtdW5pdHMnKVxufTtcblxudXRpbC5leHRlbmQoZGwsIHV0aWwpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vZ2VuZXJhdGUnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9zdGF0cycpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2ltcG9ydC9yZWFkZXJzJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRsOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxudmFyIEZNVCA9IHtcbiAgJ2RhdGUnOiAgICAnfHRpbWU6XCIlbS8lZC8lWSAlSDolTTolU1wiJyxcbiAgJ251bWJlcic6ICAnfG51bWJlcjpcIi40ZlwiJyxcbiAgJ2ludGVnZXInOiAnfG51bWJlcjpcImRcIidcbn07XG5cbnZhciBQT1MgPSB7XG4gICdudW1iZXInOiAgJ2xlZnQnLFxuICAnaW50ZWdlcic6ICdsZWZ0J1xufTtcblxubW9kdWxlLmV4cG9ydHMudGFibGUgPSBmdW5jdGlvbihkYXRhLCBvcHQpIHtcbiAgb3B0ID0gdXRpbC5leHRlbmQoe3NlcGFyYXRvcjonICcsIG1pbndpZHRoOiA4LCBtYXh3aWR0aDogMTV9LCBvcHQpO1xuICB2YXIgZmllbGRzID0gb3B0LmZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSksXG4gICAgICB0eXBlcyA9IHR5cGUuYWxsKGRhdGEpO1xuXG4gIGlmIChvcHQuc3RhcnQgfHwgb3B0LmxpbWl0KSB7XG4gICAgdmFyIGEgPSBvcHQuc3RhcnQgfHwgMCxcbiAgICAgICAgYiA9IG9wdC5saW1pdCA/IGEgKyBvcHQubGltaXQgOiBkYXRhLmxlbmd0aDtcbiAgICBkYXRhID0gZGF0YS5zbGljZShhLCBiKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBjaGFyIHdpZHRoIG9mIGZpZWxkc1xuICB2YXIgbGVucyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmb3JtYXQgPSBGTVRbdHlwZXNbbmFtZV1dIHx8ICcnLFxuICAgICAgICB0ID0gdGVtcGxhdGUoJ3t7JyArIG5hbWUgKyBmb3JtYXQgKyAnfX0nKSxcbiAgICAgICAgbCA9IHN0YXRzLm1heChkYXRhLCBmdW5jdGlvbih4KSB7IHJldHVybiB0KHgpLmxlbmd0aDsgfSk7XG4gICAgbCA9IE1hdGgubWF4KE1hdGgubWluKG5hbWUubGVuZ3RoLCBvcHQubWlud2lkdGgpLCBsKTtcbiAgICByZXR1cm4gb3B0Lm1heHdpZHRoID4gMCA/IE1hdGgubWluKGwsIG9wdC5tYXh3aWR0aCkgOiBsO1xuICB9KTtcblxuICAvLyBwcmludCBoZWFkZXIgcm93XG4gIHZhciBoZWFkID0gZmllbGRzLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIHV0aWwudHJ1bmNhdGUodXRpbC5wYWQobmFtZSwgbGVuc1tpXSwgJ2NlbnRlcicpLCBsZW5zW2ldKTtcbiAgfSkuam9pbihvcHQuc2VwYXJhdG9yKTtcblxuICAvLyBidWlsZCB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgZWFjaCByb3dcbiAgdmFyIHRtcGwgPSB0ZW1wbGF0ZShmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gJ3t7JyArXG4gICAgICBuYW1lICtcbiAgICAgIChGTVRbdHlwZXNbbmFtZV1dIHx8ICcnKSArXG4gICAgICAoJ3xwYWQ6JyArIGxlbnNbaV0gKyAnLCcgKyBQT1NbdHlwZXNbbmFtZV1dIHx8ICdyaWdodCcpICtcbiAgICAgICgnfHRydW5jYXRlOicgKyBsZW5zW2ldKSArXG4gICAgJ319JztcbiAgfSkuam9pbihvcHQuc2VwYXJhdG9yKSk7XG5cbiAgLy8gcHJpbnQgdGFibGVcbiAgcmV0dXJuIGhlYWQgKyBcIlxcblwiICsgZGF0YS5tYXAodG1wbCkuam9pbignXFxuJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zdW1tYXJ5ID0gZnVuY3Rpb24ocykge1xuICBzID0gcyA/IHMuX19zdW1tYXJ5X18gPyBzIDogc3RhdHMuc3VtbWFyeShzKSA6IHRoaXM7XG4gIHZhciBzdHIgPSBbXSwgaSwgbjtcbiAgZm9yIChpPTAsIG49cy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RyLnB1c2goJy0tICcgKyBzW2ldLmZpZWxkICsgJyAtLScpO1xuICAgIGlmIChzW2ldLnR5cGUgPT09ICdzdHJpbmcnIHx8IHNbaV0uZGlzdGluY3QgPCAxMCkge1xuICAgICAgc3RyLnB1c2gocHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUoc1tpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIucHVzaChwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUoc1tpXSkpO1xuICAgIH1cbiAgICBzdHIucHVzaCgnJyk7XG4gIH1cbiAgcmV0dXJuIHN0ci5qb2luKCdcXG4nKTtcbn07XG5cbmZ1bmN0aW9uIHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShwKSB7XG4gIHJldHVybiBbXG4gICAgJ3ZhbGlkOiAgICAnICsgcC52YWxpZCxcbiAgICAnbWlzc2luZzogICcgKyBwLm1pc3NpbmcsXG4gICAgJ2Rpc3RpbmN0OiAnICsgcC5kaXN0aW5jdCxcbiAgICAnbWluOiAgICAgICcgKyBwLm1pbixcbiAgICAnbWF4OiAgICAgICcgKyBwLm1heCxcbiAgICAnbWVkaWFuOiAgICcgKyBwLm1lZGlhbixcbiAgICAnbWVhbjogICAgICcgKyBwLm1lYW4sXG4gICAgJ3N0ZGV2OiAgICAnICsgcC5zdGRldixcbiAgICAnbW9kZXNrZXc6ICcgKyBwLm1vZGVza2V3XG4gIF0uam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHApIHtcbiAgdmFyIGxpc3QgPSBbXG4gICAgJ3ZhbGlkOiAgICAnICsgcC52YWxpZCxcbiAgICAnbWlzc2luZzogICcgKyBwLm1pc3NpbmcsXG4gICAgJ2Rpc3RpbmN0OiAnICsgcC5kaXN0aW5jdCxcbiAgICAndG9wIHZhbHVlczogJ1xuICBdO1xuICB2YXIgdSA9IHAudW5pcXVlO1xuICB2YXIgdG9wID0gdXRpbC5rZXlzKHUpXG4gICAgLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiB1W2JdIC0gdVthXTsgfSlcbiAgICAuc2xpY2UoMCwgNilcbiAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuICcgXFwnJyArIHYgKyAnXFwnICgnICsgdVt2XSArICcpJzsgfSk7XG4gIHJldHVybiBsaXN0LmNvbmNhdCh0b3ApLmpvaW4oJ1xcbicpO1xufSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKTtcbnZhciBnZW4gPSByZXF1aXJlKCcuL2dlbmVyYXRlJyk7XG52YXIgc3RhdHMgPSB7fTtcblxuLy8gQ29sbGVjdCB1bmlxdWUgdmFsdWVzLlxuLy8gT3V0cHV0OiBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBmaXJzdC1vYnNlcnZlZCBvcmRlclxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBhcnJheS5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCB8fCAwO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBub24tbnVsbCwgbm9uLXVuZGVmaW5lZCwgbm9uLU5hTiB2YWx1ZXMuXG5zdGF0cy5jb3VudC52YWxpZCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgdmFsaWQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHZhbGlkICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5taXNzaW5nID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgPT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbi8vIE51bGwsIHVuZGVmaW5lZCBhbmQgTmFOIGFyZSBlYWNoIGNvbnNpZGVyZWQgZGlzdGluY3QgdmFsdWVzLlxuc3RhdHMuY291bnQuZGlzdGluY3QgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gZGlzdGluY3QgdmFsdWVzIHRvIG9jY3VycmVuY2UgY291bnRzLlxuc3RhdHMuY291bnQubWFwID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtYXAgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBtYXBbdl0gPSAodiBpbiBtYXApID8gbWFwW3ZdICsgMSA6IDE7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lZGlhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgcmV0dXJuIHN0YXRzLnF1YW50aWxlKHZhbHVlcywgMC41KTtcbn07XG5cbi8vIENvbXB1dGVzIHRoZSBxdWFydGlsZSBib3VuZGFyaWVzIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5xdWFydGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHZhciBxID0gc3RhdHMucXVhbnRpbGU7XG4gIHJldHVybiBbcSh2YWx1ZXMsIDAuMjUpLCBxKHZhbHVlcywgMC41MCksIHEodmFsdWVzLCAwLjc1KV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBxdWFudGlsZSBvZiBhIHNvcnRlZCBhcnJheSBvZiBudW1iZXJzLlxuLy8gQWRhcHRlZCBmcm9tIHRoZSBEMy5qcyBpbXBsZW1lbnRhdGlvbi5cbnN0YXRzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmLCBwKSB7XG4gIGlmIChwID09PSB1bmRlZmluZWQpIHsgcCA9IGY7IGYgPSB1dGlsLmlkZW50aXR5OyB9XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLFxuICAgICAgaCA9IE1hdGguZmxvb3IoSCksXG4gICAgICB2ID0gK2YodmFsdWVzW2ggLSAxXSksXG4gICAgICBlID0gSCAtIGg7XG4gIHJldHVybiBlID8gdiArIGUgKiAoZih2YWx1ZXNbaF0pIC0gdikgOiB2O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc3VtIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdW0gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgZm9yICh2YXIgc3VtPTAsIGk9MCwgbj12YWx1ZXMubGVuZ3RoLCB2OyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHN1bSArPSB2O1xuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWVhbiA9IDAsIGRlbHRhLCBpLCBuLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgdmFyaWFuY2Ugb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgbWVhbiA9IDAsIE0yID0gMCwgZGVsdGEsIGksIGMsIHY7XG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh2IC0gbWVhbik7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoYyAtIDEpO1xuICByZXR1cm4gTTI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdGRldiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHN0YXRzLnZhcmlhbmNlKHZhbHVlcywgZikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgUGVhcnNvbiBtb2RlIHNrZXduZXNzICgobWVkaWFuLW1lYW4pL3N0ZGV2KSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubW9kZXNrZXcgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGF2ZyA9IHN0YXRzLm1lYW4odmFsdWVzLCBmKSxcbiAgICAgIG1lZCA9IHN0YXRzLm1lZGlhbih2YWx1ZXMsIGYpLFxuICAgICAgc3RkID0gc3RhdHMuc3RkZXYodmFsdWVzLCBmKTtcbiAgcmV0dXJuIHN0ZCA9PT0gMCA/IDAgOiAoYXZnIC0gbWVkKSAvIHN0ZDtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5taW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzBdO1xufTtcblxuLy8gRmluZCB0aGUgbWF4aW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1heCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMV07XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG9mIGFuIGFycmF5IG9mIHZhbHVlcy5cbnN0YXRzLmV4dGVudCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHsgYSA9IGIgPSB2OyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGlmICh2IDwgYSkgYSA9IHY7XG4gICAgICBpZiAodiA+IGIpIGIgPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufTtcblxuLy8gRmluZCB0aGUgaW50ZWdlciBpbmRpY2VzIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcy5cbnN0YXRzLmV4dGVudC5pbmRleCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgeCA9IC0xLCB5ID0gLTEsIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgeCA9IHkgPSBpOyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGlmICh2IDwgYSkgeyBhID0gdjsgeCA9IGk7IH1cbiAgICAgIGlmICh2ID4gYikgeyBiID0gdjsgeSA9IGk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmRvdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgc3VtID0gMCwgaSwgdjtcbiAgaWYgKCFiKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXJyYXkgbGVuZ3RocyBtdXN0IG1hdGNoLicpO1xuICAgIH1cbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaV0gKiBhW2ldO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odikpIHN1bSArPSB2O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gYSh2YWx1ZXNbaV0pICogYih2YWx1ZXNbaV0pO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odikpIHN1bSArPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSBhc2NlbmRpbmcgcmFuayBzY29yZXMgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbi8vIFRpZXMgYXJlIGFzc2lnbmVkIHRoZWlyIGNvbGxlY3RpdmUgbWVhbiByYW5rLlxuc3RhdHMucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpIHx8IHV0aWwuaWRlbnRpdHk7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge2lkeDogaSwgdmFsOiBmKHYpfTtcbiAgICB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcigndmFsJykpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG4gIGEgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcztcblxuICB2YXIgZG90ID0gc3RhdHMuZG90KGEsIGIpLFxuICAgICAgbXVhID0gc3RhdHMubWVhbihhKSxcbiAgICAgIG11YiA9IHN0YXRzLm1lYW4oYiksXG4gICAgICBzZGEgPSBzdGF0cy5zdGRldihhKSxcbiAgICAgIHNkYiA9IHN0YXRzLnN0ZGV2KGIpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgcmV0dXJuIChkb3QgLSBuKm11YSptdWIpIC8gKChuLTEpICogc2RhICogc2RiKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNwZWFybWFuIHJhbmsgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiB2YWx1ZXMuXG5zdGF0cy5jb3IucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgcmEgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChhKSkgOiBzdGF0cy5yYW5rKHZhbHVlcyksXG4gICAgICByYiA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgdXRpbC4kKGIpKSA6IHN0YXRzLnJhbmsoYSksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgaSwgcywgZDtcblxuICBmb3IgKGk9MCwgcz0wOyBpPG47ICsraSkge1xuICAgIGQgPSByYVtpXSAtIHJiW2ldO1xuICAgIHMgKz0gZCAqIGQ7XG4gIH1cblxuICByZXR1cm4gMSAtIDYqcyAvIChuICogKG4qbi0xKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkaXN0YW5jZSBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2NvcnJlbGF0aW9uXG5zdGF0cy5jb3IuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgWCA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICBZID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG5cbiAgdmFyIEEgPSBzdGF0cy5kaXN0Lm1hdChYKSxcbiAgICAgIEIgPSBzdGF0cy5kaXN0Lm1hdChZKSxcbiAgICAgIG4gPSBBLmxlbmd0aCxcbiAgICAgIGksIGFhLCBiYiwgYWI7XG5cbiAgZm9yIChpPTAsIGFhPTAsIGJiPTAsIGFiPTA7IGk8bjsgKytpKSB7XG4gICAgYWEgKz0gQVtpXSpBW2ldO1xuICAgIGJiICs9IEJbaV0qQltpXTtcbiAgICBhYiArPSBBW2ldKkJbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGFiIC8gTWF0aC5zcXJ0KGFhKmJiKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSB2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBEZWZhdWx0IGlzIEV1Y2xpZGVhbiAoZXhwPTIpIGRpc3RhbmNlLCBjb25maWd1cmFibGUgdmlhIGV4cCBhcmd1bWVudC5cbnN0YXRzLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGV4cCkge1xuICB2YXIgZiA9IHV0aWwuaXNGdW5jdGlvbihiKSB8fCB1dGlsLmlzU3RyaW5nKGIpLFxuICAgICAgWCA9IHZhbHVlcyxcbiAgICAgIFkgPSBmID8gdmFsdWVzIDogYSxcbiAgICAgIGUgPSBmID8gZXhwIDogYixcbiAgICAgIEwyID0gZSA9PT0gMiB8fCBlID09IG51bGwsXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgcyA9IDAsIGQsIGk7XG4gIGlmIChmKSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICB9XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGQgPSBmID8gKGEoWFtpXSktYihZW2ldKSkgOiAoWFtpXS1ZW2ldKTtcbiAgICBzICs9IEwyID8gZCpkIDogTWF0aC5wb3coTWF0aC5hYnMoZCksIGUpO1xuICB9XG4gIHJldHVybiBMMiA/IE1hdGguc3FydChzKSA6IE1hdGgucG93KHMsIDEvZSk7XG59O1xuXG4vLyBDb25zdHJ1Y3QgYSBtZWFuLWNlbnRlcmVkIGRpc3RhbmNlIG1hdHJpeCBmb3IgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLmRpc3QubWF0ID0gZnVuY3Rpb24oWCkge1xuICB2YXIgbiA9IFgubGVuZ3RoLFxuICAgICAgbSA9IG4qbixcbiAgICAgIEEgPSBBcnJheShtKSxcbiAgICAgIFIgPSBnZW4uemVyb3MobiksXG4gICAgICBNID0gMCwgdiwgaSwgajtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBBW2kqbitpXSA9IDA7XG4gICAgZm9yIChqPWkrMTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdID0gKHYgPSBNYXRoLmFicyhYW2ldIC0gWFtqXSkpO1xuICAgICAgQVtqKm4raV0gPSB2O1xuICAgICAgUltpXSArPSB2O1xuICAgICAgUltqXSArPSB2O1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIE0gKz0gUltpXTtcbiAgICBSW2ldIC89IG47XG4gIH1cbiAgTSAvPSBtO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGZvciAoaj1pOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gKz0gTSAtIFJbaV0gLSBSW2pdO1xuICAgICAgQVtqKm4raV0gPSBBW2kqbitqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNoYW5ub24gZW50cm9weSAobG9nIGJhc2UgMikgb2YgYW4gYXJyYXkgb2YgY291bnRzLlxuc3RhdHMuZW50cm9weSA9IGZ1bmN0aW9uKGNvdW50cywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgcCwgcyA9IDAsIEggPSAwLCBuID0gY291bnRzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcyArPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSk7XG4gIH1cbiAgaWYgKHMgPT09IDApIHJldHVybiAwO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBwID0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pIC8gcztcbiAgICBpZiAocCkgSCArPSBwICogTWF0aC5sb2cocCk7XG4gIH1cbiAgcmV0dXJuIC1IIC8gTWF0aC5MTjI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZm9ybSBbTUksIE1JX2Rpc3RhbmNlXSBcbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXV0dWFsX2luZm9ybWF0aW9uXG5zdGF0cy5tdXR1YWwgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICB2YXIgeCA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIHkgPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgeiA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGNvdW50cykpIDogYjtcblxuICB2YXIgcHggPSB7fSxcbiAgICAgIHB5ID0ge30sXG4gICAgICBuID0gei5sZW5ndGgsXG4gICAgICBzID0gMCwgSSA9IDAsIEggPSAwLCBwLCB0LCBpO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dID0gMDtcbiAgICBweVt5W2ldXSA9IDA7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSArPSB6W2ldO1xuICAgIHB5W3lbaV1dICs9IHpbaV07XG4gICAgcyArPSB6W2ldO1xuICB9XG5cbiAgdCA9IDEgLyAocyAqIE1hdGguTE4yKTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYgKHpbaV0gPT09IDApIGNvbnRpbnVlO1xuICAgIHAgPSAocyAqIHpbaV0pIC8gKHB4W3hbaV1dICogcHlbeVtpXV0pO1xuICAgIEkgKz0geltpXSAqIHQgKiBNYXRoLmxvZyhwKTtcbiAgICBIICs9IHpbaV0gKiB0ICogTWF0aC5sb2coeltpXS9zKTtcbiAgfVxuXG4gIHJldHVybiBbSSwgMSArIEkvSF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuc3RhdHMubXV0dWFsLmluZm8gPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVswXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG5zdGF0cy5tdXR1YWwuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzFdO1xufTtcblxuLy8gQ29tcHV0ZSBhIHByb2ZpbGUgb2Ygc3VtbWFyeSBzdGF0aXN0aWNzIGZvciBhIHZhcmlhYmxlLlxuc3RhdHMucHJvZmlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgbWVhbiA9IDAsXG4gICAgICB2YWxpZCA9IDAsXG4gICAgICBtaXNzaW5nID0gMCxcbiAgICAgIGRpc3RpbmN0ID0gMCxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgTTIgPSAwLFxuICAgICAgdmFscyA9IFtdLFxuICAgICAgdSA9IHt9LCBkZWx0YSwgc2QsIGksIHYsIHg7XG5cbiAgLy8gY29tcHV0ZSBzdW1tYXJ5IHN0YXRzXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuXG4gICAgLy8gdXBkYXRlIHVuaXF1ZSB2YWx1ZXNcbiAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcblxuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICsrbWlzc2luZztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBpZiAobWluPT09bnVsbCB8fCB4IDwgbWluKSBtaW4gPSB4O1xuICAgICAgaWYgKG1heD09PW51bGwgfHwgeCA+IG1heCkgbWF4ID0geDtcbiAgICAgIGRlbHRhID0geCAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrdmFsaWQpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHggLSBtZWFuKTtcbiAgICAgIHZhbHMucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvICh2YWxpZCAtIDEpO1xuICBzZCA9IE1hdGguc3FydChNMik7XG5cbiAgLy8gc29ydCB2YWx1ZXMgZm9yIG1lZGlhbiBhbmQgaXFyXG4gIHZhbHMuc29ydCh1dGlsLmNtcCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAgICAgdHlwZSh2YWx1ZXMsIGYpLFxuICAgIHVuaXF1ZTogICB1LFxuICAgIGNvdW50OiAgICB2YWx1ZXMubGVuZ3RoLFxuICAgIHZhbGlkOiAgICB2YWxpZCxcbiAgICBtaXNzaW5nOiAgbWlzc2luZyxcbiAgICBkaXN0aW5jdDogZGlzdGluY3QsXG4gICAgbWluOiAgICAgIG1pbixcbiAgICBtYXg6ICAgICAgbWF4LFxuICAgIG1lYW46ICAgICBtZWFuLFxuICAgIHN0ZGV2OiAgICBzZCxcbiAgICBtZWRpYW46ICAgKHYgPSBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjUpKSxcbiAgICBxMTogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC4yNSksXG4gICAgcTM6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNzUpLFxuICAgIG1vZGVza2V3OiBzZCA9PT0gMCA/IDAgOiAobWVhbiAtIHYpIC8gc2RcbiAgfTtcbn07XG5cbi8vIENvbXB1dGUgcHJvZmlsZXMgZm9yIGFsbCB2YXJpYWJsZXMgaW4gYSBkYXRhIHNldC5cbnN0YXRzLnN1bW1hcnkgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgdmFyIHMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcCA9IHN0YXRzLnByb2ZpbGUoZGF0YSwgdXRpbC4kKGYpKTtcbiAgICByZXR1cm4gKHAuZmllbGQgPSBmLCBwKTtcbiAgfSk7XG4gIHJldHVybiAocy5fX3N1bW1hcnlfXyA9IHRydWUsIHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGF0czsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCk7XG5cbnZhciBjb250ZXh0ID0ge1xuICBmb3JtYXRzOiAgICBbXSxcbiAgZm9ybWF0X21hcDoge30sXG4gIHRydW5jYXRlOiAgIHV0aWwudHJ1bmNhdGUsXG4gIHBhZDogICAgICAgIHV0aWwucGFkXG59O1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0KSB7XG4gIHZhciBzcmMgPSBzb3VyY2UodGV4dCwgJ2QnKTtcbiAgc3JjID0gJ3ZhciBfX3Q7IHJldHVybiAnICsgc3JjICsgJzsnO1xuXG4gIHRyeSB7XG4gICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbignZCcsIHNyYykpLmJpbmQoY29udGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLnNvdXJjZSA9IHNyYztcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbnRlbXBsYXRlLnNvdXJjZSA9IHNvdXJjZTtcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbi8vIGNsZWFyIGNhY2hlIG9mIGZvcm1hdCBvYmplY3RzXG4vLyBjYW4gKmJyZWFrKiBwcmlvciB0ZW1wbGF0ZSBmdW5jdGlvbnMsIHNvIGludm9rZSB3aXRoIGNhcmVcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuZnVuY3Rpb24gc291cmNlKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhcmlhYmxlID0gdmFyaWFibGUgfHwgJ29iaic7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBzcmMgPSAnXFwnJztcbiAgdmFyIHJlZ2V4ID0gdGVtcGxhdGVfcmU7XG5cbiAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgdGV4dC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihtYXRjaCwgaW50ZXJwb2xhdGUsIG9mZnNldCkge1xuICAgIHNyYyArPSB0ZXh0XG4gICAgICAuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICAgIC5yZXBsYWNlKHRlbXBsYXRlX2VzY2FwZXIsIHRlbXBsYXRlX2VzY2FwZUNoYXIpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBzcmMgKz0gJ1xcJ1xcbisoKF9fdD0oJyArXG4gICAgICAgIHRlbXBsYXRlX3ZhcihpbnRlcnBvbGF0ZSwgdmFyaWFibGUpICtcbiAgICAgICAgJykpPT1udWxsP1xcJ1xcJzpfX3QpK1xcblxcJyc7XG4gICAgfVxuXG4gICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG4gIHJldHVybiBzcmMgKyAnXFwnJztcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfdmFyKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhciBmaWx0ZXJzID0gdGV4dC5zcGxpdCgnfCcpO1xuICB2YXIgcHJvcCA9IGZpbHRlcnMuc2hpZnQoKS50cmltKCk7XG4gIHZhciBzdHJpbmdDYXN0ID0gdHJ1ZTtcbiAgXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8ICcnO1xuICAgIGlmIChzdHJpbmdDYXN0KSB7XG4gICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICBzcmMgPSAnU3RyaW5nKCcgKyBzcmMgKyAnKScgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIFxuICBmdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiAnKHR5cGVvZiAnICsgc3JjICsgJz09PVwibnVtYmVyXCI/bmV3IERhdGUoJytzcmMrJyk6JytzcmMrJyknO1xuICB9XG4gIFxuICB2YXIgc3JjID0gdXRpbC5maWVsZChwcm9wKS5tYXAodXRpbC5zdHIpLmpvaW4oJ11bJyk7XG4gIHNyYyA9IHZhcmlhYmxlICsgJ1snICsgc3JjICsgJ10nO1xuICBcbiAgZm9yICh2YXIgaT0wOyBpPGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IGZpbHRlcnNbaV0sIGFyZ3MgPSBudWxsLCBwaWR4LCBhLCBiO1xuXG4gICAgaWYgKChwaWR4PWYuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgIGYgPSBmLnNsaWNlKDAsIHBpZHgpO1xuICAgICAgYXJncyA9IGZpbHRlcnNbaV0uc2xpY2UocGlkeCsxKS5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH0pO1xuICAgIH1cbiAgICBmID0gZi50cmltKCk7XG5cbiAgICBzd2l0Y2ggKGYpIHtcbiAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgIHN0cmNhbGwoJy5sZW5ndGgnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9VcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZUxvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cmltJzpcbiAgICAgICAgc3RyY2FsbCgnLnRyaW0oKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgwLCcgKyBhICsgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKC0nICsgYSArJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhICsgdXRpbC5udW1iZXIoYXJnc1sxXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgrJythKycsJytiKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2xpY2UnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgnKyBhICtcbiAgICAgICAgICAoYXJncy5sZW5ndGggPiAxID8gJywnICsgdXRpbC5udW1iZXIoYXJnc1sxXSkgOiAnJykgK1xuICAgICAgICAgICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT0nbGVmdCcgJiYgYiE9PSdtaWRkbGUnICYmIGIhPT0nY2VudGVyJykgPyAncmlnaHQnIDogYjtcbiAgICAgICAgc3JjID0gJ3RoaXMudHJ1bmNhdGUoJyArIHN0cmNhbGwoKSArICcsJyArIGEgKyAnLFxcJycgKyBiICsgJ1xcJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhZCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGFyZ3NbMV07XG4gICAgICAgIGIgPSAoYiE9PSdsZWZ0JyAmJiBiIT09J21pZGRsZScgJiYgYiE9PSdjZW50ZXInKSA/ICdyaWdodCcgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy5wYWQoJyArIHN0cmNhbGwoKSArICcsJyArIGEgKyAnLFxcJycgKyBiICsgJ1xcJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMuZm9ybWF0KTtcbiAgICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK3NyYysnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMudGltZS5mb3JtYXQpO1xuICAgICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrZGF0ZSgpKycpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIHRlbXBsYXRlIGZpbHRlcjogJyArIGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcmM7XG59XG5cbnZhciB0ZW1wbGF0ZV9yZSA9IC9cXHtcXHsoLis/KVxcfVxcfXwkL2c7XG5cbi8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4vLyBzdHJpbmcgbGl0ZXJhbC5cbnZhciB0ZW1wbGF0ZV9lc2NhcGVzID0ge1xuICAnXFwnJzogICAgICdcXCcnLFxuICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICdcXHInOiAgICAgJ3InLFxuICAnXFxuJzogICAgICduJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbnZhciB0ZW1wbGF0ZV9lc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZV9lc2NhcGVDaGFyKG1hdGNoKSB7XG4gIHJldHVybiAnXFxcXCcgKyB0ZW1wbGF0ZV9lc2NhcGVzW21hdGNoXTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfZm9ybWF0KHBhdHRlcm4sIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcXCcnKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gPT09ICdcIicgICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcIicpKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKCdGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogJyArIHBhdHRlcm4pO1xuICB9XG4gIGlmICghY29udGV4dC5mb3JtYXRfbWFwW3BhdHRlcm5dKSB7XG4gICAgdmFyIGYgPSBmbXQocGF0dGVybik7XG4gICAgdmFyIGkgPSBjb250ZXh0LmZvcm1hdHMubGVuZ3RoO1xuICAgIGNvbnRleHQuZm9ybWF0cy5wdXNoKGYpO1xuICAgIGNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSA9IGk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXTtcbn1cbiIsInZhciBTVEVQUyA9IFtcbiAgWzMxNTM2ZTYsIDVdLCAgLy8gMS15ZWFyXG4gIFs3Nzc2ZTYsIDRdLCAgIC8vIDMtbW9udGhcbiAgWzI1OTJlNiwgNF0sICAgLy8gMS1tb250aFxuICBbMTIwOTZlNSwgM10sICAvLyAyLXdlZWtcbiAgWzYwNDhlNSwgM10sICAgLy8gMS13ZWVrXG4gIFsxNzI4ZTUsIDNdLCAgIC8vIDItZGF5XG4gIFs4NjRlNSwgM10sICAgIC8vIDEtZGF5XG4gIFs0MzJlNSwgMl0sICAgIC8vIDEyLWhvdXJcbiAgWzIxNmU1LCAyXSwgICAgLy8gNi1ob3VyXG4gIFsxMDhlNSwgMl0sICAgIC8vIDMtaG91clxuICBbMzZlNSwgMl0sICAgICAvLyAxLWhvdXJcbiAgWzE4ZTUsIDFdLCAgICAgLy8gMzAtbWludXRlXG4gIFs5ZTUsIDFdLCAgICAgIC8vIDE1LW1pbnV0ZVxuICBbM2U1LCAxXSwgICAgICAvLyA1LW1pbnV0ZVxuICBbNmU0LCAxXSwgICAgICAvLyAxLW1pbnV0ZVxuICBbM2U0LCAwXSwgICAgICAvLyAzMC1zZWNvbmRcbiAgWzE1ZTMsIDBdLCAgICAgLy8gMTUtc2Vjb25kXG4gIFs1ZTMsIDBdLCAgICAgIC8vIDUtc2Vjb25kXG4gIFsxZTMsIDBdICAgICAgIC8vIDEtc2Vjb25kXG5dO1xuXG5mdW5jdGlvbiBpc051bWJlcihkKSB7IHJldHVybiB0eXBlb2YgZCA9PT0gJ251bWJlcic7IH1cblxudmFyIGVudHJpZXMgPSBbXG4gIHtcbiAgICB0eXBlOiAnc2Vjb25kJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogJyVZICViICUtZCAlSDolTTolUy4lTCcsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiAxZTMpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuICgrZCAvIDFlMyk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ21pbnV0ZScsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWSAlYiAlLWQgJUg6JU0nLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogNmU0KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDZlNCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ2hvdXInLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kICVIOjAwJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDM2ZTUpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gMzZlNSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ2RheScsXG4gICAgbWluc3RlcDogMSxcbiAgICBzdGVwOiBbMSwgN10sXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDg2NGU1KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDg2NGU1KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnbW9udGgnLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgc3RlcDogWzEsIDMsIDZdLFxuICAgIGZvcm1hdDogJyViICVZJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMofn4oZCAvIDEyKSwgZCAlIDEyLCAxKSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoZCkpIGQgPSBuZXcgRGF0ZShkKTtcbiAgICAgIHJldHVybiAxMiAqIGQuZ2V0VVRDRnVsbFllYXIoKSArIGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAneWVhcicsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWScsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQsIDAsIDEpKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgfVxuICB9XG5dO1xuXG52YXIgbWludXRlT2ZIb3VyID0ge1xuICB0eXBlOiAnbWludXRlT2ZIb3VyJyxcbiAgbWluOiAwLFxuICBtYXg6IDU5LFxuICBtaW5zdGVwOiAxLFxuICBmb3JtYXQ6ICclTScsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDTWludXRlcygpO1xuICB9XG59O1xuXG52YXIgaG91ck9mRGF5ID0ge1xuICB0eXBlOiAnaG91ck9mRGF5JyxcbiAgbWluOiAwLFxuICBtYXg6IDIzLFxuICBtaW5zdGVwOiAxLFxuICBmb3JtYXQ6ICclSCcsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDSG91cnMoKTtcbiAgfVxufTtcblxudmFyIGRheU9mV2VlayA9IHtcbiAgdHlwZTogJ2RheU9mV2VlaycsXG4gIG1pbjogMCxcbiAgbWF4OiA2LFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogJyVhJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCA0ICsgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRGF5KCk7XG4gIH1cbn07XG5cbnZhciBkYXlPZk1vbnRoID0ge1xuICB0eXBlOiAnZGF5T2ZNb250aCcsXG4gIG1pbjogMSxcbiAgbWF4OiAzMSxcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6ICclLWQnLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0RhdGUoKTtcbiAgfVxufTtcblxudmFyIG1vbnRoT2ZZZWFyID0ge1xuICB0eXBlOiAnbW9udGhPZlllYXInLFxuICBtaW46IDAsXG4gIG1heDogMTEsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiAnJWInLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIGQgJSAxMiwgMSkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDTW9udGgoKTtcbiAgfVxufTtcblxudmFyIHVuaXRzID0ge1xuICAnc2Vjb25kJzogICAgICAgZW50cmllc1swXSxcbiAgJ21pbnV0ZSc6ICAgICAgIGVudHJpZXNbMV0sXG4gICdob3VyJzogICAgICAgICBlbnRyaWVzWzJdLFxuICAnZGF5JzogICAgICAgICAgZW50cmllc1szXSxcbiAgJ21vbnRoJzogICAgICAgIGVudHJpZXNbNF0sXG4gICd5ZWFyJzogICAgICAgICBlbnRyaWVzWzVdLFxuICAnbWludXRlT2ZIb3VyJzogbWludXRlT2ZIb3VyLFxuICAnaG91ck9mRGF5JzogICAgaG91ck9mRGF5LFxuICAnZGF5T2ZXZWVrJzogICAgZGF5T2ZXZWVrLFxuICAnZGF5T2ZNb250aCc6ICAgZGF5T2ZNb250aCxcbiAgJ21vbnRoT2ZZZWFyJzogIG1vbnRoT2ZZZWFyLFxuICAndGltZXN0ZXBzJzogICAgZW50cmllc1xufTtcblxudW5pdHMuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIGksIGxlbiwgYmlucywgc3RlcCA9IFNURVBTWzBdO1xuXG4gIGZvciAoaSA9IDEsIGxlbiA9IFNURVBTLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW1NURVBTW2kgLSAxXVsxXV07XG4gICAgICB9XG4gICAgICBpZiAoYmlucyA+PSBtaW5iKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZW50cmllc1tTVEVQU1tTVEVQUy5sZW5ndGggLSAxXVsxXV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXRzO1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1bml0cyA9IHJlcXVpcmUoJy4vdGltZS11bml0cycpO1xudmFyIHUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyB3aGVyZSBhcmUgd2U/XG5cbnUuaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgIHR5cGVvZiBwcm9jZXNzLnN0ZGVyciAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnZhciBGTkFNRSA9ICdfX25hbWVfXyc7XG5cbnUubmFtZWRmdW5jID0gZnVuY3Rpb24obmFtZSwgZikgeyByZXR1cm4gKGZbRk5BTUVdID0gbmFtZSwgZik7IH07XG5cbnUubmFtZSA9IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGY9PW51bGwgPyBudWxsIDogZltGTkFNRV07IH07XG5cbnUuaWRlbnRpdHkgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuXG51LnRydWUgPSB1Lm5hbWVkZnVuYygndHJ1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cbnUuZmFsc2UgPSB1Lm5hbWVkZnVuYygnZmFsc2UnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51Lmxlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiB4Lmxlbmd0aCAhPSBudWxsID8geC5sZW5ndGggOiBudWxsO1xufTtcblxudS5rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5cyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkga2V5cy5wdXNoKGspO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnUudmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHZhbHMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIHZhbHMucHVzaCh4W2tdKTtcbiAgcmV0dXJuIHZhbHM7XG59O1xuXG51LnRvTWFwID0gZnVuY3Rpb24obGlzdCwgZikge1xuICByZXR1cm4gKGYgPSB1LiQoZikpID9cbiAgICBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHsgcmV0dXJuIChvYmpbZih4KV0gPSAxLCBvYmopOyB9LCB7fSkgOlxuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7IH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGlmICghbikgcmV0dXJuICcnO1xuICBmb3IgKHZhciBzPVN0cmluZyh2YWx1ZXNbMF0pLCBpPTE7IGk8bjsgKytpKSB7XG4gICAgcyArPSAnfCcgKyBTdHJpbmcodmFsdWVzW2ldKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnUuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnUuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG51LmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxudS5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG59O1xuXG51LmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzVmFsaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICFOdW1iZXIuaXNOYU4ob2JqKTtcbn07XG5cbnUuaXNCdWZmZXIgPSAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogK3M7XG59O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhcztcbn07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBEYXRlLnBhcnNlKHMpO1xufTtcblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudS5zdHIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB1LmlzQXJyYXkoeCkgPyAnWycgKyB4Lm1hcCh1LnN0cikgKyAnXSdcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/ICgnXFwnJyt1dGlsX2VzY2FwZV9zdHIoeCkrJ1xcJycpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsICckMVxcXFxcXCcnKTtcbn1cblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBTdHJpbmcoZikuc3BsaXQoJ1xcXFwuJylcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoJy4nKTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCkgeyBhW2EubGVuZ3RoLTFdICs9ICcuJyArIGIuc2hpZnQoKTsgfVxuICAgICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgW10pO1xufTtcblxudS5hY2Nlc3NvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiBmPT1udWxsIHx8IHUuaXNGdW5jdGlvbihmKSA/IGYgOlxuICAgIHUubmFtZWRmdW5jKGYsIChzID0gdS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBzLnJlZHVjZShmdW5jdGlvbih4LGYpIHsgcmV0dXJuIHhbZl07IH0sIHgpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZl07IH1cbiAgICApO1xufTtcblxudS4kID0gdS5hY2Nlc3NvcjtcblxudS5tdXRhdG9yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgZnVuY3Rpb24oeCwgdikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICB4W3NbaV1dID0gdjtcbiAgICB9IDpcbiAgICBmdW5jdGlvbih4LCB2KSB7IHhbZl0gPSB2OyB9O1xufTtcblxudS4kZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgZiA9IHUuJChmKSB8fCB1LmlkZW50aXR5O1xuICAgIHZhciBuID0gbmFtZSArICh1Lm5hbWUoZikgPyAnXycrdS5uYW1lKGYpIDogJycpO1xuICAgIHJldHVybiB1Lm5hbWVkZnVuYyhuLCBmdW5jdGlvbihkKSB7IHJldHVybiBvcChmKGQpKTsgfSk7XG4gIH07XG59O1xuXG51LiR2YWxpZCAgPSB1LiRmdW5jKCd2YWxpZCcsIHUuaXNWYWxpZCk7XG51LiRsZW5ndGggPSB1LiRmdW5jKCdsZW5ndGgnLCB1Lmxlbmd0aCk7XG51LiR5ZWFyICAgPSB1LiRmdW5jKCd5ZWFyJywgdW5pdHMueWVhci51bml0KTtcbnUuJG1vbnRoICA9IHUuJGZ1bmMoJ21vbnRoJywgdW5pdHMubW9udGhPZlllYXIudW5pdCk7XG51LiRkYXRlICAgPSB1LiRmdW5jKCdkYXRlJywgdW5pdHMuZGF5T2ZNb250aC51bml0KTtcbnUuJGRheSAgICA9IHUuJGZ1bmMoJ2RheScsIHVuaXRzLmRheU9mV2Vlay51bml0KTtcbnUuJGhvdXIgICA9IHUuJGZ1bmMoJ2hvdXInLCB1bml0cy5ob3VyT2ZEYXkudW5pdCk7XG51LiRtaW51dGUgPSB1LiRmdW5jKCdtaW51dGUnLCB1bml0cy5taW51dGVPZkhvdXIudW5pdCk7XG5cbnUuJGluID0gZnVuY3Rpb24oZiwgdmFsdWVzKSB7XG4gIGYgPSB1LiQoZik7XG4gIHZhciBtYXAgPSB1LmlzQXJyYXkodmFsdWVzKSA/IHUudG9NYXAodmFsdWVzKSA6IHZhbHVlcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhbWFwW2YoZCldOyB9O1xufTtcblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSAnLScpIHsgcyA9IC0xOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIGVsc2UgaWYgKGZbMF0gPT09ICcrJykgeyBzID0gKzE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgc2lnbi5wdXNoKHMpO1xuICAgIHJldHVybiB1LmFjY2Vzc29yKGYpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBpLCBuLCBmLCB4LCB5O1xuICAgIGZvciAoaT0wLCBuPXNvcnQubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZiA9IHNvcnRbaV07IHggPSBmKGEpOyB5ID0gZihiKTtcbiAgICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xICogc2lnbltpXTtcbiAgICAgIGlmICh4ID4geSkgcmV0dXJuIHNpZ25baV07XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufTtcblxudS5jbXAgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGEgPj0gYikge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBOYU47XG59O1xuXG51Lm51bWNtcCA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuXG51LnN0YWJsZXNvcnQgPSBmdW5jdGlvbihhcnJheSwgc29ydEJ5LCBrZXlGbikge1xuICB2YXIgaW5kaWNlcyA9IGFycmF5LnJlZHVjZShmdW5jdGlvbihpZHgsIHYsIGkpIHtcbiAgICByZXR1cm4gKGlkeFtrZXlGbih2KV0gPSBpLCBpZHgpO1xuICB9LCB7fSk7XG5cbiAgYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHNhID0gc29ydEJ5KGEpLFxuICAgICAgICBzYiA9IHNvcnRCeShiKTtcbiAgICByZXR1cm4gc2EgPCBzYiA/IC0xIDogc2EgPiBzYiA/IDFcbiAgICAgICAgIDogKGluZGljZXNba2V5Rm4oYSldIC0gaW5kaWNlc1trZXlGbihiKV0pO1xuICB9KTtcblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8vIHN0cmluZyBmdW5jdGlvbnNcblxuLy8gRVM2IGNvbXBhdGliaWxpdHkgcGVyIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoI1BvbHlmaWxsXG4vLyBXZSBjb3VsZCBoYXZlIHVzZWQgdGhlIHBvbHlmaWxsIGNvZGUsIGJ1dCBsZXRzIHdhaXQgdW50aWwgRVM2IGJlY29tZXMgYSBzdGFuZGFyZCBmaXJzdFxudS5zdGFydHNXaXRoID0gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID9cbiAgZnVuY3Rpb24oc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcbiAgfSA6XG4gIGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcsIDApID09PSAwO1xuICB9O1xuXG51LnBhZCA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCBwYWRjaGFyKSB7XG4gIHBhZGNoYXIgPSBwYWRjaGFyIHx8IFwiIFwiO1xuICB2YXIgZCA9IGxlbmd0aCAtIHMubGVuZ3RoO1xuICBpZiAoZCA8PSAwKSByZXR1cm4gcztcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBzdHJyZXAoZCwgcGFkY2hhcikgKyBzO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHJldHVybiBzdHJyZXAoTWF0aC5mbG9vcihkLzIpLCBwYWRjaGFyKSArXG4gICAgICAgICBzICsgc3RycmVwKE1hdGguY2VpbChkLzIpLCBwYWRjaGFyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHMgKyBzdHJyZXAoZCwgcGFkY2hhcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cnJlcChuLCBzdHIpIHtcbiAgdmFyIHMgPSBcIlwiLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHMgKz0gc3RyO1xuICByZXR1cm4gcztcbn1cblxudS50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVsbGlwc2lzKSA6ICdcXHUyMDI2JztcbiAgdmFyIGwgPSBNYXRoLm1heCgwLCBsZW5ndGggLSBlbGxpcHNpcy5sZW5ndGgpO1xuXG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCwxKSA6IHMuc2xpY2UobGVuLWwpKTtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB2YXIgbDEgPSBNYXRoLmNlaWwobC8yKSwgbDIgPSBNYXRoLmZsb29yKGwvMik7XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwxKSA6IHMuc2xpY2UoMCxsMSkpICtcbiAgICAgICAgZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDIsMSkgOiBzLnNsaWNlKGxlbi1sMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwpIDogcy5zbGljZSgwLGwpKSArIGVsbGlwc2lzO1xuICB9XG59O1xuXG5mdW5jdGlvbiB0cnVuY2F0ZU9uV29yZChzLCBsZW4sIHJldikge1xuICB2YXIgY250ID0gMCwgdG9rID0gcy5zcGxpdCh0cnVuY2F0ZV93b3JkX3JlKTtcbiAgaWYgKHJldikge1xuICAgIHMgPSAodG9rID0gdG9rLnJldmVyc2UoKSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KVxuICAgICAgLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBzID0gdG9rLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pO1xuICB9XG4gIHJldHVybiBzLmxlbmd0aCA/IHMuam9pbignJykudHJpbSgpIDogdG9rWzBdLnNsaWNlKDAsIGxlbik7XG59XG5cbnZhciB0cnVuY2F0ZV93b3JkX3JlID0gLyhbXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTIwMjhcXHUyMDI5XFx1MzAwMFxcdUZFRkZdKS87XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvaW5kZXgnKSxcbiAgICBzdmcgPSByZXF1aXJlKCcuLi9yZW5kZXIvc3ZnLWhlYWRsZXNzL2luZGV4JyksXG4gICAgVmlldyA9IHJlcXVpcmUoJy4vVmlldycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG52YXIgSGVhZGxlc3NWaWV3ID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgbW9kZWwpIHtcbiAgVmlldy5jYWxsKG51bGwsIHdpZHRoLCBoZWlnaHQsIG1vZGVsKTtcbiAgdGhpcy5fZWwgPSBcImJvZHlcIjtcbiAgdGhpcy5fdHlwZSA9IFwiY2FudmFzXCI7XG4gIHRoaXMuX3JlbmRlcmVycyA9IHtjYW52YXM6IGNhbnZhcywgc3ZnOiBzdmd9O1xuICB0aGlzLl9jYW52YXMgPSBudWxsO1xufVxuXG52YXIgcHJvdG90eXBlID0gKEhlYWRsZXNzVmlldy5wcm90b3R5cGUgPSBuZXcgVmlldygpKTtcblxucHJvdG90eXBlLnJlbmRlcmVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZih0eXBlKSB0aGlzLl90eXBlID0gdHlwZTtcbiAgcmV0dXJuIFZpZXcucHJvdG90eXBlLnJlbmRlcmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXM7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzQXN5bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgciA9IHRoaXMuX3JlbmRlcmVyLCB2aWV3ID0gdGhpcztcbiAgXG4gIGZ1bmN0aW9uIHdhaXQoKSB7XG4gICAgaWYgKHIucGVuZGluZ0ltYWdlcygpID09PSAwKSB7XG4gICAgICB2aWV3LnJlbmRlcigpOyAvLyByZS1yZW5kZXIgd2l0aCBhbGwgaW1hZ2VzXG4gICAgICBjYWxsYmFjayh2aWV3Ll9jYW52YXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHdhaXQsIDEwKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBpbWFnZXMgbG9hZGluZywgcG9sbCB1bnRpbCByZWFkeVxuICAoci5wZW5kaW5nSW1hZ2VzKCkgPiAwKSA/IHdhaXQoKSA6IGNhbGxiYWNrKHRoaXMuX2NhbnZhcyk7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fdHlwZSA9PT0gXCJzdmdcIilcbiAgICA/IHRoaXMuX3JlbmRlcmVyLnN2ZygpXG4gICAgOiBudWxsO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpIHsgICAgXG4gIHZhciB3ID0gdGhpcy5fd2lkdGgsXG4gICAgICBoID0gdGhpcy5faGVpZ2h0LFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZztcblxuICBpZiAodGhpcy5fdmlld3BvcnQpIHtcbiAgICB3ID0gdGhpcy5fdmlld3BvcnRbMF0gLSAocGFkID8gcGFkLmxlZnQgKyBwYWQucmlnaHQgOiAwKTtcbiAgICBoID0gdGhpcy5fdmlld3BvcnRbMV0gLSAocGFkID8gcGFkLnRvcCArIHBhZC5ib3R0b20gOiAwKTtcbiAgfVxuXG4gIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXIgfHwgbmV3IHRoaXMuX2lvLlJlbmRlcmVyKCk7XG4gIFxuICBpZiAodGhpcy5fdHlwZSA9PT0gXCJzdmdcIikge1xuICAgIHRoaXMuaW5pdFNWRyh3LCBoLCBwYWQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaW5pdENhbnZhcyh3LCBoLCBwYWQpO1xuICB9XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5pbml0Q2FudmFzID0gZnVuY3Rpb24odywgaCwgcGFkKSB7XG4gIHZhciBDYW52YXMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5jYW52YXMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmNhbnZhcyA6IG51bGwpLFxuICAgICAgdHcgPSB3ICsgcGFkLmxlZnQgKyBwYWQucmlnaHQsXG4gICAgICB0aCA9IGggKyBwYWQudG9wICsgcGFkLmJvdHRvbSxcbiAgICAgIGNhbnZhcyA9IHRoaXMuX2NhbnZhcyA9IGRsLmlzTm9kZSA/IG5ldyBDYW52YXModHcsIHRoKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICBpZighZGwuaXNOb2RlKSB7ICAvLyBNYW51YWxseSBzZXQgd2lkdGgvaGVpZ2h0IG9uIERPTSBlbGVtZW50c1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0dyk7XG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aCk7XG4gIH1cbiAgXG4gIC8vIHNldHVwIGNhbnZhcyBjb250ZXh0XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgcGFkLmxlZnQsIHBhZC50b3ApO1xuXG4gIC8vIGNvbmZpZ3VyZSByZW5kZXJlclxuICB0aGlzLl9yZW5kZXJlci5jb250ZXh0KGN0eCk7XG4gIHRoaXMuX3JlbmRlcmVyLnJlc2l6ZSh3LCBoLCBwYWQpO1xufTtcblxucHJvdG90eXBlLmluaXRTVkcgPSBmdW5jdGlvbih3LCBoLCBwYWQpIHtcbiAgLy8gY29uZmlndXJlIHJlbmRlcmVyXG4gIHRoaXMuX3JlbmRlcmVyLmluaXRpYWxpemUodGhpcy5fZWwsIHcsIGgsIHBhZCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlYWRsZXNzVmlldztcbiIsInZhciBHcmFwaCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0dyYXBoJyksIFxuICAgIE5vZGUgID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEdyb3VwQnVpbGRlciA9IHJlcXVpcmUoJy4uL3NjZW5lL0dyb3VwQnVpbGRlcicpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLCBcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxuZnVuY3Rpb24gTW9kZWwoKSB7XG4gIHRoaXMuX2RlZnMgPSB7fTtcbiAgdGhpcy5fcHJlZGljYXRlcyA9IHt9O1xuICB0aGlzLl9zY2VuZSA9IG51bGw7XG5cbiAgdGhpcy5fbm9kZSA9IG51bGw7XG4gIHRoaXMuX2J1aWxkZXIgPSBudWxsOyAvLyBUb3AtbGV2ZWwgc2NlbmVncmFwaCBidWlsZGVyXG5cbiAgR3JhcGgucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbn07XG5cbnZhciBwcm90byA9IChNb2RlbC5wcm90b3R5cGUgPSBuZXcgR3JhcGgoKSk7XG5cbnByb3RvLmRlZnMgPSBmdW5jdGlvbihkZWZzKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2RlZnM7XG4gIHRoaXMuX2RlZnMgPSBkZWZzO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm5vZGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGUgfHwgKHRoaXMuX25vZGUgPSBuZXcgTm9kZSh0aGlzKSk7XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gR3JhcGgucHJvdG90eXBlLmRhdGEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsgIC8vIG5ldyBEYXRhc291cmNlXG4gICAgdGhpcy5ub2RlKCkuYWRkTGlzdGVuZXIoZGF0YS5waXBlbGluZSgpWzBdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuZnVuY3Rpb24gcHJlZGljYXRlcyhuYW1lKSB7XG4gIHZhciBtID0gdGhpcywgcHJlZGljYXRlcyA9IHt9O1xuICBpZighZGwuaXNBcnJheShuYW1lKSkgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZXNbbmFtZV07XG4gIG5hbWUuZm9yRWFjaChmdW5jdGlvbihuKSB7IHByZWRpY2F0ZXNbbl0gPSBtLl9wcmVkaWNhdGVzW25dIH0pO1xuICByZXR1cm4gcHJlZGljYXRlcztcbn1cblxucHJvdG8ucHJlZGljYXRlID0gZnVuY3Rpb24obmFtZSwgcHJlZGljYXRlKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwcmVkaWNhdGVzLmNhbGwodGhpcywgbmFtZSk7XG4gIHJldHVybiAodGhpcy5fcHJlZGljYXRlc1tuYW1lXSA9IHByZWRpY2F0ZSk7XG59O1xuXG5wcm90by5wcmVkaWNhdGVzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcmVkaWNhdGVzOyB9O1xuXG5wcm90by5zY2VuZSA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2NlbmU7XG4gIGlmKHRoaXMuX2J1aWxkZXIpIHRoaXMubm9kZSgpLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2J1aWxkZXIuZGlzY29ubmVjdCgpKTtcbiAgdGhpcy5fYnVpbGRlciA9IG5ldyBHcm91cEJ1aWxkZXIodGhpcywgdGhpcy5fZGVmcy5tYXJrcywgdGhpcy5fc2NlbmU9e30pO1xuICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcih0aGlzLl9idWlsZGVyLmNvbm5lY3QoKSk7XG4gIHZhciBwID0gdGhpcy5fYnVpbGRlci5waXBlbGluZSgpO1xuICBwW3AubGVuZ3RoLTFdLmFkZExpc3RlbmVyKHJlbmRlcmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHsgdGhpcy5ub2RlKCkuYWRkTGlzdGVuZXIobCk7IH07XG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHsgdGhpcy5ub2RlKCkucmVtb3ZlTGlzdGVuZXIobCk7IH07XG5cbnByb3RvLmZpcmUgPSBmdW5jdGlvbihjcykge1xuICBpZighY3MpIGNzID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuICB0aGlzLnByb3BhZ2F0ZShjcywgdGhpcy5ub2RlKCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb2RlbDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIHBhcnNlU3RyZWFtcyA9IHJlcXVpcmUoJy4uL3BhcnNlL3N0cmVhbXMnKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvY2FudmFzL2luZGV4JyksXG4gICAgc3ZnID0gcmVxdWlyZSgnLi4vcmVuZGVyL3N2Zy9pbmRleCcpLFxuICAgIEVuY29kZXIgPSByZXF1aXJlKCcuLi9zY2VuZS9FbmNvZGVyJyksXG4gICAgVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL3NjZW5lL1RyYW5zaXRpb24nKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpO1xuXG52YXIgVmlldyA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBtb2RlbCkge1xuICB0aGlzLl9lbCAgICA9IG51bGw7XG4gIHRoaXMuX21vZGVsID0gbnVsbDtcbiAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aCB8fCA1MDA7XG4gIHRoaXMuX2hlaWdodCAgPSB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0IHx8IDMwMDtcbiAgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIHRoaXMuX3BhZGRpbmcgPSB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XG4gIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlciAgPSBudWxsO1xuICB0aGlzLl9zdHJlYW1lciA9IG51bGw7IC8vIFRhcmdldGVkIHVwZGF0ZSBmb3Igc3RyZWFtaW5nIGNoYW5nZXNcbiAgdGhpcy5fY2hhbmdlc2V0ID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZXJzID0ge2NhbnZhczogY2FudmFzLCBzdmc6IHN2Z307XG4gIHRoaXMuX2lvICA9IGNhbnZhcztcbiAgdGhpcy5fYXBpID0ge307IC8vIFN0YXNoIHN0cmVhbWluZyBkYXRhIEFQSSBzYW5kYm94ZXMuXG59O1xuXG52YXIgcHJvdG90eXBlID0gVmlldy5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICBpZiAodGhpcy5fbW9kZWwgIT09IG1vZGVsKSB7XG4gICAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgICB0aGlzLl9zdHJlYW1lciA9IG5ldyBOb2RlKG1vZGVsKTtcbiAgICB0aGlzLl9jaGFuZ2VzZXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIubW9kZWwobW9kZWwpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gU2FuZGJveGVkIHN0cmVhbWluZyBkYXRhIEFQSVxuZnVuY3Rpb24gc3RyZWFtaW5nKHNyYykge1xuICB2YXIgdmlldyA9IHRoaXMsXG4gICAgICBkcyA9IHRoaXMuX21vZGVsLmRhdGEoc3JjKSxcbiAgICAgIGxpc3RlbmVyID0gZHMucGlwZWxpbmUoKVswXSxcbiAgICAgIHN0cmVhbWVyID0gdGhpcy5fc3RyZWFtZXIsXG4gICAgICBjcyAgPSB0aGlzLl9jaGFuZ2VzZXQsXG4gICAgICBhcGkgPSB7fTtcblxuICBpZihkbC5rZXlzKGNzLnNpZ25hbHMpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBcIk5ldyBzaWduYWwgdmFsdWVzIGFyZSBub3QgcmVmbGVjdGVkIGluIHRoZSB2aXN1YWxpemF0aW9uLlwiICtcbiAgICAgIFwiIFBsZWFzZSBjYWxsIHZpZXcudXBkYXRlKCkgYmVmb3JlIHVwZGF0aW5nIGRhdGEgdmFsdWVzLlwiXG4gIH1cblxuICAvLyBJZiB3ZSBoYXZlIGl0IHN0YXNoZWQsIGRvbid0IGNyZWF0ZSBhIG5ldyBjbG9zdXJlLiBcbiAgaWYodGhpcy5fYXBpW3NyY10pIHJldHVybiB0aGlzLl9hcGlbc3JjXTtcblxuICBhcGkuaW5zZXJ0ID0gZnVuY3Rpb24odmFscykge1xuICAgIGRzLmluc2VydChkbC5kdXBsaWNhdGUodmFscykpOyAgLy8gRG9uJ3QgcG9sbHV0ZSB0aGUgZW52aXJvbm1lbnRcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY3MuZGF0YVtkcy5uYW1lKCldID0gMTtcbiAgICByZXR1cm4gYXBpO1xuICB9O1xuXG4gIGFwaS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY3MuZGF0YVtkcy5uYW1lKCldID0gMTtcbiAgICByZXR1cm4gKGRzLnVwZGF0ZS5hcHBseShkcywgYXJndW1lbnRzKSwgYXBpKTtcbiAgfTtcblxuICBhcGkucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgc3RyZWFtZXIuYWRkTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNzLmRhdGFbZHMubmFtZSgpXSA9IDE7XG4gICAgcmV0dXJuIChkcy5yZW1vdmUuYXBwbHkoZHMsIGFyZ3VtZW50cyksIGFwaSk7XG4gIH07XG5cbiAgYXBpLnZhbHVlcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZHMudmFsdWVzKCkgfTsgICAgXG5cbiAgcmV0dXJuICh0aGlzLl9hcGlbc3JjXSA9IGFwaSk7XG59O1xuXG5wcm90b3R5cGUuZGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHYgPSB0aGlzO1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHYuX21vZGVsLmRhdGFWYWx1ZXMoKTtcbiAgZWxzZSBpZihkbC5pc1N0cmluZyhkYXRhKSkgcmV0dXJuIHN0cmVhbWluZy5jYWxsKHYsIGRhdGEpO1xuICBlbHNlIGlmKGRsLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgZGwua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBhcGkgPSBzdHJlYW1pbmcuY2FsbCh2LCBrKTtcbiAgICAgIGRhdGFba10oYXBpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgbSAgPSB0aGlzLl9tb2RlbCxcbiAgICAgIGNzID0gdGhpcy5fY2hhbmdlc2V0LFxuICAgICAgc3RyZWFtZXIgPSB0aGlzLl9zdHJlYW1lcixcbiAgICAgIHNldHRlciA9IG5hbWU7IFxuXG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbS5zaWduYWxWYWx1ZXMoKTtcbiAgZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgZGwuaXNTdHJpbmcobmFtZSkpIHJldHVybiBtLnNpZ25hbFZhbHVlcyhuYW1lKTtcblxuICBpZihkbC5rZXlzKGNzLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBcIk5ldyBkYXRhIHZhbHVlcyBhcmUgbm90IHJlZmxlY3RlZCBpbiB0aGUgdmlzdWFsaXphdGlvbi5cIiArXG4gICAgICBcIiBQbGVhc2UgY2FsbCB2aWV3LnVwZGF0ZSgpIGJlZm9yZSB1cGRhdGluZyBzaWduYWwgdmFsdWVzLlwiXG4gIH1cblxuICBpZihhcmd1bWVudHMubGVuZ3RoID09IDIpIHtcbiAgICBzZXR0ZXIgPSB7fTtcbiAgICBzZXR0ZXJbbmFtZV0gPSB2YWx1ZTtcbiAgfVxuXG4gIGRsLmtleXMoc2V0dGVyKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihtLnNpZ25hbChrKS52YWx1ZShzZXR0ZXJba10pKTtcbiAgICBjcy5zaWduYWxzW2tdID0gMTtcbiAgICBjcy5yZWZsb3cgPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKHdpZHRoKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX193aWR0aDtcbiAgaWYgKHRoaXMuX193aWR0aCAhPT0gd2lkdGgpIHtcbiAgICB0aGlzLl93aWR0aCA9IHRoaXMuX193aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLl9zdHJpY3QpIHRoaXMuX2F1dG9wYWQgPSAxO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9faGVpZ2h0O1xuICBpZiAodGhpcy5fX2hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fc3RyaWN0KSB0aGlzLl9hdXRvcGFkID0gMTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWQpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcocGFkKSkge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDE7XG4gICAgICB0aGlzLl9wYWRkaW5nID0ge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgICAgIHRoaXMuX3N0cmljdCA9IChwYWQgPT09IFwic3RyaWN0XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvcGFkID0gMDtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgICB0aGlzLl9zdHJpY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2VsKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5yZXNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCwgcGFkKTtcbiAgICAgIGlmKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIucGFkZGluZyhwYWQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5hdXRvcGFkID0gZnVuY3Rpb24ob3B0KSB7XG4gIGlmICh0aGlzLl9hdXRvcGFkIDwgMSkgcmV0dXJuIHRoaXM7XG4gIGVsc2UgdGhpcy5fYXV0b3BhZCA9IDA7XG5cbiAgdmFyIHBhZCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICBiID0gdGhpcy5tb2RlbCgpLnNjZW5lKCkuYm91bmRzLFxuICAgICAgaW5zZXQgPSBjb25maWcuYXV0b3BhZEluc2V0LFxuICAgICAgbCA9IGIueDEgPCAwID8gTWF0aC5jZWlsKC1iLngxKSArIGluc2V0IDogMCxcbiAgICAgIHQgPSBiLnkxIDwgMCA/IE1hdGguY2VpbCgtYi55MSkgKyBpbnNldCA6IDAsXG4gICAgICByID0gYi54MiA+IHRoaXMuX3dpZHRoICA/IE1hdGguY2VpbCgrYi54MiAtIHRoaXMuX3dpZHRoKSArIGluc2V0IDogMCxcbiAgICAgIGIgPSBiLnkyID4gdGhpcy5faGVpZ2h0ID8gTWF0aC5jZWlsKCtiLnkyIC0gdGhpcy5faGVpZ2h0KSArIGluc2V0IDogMDtcbiAgcGFkID0ge2xlZnQ6bCwgdG9wOnQsIHJpZ2h0OnIsIGJvdHRvbTpifTtcblxuICBpZiAodGhpcy5fc3RyaWN0KSB7XG4gICAgdGhpcy5fYXV0b3BhZCA9IDA7XG4gICAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgICB0aGlzLl93aWR0aCA9IE1hdGgubWF4KDAsIHRoaXMuX193aWR0aCAtIChsK3IpKTtcbiAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLm1heCgwLCB0aGlzLl9faGVpZ2h0IC0gKHQrYikpO1xuICAgIHRoaXMuX21vZGVsLndpZHRoKHRoaXMuX3dpZHRoKTtcbiAgICB0aGlzLl9tb2RlbC5oZWlnaHQodGhpcy5faGVpZ2h0KTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucGFkZGluZyhwYWQpLnVwZGF0ZShvcHQpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnZpZXdwb3J0ID0gZnVuY3Rpb24oc2l6ZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl92aWV3cG9ydDtcbiAgaWYgKHRoaXMuX3ZpZXdwb3J0ICE9PSBzaXplKSB7XG4gICAgdGhpcy5fdmlld3BvcnQgPSBzaXplO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbmRlcmVyID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZW5kZXJlcjtcbiAgaWYgKHRoaXMuX3JlbmRlcmVyc1t0eXBlXSkgdHlwZSA9IHRoaXMuX3JlbmRlcmVyc1t0eXBlXTtcbiAgZWxzZSBpZiAoZGwuaXNTdHJpbmcodHlwZSkpIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcmVuZGVyZXI6IFwiICsgdHlwZSk7XG4gIGVsc2UgaWYgKCF0eXBlKSB0aHJvdyBuZXcgRXJyb3IoXCJObyByZW5kZXJlciBzcGVjaWZpZWRcIik7XG5cbiAgaWYgKHRoaXMuX2lvICE9PSB0eXBlKSB7XG4gICAgdGhpcy5faW8gPSB0eXBlO1xuICAgIHRoaXMuX3JlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5fYnVpbGQpIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsKSB7XG4gIHZhciB2ID0gdGhpcywgcHJldkhhbmRsZXIsXG4gICAgICB3ID0gdi5fd2lkdGgsIGggPSB2Ll9oZWlnaHQsIHBhZCA9IHYuX3BhZGRpbmc7XG5cbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IGVsID09PSBudWxsKSB7XG4gICAgZWwgPSB0aGlzLl9lbCA/IHRoaXMuX2VsLnBhcmVudE5vZGUgOiBudWxsO1xuICAgIGlmKCFlbCkgcmV0dXJuIHRoaXM7ICAvLyBUaGlzIFZpZXcgY2Fubm90IGluaXQgdy9vIGFuXG4gIH1cbiAgXG4gIC8vIGNsZWFyIHByZS1leGlzdGluZyBjb250YWluZXJcbiAgZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJkaXYudmVnYVwiKS5yZW1vdmUoKTtcbiAgXG4gIC8vIGFkZCBkaXYgY29udGFpbmVyXG4gIHRoaXMuX2VsID0gZWwgPSBkMy5zZWxlY3QoZWwpXG4gICAgLmFwcGVuZChcImRpdlwiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ2ZWdhXCIpXG4gICAgLnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxuICAgIC5ub2RlKCk7XG4gIGlmICh2Ll92aWV3cG9ydCkge1xuICAgIGQzLnNlbGVjdChlbClcbiAgICAgIC5zdHlsZShcIndpZHRoXCIsICAodi5fdmlld3BvcnRbMF0gfHwgdykrXCJweFwiKVxuICAgICAgLnN0eWxlKFwiaGVpZ2h0XCIsICh2Ll92aWV3cG9ydFsxXSB8fCBoKStcInB4XCIpXG4gICAgICAuc3R5bGUoXCJvdmVyZmxvd1wiLCBcImF1dG9cIik7XG4gIH1cblxuICAvLyByZW5kZXJlclxuICB2Ll9yZW5kZXJlciA9ICh2Ll9yZW5kZXJlciB8fCBuZXcgdGhpcy5faW8uUmVuZGVyZXIoKSlcbiAgICAuaW5pdGlhbGl6ZShlbCwgdywgaCwgcGFkKTtcbiAgXG4gIC8vIGlucHV0IGhhbmRsZXJcbiAgcHJldkhhbmRsZXIgPSB2Ll9oYW5kbGVyO1xuICB2Ll9oYW5kbGVyID0gbmV3IHRoaXMuX2lvLkhhbmRsZXIoKVxuICAgIC5pbml0aWFsaXplKGVsLCBwYWQsIHYpXG4gICAgLm1vZGVsKHYuX21vZGVsKTtcblxuICBpZiAocHJldkhhbmRsZXIpIHtcbiAgICBwcmV2SGFuZGxlci5oYW5kbGVycygpLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgdi5faGFuZGxlci5vbihoLnR5cGUsIGguaGFuZGxlcik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGZvciBzaWduYWwgc3RyZWFtIGRlZmluaXRpb25zLlxuICAgIHBhcnNlU3RyZWFtcyh0aGlzKTtcbiAgfVxuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBidWlsZCgpIHtcbiAgdmFyIHYgPSB0aGlzO1xuICB2Ll9yZW5kZXJOb2RlID0gbmV3IE5vZGUodi5fbW9kZWwpXG4gICAgLnJvdXRlcih0cnVlKTtcblxuICB2Ll9yZW5kZXJOb2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZWJ1ZyhpbnB1dCwgW1wicmVuZGVyaW5nXCJdKTtcblxuICAgIHZhciBzID0gdi5fbW9kZWwuc2NlbmUoKTtcbiAgICBpZihpbnB1dC50cmFucykge1xuICAgICAgaW5wdXQudHJhbnMuc3RhcnQoZnVuY3Rpb24oaXRlbXMpIHsgdi5fcmVuZGVyZXIucmVuZGVyKHMsIGl0ZW1zKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHYuX3JlbmRlcmVyLnJlbmRlcihzKTtcbiAgICB9XG5cbiAgICAvLyBGb3IgYWxsIHVwZGF0ZWQgZGF0YXNvdXJjZXMsIGZpbmFsaXplIHRoZWlyIGNoYW5nZXNldHMuXG4gICAgdmFyIGQsIGRzO1xuICAgIGZvcihkIGluIGlucHV0LmRhdGEpIHtcbiAgICAgIGRzID0gdi5fbW9kZWwuZGF0YShkKTtcbiAgICAgIGlmKCFkcy5yZXZpc2VzKCkpIGNvbnRpbnVlO1xuICAgICAgY2hhbmdlc2V0LmZpbmFsaXplKGRzLmxhc3QoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIHJldHVybiAodi5fbW9kZWwuc2NlbmUodi5fcmVuZGVyTm9kZSksIHRydWUpOyAgXG59XG5cbnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbihvcHQpIHsgICAgXG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHYgPSB0aGlzLFxuICAgICAgdHJhbnMgPSBvcHQuZHVyYXRpb25cbiAgICAgICAgPyBuZXcgVHJhbnNpdGlvbihvcHQuZHVyYXRpb24sIG9wdC5lYXNlKVxuICAgICAgICA6IG51bGw7XG5cbiAgdmFyIGNzID0gdi5fY2hhbmdlc2V0O1xuICBpZih0cmFucykgY3MudHJhbnMgPSB0cmFucztcbiAgaWYob3B0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZihkbC5rZXlzKGNzLmRhdGEpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IFwiTmV3IGRhdGEgdmFsdWVzIGFyZSBub3QgcmVmbGVjdGVkIGluIHRoZSB2aXN1YWxpemF0aW9uLlwiICtcbiAgICAgICAgXCIgUGxlYXNlIGNhbGwgdmlldy51cGRhdGUoKSBiZWZvcmUgdXBkYXRpbmcgYSBzcGVjaWZpZWQgcHJvcGVydHkgc2V0LlwiXG4gICAgfVxuXG4gICAgY3MucmVmbG93ICA9IHRydWU7XG4gICAgY3MucmVxdWVzdCA9IG9wdC5wcm9wcztcbiAgfVxuXG4gIHYuX2J1aWxkID0gdi5fYnVpbGQgfHwgYnVpbGQuY2FsbCh0aGlzKTtcblxuICAvLyBJZiBzcGVjaWZpYyBpdGVtcyBhcmUgc3BlY2lmaWVkLCBzaG9ydC1jaXJjdWl0IGRhdGFmbG93IGdyYXBoLlxuICAvLyBFbHNlLUlmIHRoZXJlIGFyZSBzdHJlYW1pbmcgdXBkYXRlcywgcGVyZm9ybSBhIHRhcmdldGVkIHByb3BhZ2F0aW9uLlxuICAvLyBPdGhlcndpc2UsIHJlZXZhbHVhdGUgdGhlIGVudGlyZSBtb2RlbCAoZGF0YXNvdXJjZXMgKyBzY2VuZSkuXG4gIGlmKG9wdC5pdGVtcykgeyBcbiAgICBFbmNvZGVyLnVwZGF0ZSh0aGlzLl9tb2RlbCwgb3B0LnRyYW5zLCBvcHQucHJvcHMsIG9wdC5pdGVtcyk7XG4gICAgdi5fcmVuZGVyTm9kZS5ldmFsdWF0ZShjcyk7XG4gIH0gZWxzZSBpZih2Ll9zdHJlYW1lci5saXN0ZW5lcnMoKS5sZW5ndGgpIHtcbiAgICB2Ll9tb2RlbC5wcm9wYWdhdGUoY3MsIHYuX3N0cmVhbWVyKTtcbiAgICB2Ll9zdHJlYW1lci5kaXNjb25uZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgdi5fbW9kZWwuZmlyZShjcyk7XG4gIH1cblxuICB2Ll9jaGFuZ2VzZXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG5cbiAgcmV0dXJuIHYuYXV0b3BhZChvcHQpO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9tb2RlbC5zY2VuZSgpLCBpdGVtcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2hhbmRsZXIub24uYXBwbHkodGhpcy5faGFuZGxlciwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub25TaWduYWwgPSBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gIHRoaXMuX21vZGVsLnNpZ25hbChuYW1lKS5vbihoYW5kbGVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2hhbmRsZXIub2ZmLmFwcGx5KHRoaXMuX2hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm9mZlNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5fbW9kZWwuc2lnbmFsKG5hbWUpLm9mZihoYW5kbGVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WaWV3LmZhY3RvcnkgPSBmdW5jdGlvbihtb2RlbCkge1xuICB2YXIgSGVhZGxlc3NWaWV3ID0gcmVxdWlyZSgnLi9IZWFkbGVzc1ZpZXcnKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB2YXIgZGVmcyA9IG1vZGVsLmRlZnMoKTtcbiAgICB2YXIgdiA9IChvcHQuZWwgPyBuZXcgVmlldygpIDogbmV3IEhlYWRsZXNzVmlldygpKVxuICAgICAgLm1vZGVsKG1vZGVsKVxuICAgICAgLnJlbmRlcmVyKG9wdC5yZW5kZXJlciB8fCBcImNhbnZhc1wiKVxuICAgICAgLndpZHRoKGRlZnMud2lkdGgpXG4gICAgICAuaGVpZ2h0KGRlZnMuaGVpZ2h0KVxuICAgICAgLnBhZGRpbmcoZGVmcy5wYWRkaW5nKTtcblxuICAgIGlmKG9wdC5lbCB8fCAoIW9wdC5lbCAmJiB2IGluc3RhbmNlb2YgSGVhZGxlc3NWaWV3KSkgdi5pbml0aWFsaXplKG9wdC5lbCk7XG4gICAgaWYob3B0LmRhdGEpIHYuZGF0YShvcHQuZGF0YSk7XG4gIFxuICAgIHJldHVybiB2O1xuICB9OyAgICBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlldztcbiIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gQ29sbGVjdG9yKGdyYXBoKSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX2RhdGEgPSBbXTtcbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKENvbGxlY3Rvci5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8uZGF0YSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZGF0YTsgfVxuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJjb2xsZWN0aW5nXCJdKTtcblxuICBpZiAoaW5wdXQucmVmbG93KSB7XG4gICAgaW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcbiAgICBpbnB1dC5tb2QgPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG5cbiAgaWYgKGlucHV0LnJlbS5sZW5ndGgpIHtcbiAgICB2YXIgaWRzID0gaW5wdXQucmVtLnJlZHVjZShmdW5jdGlvbihtLHgpIHsgcmV0dXJuIChtW3guX2lkXT0xLCBtKTsgfSwge30pO1xuICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBpZHNbeC5faWRdICE9PSAxOyB9KTtcbiAgfVxuXG4gIGlmIChpbnB1dC5hZGQubGVuZ3RoKSB7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEubGVuZ3RoID8gdGhpcy5fZGF0YS5jb25jYXQoaW5wdXQuYWRkKSA6IGlucHV0LmFkZDtcbiAgfVxuXG4gIGlmIChpbnB1dC5zb3J0KSB7XG4gICAgdGhpcy5fZGF0YS5zb3J0KGlucHV0LnNvcnQpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4vY2hhbmdlc2V0JyksIFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi90dXBsZScpLCBcbiAgICBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRGF0YXNvdXJjZShncmFwaCwgbmFtZSwgZmFjZXQpIHtcbiAgdGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX2RhdGEgPSBbXTtcbiAgdGhpcy5fc291cmNlID0gbnVsbDtcbiAgdGhpcy5fZmFjZXQgPSBmYWNldDtcbiAgdGhpcy5faW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gIHRoaXMuX291dHB1dCA9IG51bGw7ICAgIC8vIE91dHB1dCBjaGFuZ2VzZXRcblxuICB0aGlzLl9waXBlbGluZSAgPSBudWxsOyAvLyBQaXBlbGluZSBvZiB0cmFuc2Zvcm1hdGlvbnMuXG4gIHRoaXMuX2NvbGxlY3RvciA9IG51bGw7IC8vIENvbGxlY3RvciB0byBtYXRlcmlhbGl6ZSBvdXRwdXQgb2YgcGlwZWxpbmVcbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAvLyBEb2VzIGFueSBwaXBlbGluZSBvcGVyYXRvciBuZWVkIHRvIHRyYWNrIHByZXY/XG59O1xuXG52YXIgcHJvdG8gPSBEYXRhc291cmNlLnByb3RvdHlwZTtcblxucHJvdG8ubmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9uYW1lO1xuICByZXR1cm4gKHRoaXMuX25hbWUgPSBuYW1lLCB0aGlzKTtcbn07XG5cbnByb3RvLnNvdXJjZSA9IGZ1bmN0aW9uKHNyYykge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgcmV0dXJuICh0aGlzLl9zb3VyY2UgPSB0aGlzLl9ncmFwaC5kYXRhKHNyYykpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oZCkge1xuICB2YXIgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkO1xuXG4gIHRoaXMuX2lucHV0LmFkZCA9IHRoaXMuX2lucHV0LmFkZFxuICAgIC5jb25jYXQoZGwuYXJyYXkoZCkubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHR1cGxlLmluZ2VzdChkLCBwcmV2KTsgfSkpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gIHZhciBkID0gdGhpcy5fZGF0YS5maWx0ZXIod2hlcmUpO1xuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9pbnB1dC5yZW0uY29uY2F0KGQpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uKHdoZXJlLCBmaWVsZCwgZnVuYykge1xuICB2YXIgbW9kID0gdGhpcy5faW5wdXQubW9kLFxuICAgICAgaWRzID0gdHVwbGUuaWRNYXAobW9kKSxcbiAgICAgIHByZXYgPSB0aGlzLl9yZXZpc2VzID8gbnVsbCA6IHVuZGVmaW5lZDsgXG5cbiAgdGhpcy5faW5wdXQuZmllbGRzW2ZpZWxkXSA9IDE7XG4gIHRoaXMuX2RhdGEuZmlsdGVyKHdoZXJlKS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgcHJldiA9IHhbZmllbGRdLFxuICAgICAgICBuZXh0ID0gZnVuYyh4KTtcbiAgICBpZiAocHJldiAhPT0gbmV4dCkge1xuICAgICAgdHVwbGUuc2V0KHgsIGZpZWxkLCBuZXh0KTtcbiAgICAgIGlmKGlkc1t4Ll9pZF0gIT09IDEpIHtcbiAgICAgICAgbW9kLnB1c2goeCk7XG4gICAgICAgIGlkc1t4Ll9pZF0gPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udmFsdWVzID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aClcbiAgICByZXR1cm4gdGhpcy5fY29sbGVjdG9yID8gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSA6IHRoaXMuX2RhdGE7XG5cbiAgLy8gUmVwbGFjZSBiYWNraW5nIGRhdGFcbiAgdGhpcy5faW5wdXQucmVtID0gdGhpcy5fZGF0YS5zbGljZSgpO1xuICBpZiAoZGF0YSkgeyB0aGlzLmluc2VydChkYXRhKTsgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHNldF9wcmV2KGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfVxuXG5wcm90by5yZXZpc2VzID0gZnVuY3Rpb24ocCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JldmlzZXM7XG5cbiAgLy8gSWYgd2UndmUgbm90IG5lZWRlZCBwcmV2IGluIHRoZSBwYXN0LCBidXQgYSBuZXcgZGF0YWZsb3cgbm9kZSBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIHR1cGxlcyBoYXZlIHByZXYgc2V0LlxuICBpZighdGhpcy5fcmV2aXNlcyAmJiBwKSB7XG4gICAgdGhpcy5fZGF0YS5mb3JFYWNoKHNldF9wcmV2KTtcbiAgICB0aGlzLl9pbnB1dC5hZGQuZm9yRWFjaChzZXRfcHJldik7IC8vIE5ldyB0dXBsZXMgdGhhdCBoYXZlbid0IHlldCBiZWVuIG1lcmdlZCBpbnRvIF9kYXRhXG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxhc3QgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX291dHB1dDsgfTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmKGlucHV0KSB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUodGhpcy5faW5wdXQsIHRoaXMuX3BpcGVsaW5lWzBdKTsgXG59O1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gIHZhciBkcyA9IHRoaXMsIG4sIGM7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG5cbiAgaWYocGlwZWxpbmUubGVuZ3RoKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIHBpcGVsaW5lLCBhZGQgYSBjb2xsZWN0b3IgdG8gdGhlIGVuZCB0byBtYXRlcmlhbGl6ZVxuICAgIC8vIHRoZSBvdXRwdXQuXG4gICAgZHMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IodGhpcy5fZ3JhcGgpO1xuICAgIHBpcGVsaW5lLnB1c2goZHMuX2NvbGxlY3Rvcik7XG4gICAgZHMuX3JldmlzZXMgPSBwaXBlbGluZS5zb21lKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAucmV2aXNlcygpOyB9KTtcbiAgfVxuXG4gIC8vIElucHV0IG5vZGUgYXBwbGllcyB0aGUgZGF0YXNvdXJjZSdzIGRlbHRhLCBhbmQgcHJvcGFnYXRlcyBpdCB0byBcbiAgLy8gdGhlIHJlc3Qgb2YgdGhlIHBpcGVsaW5lLiBJdCByZWNlaXZlcyB0b3VjaGVzIHRvIHJlZmxvdyBkYXRhLlxuICB2YXIgaW5wdXQgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICBpbnB1dC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcImlucHV0XCIsIGRzLl9uYW1lXSk7XG5cbiAgICB2YXIgZGVsdGEgPSBkcy5faW5wdXQsIFxuICAgICAgICBvdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgICAgcmVtO1xuXG4gICAgLy8gRGVsdGEgbWlnaHQgY29udGFpbiBmaWVsZHMgdXBkYXRlZCB0aHJvdWdoIEFQSVxuICAgIGRsLmtleXMoZGVsdGEuZmllbGRzKS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHsgb3V0LmZpZWxkc1tmXSA9IDEgfSk7XG5cbiAgICBpZihpbnB1dC5yZWZsb3cpIHtcbiAgICAgIG91dC5tb2QgPSBkcy5fZGF0YS5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1cGRhdGUgZGF0YVxuICAgICAgaWYoZGVsdGEucmVtLmxlbmd0aCkge1xuICAgICAgICByZW0gPSB0dXBsZS5pZE1hcChkZWx0YS5yZW0pO1xuICAgICAgICBkcy5fZGF0YSA9IGRzLl9kYXRhXG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW1beC5faWRdICE9PSAxIH0pO1xuICAgICAgfVxuXG4gICAgICBpZihkZWx0YS5hZGQubGVuZ3RoKSBkcy5fZGF0YSA9IGRzLl9kYXRhLmNvbmNhdChkZWx0YS5hZGQpO1xuXG4gICAgICAvLyByZXNldCBjaGFuZ2UgbGlzdFxuICAgICAgZHMuX2lucHV0ID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuXG4gICAgICBvdXQuYWRkID0gZGVsdGEuYWRkOyBcbiAgICAgIG91dC5tb2QgPSBkZWx0YS5tb2Q7XG4gICAgICBvdXQucmVtID0gZGVsdGEucmVtO1xuICAgIH1cblxuICAgIHJldHVybiAob3V0LmZhY2V0ID0gZHMuX2ZhY2V0LCBvdXQpO1xuICB9O1xuXG4gIHBpcGVsaW5lLnVuc2hpZnQoaW5wdXQpO1xuXG4gIC8vIE91dHB1dCBub2RlIGNhcHR1cmVzIHRoZSBsYXN0IGNoYW5nZXNldCBzZWVuIGJ5IHRoaXMgZGF0YXNvdXJjZVxuICAvLyAobmVlZGVkIGZvciBqb2lucyBhbmQgYnVpbGRzKSBhbmQgbWF0ZXJpYWxpemVzIGFueSBuZXN0ZWQgZGF0YS5cbiAgLy8gSWYgdGhpcyBkYXRhc291cmNlIGlzIGZhY2V0ZWQsIG1hdGVyaWFsaXplcyB0aGUgdmFsdWVzIGluIHRoZSBmYWNldC5cbiAgdmFyIG91dHB1dCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIG91dHB1dC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVidWcoaW5wdXQsIFtcIm91dHB1dFwiLCBkcy5fbmFtZV0pO1xuICAgIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0LCB0cnVlKTtcblxuICAgIGlmKGRzLl9mYWNldCkge1xuICAgICAgZHMuX2ZhY2V0LnZhbHVlcyA9IGRzLnZhbHVlcygpO1xuICAgICAgaW5wdXQuZmFjZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGRzLl9vdXRwdXQgPSBpbnB1dDtcbiAgICBvdXRwdXQuZGF0YVtkcy5fbmFtZV0gPSAxO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgcGlwZWxpbmUucHVzaChvdXRwdXQpO1xuXG4gIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QoZHMuX3BpcGVsaW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5saXN0ZW5lciA9IGZ1bmN0aW9uKCkgeyBcbiAgdmFyIGwgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCkucm91dGVyKHRydWUpLFxuICAgICAgZGVzdCA9IHRoaXMsXG4gICAgICBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQ7XG5cbiAgbC5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgZGVzdC5fc3JjTWFwID0gZGVzdC5fc3JjTWFwIHx8IHt9OyAgLy8gdG8gcHJvcGFnYXRlIHR1cGxlcyBjb3JyZWN0bHlcbiAgICB2YXIgbWFwID0gZGVzdC5fc3JjTWFwLFxuICAgICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCk7XG5cbiAgICBvdXRwdXQuYWRkID0gaW5wdXQuYWRkLm1hcChmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gKG1hcFt0Ll9pZF0gPSB0dXBsZS5kZXJpdmUodCwgdC5fcHJldiAhPT0gdW5kZWZpbmVkID8gdC5fcHJldiA6IHByZXYpKTtcbiAgICB9KTtcbiAgICBvdXRwdXQubW9kID0gaW5wdXQubW9kLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBtYXBbdC5faWRdOyB9KTtcbiAgICBvdXRwdXQucmVtID0gaW5wdXQucmVtLm1hcChmdW5jdGlvbih0KSB7IFxuICAgICAgdmFyIG8gPSBtYXBbdC5faWRdO1xuICAgICAgbWFwW3QuX2lkXSA9IG51bGw7XG4gICAgICByZXR1cm4gbztcbiAgICB9KTtcblxuICAgIHJldHVybiAoZGVzdC5faW5wdXQgPSBvdXRwdXQpO1xuICB9O1xuXG4gIGwuYWRkTGlzdGVuZXIodGhpcy5fcGlwZWxpbmVbMF0pO1xuICByZXR1cm4gbDtcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICBpZihsIGluc3RhbmNlb2YgRGF0YXNvdXJjZSkge1xuICAgIGlmKHRoaXMuX2NvbGxlY3RvcikgdGhpcy5fY29sbGVjdG9yLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gICAgZWxzZSB0aGlzLl9waXBlbGluZVswXS5hZGRMaXN0ZW5lcihsLmxpc3RlbmVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5hZGRMaXN0ZW5lcihsKTsgICAgICBcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5yZW1vdmVMaXN0ZW5lcihsKTtcbn07XG5cbnByb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGRzKSB7XG4gIHJldHVybiBkcyBcbiAgICA/IHRoaXMuX2NvbGxlY3RvciA/IHRoaXMuX2NvbGxlY3Rvci5saXN0ZW5lcnMoKSA6IHRoaXMuX3BpcGVsaW5lWzBdLmxpc3RlbmVycygpXG4gICAgOiB0aGlzLl9waXBlbGluZVt0aGlzLl9waXBlbGluZS5sZW5ndGgtMV0ubGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFzb3VyY2U7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEhlYXAgPSByZXF1aXJlKCdoZWFwJyksXG4gICAgRGF0YXNvdXJjZSA9IHJlcXVpcmUoJy4vRGF0YXNvdXJjZScpLFxuICAgIFNpZ25hbCA9IHJlcXVpcmUoJy4vU2lnbmFsJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gR3JhcGgoKSB7XG59XG5cbnZhciBwcm90byA9IEdyYXBoLnByb3RvdHlwZTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdGFtcCA9IDA7XG4gIHRoaXMuX3JhbmsgID0gMDtcblxuICB0aGlzLl9kYXRhID0ge307XG4gIHRoaXMuX3NpZ25hbHMgPSB7fTtcblxuICB0aGlzLmRvTm90UHJvcGFnYXRlID0ge307XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24obmFtZSwgcGlwZWxpbmUsIGZhY2V0KSB7XG4gIHZhciBkYiA9IHRoaXMuX2RhdGE7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZGwua2V5cyhkYikubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRiW2RdOyB9KTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGRiW25hbWVdO1xuICByZXR1cm4gKGRiW25hbWVdID0gbmV3IERhdGFzb3VyY2UodGhpcywgbmFtZSwgZmFjZXQpLnBpcGVsaW5lKHBpcGVsaW5lKSk7XG59O1xuXG5wcm90by5kYXRhVmFsdWVzID0gZnVuY3Rpb24obmFtZXMpIHtcbiAgdmFyIGdyYXBoID0gdGhpcztcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSBuYW1lcyA9IGRsLmtleXModGhpcy5fZGF0YSk7XG4gIGlmICghZGwuaXNBcnJheShuYW1lcykpIHJldHVybiB0aGlzLl9kYXRhW25hbWVzXS52YWx1ZXMoKTtcbiAgcmV0dXJuIG5hbWVzLnJlZHVjZShmdW5jdGlvbihkYiwgbikge1xuICAgIHJldHVybiAoZGJbbl0gPSBncmFwaC5fZGF0YVtuXS52YWx1ZXMoKSwgZGIpO1xuICB9LCB7fSk7XG59O1xuXG5mdW5jdGlvbiBzaWduYWwobmFtZSkge1xuICB2YXIgbSA9IHRoaXMsIGksIGxlbjtcbiAgaWYoIWRsLmlzQXJyYXkobmFtZSkpIHJldHVybiB0aGlzLl9zaWduYWxzW25hbWVdO1xuICByZXR1cm4gbmFtZS5tYXAoZnVuY3Rpb24obikgeyBtLl9zaWduYWxzW25dOyB9KTtcbn1cblxucHJvdG8uc2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaW5pdCkge1xuICB2YXIgbSA9IHRoaXM7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBzaWduYWwuY2FsbCh0aGlzLCBuYW1lKTtcbiAgcmV0dXJuICh0aGlzLl9zaWduYWxzW25hbWVdID0gbmV3IFNpZ25hbCh0aGlzLCBuYW1lLCBpbml0KSk7XG59O1xuXG5wcm90by5zaWduYWxWYWx1ZXMgPSBmdW5jdGlvbihuYW1lcykge1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgbmFtZXMgPSBkbC5rZXlzKHRoaXMuX3NpZ25hbHMpO1xuICBpZighZGwuaXNBcnJheShuYW1lcykpIHJldHVybiB0aGlzLl9zaWduYWxzW25hbWVzXS52YWx1ZSgpO1xuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKHNnLCBuKSB7XG4gICAgcmV0dXJuIChzZ1tuXSA9IGdyYXBoLl9zaWduYWxzW25dLnZhbHVlKCksIHNnKTtcbiAgfSwge30pO1xufTtcblxucHJvdG8uc2lnbmFsUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmKCFkbC5pc0FycmF5KHJlZikpIHJlZiA9IGRsLmZpZWxkKHJlZik7XG4gIHZhciB2YWx1ZSA9IHRoaXMuc2lnbmFsKHJlZi5zaGlmdCgpKS52YWx1ZSgpO1xuICBpZihyZWYubGVuZ3RoID4gMCkge1xuICAgIHZhciBmbiA9IEZ1bmN0aW9uKFwic1wiLCBcInJldHVybiBzW1wiK3JlZi5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCIpO1xuICAgIHZhbHVlID0gZm4uY2FsbChudWxsLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgc2NoZWR1bGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIC8vIElmIHRoZSBub2RlcyBhcmUgZXF1YWwsIHByb3BhZ2F0ZSB0aGUgbm9uLXJlZmxvdyBwdWxzZSBmaXJzdCxcbiAgLy8gc28gdGhhdCB3ZSBjYW4gaWdub3JlIHN1YnNlcXVlbnQgcmVmbG93IHB1bHNlcy4gXG4gIGlmKGEucmFuayA9PSBiLnJhbmspIHJldHVybiBhLnB1bHNlLnJlZmxvdyA/IDEgOiAtMTtcbiAgZWxzZSByZXR1cm4gYS5yYW5rIC0gYi5yYW5rOyBcbn07XG5cbnByb3RvLnByb3BhZ2F0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciB2LCBsLCBuLCBwLCByLCBpLCBsZW4sIHJlZmxvd2VkO1xuXG4gIC8vIG5ldyBQUSB3aXRoIGVhY2ggcHJvcGFnYXRpb24gY3ljbGUgc28gdGhhdCB3ZSBjYW4gcHVsc2UgYnJhbmNoZXNcbiAgLy8gb2YgdGhlIGRhdGFmbG93IGdyYXBoIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuLCB3aGVuIGNyZWF0aW5nXG4gIC8vIGEgbmV3IGlubGluZSBkYXRhc291cmNlKS5cbiAgdmFyIHBxID0gbmV3IEhlYXAoc2NoZWR1bGUpOyBcblxuICBpZihwdWxzZS5zdGFtcCkgdGhyb3cgXCJQdWxzZSBhbHJlYWR5IGhhcyBhIG5vbi16ZXJvIHN0YW1wXCJcblxuICBwdWxzZS5zdGFtcCA9ICsrdGhpcy5fc3RhbXA7XG4gIHBxLnB1c2goeyBub2RlOiBub2RlLCBwdWxzZTogcHVsc2UsIHJhbms6IG5vZGUucmFuaygpIH0pO1xuXG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnBvcCgpLCBuID0gdi5ub2RlLCBwID0gdi5wdWxzZSwgciA9IHYucmFuaywgbCA9IG4uX2xpc3RlbmVycztcbiAgICByZWZsb3dlZCA9IHAucmVmbG93ICYmIG4ubGFzdCgpID49IHAuc3RhbXA7XG5cbiAgICBpZihyZWZsb3dlZCkgY29udGludWU7IC8vIERvbid0IG5lZWRsZXNzbHkgcmVmbG93IG9wcy5cblxuICAgIC8vIEEgbm9kZSdzIHJhbmsgbWlnaHQgY2hhbmdlIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuIGluc3RhbnRpYXRpbmdcbiAgICAvLyBhIGdyb3VwJ3MgZGF0YWZsb3cgYnJhbmNoKS4gUmUtcXVldWUgaWYgaXQgaGFzLiBUXG4gICAgLy8gVE9ETzogdXNlIHBxLnJlcGxhY2Ugb3IgcHEucG9wcHVzaD9cbiAgICBpZihyICE9IG4ucmFuaygpKSB7XG4gICAgICBkZWJ1ZyhwLCBbJ1JhbmsgbWlzbWF0Y2gnLCByLCBuLnJhbmsoKV0pO1xuICAgICAgcHEucHVzaCh7IG5vZGU6IG4sIHB1bHNlOiBwLCByYW5rOiBuLnJhbmsoKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHAgPSB0aGlzLmV2YWx1YXRlKHAsIG4pO1xuXG4gICAgLy8gRXZlbiBpZiB3ZSBkaWRuJ3QgcnVuIHRoZSBub2RlLCB3ZSBzdGlsbCB3YW50IHRvIHByb3BhZ2F0ZSBcbiAgICAvLyB0aGUgcHVsc2UuIFxuICAgIGlmIChwICE9PSB0aGlzLmRvTm90UHJvcGFnYXRlKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBxLnB1c2goeyBub2RlOiBsW2ldLCBwdWxzZTogcCwgcmFuazogbFtpXS5fcmFuayB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENvbm5lY3QgYSBicmFuY2ggb2YgZGF0YWZsb3cgbm9kZXMuIFxuLy8gRGVwZW5kZW5jaWVzIGdldCB3aXJlZCB0byB0aGUgbmVhcmVzdCBjb2xsZWN0b3IuIFxuZnVuY3Rpb24gZm9yRWFjaE5vZGUoYnJhbmNoLCBmbikge1xuICB2YXIgbm9kZSwgY29sbGVjdG9yLCBpLCBsZW47XG4gIGZvcihpPTAsIGxlbj1icmFuY2gubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbm9kZSA9IGJyYW5jaFtpXTtcbiAgICBpZihub2RlLmNvbGxlY3RvcigpKSBjb2xsZWN0b3IgPSBub2RlO1xuICAgIGZuKG5vZGUsIGNvbGxlY3RvciwgaSk7XG4gIH1cbn1cblxucHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uKGJyYW5jaCkge1xuICBkZWJ1Zyh7fSwgWydjb25uZWN0aW5nJ10pO1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBmb3JFYWNoTm9kZShicmFuY2gsIGZ1bmN0aW9uKG4sIGMsIGkpIHtcbiAgICB2YXIgZGF0YSA9IG4uZGVwZW5kZW5jeShDLkRBVEEpLFxuICAgICAgICBzaWduYWxzID0gbi5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG5cbiAgICBpZihkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IFxuICAgICAgICBncmFwaC5kYXRhKGQpXG4gICAgICAgICAgLnJldmlzZXMobi5yZXZpc2VzKCkpXG4gICAgICAgICAgLmFkZExpc3RlbmVyKGMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoc2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBncmFwaC5zaWduYWwocykuYWRkTGlzdGVuZXIoYyk7IH0pO1xuICAgIH1cblxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBicmFuY2hbaS0xXS5hZGRMaXN0ZW5lcihicmFuY2hbaV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgZGVidWcoe30sIFsnZGlzY29ubmVjdGluZyddKTtcbiAgdmFyIGdyYXBoID0gdGhpcztcblxuICBmb3JFYWNoTm9kZShicmFuY2gsIGZ1bmN0aW9uKG4sIGMsIGkpIHtcbiAgICB2YXIgZGF0YSA9IG4uZGVwZW5kZW5jeShDLkRBVEEpLFxuICAgICAgICBzaWduYWxzID0gbi5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG5cbiAgICBpZihkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IGdyYXBoLmRhdGEoZCkucmVtb3ZlTGlzdGVuZXIoYyk7IH0pO1xuICAgIH1cblxuICAgIGlmKHNpZ25hbHMubGVuZ3RoID4gMCkge1xuICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgZ3JhcGguc2lnbmFsKHMpLnJlbW92ZUxpc3RlbmVyKGMpIH0pO1xuICAgIH1cblxuICAgIG4uZGlzY29ubmVjdCgpOyAgXG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90by5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgdmFyIHJlZmxvd2VkID0gIXB1bHNlLnJlZmxvdyB8fCAocHVsc2UucmVmbG93ICYmIG5vZGUubGFzdCgpID49IHB1bHNlLnN0YW1wKSxcbiAgICAgIHJ1biA9ICEhcHVsc2UuYWRkLmxlbmd0aCB8fCAhIXB1bHNlLnJlbS5sZW5ndGggfHwgbm9kZS5yb3V0ZXIoKTtcbiAgcnVuID0gcnVuIHx8ICFyZWZsb3dlZDtcbiAgcmV0dXJuIHJ1biB8fCBub2RlLnJlZXZhbHVhdGUocHVsc2UpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICBpZighdGhpcy5yZWV2YWx1YXRlKHB1bHNlLCBub2RlKSkgcmV0dXJuIHB1bHNlO1xuICBwdWxzZSA9IG5vZGUuZXZhbHVhdGUocHVsc2UpO1xuICBub2RlLmxhc3QocHVsc2Uuc3RhbXApO1xuICByZXR1cm4gcHVsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIFJFRVZBTCA9IFtDLkRBVEEsIEMuRklFTERTLCBDLlNDQUxFUywgQy5TSUdOQUxTXTtcblxudmFyIG5vZGVfaWQgPSAxO1xuXG5mdW5jdGlvbiBOb2RlKGdyYXBoKSB7XG4gIGlmKGdyYXBoKSB0aGlzLmluaXQoZ3JhcGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gTm9kZS5wcm90b3R5cGU7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLl9pZCA9IG5vZGVfaWQrKztcbiAgdGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5fcmFuayA9ICsrZ3JhcGguX3Jhbms7IC8vIEZvciB0b3BvbG9naWFsIHNvcnRcbiAgdGhpcy5fc3RhbXAgPSAwOyAgLy8gTGFzdCBzdGFtcCBzZWVuXG5cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX3JlZ2lzdGVyZWQgPSB7fTsgLy8gVG8gcHJldmVudCBkdXBsaWNhdGUgbGlzdGVuZXJzXG5cbiAgdGhpcy5fZGVwcyA9IHtcbiAgICBkYXRhOiAgICBbXSxcbiAgICBmaWVsZHM6ICBbXSxcbiAgICBzY2FsZXM6ICBbXSxcbiAgICBzaWduYWxzOiBbXSxcbiAgfTtcblxuICB0aGlzLl9pc1JvdXRlciA9IGZhbHNlOyAvLyBSZXNwb25zaWJsZSBmb3IgcHJvcGFnYXRpbmcgdHVwbGVzLCBjYW5ub3QgZXZlciBiZSBza2lwcGVkXG4gIHRoaXMuX2lzQ29sbGVjdG9yID0gZmFsc2U7ICAvLyBIb2xkcyBhIG1hdGVyaWFsaXplZCBkYXRhc2V0LCBwdWxzZSB0byByZWZsb3dcbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAvLyBEb2VzIHRoZSBvcGVyYXRvciByZXF1aXJlIHR1cGxlcycgcHJldmlvdXMgdmFsdWVzPyBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKTtcbiAgbi5ldmFsdWF0ZSA9IHRoaXMuZXZhbHVhdGU7XG4gIG4uX2RlcHMgPSB0aGlzLl9kZXBzO1xuICBuLl9pc1JvdXRlciA9IHRoaXMuX2lzUm91dGVyO1xuICBuLl9pc0NvbGxlY3RvciA9IHRoaXMuX2lzQ29sbGVjdG9yO1xuICByZXR1cm4gbjtcbn07XG5cbnByb3RvLnJhbmsgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3Jhbms7IH07XG5cbnByb3RvLmxhc3QgPSBmdW5jdGlvbihzdGFtcCkgeyBcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zdGFtcDtcbiAgdGhpcy5fc3RhbXAgPSBzdGFtcDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICB2YXIgZCA9IHRoaXMuX2RlcHNbdHlwZV07XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBkO1xuICBpZihkZXBzID09PSBudWxsKSB7IC8vIENsZWFyIGRlcGVuZGVuY2llcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgIHdoaWxlKGQubGVuZ3RoID4gMCkgZC5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBpZighZGwuaXNBcnJheShkZXBzKSAmJiBkLmluZGV4T2YoZGVwcykgPCAwKSBkLnB1c2goZGVwcyk7XG4gICAgZWxzZSBkLnB1c2guYXBwbHkoZCwgZGwuYXJyYXkoZGVwcykpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucm91dGVyID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2lzUm91dGVyO1xuICB0aGlzLl9pc1JvdXRlciA9ICEhYm9vbFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmNvbGxlY3RvciA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pc0NvbGxlY3RvcjtcbiAgdGhpcy5faXNDb2xsZWN0b3IgPSAhIWJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuICB0aGlzLl9yZXZpc2VzID0gISFib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIGlmKCEobCBpbnN0YW5jZW9mIE5vZGUpKSB0aHJvdyBcIkxpc3RlbmVyIGlzIG5vdCBhIE5vZGVcIjtcbiAgaWYodGhpcy5fcmVnaXN0ZXJlZFtsLl9pZF0pIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX2xpc3RlbmVycy5wdXNoKGwpO1xuICB0aGlzLl9yZWdpc3RlcmVkW2wuX2lkXSA9IDE7XG4gIGlmKHRoaXMuX3JhbmsgPiBsLl9yYW5rKSB7XG4gICAgdmFyIHEgPSBbbF07XG4gICAgd2hpbGUocS5sZW5ndGgpIHtcbiAgICAgIHZhciBjdXIgPSBxLnNwbGljZSgwLDEpWzBdO1xuICAgICAgY3VyLl9yYW5rID0gKyt0aGlzLl9ncmFwaC5fcmFuaztcbiAgICAgIHEucHVzaC5hcHBseShxLCBjdXIuX2xpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsKSB7XG4gIHZhciBmb3VuZFNlbmRpbmcgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW4gJiYgIWZvdW5kU2VuZGluZzsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tpXSA9PT0gbCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRbbC5faWRdID0gbnVsbDtcbiAgICAgIGZvdW5kU2VuZGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZm91bmRTZW5kaW5nO1xufTtcblxucHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5fcmVnaXN0ZXJlZCA9IHt9O1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkgeyByZXR1cm4gcHVsc2U7IH1cblxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHZhciBub2RlID0gdGhpcywgcmVldmFsID0gZmFsc2U7XG4gIHJldHVybiBSRUVWQUwuc29tZShmdW5jdGlvbihwcm9wKSB7XG4gICAgcmVldmFsID0gcmVldmFsIHx8IG5vZGUuX2RlcHNbcHJvcF0uc29tZShmdW5jdGlvbihrKSB7IHJldHVybiAhIXB1bHNlW3Byb3BdW2tdIH0pO1xuICAgIHJldHVybiByZWV2YWw7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlOyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gU2lnbmFsKGdyYXBoLCBuYW1lLCBpbml0KSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX25hbWUgID0gbmFtZTtcbiAgdGhpcy5fdmFsdWUgPSBpbml0O1xuICB0aGlzLl9oYW5kbGVycyA9IFtdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBwcm90byA9IChTaWduYWwucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLm5hbWUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH07XG5cbnByb3RvLnZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIHRoaXMuX3ZhbHVlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmZpcmUgPSBmdW5jdGlvbihjcykge1xuICBpZighY3MpIGNzID0gY2hhbmdlc2V0LmNyZWF0ZShudWxsLCB0cnVlKTtcbiAgY3Muc2lnbmFsc1t0aGlzLl9uYW1lXSA9IDE7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShjcywgdGhpcyk7XG59O1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIHNnID0gdGhpcyxcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSh0aGlzLl9ncmFwaCk7XG5cbiAgbm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIChoYW5kbGVyKHNnLm5hbWUoKSwgc2cudmFsdWUoKSksIGlucHV0KTtcbiAgfTtcblxuICB0aGlzLl9oYW5kbGVycy5wdXNoKHsgaGFuZGxlcjogaGFuZGxlciwgbm9kZTogbm9kZSB9KTtcbiAgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIobm9kZSk7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gIHZhciBzZyA9IHRoaXMsIGggPSB0aGlzLl9oYW5kbGVycztcbiAgZm9yKHZhciBpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBzZy5yZW1vdmVMaXN0ZW5lcihoLnNwbGljZShpLCAxKVswXS5ub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbDsiLCJ2YXIgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG52YXIgUkVFVkFMID0gW0MuREFUQSwgQy5GSUVMRFMsIEMuU0NBTEVTLCBDLlNJR05BTFNdO1xuXG5mdW5jdGlvbiBjcmVhdGUoY3MsIHJlZmxvdykge1xuICB2YXIgb3V0ID0ge307XG4gIGNvcHkoY3MsIG91dCk7XG5cbiAgb3V0LmFkZCA9IFtdO1xuICBvdXQubW9kID0gW107XG4gIG91dC5yZW0gPSBbXTtcblxuICBvdXQucmVmbG93ID0gcmVmbG93O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHJlc2V0X3ByZXYoeCkge1xuICB4Ll9wcmV2ID0gKHguX3ByZXYgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiBDLlNFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShjcykge1xuICBmb3IoaT0wLCBsZW49Y3MuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkgcmVzZXRfcHJldihjcy5hZGRbaV0pO1xuICBmb3IoaT0wLCBsZW49Y3MubW9kLmxlbmd0aDsgaTxsZW47ICsraSkgcmVzZXRfcHJldihjcy5tb2RbaV0pO1xufVxuXG5mdW5jdGlvbiBjb3B5KGEsIGIpIHtcbiAgYi5zdGFtcCA9IGEgPyBhLnN0YW1wIDogMDtcbiAgYi5zb3J0ICA9IGEgPyBhLnNvcnQgIDogbnVsbDtcbiAgYi5mYWNldCA9IGEgPyBhLmZhY2V0IDogbnVsbDtcbiAgYi50cmFucyA9IGEgPyBhLnRyYW5zIDogbnVsbDtcbiAgYi5yZXF1ZXN0ID0gYSA/IGEucmVxdWVzdCA6IG51bGw7XG4gIFJFRVZBTC5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgYltkXSA9IGEgPyBhW2RdIDoge307IH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiBjcmVhdGUsXG4gIGNvcHk6IGNvcHksXG4gIGZpbmFsaXplOiBmaW5hbGl6ZSxcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIHR1cGxlX2lkID0gMTtcblxuLy8gT2JqZWN0LmNyZWF0ZSBpcyBleHBlbnNpdmUuIFNvLCB3aGVuIGluZ2VzdGluZywgdHJ1c3QgdGhhdCB0aGVcbi8vIGRhdHVtIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBiZWVuIGFwcHJvcHJpYXRlbHkgc2FuZGJveGVkIGZyb20gXG4vLyB0aGUgb3V0c2lkZSBlbnZpcm9ubWVudC4gXG5mdW5jdGlvbiBpbmdlc3QoZGF0dW0sIHByZXYpIHtcbiAgZGF0dW0gPSBkbC5pc09iamVjdChkYXR1bSkgPyBkYXR1bSA6IHtkYXRhOiBkYXR1bX07XG4gIGRhdHVtLl9pZCA9IHR1cGxlX2lkKys7XG4gIGRhdHVtLl9wcmV2ID0gKHByZXYgIT09IHVuZGVmaW5lZCkgPyAocHJldiB8fCBDLlNFTlRJTkVMKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGRhdHVtO1xufVxuXG5mdW5jdGlvbiBkZXJpdmUoZGF0dW0sIHByZXYpIHtcbiAgcmV0dXJuIGluZ2VzdChPYmplY3QuY3JlYXRlKGRhdHVtKSwgcHJldik7XG59XG5cbi8vIFdBUk5JTkc6IG9wZXJhdG9ycyBzaG91bGQgb25seSBjYWxsIHRoaXMgb25jZSBwZXIgdGltZXN0YW1wIVxuZnVuY3Rpb24gc2V0KHQsIGssIHYpIHtcbiAgdmFyIHByZXYgPSB0W2tdO1xuICBpZihwcmV2ID09PSB2KSByZXR1cm47XG4gIHNldF9wcmV2KHQsIGspO1xuICB0W2tdID0gdjtcbn1cblxuZnVuY3Rpb24gc2V0X3ByZXYodCwgaykge1xuICBpZih0Ll9wcmV2ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgdC5fcHJldiA9ICh0Ll9wcmV2ID09PSBDLlNFTlRJTkVMKSA/IHt9IDogdC5fcHJldjtcbiAgdC5fcHJldltrXSA9IHRba107XG59XG5cbmZ1bmN0aW9uIHJlc2V0KCkgeyB0dXBsZV9pZCA9IDE7IH1cblxuZnVuY3Rpb24gaWRNYXAoYSkge1xuICByZXR1cm4gYS5yZWR1Y2UoZnVuY3Rpb24obSx4KSB7XG4gICAgcmV0dXJuIChtW3guX2lkXSA9IDEsIG0pO1xuICB9LCB7fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5nZXN0OiBpbmdlc3QsXG4gIGRlcml2ZTogZGVyaXZlLFxuICBzZXQ6ICAgIHNldCxcbiAgcHJldjogICBzZXRfcHJldixcbiAgcmVzZXQ6ICByZXNldCxcbiAgaWRNYXA6ICBpZE1hcFxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbiAgdmFyIGZ1bmN0aW9ucyA9IChvcHQuZnVuY3Rpb25zIHx8IHJlcXVpcmUoJy4vZnVuY3Rpb25zJykpKGNvZGVnZW4pO1xuICB2YXIgaWRXaGl0ZUxpc3QgPSBvcHQuaWRXaGl0ZUxpc3QgPyBkbC50b01hcChvcHQuaWRXaGl0ZUxpc3QpIDogbnVsbDtcbiAgdmFyIGlkQmxhY2tMaXN0ID0gb3B0LmlkQmxhY2tMaXN0ID8gZGwudG9NYXAob3B0LmlkQmxhY2tMaXN0KSA6IG51bGw7XG4gIHZhciBtZW1iZXJEZXB0aCA9IDA7XG5cbiAgLy8gVE9ETyBnZW5lcmFsaXplP1xuICB2YXIgREFUVU0gPSAnZCc7XG4gIHZhciBTSUdOQUxfUFJFRklYID0gJ3NnLic7XG4gIHZhciBzaWduYWxzID0ge307XG4gIHZhciBmaWVsZHMgPSB7fTtcblxuICBmdW5jdGlvbiBjb2RlZ2VuX3dyYXAoYXN0KSB7ICAgIFxuICAgIHZhciByZXR2YWwgPSB7XG4gICAgICBmbjogY29kZWdlbihhc3QpLFxuICAgICAgc2lnbmFsczogZGwua2V5cyhzaWduYWxzKSxcbiAgICAgIGZpZWxkczogZGwua2V5cyhmaWVsZHMpXG4gICAgfTtcbiAgICBzaWduYWxzID0ge307XG4gICAgZmllbGRzID0ge307XG4gICAgcmV0dXJuIHJldHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvZGVnZW4oYXN0KSB7XG4gICAgaWYgKGFzdCBpbnN0YW5jZW9mIFN0cmluZykgcmV0dXJuIGFzdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gQ09ERUdFTl9UWVBFU1thc3QudHlwZV07XG4gICAgaWYgKGdlbmVyYXRvciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCB0eXBlOiBcIiArIGFzdC50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyYXRvcihhc3QpO1xuICB9XG5cbiAgdmFyIENPREVHRU5fVFlQRVMgPSB7XG4gICAgXCJMaXRlcmFsXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIG4ucmF3O1xuICAgICAgfSxcbiAgICBcIklkZW50aWZpZXJcIjogZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgaWQgPSBuLm5hbWU7XG4gICAgICAgIGlmIChtZW1iZXJEZXB0aCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0YW50cy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICByZXR1cm4gY29uc3RhbnRzW2lkXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRXaGl0ZUxpc3QpIHtcbiAgICAgICAgICBpZiAoaWRXaGl0ZUxpc3QuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25hbHNbaWRdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBTSUdOQUxfUFJFRklYICsgaWQ7IC8vIEhBQ0tpc2guLi5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkQmxhY2tMaXN0ICYmIGlkQmxhY2tMaXN0Lmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaWRlbnRpZmllcjogXCIgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfSxcbiAgICBcIlByb2dyYW1cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi5ib2R5Lm1hcChjb2RlZ2VuKS5qb2luKFwiXFxuXCIpO1xuICAgICAgfSxcbiAgICBcIk1lbWJlckV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICB2YXIgZCA9ICFuLmNvbXB1dGVkO1xuICAgICAgICB2YXIgbyA9IGNvZGVnZW4obi5vYmplY3QpO1xuICAgICAgICBpZiAoZCkgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgICAgdmFyIHAgPSBjb2RlZ2VuKG4ucHJvcGVydHkpO1xuICAgICAgICBpZiAobyA9PT0gREFUVU0pIHsgZmllbGRzW3BdID0gMTsgfSAvLyBIQUNLaXNoLi4uXG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCAtPSAxO1xuICAgICAgICByZXR1cm4gbyArIChkID8gXCIuXCIrcCA6IFwiW1wiK3ArXCJdXCIpO1xuICAgICAgfSxcbiAgICBcIkNhbGxFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgaWYgKG4uY2FsbGVlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjYWxsZWUgdHlwZTogXCIgKyBuLmNhbGxlZS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGVlID0gbi5jYWxsZWUubmFtZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBuLmFyZ3VtZW50cztcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb25zLmhhc093blByb3BlcnR5KGNhbGxlZSkgJiYgZnVuY3Rpb25zW2NhbGxlZV07XG4gICAgICAgIGlmICghZm4pIHRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXplZCBmdW5jdGlvbjogXCIgKyBjYWxsZWUpO1xuICAgICAgICByZXR1cm4gZm4gaW5zdGFuY2VvZiBGdW5jdGlvblxuICAgICAgICAgID8gZm4oYXJncylcbiAgICAgICAgICA6IGZuICsgXCIoXCIgKyBhcmdzLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIkFycmF5RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIltcIiArIG4uZWxlbWVudHMubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICB9LFxuICAgIFwiQmluYXJ5RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiVW5hcnlFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5hcmd1bWVudCkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJVcGRhdGVFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgKHByZWZpeFxuICAgICAgICAgID8gbi5vcGVyYXRvciArIGNvZGVnZW4obi5hcmd1bWVudClcbiAgICAgICAgICA6IGNvZGVnZW4obi5hcmd1bWVudCkgKyBuLm9wZXJhdG9yXG4gICAgICAgICkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBjb2RlZ2VuKG4udGVzdClcbiAgICAgICAgICArIFwiP1wiICsgY29kZWdlbihuLmNvbnNlcXVlbnQpXG4gICAgICAgICAgKyBcIjpcIiArIGNvZGVnZW4obi5hbHRlcm5hdGUpXG4gICAgICAgICAgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJMb2dpY2FsRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGNvZGVnZW4obi5sZWZ0KSArIG4ub3BlcmF0b3IgKyBjb2RlZ2VuKG4ucmlnaHQpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiT2JqZWN0RXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIntcIiArIG4ucHJvcGVydGllcy5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICAgIH0sXG4gICAgXCJQcm9wZXJ0eVwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICAgIHZhciBrID0gY29kZWdlbihuLmtleSk7XG4gICAgICAgIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBrICsgXCI6XCIgKyBjb2RlZ2VuKG4udmFsdWUpO1xuICAgICAgfSxcbiAgICBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gY29kZWdlbihuLmV4cHJlc3Npb24pO1xuICAgICAgfVxuICB9O1xuICBcbiAgcmV0dXJuIGNvZGVnZW5fd3JhcDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwiTmFOXCI6ICAgICBcIk5hTlwiLFxuICBcIkVcIjogICAgICAgXCJNYXRoLkVcIixcbiAgXCJMTjJcIjogICAgIFwiTWF0aC5MTjJcIixcbiAgXCJMTjEwXCI6ICAgIFwiTWF0aC5MTjEwXCIsXG4gIFwiTE9HMkVcIjogICBcIk1hdGguTE9HMkVcIixcbiAgXCJMT0cxMEVcIjogIFwiTWF0aC5MT0cxMEVcIixcbiAgXCJQSVwiOiAgICAgIFwiTWF0aC5QSVwiLFxuICBcIlNRUlQxXzJcIjogXCJNYXRoLlNRUlQxXzJcIixcbiAgXCJTUVJUMlwiOiAgIFwiTWF0aC5TUVJUMlwiXG59OyIsInZhciBkYXRhbGliID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvZGVnZW4pIHtcblxuICBmdW5jdGlvbiBmbmNhbGwobmFtZSwgYXJncywgY2FzdCwgdHlwZSkge1xuICAgIHZhciBvYmogPSBjb2RlZ2VuKGFyZ3NbMF0pO1xuICAgIGlmIChjYXN0KSB7XG4gICAgICBvYmogPSBjYXN0ICsgXCIoXCIgKyBvYmogKyBcIilcIjtcbiAgICAgIGlmIChkbC5zdGFydHNXaXRoKGNhc3QsIFwibmV3IFwiKSkgb2JqID0gXCIoXCIgKyBvYmogKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIG9iaiArIFwiLlwiICsgbmFtZSArICh0eXBlIDwgMCA/IFwiXCIgOiB0eXBlID09PSAwXG4gICAgICA/IFwiKClcIlxuICAgICAgOiBcIihcIiArIGFyZ3Muc2xpY2UoMSkubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCIpXCIpO1xuICB9XG4gIFxuICB2YXIgREFURSA9IFwibmV3IERhdGVcIjtcbiAgdmFyIFNUUklORyA9IFwiU3RyaW5nXCI7XG4gIHZhciBSRUdFWFAgPSBcIlJlZ0V4cFwiO1xuXG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICBcImlzTmFOXCI6ICAgIFwiaXNOYU5cIixcbiAgICBcImlzRmluaXRlXCI6IFwiaXNGaW5pdGVcIixcbiAgICBcImFic1wiOiAgICAgIFwiTWF0aC5hYnNcIixcbiAgICBcImFjb3NcIjogICAgIFwiTWF0aC5hY29zXCIsXG4gICAgXCJhc2luXCI6ICAgICBcIk1hdGguYXNpblwiLFxuICAgIFwiYXRhblwiOiAgICAgXCJNYXRoLmF0YW5cIixcbiAgICBcImF0YW4yXCI6ICAgIFwiTWF0aC5hdGFuMlwiLFxuICAgIFwiY2VpbFwiOiAgICAgXCJNYXRoLmNlaWxcIixcbiAgICBcImNvc1wiOiAgICAgIFwiTWF0aC5jb3NcIixcbiAgICBcImV4cFwiOiAgICAgIFwiTWF0aC5leHBcIixcbiAgICBcImZsb29yXCI6ICAgIFwiTWF0aC5mbG9vclwiLFxuICAgIFwibG9nXCI6ICAgICAgXCJNYXRoLmxvZ1wiLFxuICAgIFwibWF4XCI6ICAgICAgXCJNYXRoLm1heFwiLFxuICAgIFwibWluXCI6ICAgICAgXCJNYXRoLm1pblwiLFxuICAgIFwicG93XCI6ICAgICAgXCJNYXRoLnBvd1wiLFxuICAgIFwicmFuZG9tXCI6ICAgXCJNYXRoLnJhbmRvbVwiLFxuICAgIFwicm91bmRcIjogICAgXCJNYXRoLnJvdW5kXCIsXG4gICAgXCJzaW5cIjogICAgICBcIk1hdGguc2luXCIsXG4gICAgXCJzcXJ0XCI6ICAgICBcIk1hdGguc3FydFwiLFxuICAgIFwidGFuXCI6ICAgICAgXCJNYXRoLnRhblwiLFxuXG4gICAgLy8gREFURSBmdW5jdGlvbnNcbiAgICBcIm5vd1wiOiAgICAgIFwiRGF0ZS5ub3dcIixcbiAgICBcImRhdGV0aW1lXCI6IFwibmV3IERhdGVcIixcbiAgICBcImRhdGVcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0RGF0ZVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJkYXlcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0RGF5XCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInllYXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0RnVsbFllYXJcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwibW9udGhcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0TW9udGhcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwiaG91cnNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0SG91cnNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwibWludXRlc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRNaW51dGVzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInNlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0U2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJtaWxsaXNlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0TWlsbGlzZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInRpbWVcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VGltZVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ0aW1lem9uZW9mZnNldFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRUaW1lem9uZU9mZnNldFwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNkYXRlXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0RhdGVcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjZGF5XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0RheVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGN5ZWFyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0Z1bGxZZWFyXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y21vbnRoXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ01vbnRoXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y2hvdXJzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ0hvdXJzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y21pbnV0ZXNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDTWludXRlc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ1NlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjbWlsbGlzZWNvbmRzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFVUQ01pbGxpc2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG5cbiAgICAvLyBzaGFyZWQgc2VxdWVuY2UgZnVuY3Rpb25zXG4gICAgXCJsZW5ndGhcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwibGVuZ3RoXCIsIGFyZ3MsIG51bGwsIC0xKTtcbiAgICAgIH0sXG4gICAgXCJpbmRleG9mXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImluZGV4T2ZcIiwgYXJncywgbnVsbCk7XG4gICAgICB9LFxuICAgIFwibGFzdGluZGV4b2ZcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwibGFzdEluZGV4T2ZcIiwgYXJncywgbnVsbCk7XG4gICAgICB9LFxuXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgIFwicGFyc2VGbG9hdFwiOiBcInBhcnNlRmxvYXRcIixcbiAgICBcInBhcnNlSW50XCI6IFwicGFyc2VJbnRcIixcbiAgICBcInVwcGVyXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInRvVXBwZXJDYXNlXCIsIGFyZ3MsIFNUUklORywgMCk7XG4gICAgICB9LFxuICAgIFwibG93ZXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwidG9Mb3dlckNhc2VcIiwgYXJncywgU1RSSU5HLCAwKTtcbiAgICAgIH0sXG4gICAgXCJzbGljZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJzbGljZVwiLCBhcmdzLCBTVFJJTkcpO1xuICAgICAgfSxcbiAgICBcInN1YnN0cmluZ1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJzdWJzdHJpbmdcIiwgYXJncywgU1RSSU5HKTtcbiAgICAgIH0sXG5cbiAgICAvLyBSRUdFWFAgZnVuY3Rpb25zXG4gICAgXCJ0ZXN0XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInRlc3RcIiwgYXJncywgUkVHRVhQKTtcbiAgICAgIH0sXG4gICAgXG4gICAgLy8gQ29udHJvbCBGbG93IGZ1bmN0aW9uc1xuICAgIFwiaWZcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAzKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG9vIG1hbnkgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLlwiKTtcbiAgICAgICAgdmFyIGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgICAgcmV0dXJuIGFbMF0rXCI/XCIrYVsxXStcIjpcIithWzJdO1xuICAgICAgfVxuICB9O1xufTsiLCJ2YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZXInKSxcbiAgICBjb2RlZ2VuID0gcmVxdWlyZSgnLi9jb2RlZ2VuJyk7XG4gICAgXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0LCBvcHQpIHsgcmV0dXJuIHBhcnNlci5wYXJzZShcIihcIitpbnB1dCtcIilcIiwgb3B0KTsgfSxcbiAgY29kZTogZnVuY3Rpb24ob3B0KSB7IHJldHVybiBjb2RlZ2VuKG9wdCk7IH1cbn07XG4iLCIvKlxuICBUaGUgZm9sbG93aW5nIGV4cHJlc3Npb24gcGFyc2VyIGlzIGJhc2VkIG9uIEVzcHJpbWEgKGh0dHA6Ly9lc3ByaW1hLm9yZy8pLlxuICBPcmlnaW5hbCBoZWFkZXIgY29tbWVudCBhbmQgbGljZW5zZSBmb3IgRXNwcmltYSBpcyBpbmNsdWRlZCBoZXJlOlxuXG4gIENvcHlyaWdodCAoQykgMjAxMyBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIFRoYWRkZWUgVHlsIDx0aGFkZGVlLnR5bEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMyBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMiBNYXRoaWFzIEJ5bmVucyA8bWF0aGlhc0BxaXdpLmJlPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgSm9vc3QtV2ltIEJvZWtlc3RlaWpuIDxqb29zdC13aW1AYm9la2VzdGVpam4ubmw+XG4gIENvcHlyaWdodCAoQykgMjAxMiBLcmlzIEtvd2FsIDxrcmlzLmtvd2FsQGNpeGFyLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEFycGFkIEJvcnNvcyA8YXJwYWQuYm9yc29zQGdvb2dsZW1haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTEgQXJpeWEgSGlkYXlhdCA8YXJpeWEuaGlkYXlhdEBnbWFpbC5jb20+XG5cbiAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4gIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cbiAgVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4gIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4gIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFRva2VuLFxuICAgICAgVG9rZW5OYW1lLFxuICAgICAgU3ludGF4LFxuICAgICAgUHJvcGVydHlLaW5kLFxuICAgICAgTWVzc2FnZXMsXG4gICAgICBSZWdleCxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHN0cmljdCxcbiAgICAgIGluZGV4LFxuICAgICAgbGluZU51bWJlcixcbiAgICAgIGxpbmVTdGFydCxcbiAgICAgIGxlbmd0aCxcbiAgICAgIGxvb2thaGVhZCxcbiAgICAgIHN0YXRlLFxuICAgICAgZXh0cmE7XG5cbiAgVG9rZW4gPSB7XG4gICAgICBCb29sZWFuTGl0ZXJhbDogMSxcbiAgICAgIEVPRjogMixcbiAgICAgIElkZW50aWZpZXI6IDMsXG4gICAgICBLZXl3b3JkOiA0LFxuICAgICAgTnVsbExpdGVyYWw6IDUsXG4gICAgICBOdW1lcmljTGl0ZXJhbDogNixcbiAgICAgIFB1bmN0dWF0b3I6IDcsXG4gICAgICBTdHJpbmdMaXRlcmFsOiA4LFxuICAgICAgUmVndWxhckV4cHJlc3Npb246IDlcbiAgfTtcblxuICBUb2tlbk5hbWUgPSB7fTtcbiAgVG9rZW5OYW1lW1Rva2VuLkJvb2xlYW5MaXRlcmFsXSA9ICdCb29sZWFuJztcbiAgVG9rZW5OYW1lW1Rva2VuLkVPRl0gPSAnPGVuZD4nO1xuICBUb2tlbk5hbWVbVG9rZW4uSWRlbnRpZmllcl0gPSAnSWRlbnRpZmllcic7XG4gIFRva2VuTmFtZVtUb2tlbi5LZXl3b3JkXSA9ICdLZXl3b3JkJztcbiAgVG9rZW5OYW1lW1Rva2VuLk51bGxMaXRlcmFsXSA9ICdOdWxsJztcbiAgVG9rZW5OYW1lW1Rva2VuLk51bWVyaWNMaXRlcmFsXSA9ICdOdW1lcmljJztcbiAgVG9rZW5OYW1lW1Rva2VuLlB1bmN0dWF0b3JdID0gJ1B1bmN0dWF0b3InO1xuICBUb2tlbk5hbWVbVG9rZW4uU3RyaW5nTGl0ZXJhbF0gPSAnU3RyaW5nJztcbiAgVG9rZW5OYW1lW1Rva2VuLlJlZ3VsYXJFeHByZXNzaW9uXSA9ICdSZWd1bGFyRXhwcmVzc2lvbic7XG5cbiAgU3ludGF4ID0ge1xuICAgICAgQXNzaWdubWVudEV4cHJlc3Npb246ICdBc3NpZ25tZW50RXhwcmVzc2lvbicsXG4gICAgICBBcnJheUV4cHJlc3Npb246ICdBcnJheUV4cHJlc3Npb24nLFxuICAgICAgQmluYXJ5RXhwcmVzc2lvbjogJ0JpbmFyeUV4cHJlc3Npb24nLFxuICAgICAgQ2FsbEV4cHJlc3Npb246ICdDYWxsRXhwcmVzc2lvbicsXG4gICAgICBDb25kaXRpb25hbEV4cHJlc3Npb246ICdDb25kaXRpb25hbEV4cHJlc3Npb24nLFxuICAgICAgRXhwcmVzc2lvblN0YXRlbWVudDogJ0V4cHJlc3Npb25TdGF0ZW1lbnQnLFxuICAgICAgSWRlbnRpZmllcjogJ0lkZW50aWZpZXInLFxuICAgICAgTGl0ZXJhbDogJ0xpdGVyYWwnLFxuICAgICAgTG9naWNhbEV4cHJlc3Npb246ICdMb2dpY2FsRXhwcmVzc2lvbicsXG4gICAgICBNZW1iZXJFeHByZXNzaW9uOiAnTWVtYmVyRXhwcmVzc2lvbicsXG4gICAgICBPYmplY3RFeHByZXNzaW9uOiAnT2JqZWN0RXhwcmVzc2lvbicsXG4gICAgICBQcm9ncmFtOiAnUHJvZ3JhbScsXG4gICAgICBQcm9wZXJ0eTogJ1Byb3BlcnR5JyxcbiAgICAgIFVuYXJ5RXhwcmVzc2lvbjogJ1VuYXJ5RXhwcmVzc2lvbicsXG4gICAgICBVcGRhdGVFeHByZXNzaW9uOiAnVXBkYXRlRXhwcmVzc2lvbidcbiAgfTtcblxuICBQcm9wZXJ0eUtpbmQgPSB7XG4gICAgICBEYXRhOiAxLFxuICAgICAgR2V0OiAyLFxuICAgICAgU2V0OiA0XG4gIH07XG5cbiAgLy8gRXJyb3IgbWVzc2FnZXMgc2hvdWxkIGJlIGlkZW50aWNhbCB0byBWOC5cbiAgTWVzc2FnZXMgPSB7XG4gICAgICBVbmV4cGVjdGVkVG9rZW46ICAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXG4gICAgICBVbmV4cGVjdGVkTnVtYmVyOiAgJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgICAgIFVuZXhwZWN0ZWRTdHJpbmc6ICAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICAgICAgVW5leHBlY3RlZElkZW50aWZpZXI6ICAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcbiAgICAgIFVuZXhwZWN0ZWRSZXNlcnZlZDogICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICAgICAgVW5leHBlY3RlZEVPUzogICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gICAgICBOZXdsaW5lQWZ0ZXJUaHJvdzogICdJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cnLFxuICAgICAgSW52YWxpZFJlZ0V4cDogJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgICAgIFVudGVybWluYXRlZFJlZ0V4cDogICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJyxcbiAgICAgIEludmFsaWRMSFNJbkFzc2lnbm1lbnQ6ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBhc3NpZ25tZW50JyxcbiAgICAgIEludmFsaWRMSFNJbkZvckluOiAgJ0ludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gZm9yLWluJyxcbiAgICAgIE11bHRpcGxlRGVmYXVsdHNJblN3aXRjaDogJ01vcmUgdGhhbiBvbmUgZGVmYXVsdCBjbGF1c2UgaW4gc3dpdGNoIHN0YXRlbWVudCcsXG4gICAgICBOb0NhdGNoT3JGaW5hbGx5OiAgJ01pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBhZnRlciB0cnknLFxuICAgICAgVW5rbm93bkxhYmVsOiAnVW5kZWZpbmVkIGxhYmVsIFxcJyUwXFwnJyxcbiAgICAgIFJlZGVjbGFyYXRpb246ICclMCBcXCclMVxcJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkJyxcbiAgICAgIElsbGVnYWxDb250aW51ZTogJ0lsbGVnYWwgY29udGludWUgc3RhdGVtZW50JyxcbiAgICAgIElsbGVnYWxCcmVhazogJ0lsbGVnYWwgYnJlYWsgc3RhdGVtZW50JyxcbiAgICAgIElsbGVnYWxSZXR1cm46ICdJbGxlZ2FsIHJldHVybiBzdGF0ZW1lbnQnLFxuICAgICAgU3RyaWN0TW9kZVdpdGg6ICAnU3RyaWN0IG1vZGUgY29kZSBtYXkgbm90IGluY2x1ZGUgYSB3aXRoIHN0YXRlbWVudCcsXG4gICAgICBTdHJpY3RDYXRjaFZhcmlhYmxlOiAgJ0NhdGNoIHZhcmlhYmxlIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0VmFyTmFtZTogICdWYXJpYWJsZSBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UGFyYW1OYW1lOiAgJ1BhcmFtZXRlciBuYW1lIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFBhcmFtRHVwZTogJ1N0cmljdCBtb2RlIGZ1bmN0aW9uIG1heSBub3QgaGF2ZSBkdXBsaWNhdGUgcGFyYW1ldGVyIG5hbWVzJyxcbiAgICAgIFN0cmljdEZ1bmN0aW9uTmFtZTogICdGdW5jdGlvbiBuYW1lIG1heSBub3QgYmUgZXZhbCBvciBhcmd1bWVudHMgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0T2N0YWxMaXRlcmFsOiAgJ09jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS4nLFxuICAgICAgU3RyaWN0RGVsZXRlOiAgJ0RlbGV0ZSBvZiBhbiB1bnF1YWxpZmllZCBpZGVudGlmaWVyIGluIHN0cmljdCBtb2RlLicsXG4gICAgICBTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eTogICdEdXBsaWNhdGUgZGF0YSBwcm9wZXJ0eSBpbiBvYmplY3QgbGl0ZXJhbCBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBBY2Nlc3NvckRhdGFQcm9wZXJ0eTogICdPYmplY3QgbGl0ZXJhbCBtYXkgbm90IGhhdmUgZGF0YSBhbmQgYWNjZXNzb3IgcHJvcGVydHkgd2l0aCB0aGUgc2FtZSBuYW1lJyxcbiAgICAgIEFjY2Vzc29yR2V0U2V0OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBtdWx0aXBsZSBnZXQvc2V0IGFjY2Vzc29ycyB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgU3RyaWN0TEhTQXNzaWdubWVudDogICdBc3NpZ25tZW50IHRvIGV2YWwgb3IgYXJndW1lbnRzIGlzIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdExIU1Bvc3RmaXg6ICAnUG9zdGZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdExIU1ByZWZpeDogICdQcmVmaXggaW5jcmVtZW50L2RlY3JlbWVudCBtYXkgbm90IGhhdmUgZXZhbCBvciBhcmd1bWVudHMgb3BlcmFuZCBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RSZXNlcnZlZFdvcmQ6ICAnVXNlIG9mIGZ1dHVyZSByZXNlcnZlZCB3b3JkIGluIHN0cmljdCBtb2RlJ1xuICB9O1xuXG4gIC8vIFNlZSBhbHNvIHRvb2xzL2dlbmVyYXRlLXVuaWNvZGUtcmVnZXgucHkuXG4gIFJlZ2V4ID0ge1xuICAgICAgTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYyMC1cXHUwNjRBXFx1MDY2RVxcdTA2NkZcXHUwNjcxLVxcdTA2RDNcXHUwNkQ1XFx1MDZFNVxcdTA2RTZcXHUwNkVFXFx1MDZFRlxcdTA2RkEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMVxcdTA3Q0EtXFx1MDdFQVxcdTA3RjRcXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgxNVxcdTA4MUFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4QTAtXFx1MDhCMlxcdTA5MDQtXFx1MDkzOVxcdTA5M0RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCRFxcdTA5Q0VcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFMVxcdTA5RjBcXHUwOUYxXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE3Mi1cXHUwQTc0XFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJEXFx1MEFEMFxcdTBBRTBcXHUwQUUxXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OFxcdTBDNTlcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ2MFxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y0XFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlDMS1cXHUxOUM3XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkNDXFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgwMVxcdUE4MDMtXFx1QTgwNVxcdUE4MDctXFx1QTgwQVxcdUE4MEMtXFx1QTgyMlxcdUE4NDAtXFx1QTg3M1xcdUE4ODItXFx1QThCM1xcdUE4RjItXFx1QThGN1xcdUE4RkJcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjVGXFx1QUI2NFxcdUFCNjVcXHVBQkMwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJyksXG4gICAgICBOb25Bc2NpaUlkZW50aWZpZXJQYXJ0OiBuZXcgUmVnRXhwKCdbXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEIyXFx1MDhFNC1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEIwMS1cXHUwQjAzXFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0MtXFx1MEI0NFxcdTBCNDdcXHUwQjQ4XFx1MEI0Qi1cXHUwQjREXFx1MEI1NlxcdTBCNTdcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2M1xcdTBCNjYtXFx1MEI2RlxcdTBCNzFcXHUwQjgyXFx1MEI4M1xcdTBCODUtXFx1MEI4QVxcdTBCOEUtXFx1MEI5MFxcdTBCOTItXFx1MEI5NVxcdTBCOTlcXHUwQjlBXFx1MEI5Q1xcdTBCOUVcXHUwQjlGXFx1MEJBM1xcdTBCQTRcXHUwQkE4LVxcdTBCQUFcXHUwQkFFLVxcdTBCQjlcXHUwQkJFLVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0RcXHUwQkQwXFx1MEJEN1xcdTBCRTYtXFx1MEJFRlxcdTBDMDAtXFx1MEMwM1xcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0QtXFx1MEM0NFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM1OFxcdTBDNTlcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgxLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTdcXHUwRDYwLVxcdTBENjNcXHUwRDY2LVxcdTBENkZcXHUwRDdBLVxcdTBEN0ZcXHUwRDgyXFx1MEQ4M1xcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRENBXFx1MERDRi1cXHUwREQ0XFx1MERENlxcdTBERDgtXFx1MERERlxcdTBERTYtXFx1MERFRlxcdTBERjJcXHUwREYzXFx1MEUwMS1cXHUwRTNBXFx1MEU0MC1cXHUwRTRFXFx1MEU1MC1cXHUwRTU5XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjlcXHUwRUJCLVxcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVDOC1cXHUwRUNEXFx1MEVEMC1cXHUwRUQ5XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjI5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEYzRS1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY3MS1cXHUwRjg0XFx1MEY4Ni1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMDAtXFx1MTA0OVxcdTEwNTAtXFx1MTA5RFxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzVELVxcdTEzNUZcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTRcXHUxNzIwLVxcdTE3MzRcXHUxNzQwLVxcdTE3NTNcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdEM1xcdTE3RDdcXHUxN0RDXFx1MTdERFxcdTE3RTAtXFx1MTdFOVxcdTE4MEItXFx1MTgwRFxcdTE4MTAtXFx1MTgxOVxcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5MjAtXFx1MTkyQlxcdTE5MzAtXFx1MTkzQlxcdTE5NDYtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTE5RDAtXFx1MTlEOVxcdTFBMDAtXFx1MUExQlxcdTFBMjAtXFx1MUE1RVxcdTFBNjAtXFx1MUE3Q1xcdTFBN0YtXFx1MUE4OVxcdTFBOTAtXFx1MUE5OVxcdTFBQTdcXHUxQUIwLVxcdTFBQkRcXHUxQjAwLVxcdTFCNEJcXHUxQjUwLVxcdTFCNTlcXHUxQjZCLVxcdTFCNzNcXHUxQjgwLVxcdTFCRjNcXHUxQzAwLVxcdTFDMzdcXHUxQzQwLVxcdTFDNDlcXHUxQzRELVxcdTFDN0RcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRjZcXHUxQ0Y4XFx1MUNGOVxcdTFEMDAtXFx1MURGNVxcdTFERkMtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDBDXFx1MjAwRFxcdTIwM0ZcXHUyMDQwXFx1MjA1NFxcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjBEMC1cXHUyMERDXFx1MjBFMVxcdTIwRTUtXFx1MjBGMFxcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDdGLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyREUwLVxcdTJERkZcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDJGXFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5OVxcdTMwOUFcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MkJcXHVBNjQwLVxcdUE2NkZcXHVBNjc0LVxcdUE2N0RcXHVBNjdGLVxcdUE2OURcXHVBNjlGLVxcdUE2RjFcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3OEVcXHVBNzkwLVxcdUE3QURcXHVBN0IwXFx1QTdCMVxcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNFxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFQVxcdUFCRUNcXHVBQkVEXFx1QUJGMC1cXHVBQkY5XFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRC1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkRcXHVGRTMzXFx1RkUzNFxcdUZFNEQtXFx1RkU0RlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMTAtXFx1RkYxOVxcdUZGMjEtXFx1RkYzQVxcdUZGM0ZcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdJylcbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4gIC8vIFRoaXMgaXMgb25seSB0byBoYXZlIGEgYmV0dGVyIGNvbnRyYWN0IHNlbWFudGljLCBpLmUuIGFub3RoZXIgc2FmZXR5IG5ldFxuICAvLyB0byBjYXRjaCBhIGxvZ2ljIGVycm9yLiBUaGUgY29uZGl0aW9uIHNoYWxsIGJlIGZ1bGZpbGxlZCBpbiBub3JtYWwgY2FzZS5cbiAgLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0RlY2ltYWxEaWdpdChjaCkge1xuICAgICAgcmV0dXJuIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpOyAgIC8vIDAuLjlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgICAgIHJldHVybiAnMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRicuaW5kZXhPZihjaCkgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT2N0YWxEaWdpdChjaCkge1xuICAgICAgcmV0dXJuICcwMTIzNDU2NycuaW5kZXhPZihjaCkgPj0gMDtcbiAgfVxuXG4gIC8vIDcuMiBXaGl0ZSBTcGFjZVxuXG4gIGZ1bmN0aW9uIGlzV2hpdGVTcGFjZShjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyMCkgfHwgKGNoID09PSAweDA5KSB8fCAoY2ggPT09IDB4MEIpIHx8IChjaCA9PT0gMHgwQykgfHwgKGNoID09PSAweEEwKSB8fFxuICAgICAgICAgIChjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmRleE9mKGNoKSA+PSAwKTtcbiAgfVxuXG4gIC8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbiAgZnVuY3Rpb24gaXNMaW5lVGVybWluYXRvcihjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgwQSkgfHwgKGNoID09PSAweDBEKSB8fCAoY2ggPT09IDB4MjAyOCkgfHwgKGNoID09PSAweDIwMjkpO1xuICB9XG5cbiAgLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY2gpIHtcbiAgICAgIHJldHVybiAoY2ggPT09IDB4MjQpIHx8IChjaCA9PT0gMHg1RikgfHwgIC8vICQgKGRvbGxhcikgYW5kIF8gKHVuZGVyc2NvcmUpXG4gICAgICAgICAgKGNoID49IDB4NDEgJiYgY2ggPD0gMHg1QSkgfHwgICAgICAgICAvLyBBLi5aXG4gICAgICAgICAgKGNoID49IDB4NjEgJiYgY2ggPD0gMHg3QSkgfHwgICAgICAgICAvLyBhLi56XG4gICAgICAgICAgKGNoID09PSAweDVDKSB8fCAgICAgICAgICAgICAgICAgICAgICAvLyBcXCAoYmFja3NsYXNoKVxuICAgICAgICAgICgoY2ggPj0gMHg4MCkgJiYgUmVnZXguTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNJZGVudGlmaWVyUGFydChjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAoY2ggPj0gMHgzMCAmJiBjaCA8PSAweDM5KSB8fCAgICAgICAgIC8vIDAuLjlcbiAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpKTtcbiAgfVxuXG4gIC8vIDcuNi4xLjIgRnV0dXJlIFJlc2VydmVkIFdvcmRzXG5cbiAgZnVuY3Rpb24gaXNGdXR1cmVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgIGNhc2UgJ2NsYXNzJzpcbiAgICAgIGNhc2UgJ2VudW0nOlxuICAgICAgY2FzZSAnZXhwb3J0JzpcbiAgICAgIGNhc2UgJ2V4dGVuZHMnOlxuICAgICAgY2FzZSAnaW1wb3J0JzpcbiAgICAgIGNhc2UgJ3N1cGVyJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKGlkKSB7XG4gICAgICBzd2l0Y2ggKGlkKSB7XG4gICAgICBjYXNlICdpbXBsZW1lbnRzJzpcbiAgICAgIGNhc2UgJ2ludGVyZmFjZSc6XG4gICAgICBjYXNlICdwYWNrYWdlJzpcbiAgICAgIGNhc2UgJ3ByaXZhdGUnOlxuICAgICAgY2FzZSAncHJvdGVjdGVkJzpcbiAgICAgIGNhc2UgJ3B1YmxpYyc6XG4gICAgICBjYXNlICdzdGF0aWMnOlxuICAgICAgY2FzZSAneWllbGQnOlxuICAgICAgY2FzZSAnbGV0JzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG4gIGZ1bmN0aW9uIGlzS2V5d29yZChpZCkge1xuICAgICAgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vICdjb25zdCcgaXMgc3BlY2lhbGl6ZWQgYXMgS2V5d29yZCBpbiBWOC5cbiAgICAgIC8vICd5aWVsZCcgYW5kICdsZXQnIGFyZSBmb3IgY29tcGF0aWJsaXR5IHdpdGggU3BpZGVyTW9ua2V5IGFuZCBFUy5uZXh0LlxuICAgICAgLy8gU29tZSBvdGhlcnMgYXJlIGZyb20gZnV0dXJlIHJlc2VydmVkIHdvcmRzLlxuXG4gICAgICBzd2l0Y2ggKGlkLmxlbmd0aCkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpZicpIHx8IChpZCA9PT0gJ2luJykgfHwgKGlkID09PSAnZG8nKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAndmFyJykgfHwgKGlkID09PSAnZm9yJykgfHwgKGlkID09PSAnbmV3JykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndHJ5JykgfHwgKGlkID09PSAnbGV0Jyk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3RoaXMnKSB8fCAoaWQgPT09ICdlbHNlJykgfHwgKGlkID09PSAnY2FzZScpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3ZvaWQnKSB8fCAoaWQgPT09ICd3aXRoJykgfHwgKGlkID09PSAnZW51bScpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd3aGlsZScpIHx8IChpZCA9PT0gJ2JyZWFrJykgfHwgKGlkID09PSAnY2F0Y2gnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd0aHJvdycpIHx8IChpZCA9PT0gJ2NvbnN0JykgfHwgKGlkID09PSAneWllbGQnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICdjbGFzcycpIHx8IChpZCA9PT0gJ3N1cGVyJyk7XG4gICAgICBjYXNlIDY6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3JldHVybicpIHx8IChpZCA9PT0gJ3R5cGVvZicpIHx8IChpZCA9PT0gJ2RlbGV0ZScpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3N3aXRjaCcpIHx8IChpZCA9PT0gJ2V4cG9ydCcpIHx8IChpZCA9PT0gJ2ltcG9ydCcpO1xuICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdkZWZhdWx0JykgfHwgKGlkID09PSAnZmluYWxseScpIHx8IChpZCA9PT0gJ2V4dGVuZHMnKTtcbiAgICAgIGNhc2UgODpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAnZnVuY3Rpb24nKSB8fCAoaWQgPT09ICdjb250aW51ZScpIHx8IChpZCA9PT0gJ2RlYnVnZ2VyJyk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdpbnN0YW5jZW9mJyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNraXBDb21tZW50KCkge1xuICAgICAgdmFyIGNoLCBzdGFydDtcblxuICAgICAgc3RhcnQgPSAoaW5kZXggPT09IDApO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZVNwYWNlKGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAweDBEICYmIHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgwQSkge1xuICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICBzdGFydCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhbkhleEVzY2FwZShwcmVmaXgpIHtcbiAgICAgIHZhciBpLCBsZW4sIGNoLCBjb2RlID0gMDtcblxuICAgICAgbGVuID0gKHByZWZpeCA9PT0gJ3UnKSA/IDQgOiAyO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgICAgIHZhciBjaCwgY29kZSwgY3UxLCBjdTI7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGNvZGUgPSAwO1xuXG4gICAgICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cbiAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb2RlID0gY29kZSAqIDE2ICsgJzAxMjM0NTY3ODlhYmNkZWYnLmluZGV4T2YoY2gudG9Mb3dlckNhc2UoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgLy8gVVRGLTE2IEVuY29kaW5nXG4gICAgICBpZiAoY29kZSA8PSAweEZGRkYpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgIH1cbiAgICAgIGN1MSA9ICgoY29kZSAtIDB4MTAwMDApID4+IDEwKSArIDB4RDgwMDtcbiAgICAgIGN1MiA9ICgoY29kZSAtIDB4MTAwMDApICYgMTAyMykgKyAweERDMDA7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjdTEsIGN1Mik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFc2NhcGVkSWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBjaCwgaWQ7XG5cbiAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgrKyk7XG4gICAgICBpZCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclN0YXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWQgPSBjaDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAgICAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIHN0YXJ0LCBjaDtcblxuICAgICAgc3RhcnQgPSBpbmRleCsrO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAgICAgICAgIC8vIEJsYWNrc2xhc2ggKFUrMDA1QykgbWFya3MgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgIGluZGV4ID0gc3RhcnQ7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRFc2NhcGVkSWRlbnRpZmllcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5JZGVudGlmaWVyKCkge1xuICAgICAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcblxuICAgICAgLy8gQmFja3NsYXNoIChVKzAwNUMpIHN0YXJ0cyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIGlkID0gKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QykgPyBnZXRFc2NhcGVkSWRlbnRpZmllcigpIDogZ2V0SWRlbnRpZmllcigpO1xuXG4gICAgICAvLyBUaGVyZSBpcyBubyBrZXl3b3JkIG9yIGxpdGVyYWwgd2l0aCBvbmx5IG9uZSBjaGFyYWN0ZXIuXG4gICAgICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gICAgICBpZiAoaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICB9IGVsc2UgaWYgKGlzS2V5d29yZChpZCkpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uS2V5d29yZDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICdudWxsJykge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5OdWxsTGl0ZXJhbDtcbiAgICAgIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLklkZW50aWZpZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogaWQsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIC8vIDcuNyBQdW5jdHVhdG9yc1xuXG4gIGZ1bmN0aW9uIHNjYW5QdW5jdHVhdG9yKCkge1xuICAgICAgdmFyIHN0YXJ0ID0gaW5kZXgsXG4gICAgICAgICAgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSxcbiAgICAgICAgICBjb2RlMixcbiAgICAgICAgICBjaDEgPSBzb3VyY2VbaW5kZXhdLFxuICAgICAgICAgIGNoMixcbiAgICAgICAgICBjaDMsXG4gICAgICAgICAgY2g0O1xuXG4gICAgICBzd2l0Y2ggKGNvZGUpIHtcblxuICAgICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgICBjYXNlIDB4MkU6ICAvLyAuIGRvdFxuICAgICAgY2FzZSAweDI4OiAgLy8gKCBvcGVuIGJyYWNrZXRcbiAgICAgIGNhc2UgMHgyOTogIC8vICkgY2xvc2UgYnJhY2tldFxuICAgICAgY2FzZSAweDNCOiAgLy8gOyBzZW1pY29sb25cbiAgICAgIGNhc2UgMHgyQzogIC8vICwgY29tbWFcbiAgICAgIGNhc2UgMHg3QjogIC8vIHsgb3BlbiBjdXJseSBicmFjZVxuICAgICAgY2FzZSAweDdEOiAgLy8gfSBjbG9zZSBjdXJseSBicmFjZVxuICAgICAgY2FzZSAweDVCOiAgLy8gW1xuICAgICAgY2FzZSAweDVEOiAgLy8gXVxuICAgICAgY2FzZSAweDNBOiAgLy8gOlxuICAgICAgY2FzZSAweDNGOiAgLy8gP1xuICAgICAgY2FzZSAweDdFOiAgLy8gflxuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgaWYgKGV4dHJhLnRva2VuaXplKSB7XG4gICAgICAgICAgICAgIGlmIChjb2RlID09PSAweDI4KSB7XG4gICAgICAgICAgICAgICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg3Qikge1xuICAgICAgICAgICAgICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSBleHRyYS50b2tlbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb2RlMiA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICAgICAgICAvLyAnPScgKFUrMDAzRCkgbWFya3MgYW4gYXNzaWdubWVudCBvciBjb21wYXJpc29uIG9wZXJhdG9yLlxuICAgICAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAweDJCOiAgLy8gK1xuICAgICAgICAgICAgICBjYXNlIDB4MkQ6ICAvLyAtXG4gICAgICAgICAgICAgIGNhc2UgMHgyRjogIC8vIC9cbiAgICAgICAgICAgICAgY2FzZSAweDNDOiAgLy8gPFxuICAgICAgICAgICAgICBjYXNlIDB4M0U6ICAvLyA+XG4gICAgICAgICAgICAgIGNhc2UgMHg1RTogIC8vIF5cbiAgICAgICAgICAgICAgY2FzZSAweDdDOiAgLy8gfFxuICAgICAgICAgICAgICBjYXNlIDB4MjU6ICAvLyAlXG4gICAgICAgICAgICAgIGNhc2UgMHgyNjogIC8vICZcbiAgICAgICAgICAgICAgY2FzZSAweDJBOiAgLy8gKlxuICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgY2FzZSAweDIxOiAvLyAhXG4gICAgICAgICAgICAgIGNhc2UgMHgzRDogLy8gPVxuICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgICAgICAgICAgICAgLy8gIT09IGFuZCA9PT1cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyA0LWNoYXJhY3RlciBwdW5jdHVhdG9yOiA+Pj49XG5cbiAgICAgIGNoNCA9IHNvdXJjZS5zdWJzdHIoaW5kZXgsIDQpO1xuXG4gICAgICBpZiAoY2g0ID09PSAnPj4+PScpIHtcbiAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDQsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAzLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPT09ICE9PSA+Pj4gPDw9ID4+PVxuXG4gICAgICBjaDMgPSBjaDQuc3Vic3RyKDAsIDMpO1xuXG4gICAgICBpZiAoY2gzID09PSAnPj4+JyB8fCBjaDMgPT09ICc8PD0nIHx8IGNoMyA9PT0gJz4+PScpIHtcbiAgICAgICAgICBpbmRleCArPSAzO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDMsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlciAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogKysgLS0gPDwgPj4gJiYgfHxcbiAgICAgIGNoMiA9IGNoMy5zdWJzdHIoMCwgMik7XG5cbiAgICAgIGlmICgoY2gxID09PSBjaDJbMV0gJiYgKCcrLTw+JnwnLmluZGV4T2YoY2gxKSA+PSAwKSkgfHwgY2gyID09PSAnPT4nKSB7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gyLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gMS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6IDwgPiA9ICEgKyAtICogJSAmIHwgXiAvXG5cbiAgICAgIGlmICgnPD49ISstKiUmfF4vJy5pbmRleE9mKGNoMSkgPj0gMCkge1xuICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMSxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgfVxuXG4gIC8vIDcuOC4zIE51bWVyaWMgTGl0ZXJhbHNcblxuICBmdW5jdGlvbiBzY2FuSGV4TGl0ZXJhbChzdGFydCkge1xuICAgICAgdmFyIG51bWJlciA9ICcnO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICB9XG5cbiAgICAgIGlmIChudW1iZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQoJzB4JyArIG51bWJlciwgMTYpLFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICB2YXIgbnVtYmVyID0gJzAnICsgc291cmNlW2luZGV4KytdO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgICAgICAgb2N0YWw6IHRydWUsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgICAgIHZhciBudW1iZXIsIHN0YXJ0LCBjaDtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpIHx8IChjaCA9PT0gJy4nKSxcbiAgICAgICAgICAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICBudW1iZXIgPSAnJztcbiAgICAgIGlmIChjaCAhPT0gJy4nKSB7XG4gICAgICAgICAgbnVtYmVyID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcblxuICAgICAgICAgIC8vIEhleCBudW1iZXIgc3RhcnRzIHdpdGggJzB4Jy5cbiAgICAgICAgICAvLyBPY3RhbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnLlxuICAgICAgICAgIGlmIChudW1iZXIgPT09ICcwJykge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICd4JyB8fCBjaCA9PT0gJ1gnKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gZGVjaW1hbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnIHN1Y2ggYXMgJzA5JyBpcyBpbGxlZ2FsLlxuICAgICAgICAgICAgICBpZiAoY2ggJiYgaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgaWYgKGNoID09PSAnKycgfHwgY2ggPT09ICctJykge1xuICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIC8vIDcuOC40IFN0cmluZyBMaXRlcmFsc1xuXG4gIGZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICAgICAgdmFyIHN0ciA9ICcnLCBxdW90ZSwgc3RhcnQsIGNoLCBjb2RlLCB1bmVzY2FwZWQsIHJlc3RvcmUsIG9jdGFsID0gZmFsc2UsIHN0YXJ0TGluZU51bWJlciwgc3RhcnRMaW5lU3RhcnQ7XG4gICAgICBzdGFydExpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnRMaW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG5cbiAgICAgIHF1b3RlID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydCgocXVvdGUgPT09ICdcXCcnIHx8IHF1b3RlID09PSAnXCInKSxcbiAgICAgICAgICAnU3RyaW5nIGxpdGVyYWwgbXVzdCBzdGFydHMgd2l0aCBhIHF1b3RlJyk7XG5cbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG4gICAgICArK2luZGV4O1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgIGlmIChjaCA9PT0gcXVvdGUpIHtcbiAgICAgICAgICAgICAgcXVvdGUgPSAnJztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICBpZiAoIWNoIHx8ICFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICB1bmVzY2FwZWQgPSBzY2FuSGV4RXNjYXBlKGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IHVuZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gcmVzdG9yZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxyJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx0JztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxmJztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFx4MEInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSAnMDEyMzQ1NjcnLmluZGV4T2YoY2gpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFxcMCBpcyBub3Qgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvY3RhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29kZSAqIDggKyAnMDEyMzQ1NjcnLmluZGV4T2Yoc291cmNlW2luZGV4KytdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggMCwgMSwgMiwgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCcwMTIzJy5pbmRleE9mKGNoKSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IDwgbGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICArK2xpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICAnXFxyJyAmJiBzb3VyY2VbaW5kZXhdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsaW5lU3RhcnQgPSBpbmRleDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocXVvdGUgIT09ICcnKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLlN0cmluZ0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHN0cixcbiAgICAgICAgICBvY3RhbDogb2N0YWwsXG4gICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgc3RhcnRMaW5lU3RhcnQ6IHN0YXJ0TGluZVN0YXJ0LFxuICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gICAgICB2YXIgdG1wID0gcGF0dGVybixcbiAgICAgICAgICB2YWx1ZTtcblxuICAgICAgaWYgKGZsYWdzLmluZGV4T2YoJ3UnKSA+PSAwKSB7XG4gICAgICAgICAgLy8gUmVwbGFjZSBlYWNoIGFzdHJhbCBzeW1ib2wgYW5kIGV2ZXJ5IFVuaWNvZGUgY29kZSBwb2ludFxuICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZSB3aXRoIGEgc2luZ2xlIEFTQ0lJIHN5bWJvbCB0byBhdm9pZCB0aHJvd2luZyBvblxuICAgICAgICAgIC8vIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZVxuICAgICAgICAgIC8vIGAvdWAgZmxhZy5cbiAgICAgICAgICAvLyBOb3RlOiByZXBsYWNpbmcgd2l0aCB0aGUgQVNDSUkgc3ltYm9sIGB4YCBtaWdodCBjYXVzZSBmYWxzZVxuICAgICAgICAgIC8vIG5lZ2F0aXZlcyBpbiB1bmxpa2VseSBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXs2MX0tYl1gIGlzIGFcbiAgICAgICAgICAvLyBwZXJmZWN0bHkgdmFsaWQgcGF0dGVybiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYFthLWJdYCwgYnV0IGl0XG4gICAgICAgICAgLy8gd291bGQgYmUgcmVwbGFjZWQgYnkgYFt4LWJdYCB3aGljaCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgICAgdG1wID0gdG1wXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZUludCgkMSwgMTYpIDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd4JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLkludmFsaWRSZWdFeHApO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgZGV0ZWN0IGludmFsaWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSBuZXcgUmVnRXhwKHRtcCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgZm9yIHRoaXMgcGF0dGVybi1mbGFnIHBhaXIsIG9yXG4gICAgICAvLyBgbnVsbGAgaW4gY2FzZSB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgdGhlIGZsYWdzIGl0XG4gICAgICAvLyB1c2VzLlxuICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncyk7XG4gICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICAgICAgdmFyIGNoLCBzdHIsIGNsYXNzTWFya2VyLCB0ZXJtaW5hdGVkLCBib2R5O1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoY2ggPT09ICcvJywgJ1JlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIHNsYXNoJyk7XG4gICAgICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG5cbiAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICB0ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICBzdHIgKz0gY2g7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICAgICAgICAgIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTWFya2VyKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgICAgY2xhc3NNYXJrZXIgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRlcm1pbmF0ZWQpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgfVxuXG4gICAgICAvLyBFeGNsdWRlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogYm9keSxcbiAgICAgICAgICBsaXRlcmFsOiBzdHJcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuUmVnRXhwRmxhZ3MoKSB7XG4gICAgICB2YXIgY2gsIHN0ciwgZmxhZ3MsIHJlc3RvcmU7XG5cbiAgICAgIHN0ciA9ICcnO1xuICAgICAgZmxhZ3MgPSAnJztcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgcmVzdG9yZSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgY2ggPSBzY2FuSGV4RXNjYXBlKCd1Jyk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHN0ciArPSAnXFxcXHUnOyByZXN0b3JlIDwgaW5kZXg7ICsrcmVzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc291cmNlW3Jlc3RvcmVdO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9ICd1JztcbiAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx1JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmxhZ3MgKz0gY2g7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGZsYWdzLFxuICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gICAgICB2YXIgc3RhcnQsIGJvZHksIGZsYWdzLCB2YWx1ZTtcblxuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgICAgIGZsYWdzID0gc2NhblJlZ0V4cEZsYWdzKCk7XG4gICAgICB2YWx1ZSA9IHRlc3RSZWdFeHAoYm9keS52YWx1ZSwgZmxhZ3MudmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5SZWd1bGFyRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICByZWdleDoge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICBmbGFnczogZmxhZ3MudmFsdWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdFJlZ2V4KCkge1xuICAgICAgdmFyIHBvcywgbG9jLCByZWdleCwgdG9rZW47XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZWdleCA9IHNjYW5SZWdFeHAoKTtcblxuICAgICAgbG9jLmVuZCA9IHtcbiAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgIH07XG5cbiAgICAgIGlmICghZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAvLyBQb3AgdGhlIHByZXZpb3VzIHRva2VuLCB3aGljaCBpcyBsaWtlbHkgJy8nIG9yICcvPSdcbiAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgdG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBpZiAodG9rZW4ucmFuZ2VbMF0gPT09IHBvcyAmJiB0b2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0b2tlbi52YWx1ZSA9PT0gJy8nIHx8IHRva2VuLnZhbHVlID09PSAnLz0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnUmVndWxhckV4cHJlc3Npb24nLFxuICAgICAgICAgICAgICB2YWx1ZTogcmVnZXgubGl0ZXJhbCxcbiAgICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LnJlZ2V4LFxuICAgICAgICAgICAgICByYW5nZTogW3BvcywgaW5kZXhdLFxuICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnZXg7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJOYW1lKHRva2VuKSB7XG4gICAgICByZXR1cm4gdG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllciB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQgfHxcbiAgICAgICAgICB0b2tlbi50eXBlID09PSBUb2tlbi5Cb29sZWFuTGl0ZXJhbCB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLk51bGxMaXRlcmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gYWR2YW5jZVNsYXNoKCkge1xuICAgICAgdmFyIHByZXZUb2tlbixcbiAgICAgICAgICBjaGVja1Rva2VuO1xuICAgICAgLy8gVXNpbmcgdGhlIGZvbGxvd2luZyBhbGdvcml0aG06XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zd2VldC5qcy93aWtpL2Rlc2lnblxuICAgICAgcHJldlRva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLnRva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgIGlmICghcHJldlRva2VuKSB7XG4gICAgICAgICAgLy8gTm90aGluZyBiZWZvcmUgdGhhdDogaXQgY2Fubm90IGJlIGEgZGl2aXNpb24uXG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnUHVuY3R1YXRvcicpIHtcbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnXScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICcpJykge1xuICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5QYXJlblRva2VuIC0gMV07XG4gICAgICAgICAgICAgIGlmIChjaGVja1Rva2VuICYmXG4gICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2lmJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnZhbHVlID09PSAnd2hpbGUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICdmb3InIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aXRoJykpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgIC8vIERpdmlkaW5nIGEgZnVuY3Rpb24gYnkgYW55dGhpbmcgbWFrZXMgbGl0dGxlIHNlbnNlLFxuICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSB0byBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDNdICYmXG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF07XG4gICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdLnR5cGUgPT09ICdLZXl3b3JkJykge1xuICAgICAgICAgICAgICAgICAgLy8gTmFtZWQgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgICBjaGVja1Rva2VuID0gZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNV07XG4gICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZUb2tlbi50eXBlID09PSAnS2V5d29yZCcgJiYgcHJldlRva2VuLnZhbHVlICE9PSAndGhpcycpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkdmFuY2UoKSB7XG4gICAgICB2YXIgY2g7XG5cbiAgICAgIHNraXBDb21tZW50KCk7XG5cbiAgICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5FT0YsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogaW5kZXgsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNoKSkge1xuICAgICAgICAgIHJldHVybiBzY2FuSWRlbnRpZmllcigpO1xuICAgICAgfVxuXG4gICAgICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuICAgICAgaWYgKGNoID09PSAweDI4IHx8IGNoID09PSAweDI5IHx8IGNoID09PSAweDNCKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXG4gICAgICBpZiAoY2ggPT09IDB4MjcgfHwgY2ggPT09IDB4MjIpIHtcbiAgICAgICAgICByZXR1cm4gc2NhblN0cmluZ0xpdGVyYWwoKTtcbiAgICAgIH1cblxuXG4gICAgICAvLyBEb3QgKC4pIFUrMDAyRSBjYW4gYWxzbyBzdGFydCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciwgaGVuY2UgdGhlIG5lZWRcbiAgICAgIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaCA9PT0gMHgyRSkge1xuICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCArIDEpKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEZWNpbWFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5OdW1lcmljTGl0ZXJhbCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTbGFzaCAoLykgVSswMDJGIGNhbiBhbHNvIHN0YXJ0IGEgcmVnZXguXG4gICAgICBpZiAoZXh0cmEudG9rZW5pemUgJiYgY2ggPT09IDB4MkYpIHtcbiAgICAgICAgICByZXR1cm4gYWR2YW5jZVNsYXNoKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sbGVjdFRva2VuKCkge1xuICAgICAgdmFyIGxvYywgdG9rZW4sIHZhbHVlLCBlbnRyeTtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGxvYyA9IHtcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICBsaW5lOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdG9rZW4gPSBhZHZhbmNlKCk7XG4gICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgfTtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHZhbHVlID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICAgICAgICAgIGVudHJ5ID0ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbk5hbWVbdG9rZW4udHlwZV0sXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgcmFuZ2U6IFt0b2tlbi5zdGFydCwgdG9rZW4uZW5kXSxcbiAgICAgICAgICAgICAgbG9jOiBsb2NcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmICh0b2tlbi5yZWdleCkge1xuICAgICAgICAgICAgICBlbnRyeS5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHRva2VuLnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBmbGFnczogdG9rZW4ucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXh0cmEudG9rZW5zLnB1c2goZW50cnkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBmdW5jdGlvbiBsZXgoKSB7XG4gICAgICB2YXIgdG9rZW47XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgaW5kZXggPSB0b2tlbi5lbmQ7XG4gICAgICBsaW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgIGxpbmVTdGFydCA9IHRva2VuLmxpbmVTdGFydDtcblxuICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuXG4gICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICByZXR1cm4gdG9rZW47XG4gIH1cblxuICBmdW5jdGlvbiBwZWVrKCkge1xuICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQ7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIGxvb2thaGVhZCA9ICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykgPyBjb2xsZWN0VG9rZW4oKSA6IGFkdmFuY2UoKTtcbiAgICAgIGluZGV4ID0gcG9zO1xuICAgICAgbGluZU51bWJlciA9IGxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBzdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICAgICAgdGhpcy5saW5lID0gbGluZU51bWJlcjtcbiAgICAgIHRoaXMuY29sdW1uID0gaW5kZXggLSBsaW5lU3RhcnQ7XG4gIH1cblxuICBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhcnQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFdyYXBwaW5nU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbikge1xuICAgICAgaWYgKHN0YXJ0VG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICAgIGxpbmU6IHN0YXJ0VG9rZW4uc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0VG9rZW4uc3RhcnQgLSBzdGFydFRva2VuLnN0YXJ0TGluZVN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgbGluZTogc3RhcnRUb2tlbi5saW5lTnVtYmVyLFxuICAgICAgICAgICAgICBjb2x1bW46IHN0YXJ0VG9rZW4uc3RhcnQgLSBzdGFydFRva2VuLmxpbmVTdGFydFxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBOb2RlKCkge1xuICAgICAgLy8gU2tpcCBjb21tZW50LlxuICAgICAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICBsaW5lTnVtYmVyID0gbG9va2FoZWFkLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBsb29rYWhlYWQuc3RhcnRMaW5lU3RhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQubGluZU51bWJlcjtcbiAgICAgICAgICBsaW5lU3RhcnQgPSBsb29rYWhlYWQubGluZVN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgdGhpcy5yYW5nZSA9IFtpbmRleCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgdGhpcy5sb2MgPSBuZXcgU291cmNlTG9jYXRpb24oKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFdyYXBwaW5nTm9kZShzdGFydFRva2VuKSB7XG4gICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlID0gW3N0YXJ0VG9rZW4uc3RhcnQsIDBdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgIHRoaXMubG9jID0gbmV3IFdyYXBwaW5nU291cmNlTG9jYXRpb24oc3RhcnRUb2tlbik7XG4gICAgICB9XG4gIH1cblxuICBXcmFwcGluZ05vZGUucHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGUgPSB7XG5cbiAgICAgIGZpbmlzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgICAgICB0aGlzLnJhbmdlWzFdID0gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2MuZW5kID0gbmV3IFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChleHRyYS5zb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubG9jLnNvdXJjZSA9IGV4dHJhLnNvdXJjZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEFycmF5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGVsZW1lbnRzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFycmF5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IChvcGVyYXRvciA9PT0gJ3x8JyB8fCBvcGVyYXRvciA9PT0gJyYmJykgPyBTeW50YXguTG9naWNhbEV4cHJlc3Npb24gOiBTeW50YXguQmluYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaENhbGxFeHByZXNzaW9uOiBmdW5jdGlvbiAoY2FsbGVlLCBhcmdzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNhbGxFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuY2FsbGVlID0gY2FsbGVlO1xuICAgICAgICAgIHRoaXMuYXJndW1lbnRzID0gYXJncztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAodGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkNvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAgIHRoaXMuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgICAgICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQ6IGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoSWRlbnRpZmllcjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguSWRlbnRpZmllcjtcbiAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hMaXRlcmFsOiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTGl0ZXJhbDtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gICAgICAgICAgdGhpcy5yYXcgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnJhdyA9PSAnLy8nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yYXcgPSAnLyg/OikvJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLnJlZ2V4ID0gdG9rZW4ucmVnZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hNZW1iZXJFeHByZXNzaW9uOiBmdW5jdGlvbiAoYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLmNvbXB1dGVkID0gYWNjZXNzb3IgPT09ICdbJztcbiAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaE9iamVjdEV4cHJlc3Npb246IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gU3ludGF4Lk9iamVjdEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoUHJvZ3JhbTogZnVuY3Rpb24gKGJvZHkpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvZ3JhbTtcbiAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hQcm9wZXJ0eTogZnVuY3Rpb24gKGtpbmQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguUHJvcGVydHk7XG4gICAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKG9wZXJhdG9yLCBhcmd1bWVudCkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IChvcGVyYXRvciA9PT0gJysrJyB8fCBvcGVyYXRvciA9PT0gJy0tJykgPyBTeW50YXguVXBkYXRlRXhwcmVzc2lvbiA6IFN5bnRheC5VbmFyeUV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICAgICAgICB0aGlzLnByZWZpeCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGVyZSBpcyBhIGxpbmUgdGVybWluYXRvciBiZWZvcmUgdGhlIG5leHQgdG9rZW4uXG5cbiAgZnVuY3Rpb24gcGVla0xpbmVUZXJtaW5hdG9yKCkge1xuICAgICAgdmFyIHBvcywgbGluZSwgc3RhcnQsIGZvdW5kO1xuXG4gICAgICBwb3MgPSBpbmRleDtcbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgZm91bmQgPSBsaW5lTnVtYmVyICE9PSBsaW5lO1xuICAgICAgaW5kZXggPSBwb3M7XG4gICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuXG4gICAgICByZXR1cm4gZm91bmQ7XG4gIH1cblxuICAvLyBUaHJvdyBhbiBleGNlcHRpb25cblxuICBmdW5jdGlvbiB0aHJvd0Vycm9yKHRva2VuLCBtZXNzYWdlRm9ybWF0KSB7XG4gICAgICB2YXIgZXJyb3IsXG4gICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgICAgICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKFxuICAgICAgICAgICAgICAvJShcXGQpL2csXG4gICAgICAgICAgICAgIGZ1bmN0aW9uICh3aG9sZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGFzc2VydChpbmRleCA8IGFyZ3MubGVuZ3RoLCAnTWVzc2FnZSByZWZlcmVuY2UgbXVzdCBiZSBpbiByYW5nZScpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgaWYgKHR5cGVvZiB0b2tlbi5saW5lTnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyB0b2tlbi5saW5lTnVtYmVyICsgJzogJyArIG1zZyk7XG4gICAgICAgICAgZXJyb3IuaW5kZXggPSB0b2tlbi5zdGFydDtcbiAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gdG9rZW4ubGluZU51bWJlcjtcbiAgICAgICAgICBlcnJvci5jb2x1bW4gPSB0b2tlbi5zdGFydCAtIGxpbmVTdGFydCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdMaW5lICcgKyBsaW5lTnVtYmVyICsgJzogJyArIG1zZyk7XG4gICAgICAgICAgZXJyb3IuaW5kZXggPSBpbmRleDtcbiAgICAgICAgICBlcnJvci5saW5lTnVtYmVyID0gbGluZU51bWJlcjtcbiAgICAgICAgICBlcnJvci5jb2x1bW4gPSBpbmRleCAtIGxpbmVTdGFydCArIDE7XG4gICAgICB9XG5cbiAgICAgIGVycm9yLmRlc2NyaXB0aW9uID0gbXNnO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiB0aHJvd0Vycm9yVG9sZXJhbnQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIHRocm93RXJyb3IuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgIGV4dHJhLmVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG5cblxuICAvLyBUaHJvdyBhbiBleGNlcHRpb24gYmVjYXVzZSBvZiB0aGUgdG9rZW4uXG5cbiAgZnVuY3Rpb24gdGhyb3dVbmV4cGVjdGVkKHRva2VuKSB7XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZEVPUyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWROdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRTdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uSWRlbnRpZmllcikge1xuICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRJZGVudGlmaWVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBpZiAoaXNGdXR1cmVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRSZXNlcnZlZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgaXNTdHJpY3RNb2RlUmVzZXJ2ZWRXb3JkKHRva2VuLnZhbHVlKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlN0cmljdFJlc2VydmVkV29yZCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJvb2xlYW5MaXRlcmFsLCBOdWxsTGl0ZXJhbCwgb3IgUHVuY3R1YXRvci5cbiAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICB9XG5cbiAgLy8gRXhwZWN0IHRoZSBuZXh0IHRva2VuIHRvIG1hdGNoIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cbiAgLy8gSWYgbm90LCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG5cbiAgZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdG9rZW4gPSBsZXgoKTtcbiAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yIHx8IHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgZXhwZWN0VG9sZXJhbnRcbiAgICogQGRlc2NyaXB0aW9uIFF1aWV0bHkgZXhwZWN0IHRoZSBnaXZlbiB0b2tlbiB2YWx1ZSB3aGVuIGluIHRvbGVyYW50IG1vZGUsIG90aGVyd2lzZSBkZWxlZ2F0ZXNcbiAgICogdG8gPGNvZGU+ZXhwZWN0KHZhbHVlKTwvY29kZT5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB3ZSBhcmUgZXhwZWN0aW5nIHRoZSBsb29rYWhlYWQgdG9rZW4gdG8gaGF2ZVxuICAgKiBAc2luY2UgMi4wXG4gICAqL1xuICBmdW5jdGlvbiBleHBlY3RUb2xlcmFudCh2YWx1ZSkge1xuICAgICAgaWYgKGV4dHJhLmVycm9ycykge1xuICAgICAgICAgIHZhciB0b2tlbiA9IGxvb2thaGVhZDtcbiAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGVjdCh2YWx1ZSk7XG4gICAgICB9XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxuICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICBmdW5jdGlvbiBleHBlY3RLZXl3b3JkKGtleXdvcmQpIHtcbiAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLktleXdvcmQgfHwgdG9rZW4udmFsdWUgIT09IGtleXdvcmQpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG5cbiAgZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgICAgIHJldHVybiBsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudmFsdWUgPT09IHZhbHVlO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuICBmdW5jdGlvbiBtYXRjaEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5LZXl3b3JkICYmIGxvb2thaGVhZC52YWx1ZSA9PT0ga2V5d29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVTZW1pY29sb24oKSB7XG4gICAgICB2YXIgbGluZTtcblxuICAgICAgLy8gQ2F0Y2ggdGhlIHZlcnkgY29tbW9uIGNhc2UgZmlyc3Q6IGltbWVkaWF0ZWx5IGEgc2VtaWNvbG9uIChVKzAwM0IpLlxuICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzQiB8fCBtYXRjaCgnOycpKSB7XG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBpZiAobGluZU51bWJlciAhPT0gbGluZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5FT0YgJiYgIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiB0cnVlIGlmIHByb3ZpZGVkIGV4cHJlc3Npb24gaXMgTGVmdEhhbmRTaWRlRXhwcmVzc2lvblxuXG4gIGZ1bmN0aW9uIGlzTGVmdEhhbmRTaWRlKGV4cHIpIHtcbiAgICAgIHJldHVybiBleHByLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyIHx8IGV4cHIudHlwZSA9PT0gU3ludGF4Lk1lbWJlckV4cHJlc3Npb247XG4gIH1cblxuICAvLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSBbXSwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChudWxsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFtYXRjaCgnXScpKSB7XG4gICAgICAgICAgICAgICAgICBleHBlY3QoJywnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGV4KCk7XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEFycmF5RXhwcmVzc2lvbihlbGVtZW50cyk7XG4gIH1cblxuICAvLyAxMS4xLjUgT2JqZWN0IEluaXRpYWxpc2VyXG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIC8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgZnJvbSBwYXJzZU9iamVjdFByb3BlcnR5KCksIHdoZXJlXG4gICAgICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwga2V5LCBpZCwgdmFsdWUsIHBhcmFtLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBpZCwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLkVPRiB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIHZhbHVlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHJldHVybiBub2RlLmZpbmlzaFByb3BlcnR5KCdpbml0Jywga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdEluaXRpYWxpc2VyKCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBbXSwgdG9rZW4sIHByb3BlcnR5LCBuYW1lLCBrZXksIGtpbmQsIG1hcCA9IHt9LCB0b1N0cmluZyA9IFN0cmluZywgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGV4cGVjdCgneycpO1xuXG4gICAgICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcblxuICAgICAgICAgIGlmIChwcm9wZXJ0eS5rZXkudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHByb3BlcnR5LmtleS5uYW1lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5hbWUgPSB0b1N0cmluZyhwcm9wZXJ0eS5rZXkudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBraW5kID0gKHByb3BlcnR5LmtpbmQgPT09ICdpbml0JykgPyBQcm9wZXJ0eUtpbmQuRGF0YSA6IChwcm9wZXJ0eS5raW5kID09PSAnZ2V0JykgPyBQcm9wZXJ0eUtpbmQuR2V0IDogUHJvcGVydHlLaW5kLlNldDtcblxuICAgICAgICAgIGtleSA9ICckJyArIG5hbWU7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKG1hcFtrZXldID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBraW5kID09PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuU3RyaWN0RHVwbGljYXRlUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChraW5kICE9PSBQcm9wZXJ0eUtpbmQuRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JEYXRhUHJvcGVydHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcFtrZXldICYga2luZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh7fSwgTWVzc2FnZXMuQWNjZXNzb3JHZXRTZXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1hcFtrZXldIHw9IGtpbmQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWFwW2tleV0gPSBraW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHByb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgICAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgICAgICAgICAgZXhwZWN0VG9sZXJhbnQoJywnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCgnfScpO1xuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hPYmplY3RFeHByZXNzaW9uKHByb3BlcnRpZXMpO1xuICB9XG5cbiAgLy8gMTEuMS42IFRoZSBHcm91cGluZyBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlR3JvdXBFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICArK3N0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcblxuICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cblxuICAvLyAxMS4xIFByaW1hcnkgRXhwcmVzc2lvbnNcblxuICB2YXIgbGVnYWxLZXl3b3JkcyA9IHtcImlmXCI6MSwgXCJ0aGlzXCI6MX07XG5cbiAgZnVuY3Rpb24gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0eXBlLCB0b2tlbiwgZXhwciwgbm9kZTtcblxuICAgICAgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VHcm91cEV4cHJlc3Npb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCgneycpKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKTtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IGxvb2thaGVhZC50eXBlO1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8IGxlZ2FsS2V5d29yZHNbbG9va2FoZWFkLnZhbHVlXSkge1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsIHx8IHR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgaWYgKHN0cmljdCAmJiBsb29rYWhlYWQub2N0YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGxvb2thaGVhZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICB0b2tlbi52YWx1ZSA9ICh0b2tlbi52YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWwpIHtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGNvbGxlY3RSZWdleCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBlZWsoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxleCgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4yIExlZnQtSGFuZC1TaWRlIEV4cHJlc3Npb25zXG5cbiAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdO1xuXG4gICAgICBleHBlY3QoJygnKTtcblxuICAgICAgaWYgKCFtYXRjaCgnKScpKSB7XG4gICAgICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkpO1xuICAgICAgICAgICAgICBpZiAobWF0Y2goJyknKSkge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZXhwZWN0VG9sZXJhbnQoJywnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGV4cGVjdCgnKScpO1xuXG4gICAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpIHtcbiAgICAgIHZhciB0b2tlbiwgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIHRva2VuID0gbGV4KCk7XG5cbiAgICAgIGlmICghaXNJZGVudGlmaWVyTmFtZSh0b2tlbikpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hJZGVudGlmaWVyKHRva2VuLnZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKSB7XG4gICAgICBleHBlY3QoJy4nKTtcblxuICAgICAgcmV0dXJuIHBhcnNlTm9uQ29tcHV0ZWRQcm9wZXJ0eSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb21wdXRlZE1lbWJlcigpIHtcbiAgICAgIHZhciBleHByO1xuXG4gICAgICBleHBlY3QoJ1snKTtcblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICBleHBlY3QoJ10nKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKSB7XG4gICAgICB2YXIgZXhwciwgYXJncywgcHJvcGVydHksIHN0YXJ0VG9rZW4sIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgIGV4cHIgPSBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKCcoJykpIHtcbiAgICAgICAgICAgICAgYXJncyA9IHBhcnNlQXJndW1lbnRzKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENhbGxFeHByZXNzaW9uKGV4cHIsIGFyZ3MpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignWycsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbjtcbiAgICAgIGFzc2VydChzdGF0ZS5hbGxvd0luLCAnY2FsbGVlIG9mIG5ldyBleHByZXNzaW9uIGFsd2F5cyBhbGxvdyBpbiBrZXl3b3JkLicpO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgZXhwciA9IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJy4nKSkge1xuICAgICAgICAgICAgICBwcm9wZXJ0eSA9IHBhcnNlTm9uQ29tcHV0ZWRNZW1iZXIoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoTWVtYmVyRXhwcmVzc2lvbignLicsIGV4cHIsIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjMgUG9zdGZpeCBFeHByZXNzaW9uc1xuXG4gIGZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgdG9rZW4sIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgaWYgKChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkgJiYgIXBlZWtMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuNCBVbmFyeSBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciB0b2tlbiwgZXhwciwgc3RhcnRUb2tlbjtcblxuICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoKCcrJykgfHwgbWF0Y2goJy0nKSB8fCBtYXRjaCgnficpIHx8IG1hdGNoKCchJykpIHtcbiAgICAgICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoVW5hcnlFeHByZXNzaW9uKHRva2VuLnZhbHVlLCBleHByKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCBtYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCBtYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIGFsbG93SW4pIHtcbiAgICAgIHZhciBwcmVjID0gMDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRva2VuLnZhbHVlKSB7XG4gICAgICBjYXNlICd8fCc6XG4gICAgICAgICAgcHJlYyA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYmJzpcbiAgICAgICAgICBwcmVjID0gMjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgcHJlYyA9IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgIHByZWMgPSA0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgICBwcmVjID0gNTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPT0nOlxuICAgICAgY2FzZSAnIT0nOlxuICAgICAgY2FzZSAnPT09JzpcbiAgICAgIGNhc2UgJyE9PSc6XG4gICAgICAgICAgcHJlYyA9IDY7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzwnOlxuICAgICAgY2FzZSAnPic6XG4gICAgICBjYXNlICc8PSc6XG4gICAgICBjYXNlICc+PSc6XG4gICAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICAgICAgICBwcmVjID0gNztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaW4nOlxuICAgICAgICAgIHByZWMgPSBhbGxvd0luID8gNyA6IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJzw8JzpcbiAgICAgIGNhc2UgJz4+JzpcbiAgICAgIGNhc2UgJz4+Pic6XG4gICAgICAgICAgcHJlYyA9IDg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJysnOlxuICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgcHJlYyA9IDk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyonOlxuICAgICAgY2FzZSAnLyc6XG4gICAgICBjYXNlICclJzpcbiAgICAgICAgICBwcmVjID0gMTE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmVjO1xuICB9XG5cbiAgLy8gMTEuNSBNdWx0aXBsaWNhdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNiBBZGRpdGl2ZSBPcGVyYXRvcnNcbiAgLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuICAvLyAxMS44IFJlbGF0aW9uYWwgT3BlcmF0b3JzXG4gIC8vIDExLjkgRXF1YWxpdHkgT3BlcmF0b3JzXG4gIC8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuICAvLyAxMS4xMSBCaW5hcnkgTG9naWNhbCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgbWFya2VyLCBtYXJrZXJzLCBleHByLCB0b2tlbiwgcHJlYywgc3RhY2ssIHJpZ2h0LCBvcGVyYXRvciwgbGVmdCwgaTtcblxuICAgICAgbWFya2VyID0gbG9va2FoZWFkO1xuICAgICAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgcHJlYyA9IGJpbmFyeVByZWNlZGVuY2UodG9rZW4sIHN0YXRlLmFsbG93SW4pO1xuICAgICAgaWYgKHByZWMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgbGV4KCk7XG5cbiAgICAgIG1hcmtlcnMgPSBbbWFya2VyLCBsb29rYWhlYWRdO1xuICAgICAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuXG4gICAgICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCwgc3RhdGUuYWxsb3dJbikpID4gMCkge1xuXG4gICAgICAgICAgLy8gUmVkdWNlOiBtYWtlIGEgYmluYXJ5IGV4cHJlc3Npb24gZnJvbSB0aGUgdGhyZWUgdG9wbW9zdCBlbnRyaWVzLlxuICAgICAgICAgIHdoaWxlICgoc3RhY2subGVuZ3RoID4gMikgJiYgKHByZWMgPD0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0ucHJlYykpIHtcbiAgICAgICAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgb3BlcmF0b3IgPSBzdGFjay5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBtYXJrZXJzLnBvcCgpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV0pLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTaGlmdC5cbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnByZWMgPSBwcmVjO1xuICAgICAgICAgIHN0YWNrLnB1c2godG9rZW4pO1xuICAgICAgICAgIG1hcmtlcnMucHVzaChsb29rYWhlYWQpO1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YWNrLnB1c2goZXhwcik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gICAgICBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgIGV4cHIgPSBzdGFja1tpXTtcbiAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICB3aGlsZSAoaSA+IDEpIHtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShtYXJrZXJzLnBvcCgpKS5maW5pc2hCaW5hcnlFeHByZXNzaW9uKHN0YWNrW2kgLSAxXS52YWx1ZSwgc3RhY2tbaSAtIDJdLCBleHByKTtcbiAgICAgICAgICBpIC09IDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTIgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCBwcmV2aW91c0FsbG93SW4sIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSwgc3RhcnRUb2tlbjtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJz8nKSkge1xuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHByZXZpb3VzQWxsb3dJbiA9IHN0YXRlLmFsbG93SW47XG4gICAgICAgICAgc3RhdGUuYWxsb3dJbiA9IHRydWU7XG4gICAgICAgICAgY29uc2VxdWVudCA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gcHJldmlvdXNBbGxvd0luO1xuICAgICAgICAgIGV4cGVjdCgnOicpO1xuICAgICAgICAgIGFsdGVybmF0ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcblxuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaENvbmRpdGlvbmFsRXhwcmVzc2lvbihleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjEzIEFzc2lnbm1lbnQgT3BlcmF0b3JzXG5cbiAgZnVuY3Rpb24gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBvbGRQYXJlbnRoZXNpc0NvdW50LCB0b2tlbiwgZXhwciwgcmlnaHQsIGxpc3QsIHN0YXJ0VG9rZW47XG5cbiAgICAgIG9sZFBhcmVudGhlc2lzQ291bnQgPSBzdGF0ZS5wYXJlbnRoZXNpc0NvdW50O1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjE0IENvbW1hIE9wZXJhdG9yXG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQsIGV4cHJlc3Npb25zO1xuXG4gICAgICBleHByID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICBpZiAobWF0Y2goJywnKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8gbm8gc2VxdWVuY2UgZXhwcmVzc2lvbnNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMi40IEV4cHJlc3Npb24gU3RhdGVtZW50XG5cbiAgZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgIHZhciBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICB9XG5cbiAgLy8gMTIgU3RhdGVtZW50c1xuXG4gIGZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50KCkge1xuICAgICAgdmFyIHR5cGUgPSBsb29rYWhlYWQudHlwZSxcbiAgICAgICAgICBleHByLFxuICAgICAgICAgIGxhYmVsZWRCb2R5LFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBub2RlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKGxvb2thaGVhZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gJ3snKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBibG9jayBzdGF0ZW1lbnRcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yKSB7XG4gICAgICAgICAgc3dpdGNoIChsb29rYWhlYWQudmFsdWUpIHtcbiAgICAgICAgICBjYXNlICc7JzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBlbXB0eSBzdGF0ZW1lbnRcbiAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGtleXdvcmRcbiAgICAgIH1cblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgY29uc3VtZVNlbWljb2xvbigpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudChleHByKTtcbiAgfVxuXG4gIC8vIDE0IFByb2dyYW1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnQoKSB7XG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ2NvbnN0JzpcbiAgICAgICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0YXRlbWVudCgpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTb3VyY2VFbGVtZW50cygpIHtcbiAgICAgIHZhciBzb3VyY2VFbGVtZW50LCBzb3VyY2VFbGVtZW50cyA9IFtdLCB0b2tlbiwgZGlyZWN0aXZlLCBmaXJzdFJlc3RyaWN0ZWQ7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNvdXJjZUVsZW1lbnQgPSBwYXJzZVNvdXJjZUVsZW1lbnQoKTtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50cy5wdXNoKHNvdXJjZUVsZW1lbnQpO1xuICAgICAgICAgIGlmIChzb3VyY2VFbGVtZW50LmV4cHJlc3Npb24udHlwZSAhPT0gU3ludGF4LkxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBpcyBub3QgZGlyZWN0aXZlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXJlY3RpdmUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQgKyAxLCB0b2tlbi5lbmQgLSAxKTtcbiAgICAgICAgICBpZiAoZGlyZWN0aXZlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgc3RyaWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgaWYgKGZpcnN0UmVzdHJpY3RlZCkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KGZpcnN0UmVzdHJpY3RlZCwgTWVzc2FnZXMuU3RyaWN0T2N0YWxMaXRlcmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZmlyc3RSZXN0cmljdGVkICYmIHRva2VuLm9jdGFsKSB7XG4gICAgICAgICAgICAgICAgICBmaXJzdFJlc3RyaWN0ZWQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlRWxlbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVByb2dyYW0oKSB7XG4gICAgICB2YXIgYm9keSwgbm9kZTtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHBlZWsoKTtcbiAgICAgIG5vZGUgPSBuZXcgTm9kZSgpO1xuICAgICAgc3RyaWN0ID0gdHJ1ZTsgLy8gYXNzdW1lIHN0cmljdFxuXG4gICAgICBib2R5ID0gcGFyc2VTb3VyY2VFbGVtZW50cygpO1xuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvZ3JhbShib2R5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlclRva2VuTG9jYXRpb24oKSB7XG4gICAgICB2YXIgaSwgZW50cnksIHRva2VuLCB0b2tlbnMgPSBbXTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4dHJhLnRva2Vucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGVudHJ5ID0gZXh0cmEudG9rZW5zW2ldO1xuICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICB0eXBlOiBlbnRyeS50eXBlLFxuICAgICAgICAgICAgICB2YWx1ZTogZW50cnkudmFsdWVcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChlbnRyeS5yZWdleCkge1xuICAgICAgICAgICAgICB0b2tlbi5yZWdleCA9IHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGVudHJ5LnJlZ2V4LnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICBmbGFnczogZW50cnkucmVnZXguZmxhZ3NcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRva2VuLnJhbmdlID0gZW50cnkucmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICAgICAgdG9rZW4ubG9jID0gZW50cnkubG9jO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIGV4dHJhLnRva2VucyA9IHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHRva2VuaXplKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciB0b1N0cmluZyxcbiAgICAgICAgICB0b2tlbnM7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIGluRnVuY3Rpb25Cb2R5OiBmYWxzZSxcbiAgICAgICAgICBpbkl0ZXJhdGlvbjogZmFsc2UsXG4gICAgICAgICAgaW5Td2l0Y2g6IGZhbHNlLFxuICAgICAgICAgIGxhc3RDb21tZW50U3RhcnQ6IC0xXG4gICAgICB9O1xuXG4gICAgICBleHRyYSA9IHt9O1xuXG4gICAgICAvLyBPcHRpb25zIG1hdGNoaW5nLlxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIE9mIGNvdXJzZSB3ZSBjb2xsZWN0IHRva2VucyBoZXJlLlxuICAgICAgb3B0aW9ucy50b2tlbnMgPSB0cnVlO1xuICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICBleHRyYS50b2tlbml6ZSA9IHRydWU7XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHR3byBmaWVsZHMgYXJlIG5lY2Vzc2FyeSB0byBjb21wdXRlIHRoZSBSZWdleCB0b2tlbnMuXG4gICAgICBleHRyYS5vcGVuUGFyZW5Ub2tlbiA9IC0xO1xuICAgICAgZXh0cmEub3BlbkN1cmx5VG9rZW4gPSAtMTtcblxuICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgICBwZWVrKCk7XG4gICAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICB3aGlsZSAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGxleEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2gobGV4RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gYnJlYWsgb24gdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRocm93IGxleEVycm9yO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgIHRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgdG9rZW5zLmVycm9ycyA9IGV4dHJhLmVycm9ycztcbiAgICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvZ3JhbSwgdG9TdHJpbmc7XG5cbiAgICAgIHRvU3RyaW5nID0gU3RyaW5nO1xuICAgICAgaWYgKHR5cGVvZiBjb2RlICE9PSAnc3RyaW5nJyAmJiAhKGNvZGUgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgICAgY29kZSA9IHRvU3RyaW5nKGNvZGUpO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb2RlO1xuICAgICAgaW5kZXggPSAwO1xuICAgICAgbGluZU51bWJlciA9IChzb3VyY2UubGVuZ3RoID4gMCkgPyAxIDogMDtcbiAgICAgIGxpbmVTdGFydCA9IDA7XG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgbG9va2FoZWFkID0gbnVsbDtcbiAgICAgIHN0YXRlID0ge1xuICAgICAgICAgIGFsbG93SW46IHRydWUsXG4gICAgICAgICAgbGFiZWxTZXQ6IHt9LFxuICAgICAgICAgIHBhcmVudGhlc2lzQ291bnQ6IDAsXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZXh0cmEucmFuZ2UgPSAodHlwZW9mIG9wdGlvbnMucmFuZ2UgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5yYW5nZTtcbiAgICAgICAgICBleHRyYS5sb2MgPSAodHlwZW9mIG9wdGlvbnMubG9jID09PSAnYm9vbGVhbicpICYmIG9wdGlvbnMubG9jO1xuXG4gICAgICAgICAgaWYgKGV4dHJhLmxvYyAmJiBvcHRpb25zLnNvdXJjZSAhPT0gbnVsbCAmJiBvcHRpb25zLnNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4dHJhLnNvdXJjZSA9IHRvU3RyaW5nKG9wdGlvbnMuc291cmNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudG9rZW5zID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2tlbnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEudG9rZW5zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2xlcmFudCA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzID0gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHByb2dyYW0gPSBwYXJzZVByb2dyYW0oKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgZmlsdGVyVG9rZW5Mb2NhdGlvbigpO1xuICAgICAgICAgICAgICBwcm9ncmFtLnRva2VucyA9IGV4dHJhLnRva2VucztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS5lcnJvcnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIHByb2dyYW0uZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9rZW5pemU6IHRva2VuaXplLFxuICAgIHBhcnNlOiBwYXJzZVxuICB9O1xuXG59KSgpOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBheHMgPSByZXF1aXJlKCcuLi9zY2VuZS9heGlzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKTtcblxudmFyIE9SSUVOVCA9IHtcbiAgXCJ4XCI6ICAgICAgXCJib3R0b21cIixcbiAgXCJ5XCI6ICAgICAgXCJsZWZ0XCIsXG4gIFwidG9wXCI6ICAgIFwidG9wXCIsXG4gIFwiYm90dG9tXCI6IFwiYm90dG9tXCIsXG4gIFwibGVmdFwiOiAgIFwibGVmdFwiLFxuICBcInJpZ2h0XCI6ICBcInJpZ2h0XCJcbn07XG5cbmZ1bmN0aW9uIGF4ZXMobW9kZWwsIHNwZWMsIGF4ZXMsIGdyb3VwKSB7XG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICBheGVzW2luZGV4XSA9IGF4ZXNbaW5kZXhdIHx8IGF4cyhtb2RlbCk7XG4gICAgYXhpcyhkZWYsIGluZGV4LCBheGVzW2luZGV4XSwgZ3JvdXApO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGF4aXMoZGVmLCBpbmRleCwgYXhpcywgZ3JvdXApIHtcbiAgLy8gYXhpcyBzY2FsZVxuICBpZiAoZGVmLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBheGlzLnNjYWxlKGdyb3VwLnNjYWxlKGRlZi5zY2FsZSkpO1xuICB9XG5cbiAgLy8gYXhpcyBvcmllbnRhdGlvblxuICBheGlzLm9yaWVudChkZWYub3JpZW50IHx8IE9SSUVOVFtkZWYudHlwZV0pO1xuICAvLyBheGlzIG9mZnNldFxuICBheGlzLm9mZnNldChkZWYub2Zmc2V0IHx8IDApO1xuICAvLyBheGlzIGxheWVyXG4gIGF4aXMubGF5ZXIoZGVmLmxheWVyIHx8IFwiZnJvbnRcIik7XG4gIC8vIGF4aXMgZ3JpZCBsaW5lc1xuICBheGlzLmdyaWQoZGVmLmdyaWQgfHwgZmFsc2UpO1xuICAvLyBheGlzIHRpdGxlXG4gIGF4aXMudGl0bGUoZGVmLnRpdGxlIHx8IG51bGwpO1xuICAvLyBheGlzIHRpdGxlIG9mZnNldFxuICBheGlzLnRpdGxlT2Zmc2V0KGRlZi50aXRsZU9mZnNldCAhPSBudWxsXG4gICAgPyBkZWYudGl0bGVPZmZzZXQgOiBjb25maWcuYXhpcy50aXRsZU9mZnNldCk7XG4gIC8vIGF4aXMgdmFsdWVzXG4gIGF4aXMudGlja1ZhbHVlcyhkZWYudmFsdWVzIHx8IG51bGwpO1xuICAvLyBheGlzIGxhYmVsIGZvcm1hdHRpbmdcbiAgYXhpcy50aWNrRm9ybWF0KGRlZi5mb3JtYXQgfHwgbnVsbCk7XG4gIC8vIGF4aXMgdGljayBzdWJkaXZpc2lvblxuICBheGlzLnRpY2tTdWJkaXZpZGUoZGVmLnN1YmRpdmlkZSB8fCAwKTtcbiAgLy8gYXhpcyB0aWNrIHBhZGRpbmdcbiAgYXhpcy50aWNrUGFkZGluZyhkZWYudGlja1BhZGRpbmcgfHwgY29uZmlnLmF4aXMucGFkZGluZyk7XG5cbiAgLy8gYXhpcyB0aWNrIHNpemUocylcbiAgdmFyIHNpemUgPSBbXTtcbiAgaWYgKGRlZi50aWNrU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPDM7ICsraSkgc2l6ZS5wdXNoKGRlZi50aWNrU2l6ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRzID0gY29uZmlnLmF4aXMudGlja1NpemU7XG4gICAgc2l6ZSA9IFt0cywgdHMsIHRzXTtcbiAgfVxuICBpZiAoZGVmLnRpY2tTaXplTWFqb3IgIT0gbnVsbCkgc2l6ZVswXSA9IGRlZi50aWNrU2l6ZU1ham9yO1xuICBpZiAoZGVmLnRpY2tTaXplTWlub3IgIT0gbnVsbCkgc2l6ZVsxXSA9IGRlZi50aWNrU2l6ZU1pbm9yO1xuICBpZiAoZGVmLnRpY2tTaXplRW5kICAgIT0gbnVsbCkgc2l6ZVsyXSA9IGRlZi50aWNrU2l6ZUVuZDtcbiAgaWYgKHNpemUubGVuZ3RoKSB7XG4gICAgYXhpcy50aWNrU2l6ZS5hcHBseShheGlzLCBzaXplKTtcbiAgfVxuXG4gIC8vIHRpY2sgYXJndW1lbnRzXG4gIGlmIChkZWYudGlja3MgIT0gbnVsbCkge1xuICAgIHZhciB0aWNrcyA9IGRsLmlzQXJyYXkoZGVmLnRpY2tzKSA/IGRlZi50aWNrcyA6IFtkZWYudGlja3NdO1xuICAgIGF4aXMudGlja3MuYXBwbHkoYXhpcywgdGlja3MpO1xuICB9IGVsc2Uge1xuICAgIGF4aXMudGlja3MoY29uZmlnLmF4aXMudGlja3MpO1xuICB9XG5cbiAgLy8gc3R5bGUgcHJvcGVydGllc1xuICB2YXIgcCA9IGRlZi5wcm9wZXJ0aWVzO1xuICBpZiAocCAmJiBwLnRpY2tzKSB7XG4gICAgYXhpcy5tYWpvclRpY2tQcm9wZXJ0aWVzKHAubWFqb3JUaWNrc1xuICAgICAgPyBkbC5leHRlbmQoe30sIHAudGlja3MsIHAubWFqb3JUaWNrcykgOiBwLnRpY2tzKTtcbiAgICBheGlzLm1pbm9yVGlja1Byb3BlcnRpZXMocC5taW5vclRpY2tzXG4gICAgICA/IGRsLmV4dGVuZCh7fSwgcC50aWNrcywgcC5taW5vclRpY2tzKSA6IHAudGlja3MpO1xuICB9IGVsc2Uge1xuICAgIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyhwICYmIHAubWFqb3JUaWNrcyB8fCB7fSk7XG4gICAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzKHAgJiYgcC5taW5vclRpY2tzIHx8IHt9KTtcbiAgfVxuICBheGlzLnRpY2tMYWJlbFByb3BlcnRpZXMocCAmJiBwLmxhYmVscyB8fCB7fSk7XG4gIGF4aXMudGl0bGVQcm9wZXJ0aWVzKHAgJiYgcC50aXRsZSB8fCB7fSk7XG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzKHAgJiYgcC5ncmlkIHx8IHt9KTtcbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzKHAgJiYgcC5heGlzIHx8IHt9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBheGVzOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIHBhcnNlVHJhbnNmb3JtcyA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtcycpLFxuICAgIHBhcnNlTW9kaWZ5ID0gcmVxdWlyZSgnLi9tb2RpZnknKTtcblxudmFyIHBhcnNlRGF0YSA9IGZ1bmN0aW9uKG1vZGVsLCBzcGVjLCBjYWxsYmFjaykge1xuICB2YXIgY291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIGxvYWRlZChkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZGwuZXJyb3IoXCJMT0FESU5HIEZBSUxFRDogXCIgKyBkLnVybCArIFwiIFwiICsgZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuZGF0YShkLm5hbWUpLnZhbHVlcyhkbC5yZWFkKGRhdGEsIGQuZm9ybWF0KSk7XG4gICAgICB9XG4gICAgICBpZiAoLS1jb3VudCA9PT0gMCkgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm9jZXNzIGVhY2ggZGF0YSBzZXQgZGVmaW5pdGlvblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihkKSB7XG4gICAgaWYgKGQudXJsKSB7XG4gICAgICBjb3VudCArPSAxO1xuICAgICAgZGwubG9hZChkbC5leHRlbmQoe3VybDogZC51cmx9LCBjb25maWcubG9hZCksIGxvYWRlZChkKSk7XG4gICAgfVxuICAgIHBhcnNlRGF0YS5kYXRhc291cmNlKG1vZGVsLCBkKTtcbiAgfSk7XG5cbiAgaWYgKGNvdW50ID09PSAwKSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAxKTtcbiAgcmV0dXJuIHNwZWM7XG59O1xuXG5wYXJzZURhdGEuZGF0YXNvdXJjZSA9IGZ1bmN0aW9uKG1vZGVsLCBkKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSAoZC50cmFuc2Zvcm18fFtdKS5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCB0KSB9KSxcbiAgICAgIG1vZCA9IChkLm1vZGlmeXx8W10pLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1vZGlmeShtb2RlbCwgbSwgZCkgfSksXG4gICAgICBkcyA9IG1vZGVsLmRhdGEoZC5uYW1lLCBtb2QuY29uY2F0KHRyYW5zZm9ybSkpO1xuXG4gIGlmIChkLnZhbHVlcykge1xuICAgIGRzLnZhbHVlcyhkbC5yZWFkKGQudmFsdWVzLCBkLmZvcm1hdCkpO1xuICB9IGVsc2UgaWYgKGQuc291cmNlKSB7XG4gICAgZHMuc291cmNlKGQuc291cmNlKVxuICAgICAgLnJldmlzZXMoZHMucmV2aXNlcygpKSAvLyBJZiBuZXcgZHMgcmV2aXNlcywgdGhlbiBpdCdzIG9yaWdpbiBtdXN0IHJldmlzZSB0b28uXG4gICAgICAuYWRkTGlzdGVuZXIoZHMpOyAgLy8gRGVyaXZlZCBkcyB3aWxsIGJlIHB1bHNlZCBieSBpdHMgc3JjIHJhdGhlciB0aGFuIHRoZSBtb2RlbC5cbiAgICBtb2RlbC5yZW1vdmVMaXN0ZW5lcihkcy5waXBlbGluZSgpWzBdKTsgXG4gIH1cblxuICByZXR1cm4gZHM7ICAgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZURhdGE7XG4iLCIvKlxuICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjguMC5cbiAqXG4gKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gKi9cblxuZnVuY3Rpb24gcGVnJHN1YmNsYXNzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gIGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbn1cblxuZnVuY3Rpb24gU3ludGF4RXJyb3IobWVzc2FnZSwgZXhwZWN0ZWQsIGZvdW5kLCBvZmZzZXQsIGxpbmUsIGNvbHVtbikge1xuICB0aGlzLm1lc3NhZ2UgID0gbWVzc2FnZTtcbiAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICB0aGlzLmZvdW5kICAgID0gZm91bmQ7XG4gIHRoaXMub2Zmc2V0ICAgPSBvZmZzZXQ7XG4gIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICB0aGlzLmNvbHVtbiAgID0gY29sdW1uO1xuXG4gIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7XG59XG5cbnBlZyRzdWJjbGFzcyhTeW50YXhFcnJvciwgRXJyb3IpO1xuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgIHBlZyRGQUlMRUQgPSB7fSxcblxuICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucyA9IHsgc3RhcnQ6IHBlZyRwYXJzZXN0YXJ0IH0sXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlc3RhcnQsXG5cbiAgICAgIHBlZyRjMCA9IHBlZyRGQUlMRUQsXG4gICAgICBwZWckYzEgPSBcIixcIixcbiAgICAgIHBlZyRjMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIixcIiwgZGVzY3JpcHRpb246IFwiXFxcIixcXFwiXCIgfSxcbiAgICAgIHBlZyRjMyA9IGZ1bmN0aW9uKG8sIG0pIHsgcmV0dXJuIFtvXS5jb25jYXQobSkgfSxcbiAgICAgIHBlZyRjNCA9IGZ1bmN0aW9uKG8pIHsgcmV0dXJuIFtvXSB9LFxuICAgICAgcGVnJGM1ID0gXCJbXCIsXG4gICAgICBwZWckYzYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJbXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJbXFxcIlwiIH0sXG4gICAgICBwZWckYzcgPSBcIl1cIixcbiAgICAgIHBlZyRjOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl1cIiwgZGVzY3JpcHRpb246IFwiXFxcIl1cXFwiXCIgfSxcbiAgICAgIHBlZyRjOSA9IFwiPlwiLFxuICAgICAgcGVnJGMxMCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj5cIiwgZGVzY3JpcHRpb246IFwiXFxcIj5cXFwiXCIgfSxcbiAgICAgIHBlZyRjMTEgPSBmdW5jdGlvbihmMSwgZjIsIG8pIHsgcmV0dXJuIHtzdGFydDogZjEsIGVuZDogZjIsIG1pZGRsZTogb319LFxuICAgICAgcGVnJGMxMiA9IFtdLFxuICAgICAgcGVnJGMxMyA9IGZ1bmN0aW9uKHMsIGYpIHsgcmV0dXJuIChzLmZpbHRlcnMgPSBmKSwgcyB9LFxuICAgICAgcGVnJGMxNCA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgfSxcbiAgICAgIHBlZyRjMTUgPSBudWxsLFxuICAgICAgcGVnJGMxNiA9IGZ1bmN0aW9uKHQsIGUpIHsgcmV0dXJuIHsgZXZlbnQ6IGUsIHRhcmdldDogdCB9IH0sXG4gICAgICBwZWckYzE3ID0gL15bOmEtekEtejAtOV9cXC1dLyxcbiAgICAgIHBlZyRjMTggPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzphLXpBLXowLTlfXFxcXC1dXCIsIGRlc2NyaXB0aW9uOiBcIls6YS16QS16MC05X1xcXFwtXVwiIH0sXG4gICAgICBwZWckYzE5ID0gZnVuY3Rpb24ocykgeyByZXR1cm4geyBzaWduYWw6IHMuam9pbihcIlwiKSB9fSxcbiAgICAgIHBlZyRjMjAgPSBcIihcIixcbiAgICAgIHBlZyRjMjEgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIoXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIoXFxcIlwiIH0sXG4gICAgICBwZWckYzIyID0gXCIpXCIsXG4gICAgICBwZWckYzIzID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiKVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiKVxcXCJcIiB9LFxuICAgICAgcGVnJGMyNCA9IGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHsgc3RyZWFtOiBtIH19LFxuICAgICAgcGVnJGMyNSA9IFwiLlwiLFxuICAgICAgcGVnJGMyNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgIHBlZyRjMjcgPSBcIjpcIixcbiAgICAgIHBlZyRjMjggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6XFxcIlwiIH0sXG4gICAgICBwZWckYzI5ID0gZnVuY3Rpb24oYykgeyByZXR1cm4geyB0eXBlOidjbGFzcycsIHZhbHVlOiBjIH0gfSxcbiAgICAgIHBlZyRjMzAgPSBcIiNcIixcbiAgICAgIHBlZyRjMzEgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIjXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIjXFxcIlwiIH0sXG4gICAgICBwZWckYzMyID0gZnVuY3Rpb24oaWQpIHsgcmV0dXJuIHsgdHlwZTonaWQnLCB2YWx1ZTogaWQgfSB9LFxuICAgICAgcGVnJGMzMyA9IFwibW91c2Vkb3duXCIsXG4gICAgICBwZWckYzM0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2Vkb3duXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZWRvd25cXFwiXCIgfSxcbiAgICAgIHBlZyRjMzUgPSBcIm1vdXNldXBcIixcbiAgICAgIHBlZyRjMzYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZXVwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZXVwXFxcIlwiIH0sXG4gICAgICBwZWckYzM3ID0gXCJjbGlja1wiLFxuICAgICAgcGVnJGMzOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImNsaWNrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJjbGlja1xcXCJcIiB9LFxuICAgICAgcGVnJGMzOSA9IFwiZGJsY2xpY2tcIixcbiAgICAgIHBlZyRjNDAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJkYmxjbGlja1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiZGJsY2xpY2tcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDEgPSBcIndoZWVsXCIsXG4gICAgICBwZWckYzQyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwid2hlZWxcIiwgZGVzY3JpcHRpb246IFwiXFxcIndoZWVsXFxcIlwiIH0sXG4gICAgICBwZWckYzQzID0gXCJrZXlkb3duXCIsXG4gICAgICBwZWckYzQ0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5ZG93blwiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5ZG93blxcXCJcIiB9LFxuICAgICAgcGVnJGM0NSA9IFwia2V5cHJlc3NcIixcbiAgICAgIHBlZyRjNDYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXlwcmVzc1wiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5cHJlc3NcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDcgPSBcImtleXVwXCIsXG4gICAgICBwZWckYzQ4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwia2V5dXBcIiwgZGVzY3JpcHRpb246IFwiXFxcImtleXVwXFxcIlwiIH0sXG4gICAgICBwZWckYzQ5ID0gXCJtb3VzZXdoZWVsXCIsXG4gICAgICBwZWckYzUwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2V3aGVlbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2V3aGVlbFxcXCJcIiB9LFxuICAgICAgcGVnJGM1MSA9IFwibW91c2Vtb3ZlXCIsXG4gICAgICBwZWckYzUyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2Vtb3ZlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZW1vdmVcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTMgPSBcIm1vdXNlb3V0XCIsXG4gICAgICBwZWckYzU0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VvdXRcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlb3V0XFxcIlwiIH0sXG4gICAgICBwZWckYzU1ID0gXCJtb3VzZW92ZXJcIixcbiAgICAgIHBlZyRjNTYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW92ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlb3ZlclxcXCJcIiB9LFxuICAgICAgcGVnJGM1NyA9IFwibW91c2VlbnRlclwiLFxuICAgICAgcGVnJGM1OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlZW50ZXJcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlZW50ZXJcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTkgPSBcInRvdWNoc3RhcnRcIixcbiAgICAgIHBlZyRjNjAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaHN0YXJ0XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaHN0YXJ0XFxcIlwiIH0sXG4gICAgICBwZWckYzYxID0gXCJ0b3VjaG1vdmVcIixcbiAgICAgIHBlZyRjNjIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaG1vdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNobW92ZVxcXCJcIiB9LFxuICAgICAgcGVnJGM2MyA9IFwidG91Y2hlbmRcIixcbiAgICAgIHBlZyRjNjQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ0b3VjaGVuZFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidG91Y2hlbmRcXFwiXCIgfSxcbiAgICAgIHBlZyRjNjUgPSBmdW5jdGlvbihmaWVsZCkgeyByZXR1cm4gZmllbGQgIH0sXG4gICAgICBwZWckYzY2ID0gL15bJ1wiYS16QS1aMC05Xy4+PD0hIFxcdFxcLV0vLFxuICAgICAgcGVnJGM2NyA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbJ1xcXCJhLXpBLVowLTlfLj48PSEgXFxcXHRcXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiWydcXFwiYS16QS1aMC05Xy4+PD0hIFxcXFx0XFxcXC1dXCIgfSxcbiAgICAgIHBlZyRjNjggPSBmdW5jdGlvbih2KSB7IHJldHVybiB2LmpvaW4oXCJcIikgfSxcbiAgICAgIHBlZyRjNjkgPSAvXlsgXFx0XFxyXFxuXS8sXG4gICAgICBwZWckYzcwID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsgXFxcXHRcXFxcclxcXFxuXVwiLCBkZXNjcmlwdGlvbjogXCJbIFxcXFx0XFxcXHJcXFxcbl1cIiB9LFxuXG4gICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICBwZWckcmVwb3J0ZWRQb3MgICAgICA9IDAsXG4gICAgICBwZWckY2FjaGVkUG9zICAgICAgICA9IDAsXG4gICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICBwZWckbWF4RmFpbFBvcyAgICAgICA9IDAsXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkICA9IFtdLFxuICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICBwZWckcmVzdWx0O1xuXG4gIGlmIChcInN0YXJ0UnVsZVwiIGluIG9wdGlvbnMpIHtcbiAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgcGFyc2luZyBmcm9tIHJ1bGUgXFxcIlwiICsgb3B0aW9ucy5zdGFydFJ1bGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dCgpIHtcbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0KCkge1xuICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lKCkge1xuICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICB9XG5cbiAgZnVuY3Rpb24gY29sdW1uKCkge1xuICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gIH1cblxuICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbikge1xuICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgIG51bGwsXG4gICAgICBbeyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9XSxcbiAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG1lc3NhZ2UsIG51bGwsIHBlZyRyZXBvcnRlZFBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgZnVuY3Rpb24gYWR2YW5jZShkZXRhaWxzLCBzdGFydFBvcywgZW5kUG9zKSB7XG4gICAgICB2YXIgcCwgY2g7XG5cbiAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7XG4gICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgZGV0YWlscy5saW5lKys7XG4gICAgICAgICAgZGV0YWlscy5jb2x1bW4gPSAxO1xuICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbisrO1xuICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7XG4gICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykge1xuICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJGZhaWwoZXhwZWN0ZWQpIHtcbiAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7XG4gICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgIH1cblxuICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgZXhwZWN0ZWQsIHBvcykge1xuICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB3aGlsZSAoaSA8IGV4cGVjdGVkLmxlbmd0aCkge1xuICAgICAgICBpZiAoZXhwZWN0ZWRbaSAtIDFdID09PSBleHBlY3RlZFtpXSkge1xuICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykge1xuICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH1cblxuICAgICAgICByZXR1cm4gc1xuICAgICAgICAgIC5yZXBsYWNlKC9cXFxcL2csICAgJ1xcXFxcXFxcJylcbiAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgJ1xcXFxcIicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcdC9nLCAgICdcXFxcdCcpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAgICdcXFxcbicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcci9nLCAgICdcXFxccicpXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHgwMC1cXHgwN1xceDBCXFx4MEVcXHgwRl0vZywgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceDAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMTgwLVxcdTBGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdTAnICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW1xcdTEwODAtXFx1RkZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1JyAgKyBoZXgoY2gpOyB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV4cGVjdGVkRGVzY3MgPSBuZXcgQXJyYXkoZXhwZWN0ZWQubGVuZ3RoKSxcbiAgICAgICAgICBleHBlY3RlZERlc2MsIGZvdW5kRGVzYywgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cGVjdGVkRGVzY3NbaV0gPSBleHBlY3RlZFtpXS5kZXNjcmlwdGlvbjtcbiAgICAgIH1cblxuICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICA/IGV4cGVjdGVkRGVzY3Muc2xpY2UoMCwgLTEpLmpvaW4oXCIsIFwiKVxuICAgICAgICAgICAgKyBcIiBvciBcIlxuICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgIDogZXhwZWN0ZWREZXNjc1swXTtcblxuICAgICAgZm91bmREZXNjID0gZm91bmQgPyBcIlxcXCJcIiArIHN0cmluZ0VzY2FwZShmb3VuZCkgKyBcIlxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7XG5cbiAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgfVxuXG4gICAgdmFyIHBvc0RldGFpbHMgPSBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSxcbiAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgIGlmIChleHBlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN5bnRheEVycm9yKFxuICAgICAgbWVzc2FnZSAhPT0gbnVsbCA/IG1lc3NhZ2UgOiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSxcbiAgICAgIGV4cGVjdGVkLFxuICAgICAgZm91bmQsXG4gICAgICBwb3MsXG4gICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICBwb3NEZXRhaWxzLmNvbHVtblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzdGFydCgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBzMCA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlbWVyZ2VkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgIHMzID0gcGVnJGMxO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMyhzMSwgczUpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VvcmRlcmVkKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM0KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlb3JkZXJlZCgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczksIHMxMCwgczExLCBzMTIsIHMxMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5MSkge1xuICAgICAgczEgPSBwZWckYzU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckYzE7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM2ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlZmlsdGVyZWQoKTtcbiAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgICAgICAgICAgIHM5ID0gcGVnJGM3O1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzOSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMxMCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTAgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJGM5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczExID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxMyA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMShzMywgczcsIHMxMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZpbHRlcmVkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VzdHJlYW0oKTtcbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gW107XG4gICAgICBzMyA9IHBlZyRwYXJzZWZpbHRlcigpO1xuICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTMoczEsIHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlc3RyZWFtKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXN0cmVhbSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlY2xhc3MoKTtcbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJHBhcnNlaWQoKTtcbiAgICB9XG4gICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMSA9IHBlZyRjMTU7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VldmVudFR5cGUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE2KHMxLCBzMik7XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjMTcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBpZiAocGVnJGMxNy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTgpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE5KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MCkge1xuICAgICAgICAgIHMxID0gcGVnJGMyMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjEpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VtZXJnZWQoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDEpIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckYzIyO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMyNChzMik7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlY2xhc3MoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICBzMSA9IHBlZyRjMjU7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjYpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMjc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMyOShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWlkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNSkge1xuICAgICAgczEgPSBwZWckYzMwO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMxKTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgICAgczMgPSBwZWckYzI3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMzIoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VldmVudFR5cGUoKSB7XG4gICAgdmFyIHMwO1xuXG4gICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjMzMpIHtcbiAgICAgIHMwID0gcGVnJGMzMztcbiAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNCk7IH1cbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGMzNSkge1xuICAgICAgICBzMCA9IHBlZyRjMzU7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGMzNykge1xuICAgICAgICAgIHMwID0gcGVnJGMzNztcbiAgICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjMzkpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGMzOTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0MCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0MSkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjNDE7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Mik7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA3KSA9PT0gcGVnJGM0Mykge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0MztcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA3O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDQpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNDUpIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0NTtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0Nik7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM0Nykge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDc7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OCk7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNDk7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1MCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM1MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzUxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUyKTsgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDgpID09PSBwZWckYzUzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzU1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Nik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNTcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1NztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzU5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM1OTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGM2MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjIpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM2MztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VmaWx0ZXIoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICBzMSA9IHBlZyRjNTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNldmFsdWUoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgczMgPSBwZWckYzc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzY1KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNldmFsdWUoKSB7XG4gICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gW107XG4gICAgaWYgKHBlZyRjNjYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY3KTsgfVxuICAgIH1cbiAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgaWYgKHBlZyRjNjYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjcpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICBzMSA9IHBlZyRjNjgoczEpO1xuICAgIH1cbiAgICBzMCA9IHMxO1xuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc2VwKCkge1xuICAgIHZhciBzMCwgczE7XG5cbiAgICBzMCA9IFtdO1xuICAgIGlmIChwZWckYzY5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MCk7IH1cbiAgICB9XG4gICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMC5wdXNoKHMxKTtcbiAgICAgIGlmIChwZWckYzY5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzApOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgcGVnJHJlc3VsdCA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbigpO1xuXG4gIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICB9XG5cbiAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBTeW50YXhFcnJvcjogU3ludGF4RXJyb3IsXG4gIHBhcnNlOiAgICAgICBwYXJzZVxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL2V4cHJlc3Npb24nKTtcblxudmFyIGV4cHIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJzZSA9IGV4cHJlc3Npb24ucGFyc2U7XG4gIHZhciBjb2RlZ2VuID0gZXhwcmVzc2lvbi5jb2RlKHtcbiAgICBpZFdoaXRlTGlzdDogWydkJywgJ2UnLCAnaScsICdwJywgJ3NnJ11cbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGV4cHIpIHsgICAgXG4gICAgdmFyIHZhbHVlID0gY29kZWdlbihwYXJzZShleHByKSk7XG4gICAgdmFsdWUuZm4gPSBGdW5jdGlvbignZCcsICdlJywgJ2knLCAncCcsICdzZycsXG4gICAgICAnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIHZhbHVlLmZuICsgJyk7Jyk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSkoKTtcblxuZXhwci5ldmFsID0gZnVuY3Rpb24oZ3JhcGgsIGZuLCBkLCBlLCBpLCBwLCBzZykge1xuICBzZyA9IGdyYXBoLnNpZ25hbFZhbHVlcyhkbC5hcnJheShzZykpO1xuICByZXR1cm4gZm4uY2FsbChudWxsLCBkLCBlLCBpLCBwLCBzZyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cHI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VJbnRlcmFjdG9ycyhtb2RlbCwgc3BlYywgZGVmRmFjdG9yeSkge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgc2cgPSB7fSwgcGQgPSB7fSwgbWsgPSB7fSxcbiAgICAgIHNpZ25hbHMgPSBbXSwgcHJlZGljYXRlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGxvYWRlZChpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgZGwuZXJyb3IoXCJMT0FESU5HIEZBSUxFRDogXCIgKyBpLnVybCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGVmID0gZGwuaXNPYmplY3QoZGF0YSkgPyBkYXRhIDogSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgaW50ZXJhY3RvcihpLm5hbWUsIGRlZik7XG4gICAgICB9XG4gICAgICBpZiAoLS1jb3VudCA9PSAwKSBpbmplY3QoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnRlcmFjdG9yKG5hbWUsIGRlZikge1xuICAgIHNnID0ge30sIHBkID0ge307XG4gICAgaWYgKGRlZi5zaWduYWxzKSAgICBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgbnNTaWduYWxzKG5hbWUsIGRlZi5zaWduYWxzKSk7XG4gICAgaWYgKGRlZi5wcmVkaWNhdGVzKSBwcmVkaWNhdGVzLnB1c2guYXBwbHkocHJlZGljYXRlcywgbnNQcmVkaWNhdGVzKG5hbWUsIGRlZi5wcmVkaWNhdGVzKSk7XG4gICAgbnNNYXJrcyhuYW1lLCBkZWYubWFya3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0KCkge1xuICAgIGlmIChkbC5rZXlzKG1rKS5sZW5ndGggPiAwKSBpbmplY3RNYXJrcyhzcGVjLm1hcmtzKTtcbiAgICBzcGVjLnNpZ25hbHMgPSBkbC5hcnJheShzcGVjLnNpZ25hbHMpO1xuICAgIHNwZWMucHJlZGljYXRlcyA9IGRsLmFycmF5KHNwZWMucHJlZGljYXRlcyk7XG4gICAgc3BlYy5zaWduYWxzLnVuc2hpZnQuYXBwbHkoc3BlYy5zaWduYWxzLCBzaWduYWxzKTtcbiAgICBzcGVjLnByZWRpY2F0ZXMudW5zaGlmdC5hcHBseShzcGVjLnByZWRpY2F0ZXMsIHByZWRpY2F0ZXMpO1xuICAgIGRlZkZhY3RvcnkoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluamVjdE1hcmtzKG1hcmtzKSB7XG4gICAgdmFyIG0sIHIsIGksIGxlbjtcbiAgICBtYXJrcyA9IGRsLmFycmF5KG1hcmtzKTtcblxuICAgIGZvcihpID0gMCwgbGVuID0gbWFya3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG0gPSBtYXJrc1tpXTtcbiAgICAgIGlmIChyID0gbWtbbS50eXBlXSkge1xuICAgICAgICBtYXJrc1tpXSA9IGRsLmR1cGxpY2F0ZShyKTtcbiAgICAgICAgaWYgKG0uZnJvbSkgbWFya3NbaV0uZnJvbSA9IG0uZnJvbTtcbiAgICAgICAgaWYgKG0ucHJvcGVydGllcykge1xuICAgICAgICAgIFtDLkVOVEVSLCBDLlVQREFURSwgQy5FWElUXS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIG1hcmtzW2ldLnByb3BlcnRpZXNbcF0gPSBkbC5leHRlbmQoci5wcm9wZXJ0aWVzW3BdLCBtLnByb3BlcnRpZXNbcF0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG0ubWFya3MpIHsgIC8vIFRPRE8gaG93IHRvIG92ZXJyaWRlIHByb3BlcnRpZXMgb2YgbmVzdGVkIG1hcmtzP1xuICAgICAgICBpbmplY3RNYXJrcyhtLm1hcmtzKTtcbiAgICAgIH1cbiAgICB9ICAgIFxuICB9XG5cbiAgZnVuY3Rpb24gbnMobiwgcykgeyBcbiAgICBpZiAoZGwuaXNTdHJpbmcocykpIHtcbiAgICAgIHJldHVybiBzICsgXCJfXCIgKyBuO1xuICAgIH0gZWxzZSB7XG4gICAgICBkbC5rZXlzKHMpLmZvckVhY2goZnVuY3Rpb24oeCkgeyBcbiAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXGInK3grJ1xcXFxiJywgXCJnXCIpO1xuICAgICAgICBuID0gbi5yZXBsYWNlKHJlZ2V4LCBzW3hdKSBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbnNTaWduYWxzKG5hbWUsIHNpZ25hbHMpIHtcbiAgICBzaWduYWxzID0gZGwuYXJyYXkoc2lnbmFscyk7XG4gICAgLy8gVHdvIHBhc3NlcyB0byBucyBhbGwgc2lnbmFscywgYW5kIHRoZW4gb3ZlcndyaXRlIHRoZWlyIGRlZmluaXRpb25zXG4gICAgLy8gaW4gY2FzZSBzaWduYWwgb3JkZXIgaXMgaW1wb3J0YW50LlxuICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IHMubmFtZSA9IHNnW3MubmFtZV0gPSBucyhzLm5hbWUsIG5hbWUpOyB9KTtcbiAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgICAgKHMuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgICAgIHQudHlwZSA9IG5zKHQudHlwZSwgc2cpO1xuICAgICAgICB0LmV4cHIgPSBucyh0LmV4cHIsIHNnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzaWduYWxzO1xuICB9XG5cbiAgZnVuY3Rpb24gbnNQcmVkaWNhdGVzKG5hbWUsIHByZWRpY2F0ZXMpIHtcbiAgICBwcmVkaWNhdGVzID0gZGwuYXJyYXkocHJlZGljYXRlcyk7XG4gICAgcHJlZGljYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHAubmFtZSA9IHBkW3AubmFtZV0gPSBucyhwLm5hbWUsIG5hbWUpO1xuXG4gICAgICBbcC5vcGVyYW5kcywgcC5yYW5nZV0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICh4IHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICBpZiAoby5zaWduYWwpIG8uc2lnbmFsID0gbnMoby5zaWduYWwsIHNnKTtcbiAgICAgICAgICBlbHNlIGlmIChvLnByZWRpY2F0ZSkgbnNPcGVyYW5kKG8pO1xuICAgICAgICB9KVxuICAgICAgfSk7XG5cbiAgICB9KTsgIFxuICAgIHJldHVybiBwcmVkaWNhdGVzOyBcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zT3BlcmFuZChvKSB7XG4gICAgby5wcmVkaWNhdGUgPSBwZFtvLnByZWRpY2F0ZV07XG4gICAgZGwua2V5cyhvLmlucHV0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBpID0gby5pbnB1dFtrXTtcbiAgICAgIGlmIChpLnNpZ25hbCkgaS5zaWduYWwgPSBucyhpLnNpZ25hbCwgc2cpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbnNNYXJrcyhuYW1lLCBtYXJrcykge1xuICAgIChtYXJrcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihtKSB7IFxuICAgICAgbnNQcm9wZXJ0aWVzKG0ucHJvcGVydGllcy5lbnRlcik7XG4gICAgICBuc1Byb3BlcnRpZXMobS5wcm9wZXJ0aWVzLnVwZGF0ZSk7XG4gICAgICBuc1Byb3BlcnRpZXMobS5wcm9wZXJ0aWVzLmV4aXQpO1xuICAgICAgbWtbbnMobS5uYW1lLCBuYW1lKV0gPSBtOyBcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5zUHJvcGVydGllcyhwcm9wc2V0KSB7XG4gICAgZGwua2V5cyhwcm9wc2V0KS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBwID0gcHJvcHNldFtrXTtcbiAgICAgIGlmIChwLnNpZ25hbCkgcC5zaWduYWwgPSBucyhwLnNpZ25hbCwgc2cpO1xuICAgICAgZWxzZSBpZiAocC5ydWxlKSB7XG4gICAgICAgIHAucnVsZS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHsgXG4gICAgICAgICAgaWYgKHIuc2lnbmFsKSByLnNpZ25hbCA9IG5zKHIuc2lnbmFsLCBzZyk7XG4gICAgICAgICAgaWYgKHIucHJlZGljYXRlKSBuc09wZXJhbmQocik7IFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIChzcGVjLmludGVyYWN0b3JzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoaS51cmwpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiBpLnVybH0sIGNvbmZpZy5sb2FkKSwgbG9hZGVkKGkpKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChjb3VudCA9PT0gMCkgc2V0VGltZW91dChpbmplY3QsIDEpO1xuICByZXR1cm4gc3BlYztcbn0iLCJ2YXIgbGduZCA9IHJlcXVpcmUoJy4uL3NjZW5lL2xlZ2VuZCcpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyk7XG5cbmZ1bmN0aW9uIGxlZ2VuZHMobW9kZWwsIHNwZWMsIGxlZ2VuZHMsIGdyb3VwKSB7XG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGRlZiwgaW5kZXgpIHtcbiAgICBsZWdlbmRzW2luZGV4XSA9IGxlZ2VuZHNbaW5kZXhdIHx8IGxnbmQobW9kZWwpO1xuICAgIGxlZ2VuZChkZWYsIGluZGV4LCBsZWdlbmRzW2luZGV4XSwgZ3JvdXApO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGxlZ2VuZChkZWYsIGluZGV4LCBsZWdlbmQsIGdyb3VwKSB7XG4gIC8vIGxlZ2VuZCBzY2FsZXNcbiAgbGVnZW5kLnNpemUgIChkZWYuc2l6ZSAgID8gZ3JvdXAuc2NhbGUoZGVmLnNpemUpICAgOiBudWxsKTtcbiAgbGVnZW5kLnNoYXBlIChkZWYuc2hhcGUgID8gZ3JvdXAuc2NhbGUoZGVmLnNoYXBlKSAgOiBudWxsKTtcbiAgbGVnZW5kLmZpbGwgIChkZWYuZmlsbCAgID8gZ3JvdXAuc2NhbGUoZGVmLmZpbGwpICAgOiBudWxsKTtcbiAgbGVnZW5kLnN0cm9rZShkZWYuc3Ryb2tlID8gZ3JvdXAuc2NhbGUoZGVmLnN0cm9rZSkgOiBudWxsKTtcblxuICAvLyBsZWdlbmQgb3JpZW50YXRpb25cbiAgaWYgKGRlZi5vcmllbnQpIGxlZ2VuZC5vcmllbnQoZGVmLm9yaWVudCk7XG5cbiAgLy8gbGVnZW5kIG9mZnNldFxuICBpZiAoZGVmLm9mZnNldCAhPSBudWxsKSBsZWdlbmQub2Zmc2V0KGRlZi5vZmZzZXQpO1xuXG4gIC8vIGxlZ2VuZCB0aXRsZVxuICBsZWdlbmQudGl0bGUoZGVmLnRpdGxlIHx8IG51bGwpO1xuXG4gIC8vIGxlZ2VuZCB2YWx1ZXNcbiAgbGVnZW5kLnZhbHVlcyhkZWYudmFsdWVzIHx8IG51bGwpO1xuXG4gIC8vIGxlZ2VuZCBsYWJlbCBmb3JtYXR0aW5nXG4gIGxlZ2VuZC5mb3JtYXQoZGVmLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZGVmLmZvcm1hdCA6IG51bGwpO1xuXG4gIC8vIHN0eWxlIHByb3BlcnRpZXNcbiAgdmFyIHAgPSBkZWYucHJvcGVydGllcztcbiAgbGVnZW5kLnRpdGxlUHJvcGVydGllcyhwICYmIHAudGl0bGUgfHwge30pO1xuICBsZWdlbmQubGFiZWxQcm9wZXJ0aWVzKHAgJiYgcC5sYWJlbHMgfHwge30pO1xuICBsZWdlbmQubGVnZW5kUHJvcGVydGllcyhwICYmIHAubGVnZW5kIHx8IHt9KTtcbiAgbGVnZW5kLnN5bWJvbFByb3BlcnRpZXMocCAmJiBwLnN5bWJvbHMgfHwge30pO1xuICBsZWdlbmQuZ3JhZGllbnRQcm9wZXJ0aWVzKHAgJiYgcC5ncmFkaWVudCB8fCB7fSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGVnZW5kczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgcGFyc2VQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9wcm9wZXJ0aWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VNYXJrKG1vZGVsLCBtYXJrKSB7XG4gIHZhciBwcm9wcyA9IG1hcmsucHJvcGVydGllcyxcbiAgICAgIGdyb3VwID0gbWFyay5tYXJrcztcblxuICAvLyBwYXJzZSBtYXJrIHByb3BlcnR5IGRlZmluaXRpb25zXG4gIGRsLmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHByb3BzW2tdID0gcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLnR5cGUsIHByb3BzW2tdKTtcbiAgfSk7XG5cbiAgLy8gcGFyc2UgZGVsYXkgZnVuY3Rpb25cbiAgaWYgKG1hcmsuZGVsYXkpIHtcbiAgICBtYXJrLmRlbGF5ID0gcGFyc2VQcm9wZXJ0aWVzKG1vZGVsLCBtYXJrLnR5cGUsIHtkZWxheTogbWFyay5kZWxheX0pO1xuICB9XG5cbiAgLy8gcmVjdXJzZSBpZiBncm91cCB0eXBlXG4gIGlmIChncm91cCkge1xuICAgIG1hcmsubWFya3MgPSBncm91cC5tYXAoZnVuY3Rpb24oZykgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBnKTsgfSk7XG4gIH1cbiAgICBcbiAgcmV0dXJuIG1hcms7XG59OyIsInZhciBwYXJzZU1hcmsgPSByZXF1aXJlKCcuL21hcmsnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2RlbCwgc3BlYywgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgc2NhbGVzOiBzcGVjLnNjYWxlcyB8fCBbXSxcbiAgICBheGVzOiBzcGVjLmF4ZXMgfHwgW10sXG4gICAgbGVnZW5kczogc3BlYy5sZWdlbmRzIHx8IFtdLFxuICAgIG1hcmtzOiAoc3BlYy5tYXJrcyB8fCBbXSkubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pXG4gIH07XG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIGZpbHRlciA9IGZ1bmN0aW9uKGZpZWxkLCB2YWx1ZSwgc3JjLCBkZXN0KSB7XG4gIGZvcih2YXIgaSA9IHNyYy5sZW5ndGgtMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBpZihzcmNbaV1bZmllbGRdID09IHZhbHVlKVxuICAgICAgZGVzdC5wdXNoLmFwcGx5KGRlc3QsIHNyYy5zcGxpY2UoaSwgMSkpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTW9kaWZ5KG1vZGVsLCBkZWYsIGRzKSB7XG4gIHZhciBzaWduYWwgPSBkZWYuc2lnbmFsID8gZGwuZmllbGQoZGVmLnNpZ25hbCkgOiBudWxsLCBcbiAgICAgIHNpZ25hbE5hbWUgPSBzaWduYWwgPyBzaWduYWxbMF0gOiBudWxsLFxuICAgICAgcHJlZGljYXRlID0gZGVmLnByZWRpY2F0ZSA/IG1vZGVsLnByZWRpY2F0ZShkZWYucHJlZGljYXRlKSA6IG51bGwsXG4gICAgICByZWV2YWwgPSAocHJlZGljYXRlID09PSBudWxsKSxcbiAgICAgIG5vZGUgPSBuZXcgTm9kZShtb2RlbCk7XG5cbiAgbm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYocHJlZGljYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGIgPSB7fTtcbiAgICAgIChwcmVkaWNhdGUuZGF0YXx8W10pLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkYltkXSA9IG1vZGVsLmRhdGEoZCkudmFsdWVzKCk7IH0pO1xuXG4gICAgICAvLyBUT0RPOiBpbnB1dFxuICAgICAgcmVldmFsID0gcHJlZGljYXRlLmNhbGwocHJlZGljYXRlLCB7fSwgZGIsIG1vZGVsLnNpZ25hbFZhbHVlcyhwcmVkaWNhdGUuc2lnbmFsc3x8W10pLCBtb2RlbC5fcHJlZGljYXRlcyk7XG4gICAgfVxuXG4gICAgZGVidWcoaW5wdXQsIFtkZWYudHlwZStcImluZ1wiLCByZWV2YWxdKTtcbiAgICBpZighcmVldmFsKSByZXR1cm4gaW5wdXQ7XG5cbiAgICB2YXIgZGF0dW0gPSB7fSwgXG4gICAgICAgIHZhbHVlID0gc2lnbmFsID8gbW9kZWwuc2lnbmFsUmVmKGRlZi5zaWduYWwpIDogbnVsbCxcbiAgICAgICAgZCA9IG1vZGVsLmRhdGEoZHMubmFtZSksXG4gICAgICAgIHByZXYgPSBkLnJldmlzZXMoKSA/IG51bGwgOiB1bmRlZmluZWQsXG4gICAgICAgIHQgPSBudWxsO1xuXG4gICAgZGF0dW1bZGVmLmZpZWxkXSA9IHZhbHVlO1xuXG4gICAgLy8gV2UgaGF2ZSB0byBtb2RpZnkgZHMuX2RhdGEgc28gdGhhdCBzdWJzZXF1ZW50IHB1bHNlcyBjb250YWluXG4gICAgLy8gb3VyIGR5bmFtaWMgZGF0YS4gVy9vIG1vZGlmeWluZyBkcy5fZGF0YSwgb25seSB0aGUgb3V0cHV0XG4gICAgLy8gY29sbGVjdG9yIHdpbGwgY29udGFpbiBkeW5hbWljIHR1cGxlcy4gXG4gICAgaWYoZGVmLnR5cGUgPT0gQy5BREQpIHtcbiAgICAgIHQgPSB0dXBsZS5pbmdlc3QoZGF0dW0sIHByZXYpO1xuICAgICAgaW5wdXQuYWRkLnB1c2godCk7XG4gICAgICBkLl9kYXRhLnB1c2godCk7XG4gICAgfSBlbHNlIGlmKGRlZi50eXBlID09IEMuUkVNT1ZFKSB7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQuYWRkLCBpbnB1dC5yZW0pO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0Lm1vZCwgaW5wdXQucmVtKTtcbiAgICAgIGQuX2RhdGEgPSBkLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB4W2RlZi5maWVsZF0gIT09IHZhbHVlIH0pO1xuICAgIH0gZWxzZSBpZihkZWYudHlwZSA9PSBDLlRPR0dMRSkge1xuICAgICAgdmFyIGFkZCA9IFtdLCByZW0gPSBbXTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5yZW0sIGFkZCk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQuYWRkLCByZW0pO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0Lm1vZCwgcmVtKTtcbiAgICAgIGlmKGFkZC5sZW5ndGggPT0gMCAmJiByZW0ubGVuZ3RoID09IDApIGFkZC5wdXNoKHR1cGxlLmluZ2VzdChkYXR1bSkpO1xuXG4gICAgICBpbnB1dC5hZGQucHVzaC5hcHBseShpbnB1dC5hZGQsIGFkZCk7XG4gICAgICBkLl9kYXRhLnB1c2guYXBwbHkoZC5fZGF0YSwgYWRkKTtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgcmVtKTtcbiAgICAgIGQuX2RhdGEgPSBkLl9kYXRhLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW0uaW5kZXhPZih4KSA9PT0gLTEgfSk7XG4gICAgfSBlbHNlIGlmKGRlZi50eXBlID09IEMuQ0xFQVIpIHtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgaW5wdXQuYWRkKTtcbiAgICAgIGlucHV0LnJlbS5wdXNoLmFwcGx5KGlucHV0LnJlbSwgaW5wdXQubW9kKTtcbiAgICAgIGlucHV0LmFkZCA9IFtdO1xuICAgICAgaW5wdXQubW9kID0gW107XG4gICAgICBkLl9kYXRhICA9IFtdO1xuICAgIH0gXG5cbiAgICBpbnB1dC5maWVsZHNbZGVmLmZpZWxkXSA9IDE7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9O1xuXG4gIGlmKHNpZ25hbE5hbWUpIG5vZGUuZGVwZW5kZW5jeShDLlNJR05BTFMsIHNpZ25hbE5hbWUpO1xuICBpZihwcmVkaWNhdGUpICBub2RlLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBwcmVkaWNhdGUuc2lnbmFscyk7XG4gIFxuICByZXR1cm4gbm9kZTtcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZCkge1xuICBpZiAocGFkID09IG51bGwpIHJldHVybiBcImF1dG9cIjtcbiAgZWxzZSBpZiAoZGwuaXNTdHJpbmcocGFkKSkgcmV0dXJuIHBhZD09PVwic3RyaWN0XCIgPyBcInN0cmljdFwiIDogXCJhdXRvXCI7XG4gIGVsc2UgaWYgKGRsLmlzT2JqZWN0KHBhZCkpIHJldHVybiBwYWQ7XG4gIHZhciBwID0gZGwuaXNOdW1iZXIocGFkKSA/IHBhZCA6IDIwO1xuICByZXR1cm4ge3RvcDpwLCBsZWZ0OnAsIHJpZ2h0OnAsIGJvdHRvbTpwfTtcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VQcmVkaWNhdGUobW9kZWwsIHNwZWMpIHtcbiAgdmFyIHR5cGVzID0ge1xuICAgICc9JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPT0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJyE9JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICc+JzogIHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPj0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJzwnOiAgcGFyc2VDb21wYXJhdG9yLFxuICAgICc8PSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnYW5kJzogcGFyc2VMb2dpY2FsLFxuICAgICcmJic6ICBwYXJzZUxvZ2ljYWwsXG4gICAgJ29yJzogIHBhcnNlTG9naWNhbCxcbiAgICAnfHwnOiAgcGFyc2VMb2dpY2FsLFxuICAgICdpbic6IHBhcnNlSW5cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZVNpZ25hbChzaWduYWwsIHNpZ25hbHMpIHtcbiAgICB2YXIgcyA9IGRsLmZpZWxkKHNpZ25hbCksXG4gICAgICAgIGNvZGUgPSBcInNpZ25hbHNbXCIrcy5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCI7XG4gICAgc2lnbmFsc1tzLnNoaWZ0KCldID0gMTtcbiAgICByZXR1cm4gY29kZTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZU9wZXJhbmRzKG9wZXJhbmRzKSB7XG4gICAgdmFyIGRlY2wgPSBbXSwgZGVmcyA9IFtdLFxuICAgICAgICBzaWduYWxzID0ge30sIGRiID0ge307XG5cbiAgICBkbC5hcnJheShvcGVyYW5kcykuZm9yRWFjaChmdW5jdGlvbihvLCBpKSB7XG4gICAgICB2YXIgc2lnbmFsLCBuYW1lID0gXCJvXCIraSwgZGVmID0gXCJcIjtcbiAgICAgIFxuICAgICAgaWYoby52YWx1ZSAhPT0gdW5kZWZpbmVkKSBkZWYgPSBkbC5zdHIoby52YWx1ZSk7XG4gICAgICBlbHNlIGlmKG8uYXJnKSAgICBkZWYgPSBcImFyZ3NbXCIrZGwuc3RyKG8uYXJnKStcIl1cIjtcbiAgICAgIGVsc2UgaWYoby5zaWduYWwpIGRlZiA9IHBhcnNlU2lnbmFsKG8uc2lnbmFsLCBzaWduYWxzKTtcbiAgICAgIGVsc2UgaWYoby5wcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHByZWQgPSBtb2RlbC5wcmVkaWNhdGUoby5wcmVkaWNhdGUpLFxuICAgICAgICAgICAgcCA9IFwicHJlZGljYXRlc1tcIitkbC5zdHIoby5wcmVkaWNhdGUpK1wiXVwiO1xuXG4gICAgICAgIHByZWQuc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgc2lnbmFsc1tzXSA9IDE7IH0pO1xuICAgICAgICBwcmVkLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IGRiW2RdID0gMSB9KTtcblxuICAgICAgICBkbC5rZXlzKG8uaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgIHZhciBpID0gby5pbnB1dFtrXSwgc2lnbmFsO1xuICAgICAgICAgIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGspK1wiXSA9IFwiO1xuICAgICAgICAgIGlmKGkuc2lnbmFsKSAgIGRlZiArPSBwYXJzZVNpZ25hbChpLnNpZ25hbCwgc2lnbmFscyk7XG4gICAgICAgICAgZWxzZSBpZihpLmFyZykgZGVmICs9IFwiYXJnc1tcIitkbC5zdHIoaS5hcmcpK1wiXVwiO1xuICAgICAgICAgIGRlZis9XCIsIFwiO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWYrPSBwK1wiLmNhbGwoXCIrcCtcIiwgYXJncywgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpXCI7XG4gICAgICB9XG5cbiAgICAgIGRlY2wucHVzaChuYW1lKTtcbiAgICAgIGRlZnMucHVzaChuYW1lK1wiPShcIitkZWYrXCIpXCIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IFwidmFyIFwiICsgZGVjbC5qb2luKFwiLCBcIikgKyBcIjtcXG5cIiArIGRlZnMuam9pbihcIjtcXG5cIikgKyBcIjtcXG5cIixcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoc2lnbmFscyksXG4gICAgICBkYXRhOiBkbC5rZXlzKGRiKVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3Ioc3BlYykge1xuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKHNwZWMub3BlcmFuZHMpO1xuICAgIGlmKHNwZWMudHlwZSA9PSAnPScpIHNwZWMudHlwZSA9ICc9PSc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIFtcIm8wXCIsIFwibzFcIl0uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICAgIGRhdGE6IG9wcy5kYXRhXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWwoc3BlYykge1xuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKHNwZWMub3BlcmFuZHMpLFxuICAgICAgICBvID0gW10sIGkgPSAwLCBsZW4gPSBzcGVjLm9wZXJhbmRzLmxlbmd0aDtcblxuICAgIHdoaWxlKG8ucHVzaChcIm9cIitpKyspPGxlbik7XG4gICAgaWYoc3BlYy50eXBlID09ICdhbmQnKSBzcGVjLnR5cGUgPSAnJiYnO1xuICAgIGVsc2UgaWYoc3BlYy50eXBlID09ICdvcicpIHNwZWMudHlwZSA9ICd8fCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIG8uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICAgIGRhdGE6IG9wcy5kYXRhXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUluKHNwZWMpIHtcbiAgICB2YXIgbyA9IFtzcGVjLml0ZW1dLCBjb2RlID0gXCJcIjtcbiAgICBpZihzcGVjLnJhbmdlKSBvLnB1c2guYXBwbHkobywgc3BlYy5yYW5nZSk7XG4gICAgaWYoc3BlYy5zY2FsZSkge1xuICAgICAgY29kZSA9IHBhcnNlU2NhbGUoc3BlYy5zY2FsZSwgbyk7XG4gICAgfVxuXG4gICAgdmFyIG9wcyA9IHBhcnNlT3BlcmFuZHMobyk7XG4gICAgY29kZSA9IG9wcy5jb2RlICsgY29kZTtcblxuICAgIGlmKHNwZWMuZGF0YSkge1xuICAgICAgdmFyIGZpZWxkID0gZGwuZmllbGQoc3BlYy5maWVsZCkubWFwKGRsLnN0cik7XG4gICAgICBjb2RlICs9IFwidmFyIHdoZXJlID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZFtcIitmaWVsZC5qb2luKFwiXVtcIikrXCJdID09IG8wIH07XFxuXCI7XG4gICAgICBjb2RlICs9IFwicmV0dXJuIGRiW1wiK2RsLnN0cihzcGVjLmRhdGEpK1wiXS5maWx0ZXIod2hlcmUpLmxlbmd0aCA+IDA7XCI7XG4gICAgfSBlbHNlIGlmKHNwZWMucmFuZ2UpIHtcbiAgICAgIC8vIFRPRE86IGluY2x1c2l2ZS9leGNsdXNpdmUgcmFuZ2U/XG4gICAgICAvLyBUT0RPOiBpbnZlcnRpbmcgb3JkaW5hbCBzY2FsZXNcbiAgICAgIGlmKHNwZWMuc2NhbGUpIGNvZGUgKz0gXCJvMSA9IHNjYWxlKG8xKTtcXG5vMiA9IHNjYWxlKG8yKTtcXG5cIjtcbiAgICAgIGNvZGUgKz0gXCJyZXR1cm4gbzEgPCBvMiA/IG8xIDw9IG8wICYmIG8wIDw9IG8yIDogbzIgPD0gbzAgJiYgbzAgPD0gbzFcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogY29kZSwgXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscywgXG4gICAgICBkYXRhOiBvcHMuZGF0YS5jb25jYXQoc3BlYy5kYXRhID8gW3NwZWMuZGF0YV0gOiBbXSlcbiAgICB9O1xuICB9O1xuXG4gIC8vIFBvcHVsYXRlIG9wcyBzdWNoIHRoYXQgdWx0aW1hdGUgc2NhbGUvaW52ZXJzaW9uIGZ1bmN0aW9uIHdpbGwgYmUgaW4gYHNjYWxlYCB2YXIuIFxuICBmdW5jdGlvbiBwYXJzZVNjYWxlKHNwZWMsIG9wcykge1xuICAgIHZhciBjb2RlID0gXCJ2YXIgc2NhbGUgPSBcIiwgXG4gICAgICAgIGlkeCAgPSBvcHMubGVuZ3RoO1xuXG4gICAgaWYoZGwuaXNTdHJpbmcoc3BlYykpIHtcbiAgICAgIG9wcy5wdXNoKHsgdmFsdWU6IHNwZWMgfSk7XG4gICAgICBjb2RlICs9IFwidGhpcy5yb290KCkuc2NhbGUob1wiK2lkeCtcIilcIjtcbiAgICB9IGVsc2UgaWYoc3BlYy5hcmcpIHsgIC8vIFNjYWxlIGZ1bmN0aW9uIGlzIGJlaW5nIHBhc3NlZCBhcyBhbiBhcmdcbiAgICAgIG9wcy5wdXNoKHNwZWMpO1xuICAgICAgY29kZSArPSBcIm9cIitpZHg7XG4gICAgfSBlbHNlIGlmKHNwZWMubmFtZSkgeyAvLyBGdWxsIHNjYWxlIHBhcmFtZXRlciB7bmFtZTogLi59XG4gICAgICBvcHMucHVzaChkbC5pc1N0cmluZyhzcGVjLm5hbWUpID8ge3ZhbHVlOiBzcGVjLm5hbWV9IDogc3BlYy5uYW1lKTtcbiAgICAgIGNvZGUgKz0gXCIodGhpcy5pc0Z1bmN0aW9uKG9cIitpZHgrXCIpID8gb1wiK2lkeCtcIiA6IFwiO1xuICAgICAgaWYoc3BlYy5zY29wZSkge1xuICAgICAgICBvcHMucHVzaChzcGVjLnNjb3BlKTtcbiAgICAgICAgY29kZSArPSBcIihvXCIrKGlkeCsxKStcIi5zY2FsZSB8fCB0aGlzLnJvb3QoKS5zY2FsZSkob1wiK2lkeCtcIilcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvZGUgKz0gXCJ0aGlzLnJvb3QoKS5zY2FsZShvXCIraWR4K1wiKVwiO1xuICAgICAgfVxuICAgICAgY29kZSArPSBcIilcIlxuICAgIH1cblxuICAgIGlmKHNwZWMuaW52ZXJ0ID09PSB0cnVlKSB7ICAvLyBBbGxvdyBzcGVjLmludmVydC5hcmc/XG4gICAgICBjb2RlICs9IFwiLmludmVydFwiXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGUrXCI7XFxuXCI7XG4gIH1cblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgdmFyIHBhcnNlID0gdHlwZXNbcy50eXBlXShzKSxcbiAgICAgICAgcHJlZCAgPSBGdW5jdGlvbihcImFyZ3NcIiwgXCJkYlwiLCBcInNpZ25hbHNcIiwgXCJwcmVkaWNhdGVzXCIsIHBhcnNlLmNvZGUpO1xuICAgIHByZWQucm9vdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kZWwuc2NlbmUoKS5pdGVtc1swXSB9OyAvLyBGb3IgZ2xvYmFsIHNjYWxlc1xuICAgIHByZWQuaXNGdW5jdGlvbiA9IGRsLmlzRnVuY3Rpb247XG4gICAgcHJlZC5zaWduYWxzID0gcGFyc2Uuc2lnbmFscztcbiAgICBwcmVkLmRhdGEgPSBwYXJzZS5kYXRhO1xuICAgIG1vZGVsLnByZWRpY2F0ZShzLm5hbWUsIHByZWQpO1xuICB9KTtcblxuICByZXR1cm4gc3BlYztcbn0iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKTtcblxudmFyIERFUFMgPSBbXCJzaWduYWxzXCIsIFwic2NhbGVzXCIsIFwiZGF0YVwiLCBcImZpZWxkc1wiXTtcblxuZnVuY3Rpb24gY29tcGlsZShtb2RlbCwgbWFyaywgc3BlYykge1xuICB2YXIgY29kZSA9IFwiXCIsXG4gICAgICBuYW1lcyA9IGRsLmtleXMoc3BlYyksXG4gICAgICBpLCBsZW4sIG5hbWUsIHJlZiwgdmFycyA9IHt9LCBcbiAgICAgIGRlcHMgPSB7XG4gICAgICAgIHNpZ25hbHM6IHt9LFxuICAgICAgICBzY2FsZXM6ICB7fSxcbiAgICAgICAgZGF0YTogICAge30sXG4gICAgICAgIGZpZWxkczogIHt9LFxuICAgICAgICByZWZsb3c6ICBmYWxzZVxuICAgICAgfTtcbiAgICAgIFxuICBjb2RlICs9IFwidmFyIG8gPSB0cmFucyA/IHt9IDogaXRlbTtcXG5cIlxuICBcbiAgZm9yIChpPTAsIGxlbj1uYW1lcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICByZWYgPSBzcGVjW25hbWUgPSBuYW1lc1tpXV07XG4gICAgY29kZSArPSAoaSA+IDApID8gXCJcXG4gIFwiIDogXCIgIFwiO1xuICAgIGlmKHJlZi5ydWxlKSB7XG4gICAgICByZWYgPSBydWxlKG1vZGVsLCBuYW1lLCByZWYucnVsZSk7XG4gICAgICBjb2RlICs9IFwiXFxuICBcIiArIHJlZi5jb2RlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHZhbHVlUmVmKG5hbWUsIHJlZik7XG4gICAgICBjb2RlICs9IFwidGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XCI7XG4gICAgfVxuXG4gICAgdmFyc1tuYW1lXSA9IHRydWU7XG4gICAgREVQUy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIGlmKHJlZltwXSAhPSBudWxsKSBkbC5hcnJheShyZWZbcF0pLmZvckVhY2goZnVuY3Rpb24oaykgeyBkZXBzW3BdW2tdID0gMSB9KTtcbiAgICB9KTtcbiAgICBkZXBzLnJlZmxvdyA9IGRlcHMucmVmbG93IHx8IHJlZi5yZWZsb3c7XG4gIH1cblxuICBpZiAodmFycy54Mikge1xuICAgIGlmICh2YXJzLngpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGlmIChvLnggPiBvLngyKSB7IFwiXG4gICAgICAgICAgICArIFwidmFyIHQgPSBvLng7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3gnLCBvLngyKTtcIlxuICAgICAgICAgICAgKyBcInRoaXMudHBsLnNldChvLCAneDInLCB0KTsgXCJcbiAgICAgICAgICAgICsgXCJ9O1wiO1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd3aWR0aCcsIChvLngyIC0gby54KSk7XCI7XG4gICAgfSBlbHNlIGlmICh2YXJzLndpZHRoKSB7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3gnLCAoby54MiAtIG8ud2lkdGgpKTtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd4Jywgby54Mik7XCJcbiAgICB9XG4gIH1cblxuICBpZiAodmFycy55Mikge1xuICAgIGlmICh2YXJzLnkpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIGlmIChvLnkgPiBvLnkyKSB7IFwiXG4gICAgICAgICAgICArIFwidmFyIHQgPSBvLnk7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3knLCBvLnkyKTtcIlxuICAgICAgICAgICAgKyBcInRoaXMudHBsLnNldChvLCAneTInLCB0KTtcIlxuICAgICAgICAgICAgKyBcIn07XCI7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ2hlaWdodCcsIChvLnkyIC0gby55KSk7XCI7XG4gICAgfSBlbHNlIGlmICh2YXJzLmhlaWdodCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd5JywgKG8ueTIgLSBvLmhlaWdodCkpO1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3knLCBvLnkyKTtcIlxuICAgIH1cbiAgfVxuICBcbiAgaWYgKGhhc1BhdGgobWFyaywgdmFycykpIGNvZGUgKz0gXCJcXG4gIGl0ZW0udG91Y2goKTtcIjtcbiAgY29kZSArPSBcIlxcbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcIjtcblxuICB0cnkge1xuICAgIHZhciBlbmNvZGVyID0gRnVuY3Rpb24oXCJpdGVtXCIsIFwiZ3JvdXBcIiwgXCJ0cmFuc1wiLCBcImRiXCIsIFxuICAgICAgXCJzaWduYWxzXCIsIFwicHJlZGljYXRlc1wiLCBjb2RlKTtcbiAgICBlbmNvZGVyLnRwbCAgPSB0dXBsZTtcbiAgICBlbmNvZGVyLnV0aWwgPSBkbDtcbiAgICBlbmNvZGVyLmQzICAgPSBkMzsgLy8gRm9yIGNvbG9yIHNwYWNlc1xuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6ICBlbmNvZGVyLFxuICAgICAgc2lnbmFsczogZGwua2V5cyhkZXBzLnNpZ25hbHMpLFxuICAgICAgc2NhbGVzOiAgZGwua2V5cyhkZXBzLnNjYWxlcyksXG4gICAgICBkYXRhOiAgICBkbC5rZXlzKGRlcHMuZGF0YSksXG4gICAgICBmaWVsZHM6ICBkbC5rZXlzKGRlcHMuZmllbGRzKSxcbiAgICAgIHJlZmxvdzogIGRlcHMucmVmbG93XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGwuZXJyb3IoZSk7XG4gICAgZGwubG9nKGNvZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc1BhdGgobWFyaywgdmFycykge1xuICByZXR1cm4gdmFycy5wYXRoIHx8XG4gICAgKChtYXJrPT09XCJhcmVhXCIgfHwgbWFyaz09PVwibGluZVwiKSAmJlxuICAgICAgKHZhcnMueCB8fCB2YXJzLngyIHx8IHZhcnMud2lkdGggfHxcbiAgICAgICB2YXJzLnkgfHwgdmFycy55MiB8fCB2YXJzLmhlaWdodCB8fFxuICAgICAgIHZhcnMudGVuc2lvbiB8fCB2YXJzLmludGVycG9sYXRlKSk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobW9kZWwsIG5hbWUsIHJ1bGVzKSB7XG4gIHZhciBzaWduYWxzID0gW10sIHNjYWxlcyA9IFtdLCBkYiA9IFtdLFxuICAgICAgaW5wdXRzID0gW10sIGNvZGUgPSBcIlwiO1xuXG4gIChydWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ociwgaSkge1xuICAgIHZhciBwcmVkTmFtZSA9IHIucHJlZGljYXRlLFxuICAgICAgICBwcmVkID0gbW9kZWwucHJlZGljYXRlKHByZWROYW1lKSxcbiAgICAgICAgcCA9IFwicHJlZGljYXRlc1tcIitkbC5zdHIocHJlZE5hbWUpK1wiXVwiLFxuICAgICAgICBpbnB1dCA9IFtdLCBhcmdzID0gbmFtZStcIl9hcmdcIitpLFxuICAgICAgICByZWY7XG5cbiAgICBkbC5rZXlzKHIuaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHJlZiA9IHZhbHVlUmVmKGksIHIuaW5wdXRba10pO1xuICAgICAgaW5wdXQucHVzaChkbC5zdHIoaykrXCI6IFwiK3JlZi52YWwpO1xuICAgICAgaWYocmVmLnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBkbC5hcnJheShyZWYuc2lnbmFscykpO1xuICAgICAgaWYocmVmLnNjYWxlcykgIHNjYWxlcy5wdXNoLmFwcGx5KHNjYWxlcywgZGwuYXJyYXkocmVmLnNjYWxlcykpO1xuICAgIH0pO1xuXG4gICAgcmVmID0gdmFsdWVSZWYobmFtZSwgcik7XG4gICAgaWYocmVmLnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBkbC5hcnJheShyZWYuc2lnbmFscykpO1xuICAgIGlmKHJlZi5zY2FsZXMpICBzY2FsZXMucHVzaC5hcHBseShzY2FsZXMsIGRsLmFycmF5KHJlZi5zY2FsZXMpKTtcblxuICAgIGlmKHByZWROYW1lKSB7XG4gICAgICBzaWduYWxzLnB1c2guYXBwbHkoc2lnbmFscywgcHJlZC5zaWduYWxzKTtcbiAgICAgIGRiLnB1c2guYXBwbHkoZGIsIHByZWQuZGF0YSk7XG4gICAgICBpbnB1dHMucHVzaChhcmdzK1wiID0ge1wiK2lucHV0LmpvaW4oJywgJykrXCJ9XCIpO1xuICAgICAgY29kZSArPSBcImlmKFwiK3ArXCIuY2FsbChcIitwK1wiLFwiK2FyZ3MrXCIsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSkge1xcblwiICtcbiAgICAgICAgXCIgICAgdGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XFxuXCI7XG4gICAgICBjb2RlICs9IHJ1bGVzW2krMV0gPyBcIiAgfSBlbHNlIFwiIDogXCIgIH1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIntcXG5cIiArIFxuICAgICAgICBcIiAgICB0aGlzLnRwbC5zZXQobywgXCIrZGwuc3RyKG5hbWUpK1wiLCBcIityZWYudmFsK1wiKTtcXG5cIitcbiAgICAgICAgXCIgIH1cIjtcbiAgICB9XG4gIH0pO1xuXG4gIGNvZGUgPSBcInZhciBcIiArIGlucHV0cy5qb2luKFwiLFxcbiAgICAgIFwiKSArIFwiO1xcbiAgXCIgKyBjb2RlO1xuICByZXR1cm4ge2NvZGU6IGNvZGUsIHNpZ25hbHM6IHNpZ25hbHMsIHNjYWxlczogc2NhbGVzLCBkYXRhOiBkYn07XG59XG5cbmZ1bmN0aW9uIHZhbHVlUmVmKG5hbWUsIHJlZikge1xuICBpZiAocmVmID09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIGlmIChuYW1lPT09XCJmaWxsXCIgfHwgbmFtZT09PVwic3Ryb2tlXCIpIHtcbiAgICBpZiAocmVmLmMpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcImhjbFwiLCByZWYuaCwgcmVmLmMsIHJlZi5sKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5oIHx8IHJlZi5zKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJoc2xcIiwgcmVmLmgsIHJlZi5zLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYubCB8fCByZWYuYSkge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwibGFiXCIsIHJlZi5sLCByZWYuYSwgcmVmLmIpO1xuICAgIH0gZWxzZSBpZiAocmVmLnIgfHwgcmVmLmcgfHwgcmVmLmIpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcInJnYlwiLCByZWYuciwgcmVmLmcsIHJlZi5iKTtcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHZhbHVlXG4gIHZhciB2YWwgPSBudWxsLCBzY2FsZSA9IG51bGwsIFxuICAgICAgc2dSZWYgPSB7fSwgZlJlZiA9IHt9LCBzUmVmID0ge30sXG4gICAgICBzaWduYWxzID0gW10sIGZpZWxkcyA9IFtdLCByZWZsb3cgPSBmYWxzZTtcblxuICBpZiAocmVmLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBkbC5zdHIocmVmLnZhbHVlKTtcbiAgfVxuXG4gIGlmIChyZWYuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZ1JlZiA9IGRsLmZpZWxkKHJlZi5zaWduYWwpO1xuICAgIHZhbCA9IFwic2lnbmFsc1tcIitzZ1JlZi5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCI7IFxuICAgIHNpZ25hbHMucHVzaChzZ1JlZi5zaGlmdCgpKTtcbiAgfVxuXG4gIGlmKHJlZi5maWVsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmVmLmZpZWxkID0gZGwuaXNTdHJpbmcocmVmLmZpZWxkKSA/IHtkYXR1bTogcmVmLmZpZWxkfSA6IHJlZi5maWVsZDtcbiAgICBmUmVmICA9IGZpZWxkUmVmKHJlZi5maWVsZCk7XG4gICAgdmFsID0gZlJlZi52YWw7XG4gIH1cblxuICBpZiAocmVmLnNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICBzUmVmID0gc2NhbGVSZWYocmVmLnNjYWxlKTtcbiAgICBzY2FsZSA9IHNSZWYudmFsO1xuXG4gICAgLy8gcnVuIHRocm91Z2ggc2NhbGUgZnVuY3Rpb24gaWYgdmFsIHNwZWNpZmllZC5cbiAgICAvLyBpZiBubyB2YWwsIHNjYWxlIGZ1bmN0aW9uIGlzIHByZWRpY2F0ZSBhcmcuXG4gICAgaWYodmFsICE9PSBudWxsIHx8IHJlZi5iYW5kIHx8IHJlZi5tdWx0IHx8IHJlZi5vZmZzZXQpIHtcbiAgICAgIHZhbCA9IHNjYWxlICsgKHJlZi5iYW5kID8gXCIucmFuZ2VCYW5kKClcIiA6IFxuICAgICAgICBcIihcIisodmFsICE9PSBudWxsID8gdmFsIDogXCJpdGVtLmRhdHVtLmRhdGFcIikrXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBzY2FsZTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIG11bHRpcGx5LCBvZmZzZXQsIHJldHVybiB2YWx1ZVxuICB2YWwgPSBcIihcIiArIChyZWYubXVsdD8oZGwubnVtYmVyKHJlZi5tdWx0KStcIiAqIFwiKTpcIlwiKSArIHZhbCArIFwiKVwiXG4gICAgKyAocmVmLm9mZnNldCA/IFwiICsgXCIgKyBkbC5udW1iZXIocmVmLm9mZnNldCkgOiBcIlwiKTtcblxuICAvLyBDb2xsYXRlIGRlcGVuZGVuY2llc1xuICByZXR1cm4ge1xuICAgIHZhbDogdmFsLFxuICAgIHNpZ25hbHM6IHNpZ25hbHMuY29uY2F0KGRsLmFycmF5KGZSZWYuc2lnbmFscykpLmNvbmNhdChkbC5hcnJheShzUmVmLnNpZ25hbHMpKSxcbiAgICBmaWVsZHM6ICBmaWVsZHMuY29uY2F0KGRsLmFycmF5KGZSZWYuZmllbGRzKSkuY29uY2F0KGRsLmFycmF5KHNSZWYuZmllbGRzKSksXG4gICAgc2NhbGVzOiAgcmVmLnNjYWxlID8gKHJlZi5zY2FsZS5uYW1lIHx8IHJlZi5zY2FsZSkgOiBudWxsLCAvLyBUT0RPOiBjb25uZWN0IHNSZWYnZCBzY2FsZT9cbiAgICByZWZsb3c6ICByZWZsb3cgfHwgZlJlZi5yZWZsb3cgfHwgc1JlZi5yZWZsb3dcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29sb3JSZWYodHlwZSwgeCwgeSwgeikge1xuICB2YXIgeHggPSB4ID8gdmFsdWVSZWYoXCJcIiwgeCkgOiBjb25maWcuY29sb3JbdHlwZV1bMF0sXG4gICAgICB5eSA9IHkgPyB2YWx1ZVJlZihcIlwiLCB5KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsxXSxcbiAgICAgIHp6ID0geiA/IHZhbHVlUmVmKFwiXCIsIHopIDogY29uZmlnLmNvbG9yW3R5cGVdWzJdXG4gICAgICBzaWduYWxzID0gW10sIHNjYWxlcyA9IFtdO1xuXG4gIFt4eCwgeXksIHp6XS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZih2LnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCB2LnNpZ25hbHMpO1xuICAgIGlmKHYuc2NhbGVzKSAgc2NhbGVzLnB1c2godi5zY2FsZXMpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHZhbDogXCIodGhpcy5kMy5cIiArIHR5cGUgKyBcIihcIiArIFt4eC52YWwsIHl5LnZhbCwgenoudmFsXS5qb2luKFwiLFwiKSArICcpICsgXCJcIiknLFxuICAgIHNpZ25hbHM6IHNpZ25hbHMsXG4gICAgc2NhbGVzOiBzY2FsZXNcbiAgfTtcbn1cblxuLy8ge2ZpZWxkOiB7ZGF0dW06IFwiZm9vXCJ9IH0gIC0+IGl0ZW0uZGF0dW0uZm9vXG4vLyB7ZmllbGQ6IHtncm91cDogXCJmb29cIn0gfSAgLT4gZ3JvdXAuZm9vXG4vLyB7ZmllbGQ6IHtwYXJlbnQ6IFwiZm9vXCJ9IH0gLT4gZ3JvdXAuZGF0dW0uZm9vXG5mdW5jdGlvbiBmaWVsZFJlZihyZWYpIHtcbiAgaWYoZGwuaXNTdHJpbmcocmVmKSkge1xuICAgIHJldHVybiB7dmFsOiBkbC5maWVsZChyZWYpLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKX07XG4gIH0gXG5cbiAgLy8gUmVzb2x2ZSBuZXN0aW5nL3BhcmVudCBsb29rdXBzXG4gIHZhciBsID0gcmVmLmxldmVsLFxuICAgICAgbmVzdGVkID0gKHJlZi5ncm91cCB8fCByZWYucGFyZW50KSAmJiBsLFxuICAgICAgc2NvcGUgPSBuZXN0ZWQgPyBBcnJheShsKS5qb2luKFwiZ3JvdXAubWFyay5cIikgOiBcIlwiLFxuICAgICAgciA9IGZpZWxkUmVmKHJlZi5kYXR1bSB8fCByZWYuZ3JvdXAgfHwgcmVmLnBhcmVudCB8fCByZWYuc2lnbmFsKSxcbiAgICAgIHZhbCA9IHIudmFsLFxuICAgICAgZmllbGRzICA9IHIuZmllbGRzICB8fCBbXSxcbiAgICAgIHNpZ25hbHMgPSByLnNpZ25hbHMgfHwgW10sXG4gICAgICByZWZsb3cgID0gci5yZWZsb3cgIHx8IGZhbHNlOyAvLyBOZXN0ZWQgZmllbGRyZWZzIHRyaWdnZXIgZnVsbCByZWV2YWwgb2YgRW5jb2Rlci5cblxuICBpZihyZWYuZGF0dW0pIHtcbiAgICB2YWwgPSBcIml0ZW0uZGF0dW1bXCIrdmFsK1wiXVwiO1xuICAgIGZpZWxkcy5wdXNoKHJlZi5kYXR1bSk7XG4gIH0gZWxzZSBpZihyZWYuZ3JvdXApIHtcbiAgICB2YWwgPSBzY29wZStcImdyb3VwW1wiK3ZhbCtcIl1cIjtcbiAgICByZWZsb3cgPSB0cnVlO1xuICB9IGVsc2UgaWYocmVmLnBhcmVudCkge1xuICAgIHZhbCA9IHNjb3BlK1wiZ3JvdXAuZGF0dW1bXCIrdmFsK1wiXVwiO1xuICAgIHJlZmxvdyA9IHRydWU7XG4gIH0gZWxzZSBpZihyZWYuc2lnbmFsKSB7XG4gICAgdmFsID0gXCJzaWduYWxzW1wiK3ZhbCtcIl1cIjtcbiAgICBzaWduYWxzLnB1c2goZGwuZmllbGQocmVmLnNpZ25hbClbMF0pO1xuICAgIHJlZmxvdyA9IHRydWU7XG4gIH1cblxuICByZXR1cm4ge3ZhbDogdmFsLCBmaWVsZHM6IGZpZWxkcywgc2lnbmFsczogc2lnbmFscywgcmVmbG93OiByZWZsb3d9O1xufVxuXG4vLyB7c2NhbGU6IFwieFwifVxuLy8ge3NjYWxlOiB7bmFtZTogXCJ4XCJ9fSxcbi8vIHtzY2FsZTogZmllbGRSZWZ9XG5mdW5jdGlvbiBzY2FsZVJlZihyZWYpIHtcbiAgdmFyIHNjYWxlID0gbnVsbCxcbiAgICAgIGZyID0gbnVsbDtcblxuICBpZihkbC5pc1N0cmluZyhyZWYpKSB7XG4gICAgc2NhbGUgPSBkbC5zdHIocmVmKTtcbiAgfSBlbHNlIGlmKHJlZi5uYW1lKSB7XG4gICAgc2NhbGUgPSBkbC5pc1N0cmluZyhyZWYubmFtZSkgPyBkbC5zdHIocmVmLm5hbWUpIDogKGZyID0gZmllbGRSZWYocmVmLm5hbWUpKS52YWw7XG4gIH0gZWxzZSB7XG4gICAgc2NhbGUgPSAoZnIgPSBmaWVsZFJlZihyZWYpKS52YWw7XG4gIH1cblxuICBzY2FsZSA9IFwiZ3JvdXAuc2NhbGUoXCIrc2NhbGUrXCIpXCI7XG4gIGlmKHJlZi5pbnZlcnQpIHNjYWxlICs9IFwiLmludmVydFwiOyAgLy8gVE9ETzogb3JkaW5hbCBzY2FsZXNcblxuICByZXR1cm4gZnIgPyAoZnIudmFsID0gc2NhbGUsIGZyKSA6IHt2YWw6IHNjYWxlfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlOyIsInZhciBleHByID0gcmVxdWlyZSgnLi9leHByJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIHBhcnNlU2lnbmFscyhtb2RlbCwgc3BlYykge1xuICAvLyBwcm9jZXNzIGVhY2ggc2lnbmFsIGRlZmluaXRpb25cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBzaWduYWwgPSBtb2RlbC5zaWduYWwocy5uYW1lLCBzLmluaXQpO1xuXG4gICAgaWYocy5pbml0ICYmIHMuaW5pdC5leHByKSB7XG4gICAgICBzLmluaXQuZXhwciA9IGV4cHIocy5pbml0LmV4cHIpO1xuICAgICAgc2lnbmFsLnZhbHVlKGV4cHJWYWwobW9kZWwsIHMuaW5pdCkpO1xuICAgIH1cblxuICAgIGlmKHMuZXhwcikge1xuICAgICAgcy5leHByID0gZXhwcihzLmV4cHIpO1xuICAgICAgc2lnbmFsLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgc2lnbmFsLnZhbHVlKGV4cHJWYWwobW9kZWwsIHMpKTtcbiAgICAgICAgaW5wdXQuc2lnbmFsc1tzLm5hbWVdID0gMTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfTtcbiAgICAgIHNpZ25hbC5kZXBlbmRlbmN5KEMuU0lHTkFMUywgcy5leHByLnNpZ25hbHMpO1xuICAgICAgcy5leHByLnNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihkZXApIHsgbW9kZWwuc2lnbmFsKGRlcCkuYWRkTGlzdGVuZXIoc2lnbmFsKTsgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3BlYztcbn07XG5cbmZ1bmN0aW9uIGV4cHJWYWwobW9kZWwsIHNwZWMpIHtcbiAgdmFyIGUgPSBzcGVjLmV4cHIsXG4gICAgICB2YWwgPSBleHByLmV2YWwobW9kZWwsIGUuZm4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGUuc2lnbmFscyk7XG4gIHJldHVybiBzcGVjLnNjYWxlID8gc2NhbGUobW9kZWwsIHNwZWMsIHZhbCkgOiB2YWw7XG59XG5cbnBhcnNlU2lnbmFscy5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKG1vZGVsLCBzcGVjLCB2YWx1ZSkge1xuICB2YXIgZGVmID0gc3BlYy5zY2FsZSxcbiAgICAgIG5hbWUgID0gZGVmLm5hbWUgfHwgZGVmLnNpZ25hbCB8fCBkZWYsXG4gICAgICBzY29wZSA9IGRlZi5zY29wZSA/IG1vZGVsLnNpZ25hbFJlZihkZWYuc2NvcGUuc2lnbmFsKSA6IG51bGw7XG5cbiAgaWYoIXNjb3BlIHx8ICFzY29wZS5zY2FsZSkge1xuICAgIHNjb3BlID0gKHNjb3BlICYmIHNjb3BlLm1hcmspID8gc2NvcGUubWFyay5ncm91cCA6IG1vZGVsLnNjZW5lKCkuaXRlbXNbMF07XG4gIH1cblxuICB2YXIgc2NhbGUgPSBzY29wZS5zY2FsZShuYW1lKTtcbiAgaWYoIXNjYWxlKSByZXR1cm4gdmFsdWU7XG4gIHJldHVybiBkZWYuaW52ZXJ0ID8gc2NhbGUuaW52ZXJ0KHZhbHVlKSA6IHNjYWxlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZVNpZ25hbHM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi4vY29yZS9Nb2RlbCcpLCBcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi4vY29yZS9WaWV3JyksIFxuICAgIHBhcnNlUGFkZGluZyA9IHJlcXVpcmUoJy4uL3BhcnNlL3BhZGRpbmcnKSxcbiAgICBwYXJzZU1hcmtzID0gcmVxdWlyZSgnLi4vcGFyc2UvbWFya3MnKSxcbiAgICBwYXJzZVNpZ25hbHMgPSByZXF1aXJlKCcuLi9wYXJzZS9zaWduYWxzJyksXG4gICAgcGFyc2VQcmVkaWNhdGVzID0gcmVxdWlyZSgnLi4vcGFyc2UvcHJlZGljYXRlcycpLFxuICAgIHBhcnNlRGF0YSA9IHJlcXVpcmUoJy4uL3BhcnNlL2RhdGEnKSxcbiAgICBwYXJzZUludGVyYWN0b3JzID0gcmVxdWlyZSgnLi4vcGFyc2UvaW50ZXJhY3RvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVNwZWMoc3BlYywgY2FsbGJhY2ssIHZpZXdGYWN0b3J5KSB7XG4gIC8vIHByb3RlY3QgYWdhaW5zdCBzdWJzZXF1ZW50IHNwZWMgbW9kaWZpY2F0aW9uXG4gIHNwZWMgPSBkbC5kdXBsaWNhdGUoc3BlYyk7XG5cbiAgdmlld0ZhY3RvcnkgPSB2aWV3RmFjdG9yeSB8fCBWaWV3LmZhY3Rvcnk7XG5cbiAgdmFyIHdpZHRoID0gc3BlYy53aWR0aCB8fCA1MDAsXG4gICAgICBoZWlnaHQgPSBzcGVjLmhlaWdodCB8fCA1MDAsXG4gICAgICB2aWV3cG9ydCA9IHNwZWMudmlld3BvcnQgfHwgbnVsbCxcbiAgICAgIG1vZGVsID0gbmV3IE1vZGVsKCk7XG5cbiAgcGFyc2VJbnRlcmFjdG9ycyhtb2RlbCwgc3BlYywgZnVuY3Rpb24oKSB7XG4gICAgbW9kZWwuZGVmcyh7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHBhZGRpbmc6IHBhcnNlUGFkZGluZyhzcGVjLnBhZGRpbmcpLFxuICAgICAgc2lnbmFsczogcGFyc2VTaWduYWxzKG1vZGVsLCBzcGVjLnNpZ25hbHMpLFxuICAgICAgcHJlZGljYXRlczogcGFyc2VQcmVkaWNhdGVzKG1vZGVsLCBzcGVjLnByZWRpY2F0ZXMpLFxuICAgICAgbWFya3M6IHBhcnNlTWFya3MobW9kZWwsIHNwZWMsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgZGF0YTogcGFyc2VEYXRhKG1vZGVsLCBzcGVjLmRhdGEsIGZ1bmN0aW9uKCkgeyBjYWxsYmFjayh2aWV3RmFjdG9yeShtb2RlbCkpOyB9KVxuICAgIH0pO1xuICB9KTtcbn1cbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgcGFyc2VTaWduYWxzID0gcmVxdWlyZSgnLi9zaWduYWxzJyksXG4gICAgY2hhbmdzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBzZWxlY3RvciA9IHJlcXVpcmUoJy4vZXZlbnRzJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4vZXhwcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgU1RBUlQgPSBcInN0YXJ0XCIsIE1JRERMRSA9IFwibWlkZGxlXCIsIEVORCA9IFwiZW5kXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmlldykge1xuICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsKCksXG4gICAgICBzcGVjICA9IG1vZGVsLmRlZnMoKS5zaWduYWxzLFxuICAgICAgcmVnaXN0ZXIgPSB7fSwgbm9kZXMgPSB7fTtcblxuICBmdW5jdGlvbiBzaWduYWwoc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgdmFyIG4gPSBuZXcgTm9kZShtb2RlbCk7XG4gICAgbi5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZighaW5wdXQuc2lnbmFsc1tzZWxlY3Rvci5zaWduYWxdKSByZXR1cm4gbW9kZWwuZG9Ob3RQcm9wYWdhdGU7XG4gICAgICB2YXIgdmFsID0gZXhwci5ldmFsKG1vZGVsLCBleHAuZm4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGV4cC5zaWduYWxzKTtcbiAgICAgIGlmKHNwZWMuc2NhbGUpIHZhbCA9IHBhcnNlU2lnbmFscy5zY2FsZShtb2RlbCwgc3BlYywgdmFsKTtcbiAgICAgIHNpZy52YWx1ZSh2YWwpO1xuICAgICAgaW5wdXQuc2lnbmFsc1tzaWcubmFtZSgpXSA9IDE7XG4gICAgICBpbnB1dC5yZWZsb3cgPSB0cnVlO1xuICAgICAgcmV0dXJuIGlucHV0OyAgXG4gICAgfTtcbiAgICBuLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzZWxlY3Rvci5zaWduYWwpO1xuICAgIG4uYWRkTGlzdGVuZXIoc2lnKTtcbiAgICBtb2RlbC5zaWduYWwoc2VsZWN0b3Iuc2lnbmFsKS5hZGRMaXN0ZW5lcihuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBldmVudChzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgZmlsdGVycyA9IHNlbGVjdG9yLmZpbHRlcnMgfHwgW10sXG4gICAgICAgIHRhcmdldCA9IHNlbGVjdG9yLnRhcmdldDtcblxuICAgIGlmKHRhcmdldCkgZmlsdGVycy5wdXNoKFwiaS5cIit0YXJnZXQudHlwZStcIj09XCIrZGwuc3RyKHRhcmdldC52YWx1ZSkpO1xuXG4gICAgcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdID0gcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdIHx8IFtdO1xuICAgIHJlZ2lzdGVyW3NlbGVjdG9yLmV2ZW50XS5wdXNoKHtcbiAgICAgIHNpZ25hbDogc2lnLFxuICAgICAgZXhwOiBleHAsXG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBleHByKGYpOyB9KSxcbiAgICAgIHNwZWM6IHNwZWNcbiAgICB9KTtcblxuICAgIG5vZGVzW3NlbGVjdG9yLmV2ZW50XSA9IG5vZGVzW3NlbGVjdG9yLmV2ZW50XSB8fCBuZXcgTm9kZShtb2RlbCk7XG4gICAgbm9kZXNbc2VsZWN0b3IuZXZlbnRdLmFkZExpc3RlbmVyKHNpZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gb3JkZXJlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgbmFtZSA9IHNpZy5uYW1lKCksIFxuICAgICAgICB0cnVlRm4gPSBleHByKFwidHJ1ZVwiKSxcbiAgICAgICAgcyA9IHt9O1xuXG4gICAgc1tTVEFSVF0gID0gbW9kZWwuc2lnbmFsKG5hbWUgKyBTVEFSVCwgIGZhbHNlKTtcbiAgICBzW01JRERMRV0gPSBtb2RlbC5zaWduYWwobmFtZSArIE1JRERMRSwgZmFsc2UpO1xuICAgIHNbRU5EXSAgICA9IG1vZGVsLnNpZ25hbChuYW1lICsgRU5ELCAgICBmYWxzZSk7XG5cbiAgICB2YXIgcm91dGVyID0gbmV3IE5vZGUobW9kZWwpO1xuICAgIHJvdXRlci5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZihzW1NUQVJUXS52YWx1ZSgpID09PSB0cnVlICYmIHNbRU5EXS52YWx1ZSgpID09PSBmYWxzZSkge1xuICAgICAgICAvLyBUT0RPOiBFeHBhbmQgc2VsZWN0b3Igc3ludGF4IHRvIGFsbG93IHN0YXJ0L2VuZCBzaWduYWxzIGludG8gc3RyZWFtLlxuICAgICAgICAvLyBVbnRpbCB0aGVuLCBwcmV2ZW50IG9sZCBtaWRkbGVzIGVudGVyaW5nIHN0cmVhbSBvbiBuZXcgc3RhcnQuXG4gICAgICAgIGlmKGlucHV0LnNpZ25hbHNbbmFtZStTVEFSVF0pIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTtcblxuICAgICAgICBzaWcudmFsdWUoc1tNSURETEVdLnZhbHVlKCkpO1xuICAgICAgICBpbnB1dC5zaWduYWxzW25hbWVdID0gMTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfVxuXG4gICAgICBpZihzW0VORF0udmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBzW1NUQVJUXS52YWx1ZShmYWxzZSk7XG4gICAgICAgIHNbRU5EXS52YWx1ZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTtcbiAgICB9O1xuICAgIHJvdXRlci5hZGRMaXN0ZW5lcihzaWcpO1xuXG4gICAgW1NUQVJULCBNSURETEUsIEVORF0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgdmFsID0gKHggPT0gTUlERExFKSA/IGV4cCA6IHRydWVGbixcbiAgICAgICAgICBzcCA9ICh4ID09IE1JRERMRSkgPyBzcGVjIDoge307XG5cbiAgICAgIGlmKHNlbGVjdG9yW3hdLmV2ZW50KSBldmVudChzW3hdLCBzZWxlY3Rvclt4XSwgdmFsLCBzcCk7XG4gICAgICBlbHNlIGlmKHNlbGVjdG9yW3hdLnNpZ25hbCkgc2lnbmFsKHNbeF0sIHNlbGVjdG9yW3hdLCB2YWwsIHNwKTtcbiAgICAgIGVsc2UgaWYoc2VsZWN0b3JbeF0uc3RyZWFtKSBtZXJnZWRTdHJlYW0oc1t4XSwgc2VsZWN0b3JbeF0uc3RyZWFtLCB2YWwsIHNwKTtcbiAgICAgIHNbeF0uYWRkTGlzdGVuZXIocm91dGVyKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtZXJnZWRTdHJlYW0oc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgc2VsZWN0b3IuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICBpZihzLmV2ZW50KSAgICAgICBldmVudChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc2lnbmFsKSBzaWduYWwoc2lnLCBzLCBleHAsIHNwZWMpO1xuICAgICAgZWxzZSBpZihzLnN0YXJ0KSAgb3JkZXJlZFN0cmVhbShzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc3RyZWFtKSBtZXJnZWRTdHJlYW0oc2lnLCBzLnN0cmVhbSwgZXhwLCBzcGVjKTtcbiAgICB9KTtcbiAgfTtcblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnbmFsID0gbW9kZWwuc2lnbmFsKHNpZy5uYW1lKTtcbiAgICBpZihzaWcuZXhwcikgcmV0dXJuOyAgLy8gQ2Fubm90IGhhdmUgYW4gZXhwciBhbmQgc3RyZWFtIGRlZmluaXRpb24uXG5cbiAgICAoc2lnLnN0cmVhbXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgc2VsID0gc2VsZWN0b3IucGFyc2Uoc3RyZWFtLnR5cGUpLFxuICAgICAgICAgIGV4cCA9IGV4cHIoc3RyZWFtLmV4cHIpO1xuICAgICAgbWVyZ2VkU3RyZWFtKHNpZ25hbCwgc2VsLCBleHAsIHN0cmVhbSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFdlIHJlZ2lzdGVyIHRoZSBldmVudCBsaXN0ZW5lcnMgYWxsIHRvZ2V0aGVyIHNvIHRoYXQgaWYgbXVsdGlwbGVcbiAgLy8gc2lnbmFscyBhcmUgcmVnaXN0ZXJlZCBvbiB0aGUgc2FtZSBldmVudCwgdGhleSB3aWxsIHJlY2VpdmUgdGhlXG4gIC8vIG5ldyB2YWx1ZSBvbiB0aGUgc2FtZSBwdWxzZS4gXG5cbiAgLy8gVE9ETzogRmlsdGVycywgdGltZSBpbnRlcnZhbHMsIHRhcmdldCBzZWxlY3RvcnNcbiAgZGwua2V5cyhyZWdpc3RlcikuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gcmVnaXN0ZXJbcl0sIFxuICAgICAgICBub2RlID0gbm9kZXNbcl07XG5cbiAgICB2aWV3Lm9uKHIsIGZ1bmN0aW9uKGV2dCwgaXRlbSkge1xuICAgICAgdmFyIGNzID0gY2hhbmdzZXQuY3JlYXRlKG51bGwsIHRydWUpLFxuICAgICAgICAgIHBhZCA9IHZpZXcucGFkZGluZygpLFxuICAgICAgICAgIGZpbHRlcmVkID0gZmFsc2UsXG4gICAgICAgICAgdmFsLCBoLCBpLCBtLCBkO1xuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gU3RvcCB0ZXh0IHNlbGVjdGlvblxuICAgICAgbSA9IGQzLm1vdXNlKChkMy5ldmVudD1ldnQsIHZpZXcuX2VsKSk7IC8vIFJlbGF0aXZlIHBvc2l0aW9uIHdpdGhpbiBjb250YWluZXJcbiAgICAgIGl0ZW0gPSBpdGVtfHx7fTtcbiAgICAgIGQgPSBpdGVtLmRhdHVtfHx7fTtcbiAgICAgIHZhciBwID0ge3g6IG1bMF0gLSBwYWQubGVmdCwgeTogbVsxXSAtIHBhZC50b3B9O1xuXG4gICAgICBmb3IoaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoID0gaGFuZGxlcnNbaV07XG4gICAgICAgIGZpbHRlcmVkID0gaC5maWx0ZXJzLnNvbWUoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiAhZXhwci5ldmFsKG1vZGVsLCBmLmZuLCBkLCBldnQsIGl0ZW0sIHAsIGYuc2lnbmFscyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihmaWx0ZXJlZCkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICB2YWwgPSBleHByLmV2YWwobW9kZWwsIGguZXhwLmZuLCBkLCBldnQsIGl0ZW0sIHAsIGguZXhwLnNpZ25hbHMpOyBcbiAgICAgICAgaWYoaC5zcGVjLnNjYWxlKSB2YWwgPSBwYXJzZVNpZ25hbHMuc2NhbGUobW9kZWwsIGguc3BlYywgdmFsKTtcbiAgICAgICAgaC5zaWduYWwudmFsdWUodmFsKTtcbiAgICAgICAgY3Muc2lnbmFsc1toLnNpZ25hbC5uYW1lKCldID0gMTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwucHJvcGFnYXRlKGNzLCBub2RlKTtcbiAgICB9KTtcbiAgfSlcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHRyYW5zZm9ybXMgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL2luZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCBkZWYpIHtcbiAgdmFyIHR4ID0gbmV3IHRyYW5zZm9ybXNbZGVmLnR5cGVdKG1vZGVsKTtcbiAgaWYoZGVmLnR5cGUgPT0gJ2ZhY2V0Jykge1xuICAgIHZhciBwaXBlbGluZSA9IChkZWYudHJhbnNmb3JtfHxbXSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCB0KTsgfSk7XG4gICAgdHgucGlwZWxpbmUocGlwZWxpbmUpO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byByZW5hbWUgb3V0cHV0IGZpZWxkcyBiZWZvcmUgc2V0dGluZyBhbnkgb3RoZXIgcHJvcGVydGllcyxcbiAgLy8gYXMgc3Vic2VxdWVudCBwcm9wZXJ0aWVzIG1heSByZXF1aXJlIG91dHB1dCB0byBiZSBzZXQgKGUuZy4gZ3JvdXAgYnkpLlxuICBpZihkZWYub3V0cHV0KSB0eC5vdXRwdXQoZGVmLm91dHB1dCk7XG5cbiAgZGwua2V5cyhkZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmKGsgPT09ICd0eXBlJyB8fCBrID09PSAnb3V0cHV0JykgcmV0dXJuO1xuICAgIGlmKGsgPT09ICd0cmFuc2Zvcm0nICYmIGRlZi50eXBlID09PSAnZmFjZXQnKSByZXR1cm47XG4gICAgKHR4W2tdKS5zZXQodHgsIGRlZltrXSk7XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbnZhciBoYW5kbGVyID0gZnVuY3Rpb24oZWwsIG1vZGVsKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGlmIChlbCkgdGhpcy5pbml0aWFsaXplKGVsKTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsKG1vZGVsKTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSBoYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBkMy5zZWxlY3QoZWwpLm5vZGUoKTtcbiAgdGhpcy5fY2FudmFzID0gZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJjYW52YXMubWFya3NcIikubm9kZSgpO1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcywgdGhhdCA9IHRoaXM7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHByb3RvdHlwZVt0eXBlXS5jYWxsKHRoYXQsIGV2dCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICByZXR1cm4gZGwua2V5cyhoKS5yZWR1Y2UoZnVuY3Rpb24oYSwgaykge1xuICAgIHJldHVybiBoW2tdLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7IHJldHVybiAoYS5wdXNoKHgpLCBhKTsgfSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbi8vIHNldHVwIGV2ZW50c1xudmFyIGV2ZW50cyA9IFtcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZXVwXCIsXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIndoZWVsXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXByZXNzXCIsXG4gIFwia2V5dXBcIixcbiAgXCJtb3VzZXdoZWVsXCIsXG4gIFwidG91Y2hzdGFydFwiXG5dO1xuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICBwcm90b3R5cGVbdHlwZV0gPSBmdW5jdGlvbihldnQpIHtcbiAgICB0aGlzLmZpcmUodHlwZSwgZXZ0KTtcbiAgfTtcbn0pO1xuZXZlbnRzLnB1c2goXCJtb3VzZW1vdmVcIik7XG5ldmVudHMucHVzaChcIm1vdXNlb3V0XCIpO1xuZXZlbnRzLnB1c2goXCJ0b3VjaG1vdmVcIik7XG5ldmVudHMucHVzaChcInRvdWNoZW5kXCIpO1xuXG5mdW5jdGlvbiBldmVudE5hbWUobmFtZSkge1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi5cIik7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59XG5cbnByb3RvdHlwZS50b3VjaG1vdmUgPSBwcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IGV2dC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB4ID0gZXZ0LmNsaWVudFggLSBiLmxlZnQsXG4gICAgICB5ID0gZXZ0LmNsaWVudFkgLSBiLnRvcCxcbiAgICAgIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBwID0gdGhpcy5waWNrKHRoaXMuX21vZGVsLnNjZW5lKCksIHgsIHksIHgtcGFkLmxlZnQsIHktcGFkLnRvcCk7XG5cbiAgaWYgKHAgPT09IGEpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW1vdmVcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNobW92ZVwiKSB0aGlzLmZpcmUoXCJ0b3VjaG1vdmVcIiwgZXZ0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaGVuZFwiKSB0aGlzLmZpcmUoXCJ0b3VjaGVuZFwiLCBldnQpO1xuICB9XG4gIHRoaXMuX2FjdGl2ZSA9IHA7XG4gIGlmIChwKSB7XG4gICAgdGhpcy5maXJlKFwibW91c2VvdmVyXCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaHN0YXJ0XCIpIHRoaXMuZmlyZShcInRvdWNoc3RhcnRcIiwgZXZ0KTtcbiAgfVxufTtcblxucHJvdG90eXBlLnRvdWNoZW5kID0gcHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW91dFwiLCBldnQpO1xuICAgIHRoaXMuZmlyZShcInRvdWNoZW5kXCIsIGV2dCk7XG4gIH1cbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbn07XG5cbi8vIHRvIGtlZXAgZmlyZWZveCBoYXBweVxucHJvdG90eXBlLkRPTU1vdXNlU2Nyb2xsID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuZmlyZShcIm1vdXNld2hlZWxcIiwgZXZ0KTtcbn07XG5cbi8vIGZpcmUgYW4gZXZlbnRcbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZXZ0KSB7XG4gIHZhciBhID0gdGhpcy5fYWN0aXZlLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuICBpZiAoaCkge1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBoW2ldLmhhbmRsZXIuY2FsbCh0aGlzLl9vYmosIGV2dCwgYSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycztcbiAgaCA9IGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSk7XG4gIGgucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSBoLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbn07XG5cbi8vIGZpbmQgdGhlIHNjZW5lZ3JhcGggaXRlbSBhdCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuLy8geCwgeSAtLSB0aGUgYWJzb2x1dGUgeCwgeSBtb3VzZSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzIGVsZW1lbnRcbi8vIGd4LCBneSAtLSB0aGUgcmVsYXRpdmUgY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBjdXJyZW50IGdyb3VwXG5wcm90b3R5cGUucGljayA9IGZ1bmN0aW9uKHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICBwaWNrZXIgPSBtYXJrcy5waWNrW21hcmt0eXBlXTtcbiAgcmV0dXJuIHBpY2tlci5jYWxsKHRoaXMsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQm91bmRzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N0eCA9IG51bGw7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5faW1nbG9hZCA9IDA7XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgXG4gIGlmICghZWwpIHJldHVybiB0aGlzOyAvLyBlYXJseSBleGl0IGlmIG5vIERPTSBlbGVtZW50XG5cbiAgLy8gc2VsZWN0IGNhbnZhcyBlbGVtZW50XG4gIHZhciBjYW52YXMgPSBkMy5zZWxlY3QoZWwpXG4gICAgLnNlbGVjdEFsbChcImNhbnZhcy5tYXJrc1wiKVxuICAgIC5kYXRhKFsxXSk7XG4gIFxuICAvLyBjcmVhdGUgbmV3IGNhbnZhcyBlbGVtZW50IGlmIG5lZWRlZFxuICBjYW52YXMuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjYW52YXNcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwibWFya3NcIik7XG4gIFxuICAvLyByZW1vdmUgZXh0cmFuZW91cyBjYW52YXMgaWYgbmVlZGVkXG4gIGNhbnZhcy5leGl0KCkucmVtb3ZlKCk7XG4gIFxuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICBcbiAgaWYgKHRoaXMuX2VsKSB7XG4gICAgdmFyIGNhbnZhcyA9IGQzLnNlbGVjdCh0aGlzLl9lbCkuc2VsZWN0KFwiY2FudmFzLm1hcmtzXCIpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjYW52YXMgYXR0cmlidXRlc1xuICAgIGNhbnZhc1xuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0KVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20pO1xuXG4gICAgLy8gZ2V0IHRoZSBjYW52YXMgZ3JhcGhpY3MgY29udGV4dFxuICAgIHZhciBzO1xuICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5ub2RlKCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHRoaXMuX2N0eC5fcmF0aW8gPSAocyA9IHNjYWxlQ2FudmFzKGNhbnZhcy5ub2RlKCksIHRoaXMuX2N0eCkgfHwgMSk7XG4gICAgdGhpcy5fY3R4LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCBzKnBhZC5sZWZ0LCBzKnBhZC50b3ApO1xuICB9XG4gIFxuICBpbml0aWFsaXplTGluZURhc2godGhpcy5fY3R4KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBzY2FsZUNhbnZhcyhjYW52YXMsIGN0eCkge1xuICAvLyBnZXQgY2FudmFzIHBpeGVsIGRhdGFcbiAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSAoXG4gICAgICAgIGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvKSB8fCAxLFxuICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cbiAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IGJhY2tpbmdTdG9yZVJhdGlvKSB7XG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGgsIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIC8vIHNldCBhY3R1YWwgYW5kIHZpc2libGUgY2FudmFzIHNpemVcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyAqIHJhdGlvKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGggKiByYXRpbyk7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICB9XG4gIHJldHVybiByYXRpbztcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUxpbmVEYXNoKGN0eCkge1xuICBpZiAoY3R4LnZnTGluZURhc2gpIHJldHVybjsgLy8gYWxyZWFkeSBzZXRcblxuICB2YXIgTk9EQVNIID0gW107XG4gIGlmIChjdHguc2V0TGluZURhc2gpIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5zZXRMaW5lRGFzaChkYXNoIHx8IE5PREFTSCk7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy5saW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgud2Via2l0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICBcdGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLndlYmtpdExpbmVEYXNoID0gZGFzaCB8fCBOT0RBU0g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgubW96RGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMubW96RGFzaCA9IGRhc2g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgfSBlbHNlIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICB9XG59XG5cbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gIGlmIChjdHgpIHsgdGhpcy5fY3R4ID0gY3R4OyByZXR1cm4gdGhpczsgfVxuICBlbHNlIHJldHVybiB0aGlzLl9jdHg7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUucGVuZGluZ0ltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW1nbG9hZDtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgYm91bmRzKSB7XG4gIHZhciBiID0gbmV3IEJvdW5kcyhib3VuZHMpO1xuICB3aGlsZSAoKGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApICE9IG51bGwpIHtcbiAgICBiLnRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xuICB9XG4gIHJldHVybiBiO1xufVxuICBcbmZ1bmN0aW9uIGdldEJvdW5kcyhpdGVtcykge1xuICByZXR1cm4gIWl0ZW1zID8gbnVsbCA6XG4gICAgZGwuYXJyYXkoaXRlbXMpLnJlZHVjZShmdW5jdGlvbihiLCBpdGVtKSB7XG4gICAgICByZXR1cm4gYi51bmlvbih0cmFuc2xhdGVkQm91bmRzKGl0ZW0sIGl0ZW0uYm91bmRzKSlcbiAgICAgICAgICAgICAgLnVuaW9uKHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgaXRlbVsnYm91bmRzOnByZXYnXSkpO1xuICAgIH0sIG5ldyBCb3VuZHMoKSk7ICBcbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGcsIGJvdW5kcykge1xuICB2YXIgYmJveCA9IG51bGw7XG4gIGlmIChib3VuZHMpIHtcbiAgICBiYm94ID0gKG5ldyBCb3VuZHMoYm91bmRzKSkucm91bmQoKTtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGcucmVjdChiYm94LngxLCBiYm94LnkxLCBiYm94LndpZHRoKCksIGJib3guaGVpZ2h0KCkpO1xuICAgIGcuY2xpcCgpO1xuICB9XG4gIHJldHVybiBiYm94O1xufVxuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIHZhciBnID0gdGhpcy5fY3R4LFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIHcgPSB0aGlzLl93aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgICAgaCA9IHRoaXMuX2hlaWdodCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICAgICAgYmIgPSBudWxsLCBiYjI7XG5cbiAgLy8gc2V0dXBcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgZy5zYXZlKCk7XG4gIGJiID0gc2V0Qm91bmRzKGcsIGdldEJvdW5kcyhpdGVtcykpO1xuICBnLmNsZWFyUmVjdCgtcGFkLmxlZnQsIC1wYWQudG9wLCB3LCBoKTtcblxuICAvLyByZW5kZXJcbiAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYik7XG5cbiAgLy8gcmVuZGVyIGFnYWluIHRvIGhhbmRsZSBwb3NzaWJsZSBib3VuZHMgY2hhbmdlXG4gIGlmIChpdGVtcykge1xuICAgIGcucmVzdG9yZSgpO1xuICAgIGcuc2F2ZSgpO1xuICAgIGJiMiA9IHNldEJvdW5kcyhnLCBnZXRCb3VuZHMoaXRlbXMpKTtcbiAgICBpZiAoIWJiLmVuY2xvc2VzKGJiMikpIHtcbiAgICAgIGcuY2xlYXJSZWN0KC1wYWQubGVmdCwgLXBhZC50b3AsIHcsIGgpO1xuICAgICAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYjIpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gdGFrZWRvd25cbiAgZy5yZXN0b3JlKCk7XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBtYXJrdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgcmVuZGVyZXIgPSBtYXJrcy5kcmF3W21hcmt0eXBlXTtcbiAgcmVuZGVyZXIuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xufTtcblxucHJvdG90eXBlLnJlbmRlckFzeW5jID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgLy8gVE9ETyBtYWtlIHNhZmUgZm9yIG11bHRpcGxlIHNjZW5lIHJlbmRlcmluZz9cbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgaWYgKHJlbmRlcmVyLl9hc3luY19pZCkge1xuICAgIGNsZWFyVGltZW91dChyZW5kZXJlci5fYXN5bmNfaWQpO1xuICB9XG4gIHJlbmRlcmVyLl9hc3luY19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lKTtcbiAgICBkZWxldGUgcmVuZGVyZXIuX2FzeW5jX2lkO1xuICB9LCA1MCk7XG59O1xuXG5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJpKSB7XG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBzY2VuZSA9IHJlbmRlcmVyLl9zY2VuZSxcbiAgICAgIGltYWdlID0gbnVsbCwgdXJsO1xuXG4gIHJlbmRlcmVyLl9pbWdsb2FkICs9IDE7XG4gIGlmIChkbC5pc05vZGUpIHtcbiAgICBpbWFnZSA9IG5ldyAoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuY2FudmFzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5jYW52YXMgOiBudWxsKS5JbWFnZSkoKTtcbiAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiB1cml9LCBjb25maWcubG9hZCksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgeyBkbC5lcnJvcihlcnIpOyByZXR1cm47IH1cbiAgICAgIGltYWdlLnNyYyA9IGRhdGE7XG4gICAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuX2ltZ2xvYWQgLT0gMTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgdXJpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaW1hZ2UubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJlbmRlcmVyLl9pbWdsb2FkIC09IDE7XG4gICAgICByZW5kZXJlci5yZW5kZXJBc3luYyhzY2VuZSk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gIH1cblxuICByZXR1cm4gaW1hZ2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9IYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1JlbmRlcmVyJylcbn07IiwidmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvQm91bmRzJyksXG4gICAgYm91bmRzQ2FsYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyksXG4gICAgcGF0aCA9IHJlcXVpcmUoJy4vcGF0aCcpO1xuXG52YXIgcGFyc2VQYXRoID0gcGF0aC5wYXJzZSxcbiAgICByZW5kZXJQYXRoID0gcGF0aC5yZW5kZXIsXG4gICAgaGFsZnBpID0gTWF0aC5QSSAvIDIsXG4gICAgc3FydDMgPSBNYXRoLnNxcnQoMyksXG4gICAgdGFuMzAgPSBNYXRoLnRhbigzMCAqIE1hdGguUEkgLyAxODApLFxuICAgIHRtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG4vLyBwYXRoIGdlbmVyYXRvcnNcblxuZnVuY3Rpb24gYXJjUGF0aChnLCBvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBpciA9IG8uaW5uZXJSYWRpdXMgfHwgMCxcbiAgICAgIG9yID0gby5vdXRlclJhZGl1cyB8fCAwLFxuICAgICAgc2EgPSAoby5zdGFydEFuZ2xlIHx8IDApIC0gTWF0aC5QSS8yLFxuICAgICAgZWEgPSAoby5lbmRBbmdsZSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgZy5iZWdpblBhdGgoKTtcbiAgaWYgKGlyID09PSAwKSBnLm1vdmVUbyh4LCB5KTtcbiAgZWxzZSBnLmFyYyh4LCB5LCBpciwgc2EsIGVhLCAwKTtcbiAgZy5hcmMoeCwgeSwgb3IsIGVhLCBzYSwgMSk7XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQYXRoKGcsIGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBtID0gby5tYXJrLFxuICAgICAgcCA9IG0ucGF0aENhY2hlIHx8IChtLnBhdGhDYWNoZSA9IHBhcnNlUGF0aChwYXRoLmFyZWEoaXRlbXMpKSk7XG4gIHJlbmRlclBhdGgoZywgcCk7XG59XG5cbmZ1bmN0aW9uIGxpbmVQYXRoKGcsIGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBtID0gby5tYXJrLFxuICAgICAgcCA9IG0ucGF0aENhY2hlIHx8IChtLnBhdGhDYWNoZSA9IHBhcnNlUGF0aChwYXRoLmxpbmUoaXRlbXMpKSk7XG4gIHJlbmRlclBhdGgoZywgcCk7XG59XG5cbmZ1bmN0aW9uIHBhdGhQYXRoKGcsIG8pIHtcbiAgaWYgKG8ucGF0aCA9PSBudWxsKSByZXR1cm47XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2VQYXRoKG8ucGF0aCkpO1xuICByZXR1cm4gcmVuZGVyUGF0aChnLCBwLCBvLngsIG8ueSk7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbFBhdGgoZywgbykge1xuICBnLmJlZ2luUGF0aCgpO1xuICB2YXIgc2l6ZSA9IG8uc2l6ZSAhPSBudWxsID8gby5zaXplIDogMTAwLFxuICAgICAgeCA9IG8ueCwgeSA9IG8ueSwgciwgdCwgcngsIHJ5O1xuXG4gIGlmIChvLnNoYXBlID09IG51bGwgfHwgby5zaGFwZSA9PT0gXCJjaXJjbGVcIikge1xuICAgIHIgPSBNYXRoLnNxcnQoc2l6ZS9NYXRoLlBJKTtcbiAgICBnLmFyYyh4LCB5LCByLCAwLCAyKk1hdGguUEksIDApO1xuICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChvLnNoYXBlKSB7XG4gICAgY2FzZSBcImNyb3NzXCI6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICB0ID0gMypyO1xuICAgICAgZy5tb3ZlVG8oeC10LCB5LXIpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5LXIpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5LXQpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5LXQpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5LXIpO1xuICAgICAgZy5saW5lVG8oeCt0LCB5LXIpO1xuICAgICAgZy5saW5lVG8oeCt0LCB5K3IpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5K3IpO1xuICAgICAgZy5saW5lVG8oeCtyLCB5K3QpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5K3QpO1xuICAgICAgZy5saW5lVG8oeC1yLCB5K3IpO1xuICAgICAgZy5saW5lVG8oeC10LCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeSk7XG4gICAgICBnLmxpbmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICB0ID0gTWF0aC5zcXJ0KHNpemUpO1xuICAgICAgciA9IHQgLyAyO1xuICAgICAgZy5yZWN0KHgtciwgeS1yLCB0LCB0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLWRvd25cIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHktcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGUtdXBcIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkrcnkpO1xuICB9XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbmZ1bmN0aW9uIGxpbmVTdHJva2UoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIGx3ID0gby5zdHJva2VXaWR0aCxcbiAgICAgIGxjID0gby5zdHJva2VDYXA7XG4gIGcubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gIGcubGluZUNhcCAgID0gbGMgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICBsaW5lUGF0aChnLCBpdGVtcyk7XG59XG5cbmZ1bmN0aW9uIHJ1bGVTdHJva2UoZywgbykge1xuICB2YXIgeDEgPSBvLnggfHwgMCxcbiAgICAgIHkxID0gby55IHx8IDAsXG4gICAgICB4MiA9IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSxcbiAgICAgIHkyID0gby55MiAhPSBudWxsID8gby55MiA6IHkxLFxuICAgICAgbHcgPSBvLnN0cm9rZVdpZHRoLFxuICAgICAgbGMgPSBvLnN0cm9rZUNhcDtcblxuICBnLmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgZy5iZWdpblBhdGgoKTtcbiAgZy5tb3ZlVG8oeDEsIHkxKTtcbiAgZy5saW5lVG8oeDIsIHkyKTtcbn1cblxuLy8gZHJhd2luZyBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZHJhd1BhdGhPbmUocGF0aCwgZywgbywgaXRlbXMpIHtcbiAgdmFyIGZpbGwgPSBvLmZpbGwsIHN0cm9rZSA9IG8uc3Ryb2tlLCBvcGFjLCBsYywgbHc7XG5cbiAgcGF0aChnLCBpdGVtcyk7XG5cbiAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgaWYgKG9wYWMgPT0gMCB8fCAhZmlsbCAmJiAhc3Ryb2tlKSByZXR1cm47XG5cbiAgaWYgKGZpbGwpIHtcbiAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgZmlsbCk7XG4gICAgZy5maWxsKCk7XG4gIH1cblxuICBpZiAoc3Ryb2tlKSB7XG4gICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgICBpZiAobHcgPiAwKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBzdHJva2UpO1xuICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgIGcubGluZUNhcCA9IChsYyA9IG8uc3Ryb2tlQ2FwKSAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gICAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgIGcuc3Ryb2tlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdQYXRoQWxsKHBhdGgsIGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmFyIGksIGxlbiwgaXRlbTtcbiAgZm9yIChpPTAsIGxlbj1zY2VuZS5pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gc2NlbmUuaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuICAgIGRyYXdQYXRoT25lKHBhdGgsIGcsIGl0ZW0sIGl0ZW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSZWN0KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBmaWxsLCBzdHJva2UsIG9wYWMsIGxjLCBsdywgeCwgeSwgdywgaDtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgeCA9IG8ueCB8fCAwO1xuICAgIHkgPSBvLnkgfHwgMDtcbiAgICB3ID0gby53aWR0aCB8fCAwO1xuICAgIGggPSBvLmhlaWdodCB8fCAwO1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PSAwKSBjb250aW51ZTtcblxuICAgIGlmIChmaWxsID0gby5maWxsKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICAgICAgZy5maWxsU3R5bGUgPSBjb2xvcihnLCBvLCBmaWxsKTtcbiAgICAgIGcuZmlsbFJlY3QoeCwgeSwgdywgaCk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSA9IG8uc3Ryb2tlKSB7XG4gICAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICAgICAgaWYgKGx3ID4gMCkge1xuICAgICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKGcsIG8sIHN0cm9rZSk7XG4gICAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGcubGluZUNhcCA9IChsYyA9IG8uc3Ryb2tlQ2FwKSAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gICAgICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgICAgIGcuc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1J1bGUoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIHN0cm9rZSwgb3BhYywgbGMsIGx3LCB4MSwgeTEsIHgyLCB5MjtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgeDEgPSBvLnggfHwgMDtcbiAgICB5MSA9IG8ueSB8fCAwO1xuICAgIHgyID0gby54MiAhPSBudWxsID8gby54MiA6IHgxO1xuICAgIHkyID0gby55MiAhPSBudWxsID8gby55MiA6IHkxO1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PSAwKSBjb250aW51ZTtcbiAgICBcbiAgICBpZiAoc3Ryb2tlID0gby5zdHJva2UpIHtcbiAgICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gICAgICBpZiAobHcgPiAwKSB7XG4gICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgc3Ryb2tlKTtcbiAgICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgICAgICAgZy52Z0xpbmVEYXNoKG8uc3Ryb2tlRGFzaCB8fCBudWxsKTtcbiAgICAgICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgICAgZy5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgZy5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgZy5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ltYWdlKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcyxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMsIG87XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIGlmICghKG8uaW1hZ2UgJiYgby5pbWFnZS51cmwgPT09IG8udXJsKSkge1xuICAgICAgby5pbWFnZSA9IHJlbmRlcmVyLmxvYWRJbWFnZShvLnVybCk7XG4gICAgICBvLmltYWdlLnVybCA9IG8udXJsO1xuICAgIH1cblxuICAgIHZhciB4LCB5LCB3LCBoLCBvcGFjO1xuICAgIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDA7XG4gICAgaCA9IG8uaGVpZ2h0IHx8IChvLmltYWdlICYmIG8uaW1hZ2UuaGVpZ2h0KSB8fCAwO1xuICAgIHggPSAoby54fHwwKSAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpO1xuICAgIHkgPSAoby55fHwwKSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKTtcblxuICAgIGlmIChvLmltYWdlLmxvYWRlZCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IChvcGFjID0gby5vcGFjaXR5KSAhPSBudWxsID8gb3BhYyA6IDE7XG4gICAgICBnLmRyYXdJbWFnZShvLmltYWdlLCB4LCB5LCB3LCBoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1RleHQoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGZpbGwsIHN0cm9rZSwgb3BhYywgbHcsIHgsIHksIHIsIHQ7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIGcuZm9udCA9IGZvbnRTdHJpbmcobyk7XG4gICAgZy50ZXh0QWxpZ24gPSBvLmFsaWduIHx8IFwibGVmdFwiO1xuICAgIGcudGV4dEJhc2VsaW5lID0gby5iYXNlbGluZSB8fCBcImFscGhhYmV0aWNcIjtcblxuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT0gMCkgY29udGludWU7XG5cbiAgICB4ID0gby54IHx8IDA7XG4gICAgeSA9IG8ueSB8fCAwO1xuICAgIGlmIChyID0gby5yYWRpdXMpIHtcbiAgICAgIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gICAgfVxuXG4gICAgaWYgKG8uYW5nbGUpIHtcbiAgICAgIGcuc2F2ZSgpO1xuICAgICAgZy50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBnLnJvdGF0ZShvLmFuZ2xlICogTWF0aC5QSS8xODApO1xuICAgICAgeCA9IG8uZHggfHwgMDtcbiAgICAgIHkgPSBvLmR5IHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0gKG8uZHggfHwgMCk7XG4gICAgICB5ICs9IChvLmR5IHx8IDApO1xuICAgIH1cblxuICAgIGlmIChmaWxsID0gby5maWxsKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLmZpbGxPcGFjaXR5PT1udWxsID8gMSA6IG8uZmlsbE9wYWNpdHkpO1xuICAgICAgZy5maWxsU3R5bGUgPSBjb2xvcihnLCBvLCBmaWxsKTtcbiAgICAgIGcuZmlsbFRleHQoby50ZXh0LCB4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlID0gby5zdHJva2UpIHtcbiAgICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogMTtcbiAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihvLCBzdHJva2UpO1xuICAgICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBnLnN0cm9rZVRleHQoby50ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoby5hbmdsZSkgZy5yZXN0b3JlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0FsbChwYXRoRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oZywgc2NlbmUsIGJvdW5kcykge1xuICAgIGRyYXdQYXRoQWxsKHBhdGhGdW5jLCBnLCBzY2VuZSwgYm91bmRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3T25lKHBhdGhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgYm91bmRzKSB7XG4gICAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhzY2VuZS5pdGVtc1swXS5ib3VuZHMpKVxuICAgICAgcmV0dXJuOyAvLyBib3VuZHMgY2hlY2tcbiAgICBkcmF3UGF0aE9uZShwYXRoRnVuYywgZywgc2NlbmUuaXRlbXNbMF0sIHNjZW5lLml0ZW1zKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3R3JvdXAoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcywgZ3JvdXAsIGF4ZXMsIGxlZ2VuZHMsXG4gICAgICByZW5kZXJlciA9IHRoaXMsIGd4LCBneSwgZ2IsIGksIG4sIGosIG07XG5cbiAgZHJhd1JlY3QoZywgc2NlbmUsIGJvdW5kcyk7XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGdyb3VwID0gaXRlbXNbaV07XG4gICAgYXhlcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXTtcbiAgICBsZWdlbmRzID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW107XG4gICAgZ3ggPSBncm91cC54IHx8IDA7XG4gICAgZ3kgPSBncm91cC55IHx8IDA7XG5cbiAgICAvLyByZW5kZXIgZ3JvdXAgY29udGVudHNcbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGlmIChncm91cC5jbGlwKSB7XG4gICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgZy5yZWN0KDAsIDAsIGdyb3VwLndpZHRoIHx8IDAsIGdyb3VwLmhlaWdodCB8fCAwKTtcbiAgICAgIGcuY2xpcCgpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKC1neCwgLWd5KTtcbiAgICBcbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhdyhnLCBheGVzW2pdLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1ncm91cC5pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICByZW5kZXJlci5kcmF3KGcsIGdyb3VwLml0ZW1zW2pdLCBib3VuZHMpO1xuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciAhPT0gXCJiYWNrXCIpIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhdyhnLCBheGVzW2pdLCBib3VuZHMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgbGVnZW5kc1tqXSwgYm91bmRzKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGcucmVzdG9yZSgpO1xuICB9ICAgIFxufVxuXG5mdW5jdGlvbiBjb2xvcihnLCBvLCB2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlLmlkKVxuICAgID8gZ3JhZGllbnQoZywgdmFsdWUsIG8uYm91bmRzKVxuICAgIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGdyYWRpZW50KGcsIHAsIGIpIHtcbiAgdmFyIHcgPSBiLndpZHRoKCksXG4gICAgICBoID0gYi5oZWlnaHQoKSxcbiAgICAgIHgxID0gYi54MSArIHAueDEgKiB3LFxuICAgICAgeTEgPSBiLnkxICsgcC55MSAqIGgsXG4gICAgICB4MiA9IGIueDEgKyBwLngyICogdyxcbiAgICAgIHkyID0gYi55MSArIHAueTIgKiBoLFxuICAgICAgZ3JhZCA9IGcuY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpLFxuICAgICAgc3RvcCA9IHAuc3RvcHMsXG4gICAgICBpLCBuO1xuXG4gIGZvciAoaT0wLCBuPXN0b3AubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGdyYWQuYWRkQ29sb3JTdG9wKHN0b3BbaV0ub2Zmc2V0LCBzdG9wW2ldLmNvbG9yKTtcbiAgfVxuICByZXR1cm4gZ3JhZDtcbn1cblxuLy8gaGl0IHRlc3RpbmdcblxuZnVuY3Rpb24gcGlja0dyb3VwKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKHNjZW5lLml0ZW1zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgc2NlbmUuYm91bmRzICYmICFzY2VuZS5ib3VuZHMuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcywgc3Vic2NlbmUsIGdyb3VwLCBoaXQsIGR4LCBkeSxcbiAgICAgIGhhbmRsZXIgPSB0aGlzLCBpLCBqO1xuXG4gIGZvciAoaT1pdGVtcy5sZW5ndGg7IC0taT49MDspIHtcbiAgICBncm91cCA9IGl0ZW1zW2ldO1xuICAgIGR4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGR5ID0gZ3JvdXAueSB8fCAwO1xuXG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZHgsIGR5KTtcbiAgICBmb3IgKGo9Z3JvdXAuaXRlbXMubGVuZ3RoOyAtLWogPj0gMDspIHtcbiAgICAgIHN1YnNjZW5lID0gZ3JvdXAuaXRlbXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICAgIGhpdCA9IGhhbmRsZXIucGljayhzdWJzY2VuZSwgeCwgeSwgZ3gtZHgsIGd5LWR5KTtcbiAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgZy5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGcucmVzdG9yZSgpO1xuICB9XG5cbiAgcmV0dXJuIHNjZW5lLmludGVyYWN0aXZlXG4gICAgPyBwaWNrQWxsKGhpdFRlc3RzLmdyb3VwLCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KVxuICAgIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBpY2tBbGwodGVzdCwgZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgbywgYiwgaTtcblxuICBpZiAoZy5fcmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcuX3JhdGlvO1xuICAgIHkgKj0gZy5fcmF0aW87XG4gIH1cblxuICBmb3IgKGk9c2NlbmUuaXRlbXMubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICBvID0gc2NlbmUuaXRlbXNbaV07IGIgPSBvLmJvdW5kcztcbiAgICAvLyBmaXJzdCBoaXQgdGVzdCBhZ2FpbnN0IGJvdW5kaW5nIGJveFxuICAgIGlmICgoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSB8fCAhYikgY29udGludWU7XG4gICAgLy8gaWYgaW4gYm91bmRpbmcgYm94LCBwZXJmb3JtIG1vcmUgY2FyZWZ1bCB0ZXN0XG4gICAgaWYgKHRlc3QoZywgbywgeCwgeSwgZ3gsIGd5KSkgcmV0dXJuIG87XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJlYShnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgYiwgaSwgZGksIGRkLCBvZCwgZHgsIGR5O1xuXG4gIGIgPSBpdGVtc1swXS5ib3VuZHM7XG4gIGlmIChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGcuX3JhdGlvICE9PSAxKSB7XG4gICAgeCAqPSBnLl9yYXRpbztcbiAgICB5ICo9IGcuX3JhdGlvO1xuICB9XG4gIGlmICghaGl0VGVzdHMuYXJlYShnLCBpdGVtcywgeCwgeSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZW1zWzBdO1xufVxuXG5mdW5jdGlvbiBwaWNrTGluZShnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgYiwgaSwgZGksIGRkLCBvZCwgZHgsIGR5O1xuXG4gIGIgPSBpdGVtc1swXS5ib3VuZHM7XG4gIGlmIChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGcuX3JhdGlvICE9PSAxKSB7XG4gICAgeCAqPSBnLl9yYXRpbztcbiAgICB5ICo9IGcuX3JhdGlvO1xuICB9XG4gIGlmICghaGl0VGVzdHMubGluZShnLCBpdGVtcywgeCwgeSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGl0ZW1zWzBdO1xufVxuXG5mdW5jdGlvbiBwaWNrKHRlc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gICAgcmV0dXJuIHBpY2tBbGwodGVzdCwgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRIaXQoZywgbywgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghby5mb250U2l6ZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIW8uYW5nbGUpIHJldHVybiB0cnVlOyAvLyBib3VuZHMgc3VmZmljaWVudCBpZiBubyByb3RhdGlvblxuXG4gIHZhciBiID0gYm91bmRzQ2FsYy50ZXh0KG8sIHRtcEJvdW5kcywgdHJ1ZSksXG4gICAgICBhID0gLW8uYW5nbGUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgY29zID0gTWF0aC5jb3MoYSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhKSxcbiAgICAgIHggPSBvLngsXG4gICAgICB5ID0gby55LFxuICAgICAgcHggPSBjb3MqZ3ggLSBzaW4qZ3kgKyAoeCAtIHgqY29zICsgeSpzaW4pLFxuICAgICAgcHkgPSBzaW4qZ3ggKyBjb3MqZ3kgKyAoeSAtIHgqc2luIC0geSpjb3MpO1xuXG4gIHJldHVybiBiLmNvbnRhaW5zKHB4LCBweSk7XG59XG5cbnZhciBoaXRUZXN0cyA9IHtcbiAgdGV4dDogICB0ZXh0SGl0LFxuICByZWN0OiAgIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcmV0dXJuIHRydWU7IH0sIC8vIGJvdW5kcyB0ZXN0IGlzIHN1ZmZpY2llbnRcbiAgaW1hZ2U6ICBmdW5jdGlvbihnLG8seCx5KSB7IHJldHVybiB0cnVlOyB9LCAvLyBib3VuZHMgdGVzdCBpcyBzdWZmaWNpZW50XG4gIGdyb3VwOiAgZnVuY3Rpb24oZyxvLHgseSkgeyByZXR1cm4gby5maWxsIHx8IG8uc3Ryb2tlOyB9LFxuICBydWxlOiAgIGZ1bmN0aW9uKGcsbyx4LHkpIHtcbiAgICAgICAgICAgIGlmICghZy5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJ1bGVTdHJva2UoZyxvKTsgcmV0dXJuIGcuaXNQb2ludEluU3Ryb2tlKHgseSk7XG4gICAgICAgICAgfSxcbiAgbGluZTogICBmdW5jdGlvbihnLHMseCx5KSB7XG4gICAgICAgICAgICBpZiAoIWcuaXNQb2ludEluU3Ryb2tlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsaW5lU3Ryb2tlKGcscyk7IHJldHVybiBnLmlzUG9pbnRJblN0cm9rZSh4LHkpO1xuICAgICAgICAgIH0sXG4gIGFyYzogICAgZnVuY3Rpb24oZyxvLHgseSkgeyBhcmNQYXRoKGcsbyk7ICByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH0sXG4gIGFyZWE6ICAgZnVuY3Rpb24oZyxzLHgseSkgeyBhcmVhUGF0aChnLHMpOyByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH0sXG4gIHBhdGg6ICAgZnVuY3Rpb24oZyxvLHgseSkgeyBwYXRoUGF0aChnLG8pOyByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH0sXG4gIHN5bWJvbDogZnVuY3Rpb24oZyxvLHgseSkgeyBzeW1ib2xQYXRoKGcsbyk7IHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IHtcbiAgICBncm91cDogICBkcmF3R3JvdXAsXG4gICAgYXJlYTogICAgZHJhd09uZShhcmVhUGF0aCksXG4gICAgbGluZTogICAgZHJhd09uZShsaW5lUGF0aCksXG4gICAgYXJjOiAgICAgZHJhd0FsbChhcmNQYXRoKSxcbiAgICBwYXRoOiAgICBkcmF3QWxsKHBhdGhQYXRoKSxcbiAgICBzeW1ib2w6ICBkcmF3QWxsKHN5bWJvbFBhdGgpLFxuICAgIHJlY3Q6ICAgIGRyYXdSZWN0LFxuICAgIHJ1bGU6ICAgIGRyYXdSdWxlLFxuICAgIHRleHQ6ICAgIGRyYXdUZXh0LFxuICAgIGltYWdlOiAgIGRyYXdJbWFnZSxcbiAgICBkcmF3T25lOiBkcmF3T25lLCAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgICBkcmF3QWxsOiBkcmF3QWxsICAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgfSxcbiAgcGljazoge1xuICAgIGdyb3VwOiAgIHBpY2tHcm91cCxcbiAgICBhcmVhOiAgICBwaWNrQXJlYSxcbiAgICBsaW5lOiAgICBwaWNrTGluZSxcbiAgICBhcmM6ICAgICBwaWNrKGhpdFRlc3RzLmFyYyksXG4gICAgcGF0aDogICAgcGljayhoaXRUZXN0cy5wYXRoKSxcbiAgICBzeW1ib2w6ICBwaWNrKGhpdFRlc3RzLnN5bWJvbCksXG4gICAgcmVjdDogICAgcGljayhoaXRUZXN0cy5yZWN0KSxcbiAgICBydWxlOiAgICBwaWNrKGhpdFRlc3RzLnJ1bGUpLFxuICAgIHRleHQ6ICAgIHBpY2soaGl0VGVzdHMudGV4dCksXG4gICAgaW1hZ2U6ICAgcGljayhoaXRUZXN0cy5pbWFnZSksXG4gICAgcGlja0FsbDogcGlja0FsbCAgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gIH1cbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9Cb3VuZHMnKTtcblxuLy8gUGF0aCBwYXJzaW5nIGFuZCByZW5kZXJpbmcgY29kZSB0YWtlbiBmcm9tIGZhYnJpYy5qcyAtLSBUaGFua3MhXG52YXIgY21kTGVuZ3RoID0geyBtOjIsIGw6MiwgaDoxLCB2OjEsIGM6Niwgczo0LCBxOjQsIHQ6MiwgYTo3IH0sXG4gICAgcmUgPSBbLyhbTUxIVkNTUVRBWm1saHZjc3F0YXpdKS9nLCAvIyMjLywgLyhcXGQpLS9nLCAvXFxzfCx8IyMjL107XG5cbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgY3VycmVudFBhdGgsXG4gICAgICBjaHVua3MsXG4gICAgICBwYXJzZWQ7XG5cbiAgLy8gRmlyc3QsIGJyZWFrIHBhdGggaW50byBjb21tYW5kIHNlcXVlbmNlXG4gIHBhdGggPSBwYXRoLnNsaWNlKCkucmVwbGFjZShyZVswXSwgJyMjIyQxJykuc3BsaXQocmVbMV0pLnNsaWNlKDEpO1xuXG4gIC8vIE5leHQsIHBhcnNlIGVhY2ggY29tbWFuZCBpbiB0dXJuXG4gIGZvciAodmFyIGk9MCwgaiwgY2h1bmtzUGFyc2VkLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyBpKyspIHtcbiAgICBjdXJyZW50UGF0aCA9IHBhdGhbaV07XG4gICAgY2h1bmtzID0gY3VycmVudFBhdGguc2xpY2UoMSkudHJpbSgpLnJlcGxhY2UocmVbMl0sJyQxIyMjLScpLnNwbGl0KHJlWzNdKTtcbiAgICBjaHVua3NQYXJzZWQgPSBbY3VycmVudFBhdGguY2hhckF0KDApXTtcblxuICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gY2h1bmtzLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgcGFyc2VkID0gcGFyc2VGbG9hdChjaHVua3Nbal0pO1xuICAgICAgaWYgKCFpc05hTihwYXJzZWQpKSB7XG4gICAgICAgIGNodW5rc1BhcnNlZC5wdXNoKHBhcnNlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvbW1hbmQgPSBjaHVua3NQYXJzZWRbMF0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgY29tbWFuZExlbmd0aCA9IGNtZExlbmd0aFtjb21tYW5kXTtcblxuICAgIGlmIChjaHVua3NQYXJzZWQubGVuZ3RoIC0gMSA+IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGsgPSAxLCBrbGVuID0gY2h1bmtzUGFyc2VkLmxlbmd0aDsgayA8IGtsZW47IGsgKz0gY29tbWFuZExlbmd0aCkge1xuICAgICAgICByZXN1bHQucHVzaChbIGNodW5rc1BhcnNlZFswXSBdLmNvbmNhdChjaHVua3NQYXJzZWQuc2xpY2UoaywgayArIGNvbW1hbmRMZW5ndGgpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goY2h1bmtzUGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBkcmF3QXJjKGcsIHgsIHksIGNvb3JkcywgYm91bmRzLCBsLCB0KSB7XG4gIHZhciByeCA9IGNvb3Jkc1swXTtcbiAgdmFyIHJ5ID0gY29vcmRzWzFdO1xuICB2YXIgcm90ID0gY29vcmRzWzJdO1xuICB2YXIgbGFyZ2UgPSBjb29yZHNbM107XG4gIHZhciBzd2VlcCA9IGNvb3Jkc1s0XTtcbiAgdmFyIGV4ID0gY29vcmRzWzVdO1xuICB2YXIgZXkgPSBjb29yZHNbNl07XG4gIHZhciBzZWdzID0gYXJjVG9TZWdtZW50cyhleCwgZXksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QsIHgsIHkpO1xuICBmb3IgKHZhciBpPTA7IGk8c2Vncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiZXogPSBzZWdtZW50VG9CZXppZXIuYXBwbHkobnVsbCwgc2Vnc1tpXSk7XG4gICAgZy5iZXppZXJDdXJ2ZVRvLmFwcGx5KGcsIGJleik7XG4gICAgYm91bmRzLmFkZChiZXpbMF0tbCwgYmV6WzFdLXQpO1xuICAgIGJvdW5kcy5hZGQoYmV6WzJdLWwsIGJlelszXS10KTtcbiAgICBib3VuZHMuYWRkKGJlels0XS1sLCBiZXpbNV0tdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRBcmMoeCwgeSwgY29vcmRzLCBib3VuZHMpIHtcbiAgdmFyIHJ4ID0gY29vcmRzWzBdO1xuICB2YXIgcnkgPSBjb29yZHNbMV07XG4gIHZhciByb3QgPSBjb29yZHNbMl07XG4gIHZhciBsYXJnZSA9IGNvb3Jkc1szXTtcbiAgdmFyIHN3ZWVwID0gY29vcmRzWzRdO1xuICB2YXIgZXggPSBjb29yZHNbNV07XG4gIHZhciBleSA9IGNvb3Jkc1s2XTtcbiAgdmFyIHNlZ3MgPSBhcmNUb1NlZ21lbnRzKGV4LCBleSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCwgeCwgeSk7XG4gIGZvciAodmFyIGk9MDsgaTxzZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJleiA9IHNlZ21lbnRUb0Jlemllci5hcHBseShudWxsLCBzZWdzW2ldKTtcbiAgICBib3VuZHMuYWRkKGJlelswXSwgYmV6WzFdKTtcbiAgICBib3VuZHMuYWRkKGJlelsyXSwgYmV6WzNdKTtcbiAgICBib3VuZHMuYWRkKGJlels0XSwgYmV6WzVdKTtcbiAgfVxufVxuXG52YXIgYXJjVG9TZWdtZW50c0NhY2hlID0geyB9LFxuICAgIHNlZ21lbnRUb0JlemllckNhY2hlID0geyB9LFxuICAgIGpvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbixcbiAgICBhcmdzU3RyO1xuXG4vLyBDb3BpZWQgZnJvbSBJbmtzY2FwZSBzdmd0b3BkZiwgdGhhbmtzIVxuZnVuY3Rpb24gYXJjVG9TZWdtZW50cyh4LCB5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90YXRlWCwgb3gsIG95KSB7XG4gIGFyZ3NTdHIgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgaWYgKGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyXSkge1xuICAgIHJldHVybiBhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cl07XG4gIH1cblxuICB2YXIgdGggPSByb3RhdGVYICogKE1hdGguUEkvMTgwKTtcbiAgdmFyIHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgdmFyIGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICB2YXIgcHggPSBjb3NfdGggKiAob3ggLSB4KSAqIDAuNSArIHNpbl90aCAqIChveSAtIHkpICogMC41O1xuICB2YXIgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICB2YXIgcGwgPSAocHgqcHgpIC8gKHJ4KnJ4KSArIChweSpweSkgLyAocnkqcnkpO1xuICBpZiAocGwgPiAxKSB7XG4gICAgcGwgPSBNYXRoLnNxcnQocGwpO1xuICAgIHJ4ICo9IHBsO1xuICAgIHJ5ICo9IHBsO1xuICB9XG5cbiAgdmFyIGEwMCA9IGNvc190aCAvIHJ4O1xuICB2YXIgYTAxID0gc2luX3RoIC8gcng7XG4gIHZhciBhMTAgPSAoLXNpbl90aCkgLyByeTtcbiAgdmFyIGExMSA9IChjb3NfdGgpIC8gcnk7XG4gIHZhciB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIHZhciB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIHZhciB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICB2YXIgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcblxuICB2YXIgZCA9ICh4MS14MCkgKiAoeDEteDApICsgKHkxLXkwKSAqICh5MS15MCk7XG4gIHZhciBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuICBpZiAoc2ZhY3Rvcl9zcSA8IDApIHNmYWN0b3Jfc3EgPSAwO1xuICB2YXIgc2ZhY3RvciA9IE1hdGguc3FydChzZmFjdG9yX3NxKTtcbiAgaWYgKHN3ZWVwID09IGxhcmdlKSBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIHZhciB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEteTApO1xuICB2YXIgeWMgPSAwLjUgKiAoeTAgKyB5MSkgKyBzZmFjdG9yICogKHgxLXgwKTtcblxuICB2YXIgdGgwID0gTWF0aC5hdGFuMih5MC15YywgeDAteGMpO1xuICB2YXIgdGgxID0gTWF0aC5hdGFuMih5MS15YywgeDEteGMpO1xuXG4gIHZhciB0aF9hcmMgPSB0aDEtdGgwO1xuICBpZiAodGhfYXJjIDwgMCAmJiBzd2VlcCA9PSAxKXtcbiAgICB0aF9hcmMgKz0gMipNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT0gMCkge1xuICAgIHRoX2FyYyAtPSAyICogTWF0aC5QSTtcbiAgfVxuXG4gIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChNYXRoLmFicyh0aF9hcmMgLyAoTWF0aC5QSSAqIDAuNSArIDAuMDAxKSkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGk9MDsgaTxzZWdtZW50czsgaSsrKSB7XG4gICAgdmFyIHRoMiA9IHRoMCArIGkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICB2YXIgdGgzID0gdGgwICsgKGkrMSkgKiB0aF9hcmMgLyBzZWdtZW50cztcbiAgICByZXN1bHRbaV0gPSBbeGMsIHljLCB0aDIsIHRoMywgcngsIHJ5LCBzaW5fdGgsIGNvc190aF07XG4gIH1cblxuICByZXR1cm4gKGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyXSA9IHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHNlZ21lbnRUb0JlemllcihjeCwgY3ksIHRoMCwgdGgxLCByeCwgcnksIHNpbl90aCwgY29zX3RoKSB7XG4gIGFyZ3NTdHIgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgaWYgKHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJdKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJdO1xuICB9XG5cbiAgdmFyIGEwMCA9IGNvc190aCAqIHJ4O1xuICB2YXIgYTAxID0gLXNpbl90aCAqIHJ5O1xuICB2YXIgYTEwID0gc2luX3RoICogcng7XG4gIHZhciBhMTEgPSBjb3NfdGggKiByeTtcblxuICB2YXIgY29zX3RoMCA9IE1hdGguY29zKHRoMCk7XG4gIHZhciBzaW5fdGgwID0gTWF0aC5zaW4odGgwKTtcbiAgdmFyIGNvc190aDEgPSBNYXRoLmNvcyh0aDEpO1xuICB2YXIgc2luX3RoMSA9IE1hdGguc2luKHRoMSk7XG5cbiAgdmFyIHRoX2hhbGYgPSAwLjUgKiAodGgxIC0gdGgwKTtcbiAgdmFyIHNpbl90aF9oMiA9IE1hdGguc2luKHRoX2hhbGYgKiAwLjUpO1xuICB2YXIgdCA9ICg4LzMpICogc2luX3RoX2gyICogc2luX3RoX2gyIC8gTWF0aC5zaW4odGhfaGFsZik7XG4gIHZhciB4MSA9IGN4ICsgY29zX3RoMCAtIHQgKiBzaW5fdGgwO1xuICB2YXIgeTEgPSBjeSArIHNpbl90aDAgKyB0ICogY29zX3RoMDtcbiAgdmFyIHgzID0gY3ggKyBjb3NfdGgxO1xuICB2YXIgeTMgPSBjeSArIHNpbl90aDE7XG4gIHZhciB4MiA9IHgzICsgdCAqIHNpbl90aDE7XG4gIHZhciB5MiA9IHkzIC0gdCAqIGNvc190aDE7XG5cbiAgcmV0dXJuIChzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyXSA9IFtcbiAgICBhMDAgKiB4MSArIGEwMSAqIHkxLCAgYTEwICogeDEgKyBhMTEgKiB5MSxcbiAgICBhMDAgKiB4MiArIGEwMSAqIHkyLCAgYTEwICogeDIgKyBhMTEgKiB5MixcbiAgICBhMDAgKiB4MyArIGEwMSAqIHkzLCAgYTEwICogeDMgKyBhMTEgKiB5M1xuICBdKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyKGcsIHBhdGgsIGwsIHQpIHtcbiAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFksXG4gICAgICBib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gIGlmIChsID09IHVuZGVmaW5lZCkgbCA9IDA7XG4gIGlmICh0ID09IHVuZGVmaW5lZCkgdCA9IDA7XG5cbiAgZy5iZWdpblBhdGgoKTtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuXG4gICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnSCc6IC8vIGhvcml6b250YWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHkgKz0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgZy5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgZy5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgeCArIGN1cnJlbnRbMV0gKyBsLCAvLyB4MVxuICAgICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCwgLy8geTFcbiAgICAgICAgICBjb250cm9sWCArIGwsIC8vIHgyXG4gICAgICAgICAgY29udHJvbFkgKyB0LCAvLyB5MlxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgeCArIGwsXG4gICAgICAgICAgeSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcblxuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyKnggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyKnkgLSBjb250cm9sWTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3QnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHRcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gdGVtcENvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSB0ZW1wQ29udHJvbFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICdxJykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciBxXG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBDb250cm9sWCA9IGNvbnRyb2xYO1xuICAgICAgICB0ZW1wQ29udHJvbFkgPSBjb250cm9sWTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgZHJhd0FyYyhnLCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIHggKyBsLFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB5ICsgdFxuICAgICAgICBdLCBib3VuZHMsIGwsIHQpO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICBdLCBib3VuZHMsIGwsIHQpO1xuICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICBnLmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG4gIHJldHVybiBib3VuZHMudHJhbnNsYXRlKGwsIHQpO1xufVxuXG5mdW5jdGlvbiBib3VuZHMocGF0aCwgYm91bmRzKSB7XG4gIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICBwcmV2aW91cyA9IG51bGwsXG4gICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICB0ZW1wWCxcbiAgICAgIHRlbXBZLFxuICAgICAgdGVtcENvbnRyb2xYLFxuICAgICAgdGVtcENvbnRyb2xZO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHBhdGhbaV07XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcblxuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyKnggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyKnkgLSBjb250cm9sWTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAndCcpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgdFxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSB0ZW1wQ29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIHRlbXBDb250cm9sWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHFcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgYm91bmRBcmMoeCwgeSwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgeCxcbiAgICAgICAgICBjdXJyZW50WzddICsgeVxuICAgICAgICBdLCBib3VuZHMpO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBib3VuZEFyYyh4LCB5LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0sXG4gICAgICAgICAgY3VycmVudFs3XVxuICAgICAgICBdLCBib3VuZHMpO1xuICAgICAgICB4ID0gY3VycmVudFs2XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGFyZWEoaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgdmFyIGFyZWEgPSBkMy5zdmcuYXJlYSgpXG4gICAgLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KVxuICAgIC55MShmdW5jdGlvbihkKSB7IHJldHVybiBkLnk7IH0pXG4gICAgLnkwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueSArIGQuaGVpZ2h0OyB9KTtcbiAgaWYgKG8uaW50ZXJwb2xhdGUpIGFyZWEuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSk7XG4gIGlmIChvLnRlbnNpb24gIT0gbnVsbCkgYXJlYS50ZW5zaW9uKG8udGVuc2lvbik7XG4gIHJldHVybiBhcmVhKGl0ZW1zKTtcbn1cblxuZnVuY3Rpb24gbGluZShpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICB2YXIgbGluZSA9IGQzLnN2Zy5saW5lKClcbiAgIC54KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueDsgfSlcbiAgIC55KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueTsgfSk7XG4gIGlmIChvLmludGVycG9sYXRlKSBsaW5lLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUpO1xuICBpZiAoby50ZW5zaW9uICE9IG51bGwpIGxpbmUudGVuc2lvbihvLnRlbnNpb24pO1xuICByZXR1cm4gbGluZShpdGVtcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogIHBhcnNlLFxuICByZW5kZXI6IHJlbmRlcixcbiAgYm91bmRzOiBib3VuZHMsXG4gIGFyZWE6ICAgYXJlYSxcbiAgbGluZTogICBsaW5lXG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyksXG4gICAgU1ZHQnVpbGRlciA9IHJlcXVpcmUoJy4vc3ZnJyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9idWlsZGVyID0gbnVsbDtcbn07XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl9idWlsZGVyID0gbmV3IFNWR0J1aWxkZXIoKTtcbiAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIHBhZCk7XG59XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkIHx8IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHRoaXMuX2F1dG9wYWQgPSBkbC5pc1N0cmluZyh0aGlzLl9wYWRkaW5nKSA/IDEgOiAwO1xuXG4gIHZhciB3ID0gdGhpcy5fd2lkdGgsIGggPSB0aGlzLl9oZWlnaHQsIHBhZCA9IHRoaXMuX3BhZGRpbmc7XG4gIFxuICAvLyAocmUtKWNvbmZpZ3VyZSBidWlsZGVyIHNpemVcbiAgdGhpcy5fYnVpbGRlci5pbml0aWFsaXplKG51bGwsIHcsIGgsIHBhZCk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIC8vIGhlYWRsZXNzIGFsd2F5cyBkcmF3cyB0aGUgZW50aXJlIHNjZW5lLCBpZ25vcmluZyBpdGVtc1xuICB0aGlzLl9idWlsZGVyLnJlbmRlcihzY2VuZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYnVpbGRlci5zdmcoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vUmVuZGVyZXInKVxufTtcbiIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9naWQgPSAwOyAvLyBncm91cCBpZCBjb3VudGVyIGZvciBkMyBkb20gY29tcGF0XG4gIHRoaXMuX3RleHQgPSB7XG4gICAgaGVhZDogXCJcIixcbiAgICByb290OiBcIlwiLFxuICAgIGZvb3Q6IFwiXCIsXG4gICAgZGVmczogXCJcIixcbiAgICBib2R5OiBcIlwiXG4gIH07XG4gIHRoaXMuX2RlZnMgPSB7XG4gICAgZ3JhZGllbnQ6IHt9LFxuICAgIGNsaXBwaW5nOiB7fVxuICB9O1xufTtcblxuZnVuY3Rpb24gb3Blbih0YWcsIGF0dHIsIHJhdykge1xuICB2YXIgcyA9IFwiPFwiICsgdGFnO1xuICBpZiAoYXR0cikge1xuICAgIGZvciAodmFyIGtleSBpbiBhdHRyKSB7XG4gICAgICB2YXIgdmFsID0gYXR0cltrZXldO1xuICAgICAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgICAgIHMgKz0gXCIgXCIgKyBrZXkgKyAnPVwiJyArIHZhbCArICdcIic7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyYXcpIHMgKz0gXCIgXCIgKyByYXc7XG4gIHJldHVybiBzICsgXCI+XCI7XG59XG5cbmZ1bmN0aW9uIGNsb3NlKHRhZykge1xuICByZXR1cm4gXCI8L1wiICsgdGFnICsgXCI+XCI7XG59XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHcsIGgsIHBhZCkge1xuICB2YXIgdCA9IHRoaXMuX3RleHQ7XG5cbiAgdC5oZWFkID0gb3Blbignc3ZnJywge1xuICAgIFwiY2xhc3NcIjogJ21hcmtzJyxcbiAgICB3aWR0aDogdyArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgIGhlaWdodDogaCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICB9LCBjb25maWcuc3ZnTmFtZXNwYWNlKTtcblxuICB0LnJvb3QgPSBvcGVuKCdnJywge1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgcGFkLmxlZnQgKyAnLCcgKyBwYWQudG9wICsgJyknXG4gIH0pO1xuXG4gIHQuZm9vdCA9IGNsb3NlKCdnJykgKyBjbG9zZSgnc3ZnJyk7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0ID0gdGhpcy5fdGV4dDtcbiAgcmV0dXJuIHQuaGVhZCArIHQuZGVmcyArIHQucm9vdCArIHQuYm9keSArIHQuZm9vdDtcbn07XG5cbnByb3RvdHlwZS5idWlsZERlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFsbCA9IHRoaXMuX2RlZnMsXG4gICAgICBkZ3JhZCA9IGRsLmtleXMoYWxsLmdyYWRpZW50KSxcbiAgICAgIGRjbGlwID0gZGwua2V5cyhhbGwuY2xpcHBpbmcpLFxuICAgICAgZGVmcyA9IFwiXCIsIGdyYWQsIGNsaXAsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8ZGdyYWQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaWQgPSBkZ3JhZFtpXSxcbiAgICAgICAgZGVmID0gYWxsLmdyYWRpZW50W2lkXSxcbiAgICAgICAgc3RvcHMgPSBkZWYuc3RvcHM7XG5cbiAgICBkZWZzICs9IG9wZW4oXCJsaW5lYXJHcmFkaWVudFwiLCB7XG4gICAgICBpZDogaWQsXG4gICAgICB4MTogZGVmLngxLFxuICAgICAgeDI6IGRlZi54MixcbiAgICAgIHkxOiBkZWYueTEsXG4gICAgICB5MjogZGVmLnkyXG4gICAgfSk7XG4gICAgXG4gICAgZm9yIChqPTA7IGo8c3RvcHMubGVuZ3RoOyArK2opIHtcbiAgICAgIGRlZnMgKz0gb3BlbihcInN0b3BcIiwge1xuICAgICAgICBvZmZzZXQ6IHN0b3BzW2pdLm9mZnNldCxcbiAgICAgICAgXCJzdG9wLWNvbG9yXCI6IHN0b3BzW2pdLmNvbG9yXG4gICAgICB9KSArIGNsb3NlKFwic3RvcFwiKTtcbiAgICB9XG4gICAgXG4gICAgZGVmcyArPSBjbG9zZShcImxpbmVhckdyYWRpZW50XCIpO1xuICB9XG4gIFxuICBmb3IgKGk9MDsgaTxkY2xpcC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IGRjbGlwW2ldLFxuICAgICAgICBkZWYgPSBhbGwuY2xpcHBpbmdbaWRdO1xuXG4gICAgZGVmcyArPSBvcGVuKFwiY2xpcFBhdGhcIiwge2lkOiBpZH0pO1xuXG4gICAgZGVmcyArPSBvcGVuKFwicmVjdFwiLCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBkZWYud2lkdGgsXG4gICAgICBoZWlnaHQ6IGRlZi5oZWlnaHRcbiAgICB9KSArIGNsb3NlKFwicmVjdFwiKTtcblxuICAgIGRlZnMgKz0gY2xvc2UoXCJjbGlwUGF0aFwiKTtcbiAgfVxuICBcbiAgaWYgKGRlZnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBvcGVuKFwiZGVmc1wiKSArIGRlZnMgKyBjbG9zZShcImRlZnNcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCJcbiAgfVxuICByZXR1cm4gZGVmcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSkge1xuICB0aGlzLl9naWQgPSAwOyAvLyByZXNldCB0aGUgZ3JvdXAgY291bnRlclxuICB0aGlzLl90ZXh0LmJvZHkgPSB0aGlzLmRyYXcoc2NlbmUpO1xuICB0aGlzLl90ZXh0LmRlZnMgPSB0aGlzLmJ1aWxkRGVmcygpO1xufTtcblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgbWV0YSA9IE1BUktTW3NjZW5lLm1hcmt0eXBlXTtcbiAgaWYgKCFtZXRhKSB7XG4gICAgcmV0dXJuOyAvLyBubyBrbm93biBtYXJrdHlwZSAoZS5nLiwgYW4gaW50ZXJhY3RvcilcbiAgfVxuICB2YXIgdGFnICA9IG1ldGFbMF0sXG4gICAgICBhdHRyID0gbWV0YVsxXSxcbiAgICAgIG5lc3QgPSBtZXRhWzJdIHx8IGZhbHNlLFxuICAgICAgZGF0YSA9IG5lc3QgPyBbc2NlbmUuaXRlbXNdIDogc2NlbmUuaXRlbXMsXG4gICAgICBkZWZzID0gdGhpcy5fZGVmcyxcbiAgICAgIHN2ZyA9IFwiXCIsIGksIHN0eTtcblxuICB2YXIgY2xzID0gY3NzQ2xhc3Moc2NlbmUuZGVmKTtcblxuICAvLyBzdHlsZSBsaXRlcmFscyB0byBleGFjdGx5IG1hdGNoIHRoZSBkMyBkb21cbiAgdmFyIHN0eWwgPSBudWxsO1xuICBpZiAoY2xzID09PSAndHlwZS1ydWxlJyB8fCBjbHMgPT09ICd0eXBlLXBhdGgnKVxuICAgIHN0eWwgPSAnc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIic7XG4gIGVsc2UgaWYgKGNscyAhPT0gJ3R5cGUtZ3JvdXAnKVxuICAgIHN0eWwgPSAnc3R5bGU9XCJcIic7XG5cbiAgc3ZnICs9IG9wZW4oJ2cnLCB7XG4gICAgJ2lkJzogJ2cnICsgKyt0aGlzLl9naWQsIC8vIGQzIGRvbSBjb21wYXRcbiAgICAnY2xhc3MnOiBjc3NDbGFzcyhzY2VuZS5kZWYpXG4gIH0sIHN0eWwpO1xuXG4gIGZvciAoaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgc3R5ID0gdGFnID09PSAnZycgPyBudWxsIDogc3R5bGUoZGF0YVtpXSwgdGFnLCBkZWZzKTtcbiAgICBzdmcgKz0gb3Blbih0YWcsIGF0dHIoZGF0YVtpXSwgZGVmcyksIHN0eSk7XG4gICAgaWYgKHRhZyA9PT0gJ3RleHQnKSBzdmcgKz0gZXNjYXBlX3RleHQoZGF0YVtpXS50ZXh0KTtcbiAgICBpZiAodGFnID09PSAnZycpIHN2ZyArPSB0aGlzLmRyYXdHcm91cChkYXRhW2ldKTtcbiAgICBzdmcgKz0gY2xvc2UodGFnKTtcbiAgfVxuXG4gIHJldHVybiBzdmcgKyBjbG9zZSgnZycpO1xufTtcblxuZnVuY3Rpb24gZXNjYXBlX3RleHQocykge1xuICBzID0gKHMgPT0gbnVsbCA/IFwiXCIgOiBTdHJpbmcocykpO1xuICByZXR1cm4gcy5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZV9mb250KHMpIHtcbiAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC9cXFwiL2csIFwiJ1wiKTtcbn1cblxudmFyIE1BUktTID0ge1xuICBncm91cDogIFsnZycsIGdyb3VwXSxcbiAgYXJlYTogICBbJ3BhdGgnLCBhcmVhLCB0cnVlXSxcbiAgbGluZTogICBbJ3BhdGgnLCBsaW5lLCB0cnVlXSxcbiAgYXJjOiAgICBbJ3BhdGgnLCBhcmNdLFxuICBwYXRoOiAgIFsncGF0aCcsIHBhdGhdLFxuICBzeW1ib2w6IFsncGF0aCcsIHN5bWJvbF0sXG4gIHJlY3Q6ICAgWydyZWN0JywgcmVjdF0sXG4gIHJ1bGU6ICAgWydsaW5lJywgcnVsZV0sXG4gIHRleHQ6ICAgWyd0ZXh0JywgdGV4dF0sXG4gIGltYWdlOiAgWydpbWFnZScsIGltYWdlXVxufTtcblxucHJvdG90eXBlLmRyYXdHcm91cCA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBzdmcgPSBcIlwiLFxuICAgICAgYXhlcyA9IHNjZW5lLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBsZWdlbmRzID0gc2NlbmUubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBpLCBqLCBtO1xuXG4gIHN2ZyArPSBncm91cF9iZyhzY2VuZSk7XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyID09PSBcImJhY2tcIikge1xuICAgICAgc3ZnICs9IHRoaXMuZHJhdyhheGVzW2pdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHN2ZyArPSB0aGlzLmRyYXcoaXRlbXNbal0pO1xuICB9XG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmRlZi5sYXllciAhPT0gXCJiYWNrXCIpIHtcbiAgICAgIHN2ZyArPSB0aGlzLmRyYXcoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHN2ZyArPSB0aGlzLmRyYXcobGVnZW5kc1tqXSk7XG4gIH1cblxuICByZXR1cm4gc3ZnO1xufTtcblxuLy8vXG5cbmZ1bmN0aW9uIGdyb3VwX2JnKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMDtcblxuICB2YXIgc3R5bCA9IG8ubWFyay5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgP1xuICAgICdzdHlsZT1cInBvaW50ZXItZXZlbnRzOiBub25lO1wiJyA6IFxuICAgICdzdHlsZT1cIlwiJztcblxuICByZXR1cm4gb3BlbigncmVjdCcsIHtcbiAgICAnY2xhc3MnOiAnYmFja2dyb3VuZCdcbiAgfSwgc3R5bCkgKyBjbG9zZSgncmVjdCcpO1xufVxuXG5mdW5jdGlvbiBncm91cChvLCBkZWZzKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBhdHRyID0ge3RyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwifTtcblxuICBpZiAoby5jbGlwKSB7XG4gICAgdmFyIGMgPSB7d2lkdGg6IG8ud2lkdGggfHwgMCwgaGVpZ2h0OiBvLmhlaWdodCB8fCAwfSxcbiAgICAgICAgaWQgPSBvLmNsaXBfaWQgfHwgKG8uY2xpcF9pZCA9IFwiY2xpcFwiICsgY2xpcF9pZCsrKTtcbiAgICBkZWZzLmNsaXBwaW5nW2lkXSA9IGM7XG4gICAgYXR0cltcImNsaXAtcGF0aFwiXSA9IFwidXJsKCNcIitpZCtcIilcIjtcbiAgfVxuXG4gIHJldHVybiBhdHRyO1xufVxuXG5mdW5jdGlvbiBhcmMobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiLFxuICAgIGQ6IGFyY19wYXRoKG8pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFyZWEoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIHBhdGggPSBvLm9yaWVudCA9PT0gXCJob3Jpem9udGFsXCIgPyBhcmVhX3BhdGhfaCA6IGFyZWFfcGF0aF92O1xuICBwYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHJldHVybiB7ZDogcGF0aChpdGVtcyl9O1xufVxuXG5mdW5jdGlvbiBsaW5lKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIGxpbmVfcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICByZXR1cm4ge2Q6IGxpbmVfcGF0aChpdGVtcyl9O1xufVxuXG5mdW5jdGlvbiBwYXRoKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIixcbiAgICBkOiBvLnBhdGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVjdChvKSB7XG4gIHJldHVybiB7XG4gICAgeDogby54IHx8IDAsXG4gICAgeTogby55IHx8IDAsXG4gICAgd2lkdGg6IG8ud2lkdGggfHwgMCxcbiAgICBoZWlnaHQ6IG8uaGVpZ2h0IHx8IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gcnVsZShvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB4MTogeDEsXG4gICAgeTE6IHkxLFxuICAgIHgyOiBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgeTI6IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MVxuICB9O1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiLFxuICAgIGQ6IHN5bWJvbF9wYXRoKG8pXG4gIH07XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDAsXG4gICAgICB4ID0gby54IC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKSxcbiAgICAgIHkgPSBvLnkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKSxcbiAgICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgby51cmw7XG4gIFxuICByZXR1cm4ge1xuICAgIFwieGxpbms6aHJlZlwiOiB1cmwsXG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaFxuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0KG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGR4ID0gby5keCB8fCAwLFxuICAgICAgZHkgPSBvLmR5IHx8IDAsXG4gICAgICBhID0gby5hbmdsZSB8fCAwLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBhbGlnbiA9IHRleHRBbGlnbltvLmFsaWduIHx8IFwibGVmdFwiXSxcbiAgICAgIGJhc2UgPSBvLmJhc2VsaW5lPT09XCJ0b3BcIiA/IFwiLjllbVwiXG4gICAgICAgICAgIDogby5iYXNlbGluZT09PVwibWlkZGxlXCIgPyBcIi4zNWVtXCIgOiAwO1xuXG4gIGlmIChyKSB7XG4gICAgdmFyIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCArIGR4LFxuICAgIHk6IHkgKyBkeSxcbiAgICAndGV4dC1hbmNob3InOiBhbGlnbixcbiAgICB0cmFuc2Zvcm06IGEgPyBcInJvdGF0ZShcIithK1wiIFwiK3grXCIsXCIreStcIilcIiA6IG51bGwsXG4gICAgZHk6IGJhc2UgPyBiYXNlIDogbnVsbFxuICB9O1xufVxuXG4vLy9cblxuZnVuY3Rpb24gY3NzQ2xhc3MoZGVmKSB7XG4gIHZhciBjbHMgPSBcInR5cGUtXCIgKyBkZWYudHlwZTtcbiAgaWYgKGRlZi5uYW1lKSBjbHMgKz0gXCIgXCIgKyBkZWYubmFtZTtcbiAgcmV0dXJuIGNscztcbn1cblxuZnVuY3Rpb24geChvKSAgICAgeyByZXR1cm4gby54IHx8IDA7IH1cbmZ1bmN0aW9uIHkobykgICAgIHsgcmV0dXJuIG8ueSB8fCAwOyB9XG5mdW5jdGlvbiB4dyhvKSAgICB7IHJldHVybiBvLnggKyBvLndpZHRoIHx8IDA7IH1cbmZ1bmN0aW9uIHloKG8pICAgIHsgcmV0dXJuIG8ueSArIG8uaGVpZ2h0IHx8IDA7IH1cbmZ1bmN0aW9uIGtleShvKSAgIHsgcmV0dXJuIG8ua2V5OyB9XG5mdW5jdGlvbiBzaXplKG8pICB7IHJldHVybiBvLnNpemU9PW51bGwgPyAxMDAgOiBvLnNpemU7IH1cbmZ1bmN0aW9uIHNoYXBlKG8pIHsgcmV0dXJuIG8uc2hhcGUgfHwgXCJjaXJjbGVcIjsgfVxuXG52YXIgYXJjX3BhdGggICAgPSBkMy5zdmcuYXJjKCksXG4gICAgYXJlYV9wYXRoX3YgPSBkMy5zdmcuYXJlYSgpLngoeCkueTEoeSkueTAoeWgpLFxuICAgIGFyZWFfcGF0aF9oID0gZDMuc3ZnLmFyZWEoKS55KHkpLngwKHh3KS54MSh4KSxcbiAgICBsaW5lX3BhdGggICA9IGQzLnN2Zy5saW5lKCkueCh4KS55KHkpLFxuICAgIHN5bWJvbF9wYXRoID0gZDMuc3ZnLnN5bWJvbCgpLnR5cGUoc2hhcGUpLnNpemUoc2l6ZSk7XG5cbnZhciBtYXJrX2lkID0gMCxcbiAgICBjbGlwX2lkID0gMDtcblxudmFyIHRleHRBbGlnbiA9IHtcbiAgXCJsZWZ0XCI6ICAgXCJzdGFydFwiLFxuICBcImNlbnRlclwiOiBcIm1pZGRsZVwiLFxuICBcInJpZ2h0XCI6ICBcImVuZFwiXG59O1xuXG52YXIgc3R5bGVzID0ge1xuICBcImZpbGxcIjogICAgICAgICAgICAgXCJmaWxsXCIsXG4gIFwiZmlsbE9wYWNpdHlcIjogICAgICBcImZpbGwtb3BhY2l0eVwiLFxuICBcInN0cm9rZVwiOiAgICAgICAgICAgXCJzdHJva2VcIixcbiAgXCJzdHJva2VXaWR0aFwiOiAgICAgIFwic3Ryb2tlLXdpZHRoXCIsXG4gIFwic3Ryb2tlT3BhY2l0eVwiOiAgICBcInN0cm9rZS1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlQ2FwXCI6ICAgICAgICBcInN0cm9rZS1saW5lY2FwXCIsXG4gIFwic3Ryb2tlRGFzaFwiOiAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgXCJzdHJva2VEYXNoT2Zmc2V0XCI6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgXCJvcGFjaXR5XCI6ICAgICAgICAgIFwib3BhY2l0eVwiXG59O1xuXG52YXIgc3R5bGVQcm9wcyA9IGRsLmtleXMoc3R5bGVzKTtcblxuZnVuY3Rpb24gc3R5bGUoZCwgdGFnLCBkZWZzKSB7XG4gIHZhciBpLCBuLCBwcm9wLCBuYW1lLCB2YWx1ZSxcbiAgICAgIG8gPSBkLm1hcmsgPyBkIDogZC5sZW5ndGggPyBkWzBdIDogbnVsbDtcbiAgaWYgKG8gPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBzID0gXCJcIjtcblxuICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICBzICs9ICdmb250OiAnICsgZm9udFN0cmluZyhvKSArICc7JztcbiAgfVxuICBcbiAgZm9yIChpPTAsIG49c3R5bGVQcm9wcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IHN0eWxlUHJvcHNbaV07XG4gICAgbmFtZSA9IHN0eWxlc1twcm9wXTtcbiAgICB2YWx1ZSA9IG9bcHJvcF07XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5hbWUgPT09IFwiZmlsbFwiKSBzICs9ICdmaWxsOiBub25lOyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5pZCkge1xuICAgICAgICAvLyBlbnN1cmUgZGVmaW5pdGlvbiBpcyBpbmNsdWRlZFxuICAgICAgICBkZWZzLmdyYWRpZW50W3ZhbHVlLmlkXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IFwidXJsKFwiICsgd2luZG93LmxvY2F0aW9uLmhyZWYgKyBcIiNcIiArIHZhbHVlLmlkICsgXCIpXCI7XG4gICAgICB9XG4gICAgICBzICs9IChzLmxlbmd0aCA/ICcgJyA6ICcnKSArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnOydcbiAgICB9XG4gIH1cbiAgXG4gIC8vIG5vdCB0aGF0IHdlIGRvbid0IGV4Y2x1ZGUgYmxhbmsgc3R5bGVzIGZvciBkMyBkb20gY29tcGF0XG4gIHJldHVybiAnc3R5bGU9XCInK3MrJ1wiJztcbn1cblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHZhciBmID0gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgJiYgZXNjYXBlX2ZvbnQoby5mb250KSB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xuICByZXR1cm4gZjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJlcjtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxudmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlbCwgbW9kZWwpIHtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaWYgKGVsKSB0aGlzLmluaXRpYWxpemUoZWwpO1xuICBpZiAobW9kZWwpIHRoaXMubW9kZWwobW9kZWwpO1xufTtcblxuZnVuY3Rpb24gc3ZnSGFuZGxlcihoYW5kbGVyKSB7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciB0YXJnZXQgPSBldnQudGFyZ2V0LFxuICAgICAgICBpdGVtID0gdGFyZ2V0Ll9fZGF0YV9fO1xuXG4gICAgaWYgKGl0ZW0pIGl0ZW0gPSBpdGVtLm1hcmsgPyBpdGVtIDogaXRlbVswXTtcbiAgICBoYW5kbGVyLmNhbGwodGhhdC5fb2JqLCBldnQsIGl0ZW0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBldmVudE5hbWUobmFtZSkge1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi5cIik7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59XG5cbnZhciBwcm90b3R5cGUgPSBoYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBkMy5zZWxlY3QoZWwpLm5vZGUoKTtcbiAgdGhpcy5fc3ZnID0gZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJzdmcubWFya3NcIikubm9kZSgpO1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICByZXR1cm4gZGwua2V5cyhoKS5yZWR1Y2UoZnVuY3Rpb24oYSwgaykge1xuICAgIHJldHVybiBoW2tdLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7IHJldHVybiAoYS5wdXNoKHgpLCBhKTsgfSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzLFxuICAgICAgZG9tID0gZDMuc2VsZWN0KHRoaXMuX3N2Zykubm9kZSgpO1xuICAgICAgXG4gIHZhciB4ID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICBzdmc6IHN2Z0hhbmRsZXIuY2FsbCh0aGlzLCBoYW5kbGVyKVxuICB9O1xuICBoID0gaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKTtcbiAgaC5wdXNoKHgpO1xuXG4gIGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHguc3ZnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyByZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSBldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sXG4gICAgICBkb20gPSBkMy5zZWxlY3QodGhpcy5fc3ZnKS5ub2RlKCk7XG4gIGlmICghaCkgcmV0dXJuO1xuICBmb3IgKHZhciBpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYgKGhbaV0udHlwZSAhPT0gdHlwZSkgY29udGludWU7XG4gICAgaWYgKCFoYW5kbGVyIHx8IGhbaV0uaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaFtpXS5zdmcpO1xuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fc3ZnID0gbnVsbDtcbiAgdGhpcy5fY3R4ID0gbnVsbDtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9kZWZzID0ge1xuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl9lbCA9IGVsO1xuXG4gIC8vIHJlbW92ZSBhbnkgZXhpc3Rpbmcgc3ZnIGVsZW1lbnRcbiAgZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJzdmcubWFya3NcIikucmVtb3ZlKCk7XG5cbiAgLy8gY3JlYXRlIHN2ZyBlbGVtZW50IGFuZCBpbml0aWFsaXplIGF0dHJpYnV0ZXNcbiAgdGhpcy5fc3ZnID0gZDMuc2VsZWN0KGVsKVxuICAgIC5hcHBlbmQoXCJzdmdcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwibWFya3NcIik7XG4gIFxuICAvLyBzZXQgdGhlIHN2ZyByb290IGdyb3VwXG4gIHRoaXMuX2N0eCA9IHRoaXMuX3N2Zy5hcHBlbmQoXCJnXCIpO1xuICBcbiAgcmV0dXJuIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQsIHBhZCk7XG59O1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgXG4gIHRoaXMuX3N2Z1xuICAgIC5hdHRyKFwid2lkdGhcIiwgd2lkdGggKyBwYWQubGVmdCArIHBhZC5yaWdodClcbiAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBwYWQudG9wICsgcGFkLmJvdHRvbSk7XG4gICAgXG4gIHRoaXMuX2N0eFxuICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3BhZC5sZWZ0K1wiLFwiK3BhZC50b3ArXCIpXCIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2N0eDtcbn07XG5cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbnByb3RvdHlwZS51cGRhdGVEZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICBhbGwgPSB0aGlzLl9kZWZzLFxuICAgICAgZGdyYWQgPSBkbC5rZXlzKGFsbC5ncmFkaWVudCksXG4gICAgICBkY2xpcCA9IGRsLmtleXMoYWxsLmNsaXBwaW5nKSxcbiAgICAgIGRlZnMgPSBzdmcuc2VsZWN0KFwiZGVmc1wiKSwgZ3JhZCwgY2xpcDtcblxuICAvLyBnZXQgb3IgY3JlYXRlIHN2ZyBkZWZzIGJsb2NrXG4gIGlmIChkZ3JhZC5sZW5ndGg9PT0wICYmIGRjbGlwLmxlbmd0aD09MCkgeyBkZWZzLnJlbW92ZSgpOyByZXR1cm47IH1cbiAgaWYgKGRlZnMuZW1wdHkoKSkgZGVmcyA9IHN2Zy5pbnNlcnQoXCJkZWZzXCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBcbiAgZ3JhZCA9IGRlZnMuc2VsZWN0QWxsKFwibGluZWFyR3JhZGllbnRcIikuZGF0YShkZ3JhZCwgZGwuaWRlbnRpdHkpO1xuICBncmFkLmVudGVyKCkuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIikuYXR0cihcImlkXCIsIGRsLmlkZW50aXR5KTtcbiAgZ3JhZC5leGl0KCkucmVtb3ZlKCk7XG4gIGdyYWQuZWFjaChmdW5jdGlvbihpZCkge1xuICAgIHZhciBkZWYgPSBhbGwuZ3JhZGllbnRbaWRdLFxuICAgICAgICBncmQgPSBkMy5zZWxlY3QodGhpcyk7XG5cbiAgICAvLyBzZXQgZ3JhZGllbnQgY29vcmRpbmF0ZXNcbiAgICBncmQuYXR0cih7eDE6IGRlZi54MSwgeDI6IGRlZi54MiwgeTE6IGRlZi55MSwgeTI6IGRlZi55Mn0pO1xuXG4gICAgLy8gc2V0IGdyYWRpZW50IHN0b3BzXG4gICAgc3RvcCA9IGdyZC5zZWxlY3RBbGwoXCJzdG9wXCIpLmRhdGEoZGVmLnN0b3BzKTtcbiAgICBzdG9wLmVudGVyKCkuYXBwZW5kKFwic3RvcFwiKTtcbiAgICBzdG9wLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBzdG9wLmF0dHIoXCJvZmZzZXRcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5vZmZzZXQ7IH0pXG4gICAgICAgIC5hdHRyKFwic3RvcC1jb2xvclwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLmNvbG9yOyB9KTtcbiAgfSk7XG4gIFxuICBjbGlwID0gZGVmcy5zZWxlY3RBbGwoXCJjbGlwUGF0aFwiKS5kYXRhKGRjbGlwLCBkbC5pZGVudGl0eSk7XG4gIGNsaXAuZW50ZXIoKS5hcHBlbmQoXCJjbGlwUGF0aFwiKS5hdHRyKFwiaWRcIiwgZGwuaWRlbnRpdHkpO1xuICBjbGlwLmV4aXQoKS5yZW1vdmUoKTtcbiAgY2xpcC5lYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGRlZiA9IGFsbC5jbGlwcGluZ1tpZF0sXG4gICAgICAgIGNyID0gZDMuc2VsZWN0KHRoaXMpLnNlbGVjdEFsbChcInJlY3RcIikuZGF0YShbMV0pO1xuICAgIGNyLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKTtcbiAgICBjci5hdHRyKFwieFwiLCAwKVxuICAgICAgLmF0dHIoXCJ5XCIsIDApXG4gICAgICAuYXR0cihcIndpZHRoXCIsIGRlZi53aWR0aClcbiAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGRlZi5oZWlnaHQpO1xuICB9KTtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgbWFya3MuY3VycmVudCA9IHRoaXM7XG5cbiAgaWYgKGl0ZW1zKSB7XG4gICAgdGhpcy5yZW5kZXJJdGVtcyhkbC5hcnJheShpdGVtcykpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZHJhdyh0aGlzLl9jdHgsIHNjZW5lLCAtMSk7XG4gIH1cbiAgdGhpcy51cGRhdGVEZWZzKCk7XG5cbiBkZWxldGUgbWFya3MuY3VycmVudDtcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJJdGVtcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIHZhciBpdGVtLCBub2RlLCB0eXBlLCBuZXN0LCBpLCBuO1xuXG4gIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgbm9kZSA9IGl0ZW0uX3N2ZztcbiAgICB0eXBlID0gaXRlbS5tYXJrLm1hcmt0eXBlO1xuXG4gICAgaXRlbSA9IG1hcmtzLm5lc3RlZFt0eXBlXSA/IGl0ZW0ubWFyay5pdGVtcyA6IGl0ZW07XG4gICAgbWFya3MudXBkYXRlW3R5cGVdLmNhbGwobm9kZSwgaXRlbSk7XG4gICAgbWFya3Muc3R5bGUuY2FsbChub2RlLCBpdGVtKTtcbiAgfVxufVxuXG5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgc2NlbmUsIGluZGV4KSB7XG4gIHZhciBtYXJrdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgcmVuZGVyZXIgPSBtYXJrcy5kcmF3W21hcmt0eXBlXTtcbiAgcmVuZGVyZXIuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBpbmRleCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKTtcblxuZnVuY3Rpb24geChvKSAgICAgeyByZXR1cm4gby54IHx8IDA7IH1cbmZ1bmN0aW9uIHkobykgICAgIHsgcmV0dXJuIG8ueSB8fCAwOyB9XG5mdW5jdGlvbiB5aChvKSAgICB7IHJldHVybiBvLnkgKyBvLmhlaWdodCB8fCAwOyB9XG5mdW5jdGlvbiBrZXkobykgICB7IHJldHVybiBvLmtleTsgfVxuZnVuY3Rpb24gc2l6ZShvKSAgeyByZXR1cm4gby5zaXplPT1udWxsID8gMTAwIDogby5zaXplOyB9XG5mdW5jdGlvbiBzaGFwZShvKSB7IHJldHVybiBvLnNoYXBlIHx8IFwiY2lyY2xlXCI7IH1cbiAgICBcbnZhciBhcmNfcGF0aCAgICA9IGQzLnN2Zy5hcmMoKSxcbiAgICBhcmVhX3BhdGggICA9IGQzLnN2Zy5hcmVhKCkueCh4KS55MSh5KS55MCh5aCksXG4gICAgbGluZV9wYXRoICAgPSBkMy5zdmcubGluZSgpLngoeCkueSh5KSxcbiAgICBzeW1ib2xfcGF0aCA9IGQzLnN2Zy5zeW1ib2woKS50eXBlKHNoYXBlKS5zaXplKHNpemUpO1xuXG52YXIgbWFya19pZCA9IDAsXG4gICAgY2xpcF9pZCA9IDA7XG5cbnZhciB0ZXh0QWxpZ24gPSB7XG4gIFwibGVmdFwiOiAgIFwic3RhcnRcIixcbiAgXCJjZW50ZXJcIjogXCJtaWRkbGVcIixcbiAgXCJyaWdodFwiOiAgXCJlbmRcIlxufTtcblxudmFyIHN0eWxlcyA9IHtcbiAgXCJmaWxsXCI6ICAgICAgICAgICAgIFwiZmlsbFwiLFxuICBcImZpbGxPcGFjaXR5XCI6ICAgICAgXCJmaWxsLW9wYWNpdHlcIixcbiAgXCJzdHJva2VcIjogICAgICAgICAgIFwic3Ryb2tlXCIsXG4gIFwic3Ryb2tlV2lkdGhcIjogICAgICBcInN0cm9rZS13aWR0aFwiLFxuICBcInN0cm9rZU9wYWNpdHlcIjogICAgXCJzdHJva2Utb3BhY2l0eVwiLFxuICBcInN0cm9rZUNhcFwiOiAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZURhc2hcIjogICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCIsXG4gIFwic3Ryb2tlRGFzaE9mZnNldFwiOiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gIFwib3BhY2l0eVwiOiAgICAgICAgICBcIm9wYWNpdHlcIlxufTtcbnZhciBzdHlsZVByb3BzID0gZGwua2V5cyhzdHlsZXMpO1xuXG5mdW5jdGlvbiBzdHlsZShkKSB7XG4gIHZhciBpLCBuLCBwcm9wLCBuYW1lLCB2YWx1ZSxcbiAgICAgIG8gPSBkLm1hcmsgPyBkIDogZC5sZW5ndGggPyBkWzBdIDogbnVsbDtcbiAgaWYgKG8gPT09IG51bGwpIHJldHVybjtcblxuICBmb3IgKGk9MCwgbj1zdHlsZVByb3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gc3R5bGVQcm9wc1tpXTtcbiAgICBuYW1lID0gc3R5bGVzW3Byb3BdO1xuICAgIHZhbHVlID0gb1twcm9wXTtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJmaWxsXCIpIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgXCJub25lXCIsIG51bGwpO1xuICAgICAgZWxzZSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgbWFya3MuY3VycmVudC5fZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBcInVybCgjXCIgKyB2YWx1ZS5pZCArIFwiKVwiO1xuICAgICAgfVxuICAgICAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZStcIlwiLCBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXJjKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIGFyY19wYXRoKG8pKTtcbn1cblxuZnVuY3Rpb24gYXJlYShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICBhcmVhX3BhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIGFyZWFfcGF0aChpdGVtcykpO1xufVxuXG5mdW5jdGlvbiBsaW5lKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIGxpbmVfcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgbGluZV9wYXRoKGl0ZW1zKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGgobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuICBpZiAoby5wYXRoICE9IG51bGwpIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBvLnBhdGgpO1xufVxuXG5mdW5jdGlvbiByZWN0KG8pIHtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4XCIsIG8ueCB8fCAwKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIG8ueSB8fCAwKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBvLndpZHRoIHx8IDApO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBvLmhlaWdodCB8fCAwKTtcbn1cblxuZnVuY3Rpb24gcnVsZShvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4MVwiLCB4MSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieTFcIiwgeTEpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIngyXCIsIG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieTJcIiwgby55MiAhPSBudWxsID8gby55MiA6IHkxKTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIHN5bWJvbF9wYXRoKG8pKTtcbn1cblxuZnVuY3Rpb24gaW1hZ2Uobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS53aWR0aCkgfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMCxcbiAgICAgIHggPSBvLnggLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IG8ueSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpLFxuICAgICAgdXJsID0gY29uZmlnLmJhc2VVUkwgKyBvLnVybDtcbiAgXG4gIHRoaXMuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsIFwiaHJlZlwiLCB1cmwpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInhcIiwgeCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCB5KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaCk7XG59XG4gIFxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG5mdW5jdGlvbiB0ZXh0KG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGR4ID0gby5keCB8fCAwLFxuICAgICAgZHkgPSBvLmR5IHx8IDAsXG4gICAgICBhID0gby5hbmdsZSB8fCAwLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBhbGlnbiA9IHRleHRBbGlnbltvLmFsaWduIHx8IFwibGVmdFwiXSxcbiAgICAgIGJhc2UgPSBvLmJhc2VsaW5lPT09XCJ0b3BcIiA/IFwiLjllbVwiXG4gICAgICAgICAgIDogby5iYXNlbGluZT09PVwibWlkZGxlXCIgPyBcIi4zNWVtXCIgOiAwO1xuXG4gIGlmIChyKSB7XG4gICAgdmFyIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCB4ICsgZHgpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgeSArIGR5KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLCBhbGlnbik7XG4gIFxuICBpZiAoYSkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoXCIrYStcIiBcIit4K1wiLFwiK3krXCIpXCIpO1xuICBlbHNlIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwidHJhbnNmb3JtXCIpO1xuICBcbiAgaWYgKGJhc2UpIHRoaXMuc2V0QXR0cmlidXRlKFwiZHlcIiwgYmFzZSk7XG4gIGVsc2UgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJkeVwiKTtcbiAgXG4gIHRoaXMudGV4dENvbnRlbnQgPSBvLnRleHQ7XG4gIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkoXCJmb250XCIsIGZvbnRTdHJpbmcobyksIG51bGwpO1xufVxuXG5mdW5jdGlvbiBncm91cChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG5cbiAgaWYgKG8uY2xpcCkge1xuICAgIHZhciBjID0ge3dpZHRoOiBvLndpZHRoIHx8IDAsIGhlaWdodDogby5oZWlnaHQgfHwgMH0sXG4gICAgICAgIGlkID0gby5jbGlwX2lkIHx8IChvLmNsaXBfaWQgPSBcImNsaXBcIiArIGNsaXBfaWQrKyk7XG4gICAgbWFya3MuY3VycmVudC5fZGVmcy5jbGlwcGluZ1tpZF0gPSBjO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKFwiY2xpcC1wYXRoXCIsIFwidXJsKCNcIitpZCtcIilcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ3JvdXBfYmcobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHcpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoKTtcbn1cblxuZnVuY3Rpb24gY3NzQ2xhc3MoZGVmKSB7XG4gIHZhciBjbHMgPSBcInR5cGUtXCIgKyBkZWYudHlwZTtcbiAgaWYgKGRlZi5uYW1lKSBjbHMgKz0gXCIgXCIgKyBkZWYubmFtZTtcbiAgcmV0dXJuIGNscztcbn1cblxuZnVuY3Rpb24gZHJhdyh0YWcsIGF0dHIsIG5lc3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBpbmRleCkge1xuICAgIGRyYXdNYXJrKGcsIHNjZW5lLCBpbmRleCwgXCJtYXJrX1wiLCB0YWcsIGF0dHIsIG5lc3QpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3TWFyayhnLCBzY2VuZSwgaW5kZXgsIHByZWZpeCwgdGFnLCBhdHRyLCBuZXN0KSB7XG4gIHZhciBkYXRhID0gbmVzdCA/IFtzY2VuZS5pdGVtc10gOiBzY2VuZS5pdGVtcyxcbiAgICAgIGV2dHMgPSBzY2VuZS5pbnRlcmFjdGl2ZT09PWZhbHNlID8gXCJub25lXCIgOiBudWxsLFxuICAgICAgZ3JwcyA9IGcubm9kZSgpLmNoaWxkTm9kZXMsXG4gICAgICBub3RHID0gKHRhZyAhPT0gXCJnXCIpLFxuICAgICAgcCA9IChwID0gZ3Jwc1tpbmRleCsxXSkgLy8gKzEgdG8gc2tpcCBncm91cCBiYWNrZ3JvdW5kIHJlY3RcbiAgICAgICAgPyBkMy5zZWxlY3QocClcbiAgICAgICAgOiBnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcImdcIisoKyttYXJrX2lkKSlcbiAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBjc3NDbGFzcyhzY2VuZS5kZWYpKTtcblxuICB2YXIgaWQgPSBwLmF0dHIoXCJpZFwiKSxcbiAgICAgIHMgPSBcIiNcIiArIGlkICsgXCIgPiBcIiArIHRhZyxcbiAgICAgIG0gPSBwLnNlbGVjdEFsbChzKS5kYXRhKGRhdGEpLFxuICAgICAgZSA9IG0uZW50ZXIoKS5hcHBlbmQodGFnKTtcblxuICBpZiAobm90Rykge1xuICAgIHAuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBldnRzKTtcbiAgICBlLmVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKGQubWFyaykgZC5fc3ZnID0gdGhpcztcbiAgICAgIGVsc2UgaWYgKGQubGVuZ3RoKSBkWzBdLl9zdmcgPSB0aGlzO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGUuYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiY2xhc3NcIixcImJhY2tncm91bmRcIikuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLGV2dHMpO1xuICB9XG4gIFxuICBtLmV4aXQoKS5yZW1vdmUoKTtcbiAgbS5lYWNoKGF0dHIpO1xuICBpZiAobm90RykgbS5lYWNoKHN0eWxlKTtcbiAgZWxzZSBwLnNlbGVjdEFsbChzK1wiID4gcmVjdC5iYWNrZ3JvdW5kXCIpLmVhY2goZ3JvdXBfYmcpLmVhY2goc3R5bGUpO1xuICBcbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGRyYXdHcm91cChnLCBzY2VuZSwgaW5kZXgsIHByZWZpeCkgeyAgICBcbiAgdmFyIHAgPSBkcmF3TWFyayhnLCBzY2VuZSwgaW5kZXgsIHByZWZpeCB8fCBcImdyb3VwX1wiLCBcImdcIiwgZ3JvdXApLFxuICAgICAgYyA9IHAubm9kZSgpLmNoaWxkTm9kZXMsIG4gPSBjLmxlbmd0aCwgaSwgaiwgbTtcbiAgXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHZhciBpdGVtcyA9IGNbaV0uX19kYXRhX18uaXRlbXMsXG4gICAgICAgIGxlZ2VuZHMgPSBjW2ldLl9fZGF0YV9fLmxlZ2VuZEl0ZW1zIHx8IFtdLFxuICAgICAgICBheGVzID0gY1tpXS5fX2RhdGFfXy5heGlzSXRlbXMgfHwgW10sXG4gICAgICAgIHNlbCA9IGQzLnNlbGVjdChjW2ldKSxcbiAgICAgICAgaWR4ID0gMDtcblxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyID09PSBcImJhY2tcIikge1xuICAgICAgICBkcmF3R3JvdXAuY2FsbCh0aGlzLCBzZWwsIGF4ZXNbal0sIGlkeCsrLCBcImF4aXNfXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICB0aGlzLmRyYXcoc2VsLCBpdGVtc1tqXSwgaWR4KyspO1xuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciAhPT0gXCJiYWNrXCIpIHtcbiAgICAgICAgZHJhd0dyb3VwLmNhbGwodGhpcywgc2VsLCBheGVzW2pdLCBpZHgrKywgXCJheGlzX1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBkcmF3R3JvdXAuY2FsbCh0aGlzLCBzZWwsIGxlZ2VuZHNbal0sIGlkeCsrLCBcImxlZ2VuZF9cIik7XG4gICAgfVxuICB9XG59XG5cbnZhciBtYXJrcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICB1cGRhdGU6IHtcbiAgICBncm91cDogICByZWN0LFxuICAgIGFyZWE6ICAgIGFyZWEsXG4gICAgbGluZTogICAgbGluZSxcbiAgICBhcmM6ICAgICBhcmMsXG4gICAgcGF0aDogICAgcGF0aCxcbiAgICBzeW1ib2w6ICBzeW1ib2wsXG4gICAgcmVjdDogICAgcmVjdCxcbiAgICBydWxlOiAgICBydWxlLFxuICAgIHRleHQ6ICAgIHRleHQsXG4gICAgaW1hZ2U6ICAgaW1hZ2VcbiAgfSxcbiAgbmVzdGVkOiB7XG4gICAgXCJhcmVhXCI6IHRydWUsXG4gICAgXCJsaW5lXCI6IHRydWVcbiAgfSxcbiAgc3R5bGU6IHN0eWxlLFxuICBkcmF3OiB7XG4gICAgZ3JvdXA6ICAgZHJhd0dyb3VwLFxuICAgIGFyZWE6ICAgIGRyYXcoXCJwYXRoXCIsIGFyZWEsIHRydWUpLFxuICAgIGxpbmU6ICAgIGRyYXcoXCJwYXRoXCIsIGxpbmUsIHRydWUpLFxuICAgIGFyYzogICAgIGRyYXcoXCJwYXRoXCIsIGFyYyksXG4gICAgcGF0aDogICAgZHJhdyhcInBhdGhcIiwgcGF0aCksXG4gICAgc3ltYm9sOiAgZHJhdyhcInBhdGhcIiwgc3ltYm9sKSxcbiAgICByZWN0OiAgICBkcmF3KFwicmVjdFwiLCByZWN0KSxcbiAgICBydWxlOiAgICBkcmF3KFwibGluZVwiLCBydWxlKSxcbiAgICB0ZXh0OiAgICBkcmF3KFwidGV4dFwiLCB0ZXh0KSxcbiAgICBpbWFnZTogICBkcmF3KFwiaW1hZ2VcIiwgaW1hZ2UpLFxuICAgIGRyYXc6ICAgIGRyYXcgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gIH0sXG4gIGN1cnJlbnQ6IG51bGxcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgRW5jb2RlciA9IHJlcXVpcmUoJy4vRW5jb2RlcicpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBCb3VuZGVyKGdyYXBoLCBtYXJrKSB7XG4gIHRoaXMuX21hcmsgPSBtYXJrO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKS5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChCb3VuZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJib3VuZHNcIiwgdGhpcy5fbWFyay5tYXJrdHlwZV0pO1xuICB2YXIgaSwgaWxlbiwgaiwgamxlbiwgZ3JvdXAsIGxlZ2VuZDtcbiAgICAgIGhhc0xlZ2VuZHMgPSB0aGlzLl9tYXJrLm1hcmt0eXBlID09IEMuR1JPVVAgXG4gICAgICAgICYmIGRsLmFycmF5KHRoaXMuX21hcmsuZGVmLmxlZ2VuZHMpLmxlbmd0aCA+IDA7XG5cbiAgYm91bmRzLm1hcmsodGhpcy5fbWFyaywgbnVsbCwgIWhhc0xlZ2VuZHMpO1xuXG4gIGlmKGhhc0xlZ2VuZHMpIHtcbiAgICBmb3IoaT0wLCBpbGVuPXRoaXMuX21hcmsuaXRlbXMubGVuZ3RoOyBpPGlsZW47ICsraSkge1xuICAgICAgZ3JvdXAgPSB0aGlzLl9tYXJrLml0ZW1zW2ldO1xuICAgICAgZ3JvdXAuX2xlZ2VuZFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBmb3Ioaj0wLCBqbGVuPWdyb3VwLmxlZ2VuZEl0ZW1zLmxlbmd0aDsgajxqbGVuOyArK2opIHtcbiAgICAgICAgbGVnZW5kID0gZ3JvdXAubGVnZW5kSXRlbXNbal07XG4gICAgICAgIEVuY29kZXIudXBkYXRlKHRoaXMuX2dyYXBoLCBpbnB1dC50cmFucywgXCJ2Z19sZWdlbmRQb3NpdGlvblwiLCBsZWdlbmQuaXRlbXMpO1xuICAgICAgICBib3VuZHMubWFyayhsZWdlbmQsIG51bGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvdW5kcy5tYXJrKHRoaXMuX21hcmssIG51bGwsIHRydWUpO1xuICB9XG5cbiAgaW5wdXQucmVmbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEVuY29kZXIgID0gcmVxdWlyZSgnLi9FbmNvZGVyJyksXG4gICAgQm91bmRlciAgPSByZXF1aXJlKCcuL0JvdW5kZXInKSxcbiAgICBJdGVtICA9IHJlcXVpcmUoJy4vSXRlbScpLFxuICAgIHBhcnNlRGF0YSA9IHJlcXVpcmUoJy4uL3BhcnNlL2RhdGEnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7ICAgIFxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbn1cblxudmFyIHByb3RvID0gKEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIHRoaXMuX2RlZiAgID0gZGVmO1xuICB0aGlzLl9tYXJrICA9IG1hcms7XG4gIHRoaXMuX2Zyb20gID0gKGRlZi5mcm9tID8gZGVmLmZyb20uZGF0YSA6IG51bGwpIHx8IGluaGVyaXRGcm9tO1xuICB0aGlzLl9kcyAgICA9IGRsLmlzU3RyaW5nKHRoaXMuX2Zyb20pID8gZ3JhcGguZGF0YSh0aGlzLl9mcm9tKSA6IG51bGw7XG4gIHRoaXMuX21hcCAgID0ge307XG5cbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAgLy8gU2hvdWxkIHNjZW5lZ3JhcGggaXRlbXMgdHJhY2sgX3ByZXY/XG5cbiAgbWFyay5kZWYgPSBkZWY7XG4gIG1hcmsubWFya3R5cGUgPSBkZWYudHlwZTtcbiAgbWFyay5pbnRlcmFjdGl2ZSA9ICEoZGVmLmludGVyYWN0aXZlID09PSBmYWxzZSk7XG4gIG1hcmsuaXRlbXMgPSBbXTtcblxuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX3BhcmVudF9pZCA9IHBhcmVudF9pZDtcblxuICBpZihkZWYuZnJvbSAmJiAoZGVmLmZyb20ubWFyayB8fCBkZWYuZnJvbS50cmFuc2Zvcm0gfHwgZGVmLmZyb20ubW9kaWZ5KSkge1xuICAgIGlubGluZURzLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBOb24tZ3JvdXAgbWFyayBidWlsZGVycyBhcmUgc3VwZXIgbm9kZXMuIEVuY29kZXIgYW5kIEJvdW5kZXIgcmVtYWluIFxuICAvLyBzZXBhcmF0ZSBvcGVyYXRvcnMgYnV0IGFyZSBlbWJlZGRlZCBhbmQgY2FsbGVkIGJ5IEJ1aWxkZXIuZXZhbHVhdGUuXG4gIHRoaXMuX2lzU3VwZXIgPSAodGhpcy5fZGVmLnR5cGUgIT09IEMuR1JPVVApOyBcbiAgdGhpcy5fZW5jb2RlciA9IG5ldyBFbmNvZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcbiAgdGhpcy5fYm91bmRlciA9IG5ldyBCb3VuZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcblxuICBpZih0aGlzLl9kcykgeyB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5EQVRBLCB0aGlzLl9mcm9tKTsgfVxuXG4gIC8vIFNpbmNlIEJ1aWxkZXJzIGFyZSBzdXBlciBub2RlcywgY29weSBvdmVyIGVuY29kZXIgZGVwZW5kZW5jaWVzXG4gIC8vIChib3VuZGVyIGhhcyBubyByZWdpc3RlcmVkIGRlcGVuZGVuY2llcykuXG4gIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLkRBVEEpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0NBTEVTLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5TQ0FMRVMpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0lHTkFMUykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKHApIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuXG4gIC8vIElmIHdlJ3ZlIG5vdCBuZWVkZWQgcHJldiBpbiB0aGUgcGFzdCwgYnV0IGEgbmV3IGlubGluZSBkcyBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIGl0ZW1zIGhhdmUgcHJldiBzZXQuXG4gIGlmKCF0aGlzLl9yZXZpc2VzICYmIHApIHtcbiAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfSk7XG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJlYWN0aXZlIGdlb21ldHJ5IGFuZCBtYXJrLWxldmVsIHRyYW5zZm9ybWF0aW9ucyBhcmUgaGFuZGxlZCBoZXJlIFxuLy8gYmVjYXVzZSB0aGV5IG5lZWQgdGhlaXIgZ3JvdXAncyBkYXRhLWpvaW5lZCBjb250ZXh0LiBcbmZ1bmN0aW9uIGlubGluZURzKCkge1xuICB2YXIgZnJvbSA9IHRoaXMuX2RlZi5mcm9tLFxuICAgICAgZ2VvbSA9IGZyb20ubWFyayxcbiAgICAgIHNyYywgbmFtZSwgc3BlYywgc2libGluZywgb3V0cHV0O1xuXG4gIGlmKGdlb20pIHtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fcGFyZW50X2lkLCBnZW9tXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sIFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3JjID0gdGhpcy5fZ3JhcGguZGF0YSh0aGlzLl9mcm9tKTtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGUsIHNyYy5saXN0ZW5lcnModHJ1ZSkubGVuZ3RoXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHNvdXJjZTogdGhpcy5fZnJvbSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sXG4gICAgICBtb2RpZnk6IGZyb20ubW9kaWZ5XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuX2Zyb20gPSBuYW1lO1xuICB0aGlzLl9kcyA9IHBhcnNlRGF0YS5kYXRhc291cmNlKHRoaXMuX2dyYXBoLCBzcGVjKTtcbiAgdmFyIHJldmlzZXMgPSB0aGlzLl9kcy5yZXZpc2VzKCk7XG5cbiAgaWYoZ2VvbSkge1xuICAgIHNpYmxpbmcgPSB0aGlzLnNpYmxpbmcoZ2VvbSkucmV2aXNlcyhyZXZpc2VzKTtcbiAgICBpZihzaWJsaW5nLl9pc1N1cGVyKSBzaWJsaW5nLmFkZExpc3RlbmVyKHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICAgIGVsc2Ugc2libGluZy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9kcy5saXN0ZW5lcigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGEgbmV3IGRhdGFzb3VyY2UgYnV0IGl0IGlzIGVtcHR5IGFzXG4gICAgLy8gdGhlIHByb3BhZ2F0aW9uIGN5Y2xlIGhhcyBhbHJlYWR5IGNyb3NzZWQgdGhlIGRhdGFzb3VyY2VzLiBcbiAgICAvLyBTbywgd2UgcmVwdWxzZSBqdXN0IHRoaXMgZGF0YXNvdXJjZS4gVGhpcyBzaG91bGQgYmUgc2FmZVxuICAgIC8vIGFzIHRoZSBkcyBpc24ndCBjb25uZWN0ZWQgdG8gdGhlIHNjZW5lZ3JhcGggeWV0LlxuICAgIFxuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9kcy5zb3VyY2UoKS5yZXZpc2VzKHJldmlzZXMpLmxhc3QoKTtcbiAgICAgICAgaW5wdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShvdXRwdXQpO1xuXG4gICAgaW5wdXQuYWRkID0gb3V0cHV0LmFkZDtcbiAgICBpbnB1dC5tb2QgPSBvdXRwdXQubW9kO1xuICAgIGlucHV0LnJlbSA9IG91dHB1dC5yZW07XG4gICAgaW5wdXQuc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShpbnB1dCwgdGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gIH1cbn1cblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QodGhpcy5waXBlbGluZSgpKTtcbiAgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0NBTEVTKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBidWlsZGVyLl9wYXJlbnQuc2NhbGUocykuYWRkTGlzdGVuZXIoYnVpbGRlcik7XG4gIH0pO1xuXG4gIGlmKHRoaXMuX3BhcmVudCkge1xuICAgIGlmKHRoaXMuX2lzU3VwZXIpIHRoaXMuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICAgIGVsc2UgdGhpcy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQuX2NvbGxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBpZighdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xuICB0aGlzLl9ncmFwaC5kaXNjb25uZWN0KHRoaXMucGlwZWxpbmUoKSk7XG4gIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNDQUxFUykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgYnVpbGRlci5fcGFyZW50LnNjYWxlKHMpLnJlbW92ZUxpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5zaWJsaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50LmNoaWxkKG5hbWUsIHRoaXMuX3BhcmVudF9pZCk7XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZ1wiLCB0aGlzLl9mcm9tLCB0aGlzLl9kZWYudHlwZV0pO1xuXG4gIHZhciBvdXRwdXQsIGZ1bGxVcGRhdGUsIGZjcywgZGF0YTtcblxuICBpZih0aGlzLl9kcykge1xuICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYW55IGVuY29kZXIgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBlbmNvZGVyJ3MgZGF0YSBzb3VyY2Ugd2lsbCBsaWtlbHkgYmUgdXBkYXRlZCwgYW5kIHNob3VsZG4ndFxuICAgIC8vIHRyaWdnZXIgYWxsIGl0ZW1zIHRvIG1vZC5cbiAgICBkYXRhID0gZGwuZHVwbGljYXRlKG91dHB1dC5kYXRhKTtcbiAgICBkZWxldGUgb3V0cHV0LmRhdGFbdGhpcy5fZHMubmFtZSgpXTtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LmRhdGEgPSBkYXRhO1xuXG4gICAgLy8gSWYgYSBzY2FsZSBvciBzaWduYWwgaW4gdGhlIHVwZGF0ZSBwcm9wc2V0IGhhcyBiZWVuIHVwZGF0ZWQsIFxuICAgIC8vIHNlbmQgZm9yd2FyZCBhbGwgaXRlbXMgZm9yIHJlZW5jb2RpbmcgaWYgd2UgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgIGlmKGZ1bGxVcGRhdGUpIG91dHB1dC5tb2QgPSB0aGlzLl9tYXJrLml0ZW1zLnNsaWNlKCk7XG5cbiAgICBmY3MgPSB0aGlzLl9kcy5sYXN0KCk7XG4gICAgaWYoIWZjcykge1xuICAgICAgb3V0cHV0LnJlZmxvdyA9IHRydWVcbiAgICB9IGVsc2UgaWYoZmNzLnN0YW1wID4gdGhpcy5fc3RhbXApIHtcbiAgICAgIG91dHB1dCA9IGpvaW5EYXRhc291cmNlLmNhbGwodGhpcywgZmNzLCB0aGlzLl9kcy52YWx1ZXMoKSwgZnVsbFVwZGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZ1bGxVcGRhdGUgPSB0aGlzLl9lbmNvZGVyLnJlZXZhbHVhdGUoaW5wdXQpO1xuICAgIGRhdGEgPSBkbC5pc0Z1bmN0aW9uKHRoaXMuX2RlZi5mcm9tKSA/IHRoaXMuX2RlZi5mcm9tKCkgOiBbQy5TRU5USU5FTF07XG4gICAgb3V0cHV0ID0gam9pblZhbHVlcy5jYWxsKHRoaXMsIGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKTtcbiAgfVxuXG4gIG91dHB1dCA9IHRoaXMuX2dyYXBoLmV2YWx1YXRlKG91dHB1dCwgdGhpcy5fZW5jb2Rlcik7XG4gIHJldHVybiB0aGlzLl9pc1N1cGVyID8gdGhpcy5fZ3JhcGguZXZhbHVhdGUob3V0cHV0LCB0aGlzLl9ib3VuZGVyKSA6IG91dHB1dDtcbn07XG5cbmZ1bmN0aW9uIG5ld0l0ZW0oKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQsXG4gICAgICBpdGVtID0gdHVwbGUuaW5nZXN0KG5ldyBJdGVtKHRoaXMuX21hcmspLCBwcmV2KTtcblxuICAvLyBGb3IgdGhlIHJvb3Qgbm9kZSdzIGl0ZW1cbiAgaWYodGhpcy5fZGVmLndpZHRoKSAgdHVwbGUuc2V0KGl0ZW0sIFwid2lkdGhcIiwgIHRoaXMuX2RlZi53aWR0aCk7XG4gIGlmKHRoaXMuX2RlZi5oZWlnaHQpIHR1cGxlLnNldChpdGVtLCBcImhlaWdodFwiLCB0aGlzLl9kZWYuaGVpZ2h0KTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBqb2luKGRhdGEsIGtleWYsIG5leHQsIG91dHB1dCwgcHJldiwgbW9kKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvcihpPTAsIGxlbj1kYXRhLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcbiAgICBpdGVtICA9IGtleWYgPyB0aGlzLl9tYXBba2V5ID0ga2V5ZihkYXR1bSldIDogcHJldltpXTtcbiAgICBlbnRlciA9IGl0ZW0gPyBmYWxzZSA6IChpdGVtID0gbmV3SXRlbS5jYWxsKHRoaXMpLCB0cnVlKTtcbiAgICBpdGVtLnN0YXR1cyA9IGVudGVyID8gQy5FTlRFUiA6IEMuVVBEQVRFO1xuICAgIGl0ZW0uZGF0dW0gPSBkYXR1bTtcbiAgICB0dXBsZS5zZXQoaXRlbSwgXCJrZXlcIiwga2V5KTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IGl0ZW07XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIGlmKGVudGVyKSBvdXRwdXQuYWRkLnB1c2goaXRlbSk7XG4gICAgZWxzZSBpZighbW9kIHx8IChtb2QgJiYgbW9kW2RhdHVtLl9pZF0pKSBvdXRwdXQubW9kLnB1c2goaXRlbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gam9pbkRhdGFzb3VyY2UoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkgfHwgXCJfaWRcIiksXG4gICAgICBhZGQgPSBpbnB1dC5hZGQsIFxuICAgICAgbW9kID0gaW5wdXQubW9kLCBcbiAgICAgIHJlbSA9IGlucHV0LnJlbSxcbiAgICAgIG5leHQgPSBbXSxcbiAgICAgIGksIGtleSwgbGVuLCBpdGVtLCBkYXR1bSwgZW50ZXI7XG5cbiAgLy8gQnVpbGQgcmVtcyBmaXJzdCwgYW5kIHB1dCB0aGVtIGF0IHRoZSBoZWFkIG9mIHRoZSBuZXh0IGl0ZW1zXG4gIC8vIFRoZW4gYnVpbGQgdGhlIHJlc3Qgb2YgdGhlIGRhdGEgdmFsdWVzICh3aGljaCB3b24ndCBjb250YWluIHJlbSkuXG4gIC8vIFRoaXMgd2lsbCBwcmVzZXJ2ZSB0aGUgc29ydCBvcmRlciB3aXRob3V0IG5lZWRpbmcgYW55dGhpbmcgZXh0cmEuXG5cbiAgZm9yKGk9MCwgbGVuPXJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gdGhpcy5fbWFwW2tleSA9IGtleWYocmVtW2ldKV07XG4gICAgaXRlbS5zdGF0dXMgPSBDLkVYSVQ7XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIG91dHB1dC5yZW0ucHVzaChpdGVtKTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IG51bGw7XG4gIH1cblxuICBqb2luLmNhbGwodGhpcywgZGF0YSwga2V5ZiwgbmV4dCwgb3V0cHV0LCBudWxsLCB0dXBsZS5pZE1hcChmdWxsVXBkYXRlID8gZGF0YSA6IG1vZCkpO1xuXG4gIHJldHVybiAodGhpcy5fbWFyay5pdGVtcyA9IG5leHQsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGpvaW5WYWx1ZXMoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkpLFxuICAgICAgcHJldiA9IHRoaXMuX21hcmsuaXRlbXMgfHwgW10sXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuRVhJVDtcbiAgICBpZiAoa2V5ZikgdGhpcy5fbWFwW2l0ZW0ua2V5XSA9IGl0ZW07XG4gIH1cbiAgXG4gIGpvaW4uY2FsbCh0aGlzLCBkYXRhLCBrZXlmLCBuZXh0LCBvdXRwdXQsIHByZXYsIGZ1bGxVcGRhdGUgPyB0dXBsZS5pZE1hcChkYXRhKSA6IG51bGwpO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkge1xuICAgICAgdHVwbGUuc2V0KGl0ZW0sIFwia2V5XCIsIGtleWYgPyBpdGVtLmtleSA6IHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICBuZXh0LnNwbGljZSgwLCAwLCBpdGVtKTsgIC8vIEtlZXAgaXRlbSBhcm91bmQgZm9yIFwiZXhpdFwiIHRyYW5zaXRpb24uXG4gICAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gKHRoaXMuX21hcmsuaXRlbXMgPSBuZXh0LCBvdXRwdXQpO1xufTtcblxuZnVuY3Rpb24ga2V5RnVuY3Rpb24oa2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBmID0gZGwuYXJyYXkoa2V5KS5tYXAoZGwuYWNjZXNzb3IpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIGZvciAodmFyIHM9XCJcIiwgaT0wLCBuPWYubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKGk+MCkgcyArPSBcInxcIjtcbiAgICAgIHMgKz0gU3RyaW5nKGZbaV0oZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEVNUFRZID0ge307XG5cbmZ1bmN0aW9uIEVuY29kZXIoZ3JhcGgsIG1hcmspIHtcbiAgdmFyIHByb3BzID0gbWFyay5kZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIHVwZGF0ZSA9IHByb3BzLnVwZGF0ZTtcblxuICBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpXG5cbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuXG4gIGlmKHVwZGF0ZSkge1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHVwZGF0ZS5kYXRhKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHVwZGF0ZS5zY2FsZXMpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIHVwZGF0ZS5zaWduYWxzKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5GSUVMRFMsIHVwZGF0ZS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChFbmNvZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJlbmNvZGluZ1wiLCB0aGlzLl9tYXJrLmRlZi50eXBlXSk7XG4gIHZhciBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgaXRlbXMgPSB0aGlzLl9tYXJrLml0ZW1zLFxuICAgICAgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgZW50ZXIgID0gcHJvcHMuZW50ZXIsXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGUsXG4gICAgICBleGl0ICAgPSBwcm9wcy5leGl0LFxuICAgICAgcHJlZHMgID0gdGhpcy5fZ3JhcGgucHJlZGljYXRlcygpLFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSwgIC8vIEZvciBleHBlZGllbmN5LCBnZXQgYWxsIHNpZ25hbCB2YWx1ZXNcbiAgICAgIGRiID0gZ3JhcGguZGF0YVZhbHVlcygpLCBcbiAgICAgIHJlcSA9IGlucHV0LnJlcXVlc3QsXG4gICAgICBpLCBsZW4sIGl0ZW0sIHByb3A7XG5cbiAgaWYocmVxKSB7XG4gICAgaWYocHJvcCA9IHByb3BzW3JlcV0pIHtcbiAgICAgIGZvcihpPTAsIGxlbj1pbnB1dC5tb2QubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICAgIGVuY29kZS5jYWxsKHRoaXMsIHByb3AsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7IC8vIGV4aXQgZWFybHkgaWYgZ2l2ZW4gcmVxdWVzdFxuICB9XG5cbiAgLy8gSXRlbXMgbWFya2VkIGZvciByZW1vdmFsIGFyZSBhdCB0aGUgaGVhZCBvZiBpdGVtcy4gUHJvY2VzcyB0aGVtIGZpcnN0LlxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5yZW1baV07XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpZihleGl0KSAgIGVuY29kZS5jYWxsKHRoaXMsIGV4aXQsICAgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpOyBcbiAgICBpZihpbnB1dC50cmFucyAmJiAhZXhpdCkgaW5wdXQudHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgRU1QVFkpO1xuICAgIGVsc2UgaWYoIWlucHV0LnRyYW5zKSBpdGVtLnJlbW92ZSgpO1xuICB9XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmKGVudGVyKSAgZW5jb2RlLmNhbGwodGhpcywgZW50ZXIsICBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcyk7XG4gICAgaWYodXBkYXRlKSBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuVVBEQVRFO1xuICB9XG5cbiAgaWYodXBkYXRlKSB7XG4gICAgZm9yKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpbnB1dC5tb2RbaV07XG4gICAgICBlbmNvZGUuY2FsbCh0aGlzLCB1cGRhdGUsIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBlbmNvZGUocHJvcCwgaXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMpIHtcbiAgdmFyIGVuYyA9IHByb3AuZW5jb2RlO1xuICBlbmMuY2FsbChlbmMsIGl0ZW0sIGl0ZW0ubWFyay5ncm91cHx8aXRlbSwgdHJhbnMsIGRiLCBzZywgcHJlZHMpO1xufVxuXG4vLyBJZiBhIHNwZWNpZmllZCBwcm9wZXJ0eSBzZXQgY2FsbGVkLCBvciB1cGRhdGUgcHJvcGVydHkgc2V0IFxuLy8gdXNlcyBuZXN0ZWQgZmllbGRyZWZzLCByZWV2YWx1YXRlIGFsbCBpdGVtcy5cbnByb3RvLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9tYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlO1xuXG4gIHJldHVybiBwdWxzZS5yZXF1ZXN0IHx8IFxuICAgIE5vZGUucHJvdG90eXBlLnJlZXZhbHVhdGUuY2FsbCh0aGlzLCBwdWxzZSkgfHwgXG4gICAgKHVwZGF0ZSA/IHVwZGF0ZS5yZWZsb3cgOiBmYWxzZSk7XG59O1xuXG4vLyBTaG9ydC1jaXJjdWl0IGVuY29kZXIgaWYgdXNlciBzcGVjaWZpZXMgaXRlbXNcbkVuY29kZXIudXBkYXRlID0gZnVuY3Rpb24oZ3JhcGgsIHRyYW5zLCByZXF1ZXN0LCBpdGVtcykge1xuICBpdGVtcyA9IGRsLmFycmF5KGl0ZW1zKTtcbiAgdmFyIHByZWRzID0gZ3JhcGgucHJlZGljYXRlcygpLCBcbiAgICAgIGRiID0gZ3JhcGguZGF0YVZhbHVlcygpLFxuICAgICAgc2cgPSBncmFwaC5zaWduYWxWYWx1ZXMoKSxcbiAgICAgIGksIGxlbiwgaXRlbSwgcHJvcHMsIHByb3A7XG5cbiAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgcHJvcHMgPSBpdGVtLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gICAgcHJvcCA9IHByb3BzICYmIHByb3BzW3JlcXVlc3RdO1xuICAgIGlmIChwcm9wKSB7XG4gICAgICBlbmNvZGUuY2FsbChudWxsLCBwcm9wLCBpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcyk7XG4gICAgICBib3VuZHMuaXRlbShpdGVtKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKSxcbiAgICBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBwYXJzZUF4ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9heGVzJyksXG4gICAgcGFyc2VMZWdlbmRzID0gcmVxdWlyZSgnLi4vcGFyc2UvbGVnZW5kcycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBHcm91cEJ1aWxkZXIoKSB7XG4gIHRoaXMuX2NoaWxkcmVuID0ge307XG4gIHRoaXMuX3NjYWxlciA9IG51bGw7XG4gIHRoaXMuX3JlY3Vyc29yID0gbnVsbDtcblxuICB0aGlzLl9zY2FsZXMgPSB7fTtcbiAgdGhpcy5zY2FsZSA9IHNjYWxlLmJpbmQodGhpcyk7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoR3JvdXBCdWlsZGVyLnByb3RvdHlwZSA9IG5ldyBCdWlsZGVyKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgsIGRlZiwgbWFyaywgcGFyZW50LCBwYXJlbnRfaWQsIGluaGVyaXRGcm9tKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcblxuICB0aGlzLl9zY2FsZXIgPSBuZXcgTm9kZShncmFwaCk7XG5cbiAgKGRlZi5zY2FsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgXG4gICAgcyA9IGJ1aWxkZXIuc2NhbGUocy5uYW1lLCBuZXcgU2NhbGUoZ3JhcGgsIHMsIGJ1aWxkZXIpKTtcbiAgICBidWlsZGVyLl9zY2FsZXIuYWRkTGlzdGVuZXIocyk7ICAvLyBTY2FsZXMgc2hvdWxkIGJlIGNvbXB1dGVkIGFmdGVyIGdyb3VwIGlzIGVuY29kZWRcbiAgfSk7XG5cbiAgdGhpcy5fcmVjdXJzb3IgPSBuZXcgTm9kZShncmFwaCk7XG4gIHRoaXMuX3JlY3Vyc29yLmV2YWx1YXRlID0gcmVjdXJzZS5iaW5kKHRoaXMpO1xuXG4gIHZhciBzY2FsZXMgPSAoZGVmLmF4ZXN8fFtdKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB4KSB7XG4gICAgcmV0dXJuIChhY2NbeC5zY2FsZV0gPSAxLCBhY2MpO1xuICB9LCB7fSk7XG5cbiAgc2NhbGVzID0gKGRlZi5sZWdlbmRzfHxbXSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiAoYWNjW3guc2l6ZSB8fCB4LnNoYXBlIHx8IHguZmlsbCB8fCB4LnN0cm9rZV0sIGFjYyk7XG4gIH0sIHNjYWxlcyk7XG5cbiAgdGhpcy5fcmVjdXJzb3IuZGVwZW5kZW5jeShDLlNDQUxFUywgZGwua2V5cyhzY2FsZXMpKTtcblxuICAvLyBXZSBvbmx5IG5lZWQgYSBjb2xsZWN0b3IgZm9yIHVwLXByb3BhZ2F0aW9uIG9mIGJvdW5kcyBjYWxjdWxhdGlvbixcbiAgLy8gc28gb25seSBHcm91cEJ1aWxkZXJzLCBhbmQgbm90IHJlZ3VsYXIgQnVpbGRlcnMsIGhhdmUgY29sbGVjdG9ycy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG5cbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IEJ1aWxkZXIucHJvdG90eXBlLmV2YWx1YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgYnVpbGRHcm91cC5jYWxsKGJ1aWxkZXIsIG91dHB1dCwgZ3JvdXApOyB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcywgdGhpcy5fc2NhbGVyLCB0aGlzLl9yZWN1cnNvciwgdGhpcy5fY29sbGVjdG9yLCB0aGlzLl9ib3VuZGVyXTtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBkbC5rZXlzKGJ1aWxkZXIuX2NoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwX2lkKSB7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXBfaWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7XG4gICAgfSlcbiAgfSk7XG5cbiAgYnVpbGRlci5fY2hpbGRyZW4gPSB7fTtcbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLmNoaWxkID0gZnVuY3Rpb24obmFtZSwgZ3JvdXBfaWQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bZ3JvdXBfaWRdLFxuICAgICAgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGNoaWxkO1xuXG4gIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmKGNoaWxkLnR5cGUgPT0gQy5NQVJLICYmIGNoaWxkLmJ1aWxkZXIuX2RlZi5uYW1lID09IG5hbWUpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkLmJ1aWxkZXI7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNlKGlucHV0KSB7XG4gIHZhciBidWlsZGVyID0gdGhpcyxcbiAgICAgIGhhc01hcmtzID0gZGwuYXJyYXkodGhpcy5fZGVmLm1hcmtzKS5sZW5ndGggPiAwLFxuICAgICAgaGFzQXhlcyA9IGRsLmFycmF5KHRoaXMuX2RlZi5heGVzKS5sZW5ndGggPiAwLFxuICAgICAgaGFzTGVnZW5kcyA9IGRsLmFycmF5KHRoaXMuX2RlZi5sZWdlbmRzKS5sZW5ndGggPiAwLFxuICAgICAgaSwgbGVuLCBncm91cCwgcGlwZWxpbmUsIGRlZiwgaW5saW5lID0gZmFsc2U7XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LmFkZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0LmFkZFtpXTtcbiAgICBpZihoYXNNYXJrcykgYnVpbGRNYXJrcy5jYWxsKHRoaXMsIGlucHV0LCBncm91cCk7XG4gICAgaWYoaGFzQXhlcykgIGJ1aWxkQXhlcy5jYWxsKHRoaXMsIGlucHV0LCBncm91cCk7XG4gICAgaWYoaGFzTGVnZW5kcykgYnVpbGRMZWdlbmRzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIFdpcmUgdXAgbmV3IGNoaWxkcmVuIGJ1aWxkZXJzIGluIHJldmVyc2UgdG8gbWluaW1pemUgZ3JhcGggcmV3cml0ZXMuXG4gIGZvciAoaT1pbnB1dC5hZGQubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGZvciAoaj10aGlzLl9jaGlsZHJlbltncm91cC5faWRdLmxlbmd0aC0xOyBqPj0wOyAtLWopIHtcbiAgICAgIGMgPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdW2pdO1xuICAgICAgYy5idWlsZGVyLmNvbm5lY3QoKTtcbiAgICAgIHBpcGVsaW5lID0gYy5idWlsZGVyLnBpcGVsaW5lKCk7XG4gICAgICBkZWYgPSBjLmJ1aWxkZXIuX2RlZjtcblxuICAgICAgLy8gVGhpcyBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYnVpbHQgZHVyaW5nIHRoaXMgcHJvcGFnYXRpb24gY3ljbGUuXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgaXRzIGJ1aWxkZXIgYXMgYSBsaXN0ZW5lciBvZmYgdGhlIF9yZWN1cnNvciBub2RlLCBcbiAgICAgIC8vIGJ1dCB0cnkgdG8gaW5saW5lIGl0IGlmIHdlIGNhbiB0byBtaW5pbWl6ZSBncmFwaCBkaXNwYXRjaGVzLlxuICAgICAgaW5saW5lID0gKGRlZi50eXBlICE9PSBDLkdST1VQKTtcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAodGhpcy5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQpOyBcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAocGlwZWxpbmVbcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpLmxlbmd0aCA9PSAxKTsgLy8gUmVhY3RpdmUgZ2VvbVxuICAgICAgYy5pbmxpbmUgPSBpbmxpbmU7XG5cbiAgICAgIGlmKGlubGluZSkgYy5idWlsZGVyLmV2YWx1YXRlKGlucHV0KTtcbiAgICAgIGVsc2UgdGhpcy5fcmVjdXJzb3IuYWRkTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQubW9kW2ldO1xuICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY29ubmVjdGlvbiBmb3IgbWFya3MgdGhhdCBkcmF3IGZyb20gYSBzb3VyY2VcbiAgICBpZihoYXNNYXJrcykge1xuICAgICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYoYy50eXBlID09IEMuTUFSSyAmJiAhYy5pbmxpbmUgJiYgYnVpbGRlci5fZ3JhcGguZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGF4ZXMgZGF0YSBkZWZzXG4gICAgaWYoaGFzQXhlcykge1xuICAgICAgcGFyc2VBeGVzKGJ1aWxkZXIuX2dyYXBoLCBidWlsZGVyLl9kZWYuYXhlcywgZ3JvdXAuYXhlcywgZ3JvdXApO1xuICAgICAgZ3JvdXAuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHsgYS5kZWYoKSB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgbGVnZW5kIGRhdGEgZGVmc1xuICAgIGlmKGhhc0xlZ2VuZHMpIHtcbiAgICAgIHBhcnNlTGVnZW5kcyhidWlsZGVyLl9ncmFwaCwgYnVpbGRlci5fZGVmLmxlZ2VuZHMsIGdyb3VwLmxlZ2VuZHMsIGdyb3VwKTtcbiAgICAgIGdyb3VwLmxlZ2VuZHMuZm9yRWFjaChmdW5jdGlvbihsLCBpKSB7IGwuZGVmKCkgfSk7XG4gICAgfSAgIFxuICB9XG5cbiAgZm9yKGk9MCwgbGVuPWlucHV0LnJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBncm91cCA9IGlucHV0LnJlbVtpXTtcbiAgICAvLyBGb3IgZGVsZXRlZCBncm91cHMsIGRpc2Nvbm5lY3QgdGhlaXIgY2hpbGRyZW5cbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLmZvckVhY2goZnVuY3Rpb24oYykgeyBcbiAgICAgIGJ1aWxkZXIuX3JlY3Vyc29yLnJlbW92ZUxpc3RlbmVyKGMuYnVpbGRlcik7XG4gICAgICBjLmJ1aWxkZXIuZGlzY29ubmVjdCgpOyBcbiAgICB9KTtcbiAgICBkZWxldGUgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXTtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmZ1bmN0aW9uIHNjYWxlKG5hbWUsIHNjYWxlKSB7XG4gIHZhciBncm91cCA9IHRoaXM7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHJldHVybiAoZ3JvdXAuX3NjYWxlc1tuYW1lXSA9IHNjYWxlLCBzY2FsZSk7XG4gIHdoaWxlKHNjYWxlID09IG51bGwpIHtcbiAgICBzY2FsZSA9IGdyb3VwLl9zY2FsZXNbbmFtZV07XG4gICAgZ3JvdXAgPSBncm91cC5tYXJrID8gZ3JvdXAubWFyay5ncm91cCA6IGdyb3VwLl9wYXJlbnQ7XG4gICAgaWYoIWdyb3VwKSBicmVhaztcbiAgfVxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkR3JvdXAoaW5wdXQsIGdyb3VwKSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZyBncm91cFwiLCBncm91cC5faWRdKTtcblxuICBncm91cC5fc2NhbGVzID0gZ3JvdXAuX3NjYWxlcyB8fCB7fTsgICAgXG4gIGdyb3VwLnNjYWxlICA9IHNjYWxlLmJpbmQoZ3JvdXApO1xuXG4gIGdyb3VwLml0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgW107XG4gIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdIHx8IFtdO1xuXG4gIGdyb3VwLmF4ZXMgPSBncm91cC5heGVzIHx8IFtdO1xuICBncm91cC5heGlzSXRlbXMgPSBncm91cC5heGlzSXRlbXMgfHwgW107XG5cbiAgZ3JvdXAubGVnZW5kcyA9IGdyb3VwLmxlZ2VuZHMgfHwgW107XG4gIGdyb3VwLmxlZ2VuZEl0ZW1zID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW107XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWFya3MoaW5wdXQsIGdyb3VwKSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZyBtYXJrc1wiLCBncm91cC5faWRdKTtcbiAgdmFyIG1hcmtzID0gdGhpcy5fZGVmLm1hcmtzLFxuICAgICAgbGlzdGVuZXJzID0gW10sXG4gICAgICBtYXJrLCBmcm9tLCBpbmhlcml0LCBpLCBsZW4sIG0sIGI7XG5cbiAgZm9yKGk9MCwgbGVuPW1hcmtzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG1hcmsgPSBtYXJrc1tpXTtcbiAgICBmcm9tID0gbWFyay5mcm9tIHx8IHt9O1xuICAgIGluaGVyaXQgPSBcInZnX1wiK2dyb3VwLmRhdHVtLl9pZDtcbiAgICBncm91cC5pdGVtc1tpXSA9IHtncm91cDogZ3JvdXB9O1xuICAgIGIgPSAobWFyay50eXBlID09PSBDLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KHRoaXMuX2dyYXBoLCBtYXJrLCBncm91cC5pdGVtc1tpXSwgdGhpcywgZ3JvdXAuX2lkLCBpbmhlcml0KTtcbiAgICB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBcbiAgICAgIGJ1aWxkZXI6IGIsIFxuICAgICAgZnJvbTogZnJvbS5kYXRhIHx8IChmcm9tLm1hcmsgPyAoXCJ2Z19cIiArIGdyb3VwLl9pZCArIFwiX1wiICsgZnJvbS5tYXJrKSA6IGluaGVyaXQpLCBcbiAgICAgIHR5cGU6IEMuTUFSSyBcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEF4ZXMoaW5wdXQsIGdyb3VwKSB7XG4gIHZhciBheGVzID0gZ3JvdXAuYXhlcyxcbiAgICAgIGF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHBhcnNlQXhlcyh0aGlzLl9ncmFwaCwgdGhpcy5fZGVmLmF4ZXMsIGF4ZXMsIGdyb3VwKTtcbiAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHtcbiAgICB2YXIgc2NhbGUgPSBidWlsZGVyLl9kZWYuYXhlc1tpXS5zY2FsZSxcbiAgICAgICAgZGVmID0gYS5kZWYoKSxcbiAgICAgICAgYiA9IG51bGw7XG5cbiAgICBheGlzSXRlbXNbaV0gPSB7Z3JvdXA6IGdyb3VwLCBheGlzRGVmOiBkZWZ9O1xuICAgIGIgPSAoZGVmLnR5cGUgPT09IEMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQoYnVpbGRlci5fZ3JhcGgsIGRlZiwgYXhpc0l0ZW1zW2ldLCBidWlsZGVyKVxuICAgICAgLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHNjYWxlKTtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBidWlsZGVyOiBiLCB0eXBlOiBDLkFYSVMsIHNjYWxlOiBzY2FsZSB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTGVnZW5kcyhpbnB1dCwgZ3JvdXApIHtcbiAgdmFyIGxlZ2VuZHMgPSBncm91cC5sZWdlbmRzLFxuICAgICAgbGVnZW5kSXRlbXMgPSBncm91cC5sZWdlbmRJdGVtcyxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHBhcnNlTGVnZW5kcyh0aGlzLl9ncmFwaCwgdGhpcy5fZGVmLmxlZ2VuZHMsIGxlZ2VuZHMsIGdyb3VwKTtcbiAgbGVnZW5kcy5mb3JFYWNoKGZ1bmN0aW9uKGwsIGkpIHtcbiAgICB2YXIgc2NhbGUgPSBsLnNpemUoKSB8fCBsLnNoYXBlKCkgfHwgbC5maWxsKCkgfHwgbC5zdHJva2UoKSxcbiAgICAgICAgZGVmID0gbC5kZWYoKSxcbiAgICAgICAgYiA9IG51bGw7XG5cbiAgICBsZWdlbmRJdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIGxlZ2VuZERlZjogZGVmfTtcbiAgICBiID0gKGRlZi50eXBlID09PSBDLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KGJ1aWxkZXIuX2dyYXBoLCBkZWYsIGxlZ2VuZEl0ZW1zW2ldLCBidWlsZGVyKVxuICAgICAgLmRlcGVuZGVuY3koQy5TQ0FMRVMsIHNjYWxlKTtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLnB1c2goeyBidWlsZGVyOiBiLCB0eXBlOiBDLkxFR0VORCwgc2NhbGU6IHNjYWxlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ1aWxkZXI7IiwiZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG59XG5cbnZhciBwcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmhhc1Byb3BlcnR5U2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gIHJldHVybiBwcm9wcyAmJiBwcm9wc1tuYW1lXSAhPSBudWxsO1xufTtcblxucHJvdG90eXBlLmNvdXNpbiA9IGZ1bmN0aW9uKG9mZnNldCwgaW5kZXgpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBncm91cCA9IG1hcmsuZ3JvdXAsXG4gICAgICBpaWR4ID0gaW5kZXg9PW51bGwgPyBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgOiBpbmRleCxcbiAgICAgIG1pZHggPSBncm91cC5pdGVtcy5pbmRleE9mKG1hcmspICsgb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXAuaXRlbXNbbWlkeF0uaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGlpZHggPSBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgKyBvZmZzZXQ7XG4gIHJldHVybiBtYXJrLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IHRoaXMsXG4gICAgICBsaXN0ID0gaXRlbS5tYXJrLml0ZW1zLFxuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGkgPj0gMCkgKGk9PT1saXN0Lmxlbmd0aC0xKSA/IGxpc3QucG9wKCkgOiBsaXN0LnNwbGljZShpLCAxKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGF0aENhY2hlKSB0aGlzLnBhdGhDYWNoZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hcmsucGF0aENhY2hlKSB0aGlzLm1hcmsucGF0aENhY2hlID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvQWdncmVnYXRlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIEdST1VQX1BST1BFUlRZID0ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9O1xuXG5mdW5jdGlvbiBTY2FsZShncmFwaCwgZGVmLCBwYXJlbnQpIHtcbiAgdGhpcy5fZGVmICAgICA9IGRlZjtcbiAgdGhpcy5fcGFyZW50ICA9IHBhcmVudDtcbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbn1cblxudmFyIHByb3RvID0gKFNjYWxlLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGZuID0gZnVuY3Rpb24oZ3JvdXApIHsgc2NhbGUuY2FsbChzZWxmLCBncm91cCk7IH07XG5cbiAgdGhpcy5fdXBkYXRlZCA9IGZhbHNlO1xuICBpbnB1dC5hZGQuZm9yRWFjaChmbik7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZuKTtcblxuICAvLyBTY2FsZXMgYXJlIGF0IHRoZSBlbmQgb2YgYW4gZW5jb2RpbmcgcGlwZWxpbmUsIHNvIHRoZXkgc2hvdWxkIGZvcndhcmQgYVxuICAvLyByZWZsb3cgcHVsc2UuIFRodXMsIGlmIG11bHRpcGxlIHNjYWxlcyB1cGRhdGUgaW4gdGhlIHBhcmVudCBncm91cCwgd2UgZG9uJ3RcbiAgLy8gcmVldmFsdWF0ZSBjaGlsZCBtYXJrcyBtdWx0aXBsZSB0aW1lcy4gXG4gIGlmICh0aGlzLl91cGRhdGVkKSBpbnB1dC5zY2FsZXNbdGhpcy5fZGVmLm5hbWVdID0gMTtcbiAgcmV0dXJuIGNoYW5nZXNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xufTtcblxuLy8gQWxsIG9mIGEgc2NhbGUncyBkZXBlbmRlbmNpZXMgYXJlIHJlZ2lzdGVyZWQgZHVyaW5nIHByb3BhZ2F0aW9uIGFzIHdlIHBhcnNlXG4vLyBkYXRhUmVmcy4gU28gYSBzY2FsZSBtdXN0IGJlIHJlc3BvbnNpYmxlIGZvciBjb25uZWN0aW5nIGl0c2VsZiB0byBkZXBlbmRlbnRzLlxucHJvdG8uZGVwZW5kZW5jeSA9IGZ1bmN0aW9uKHR5cGUsIGRlcHMpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgIGRlcHMgPSBkbC5hcnJheShkZXBzKTtcbiAgICBmb3IodmFyIGk9MCwgbGVuPWRlcHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9ncmFwaFt0eXBlID09IEMuREFUQSA/IEMuREFUQSA6IEMuU0lHTkFMXShkZXBzW2ldKVxuICAgICAgICAuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuZGVwZW5kZW5jeS5jYWxsKHRoaXMsIHR5cGUsIGRlcHMpO1xufTtcblxuZnVuY3Rpb24gc2NhbGUoZ3JvdXApIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9kZWYubmFtZSxcbiAgICAgIHByZXYgPSBuYW1lICsgXCI6cHJldlwiLFxuICAgICAgcyA9IGluc3RhbmNlLmNhbGwodGhpcywgZ3JvdXAuc2NhbGUobmFtZSkpLFxuICAgICAgbSA9IHMudHlwZT09PUMuT1JESU5BTCA/IG9yZGluYWwgOiBxdWFudGl0YXRpdmUsXG4gICAgICBybmcgPSByYW5nZS5jYWxsKHRoaXMsIGdyb3VwKTtcblxuICBtLmNhbGwodGhpcywgcywgcm5nLCBncm91cCk7XG5cbiAgZ3JvdXAuc2NhbGUobmFtZSwgcyk7XG4gIGdyb3VwLnNjYWxlKHByZXYsIGdyb3VwLnNjYWxlKHByZXYpIHx8IHMpO1xuXG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZShzY2FsZSkge1xuICB2YXIgdHlwZSA9IHRoaXMuX2RlZi50eXBlIHx8IEMuTElORUFSO1xuICBpZiAoIXNjYWxlIHx8IHR5cGUgIT09IHNjYWxlLnR5cGUpIHtcbiAgICB2YXIgY3RvciA9IGNvbmZpZy5zY2FsZVt0eXBlXSB8fCBkMy5zY2FsZVt0eXBlXTtcbiAgICBpZiAoIWN0b3IpIGRsLmVycm9yKFwiVW5yZWNvZ25pemVkIHNjYWxlIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgKHNjYWxlID0gY3RvcigpKS50eXBlID0gc2NhbGUudHlwZSB8fCB0eXBlO1xuICAgIHNjYWxlLnNjYWxlTmFtZSA9IHRoaXMuX2RlZi5uYW1lO1xuICAgIHNjYWxlLl9wcmV2ID0ge307XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBvcmRpbmFsKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkb21haW4sIHNvcnQsIHN0ciwgcmVmcywgZGF0YURyaXZlblJhbmdlID0gZmFsc2U7XG4gIFxuICAvLyByYW5nZSBwcmUtcHJvY2Vzc2luZyBmb3IgZGF0YS1kcml2ZW4gcmFuZ2VzXG4gIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpICYmICFkbC5pc0FycmF5KGRlZi5yYW5nZSkpIHtcbiAgICBkYXRhRHJpdmVuUmFuZ2UgPSB0cnVlO1xuICAgIHJuZyA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLlJBTkdFLCBkZWYucmFuZ2UsIHNjYWxlLCBncm91cCk7XG4gIH1cbiAgXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcblxuICBzdHIgPSB0eXBlb2Ygcm5nWzBdID09PSAnc3RyaW5nJztcbiAgaWYgKHN0ciB8fCBybmcubGVuZ3RoID4gMiB8fCBybmcubGVuZ3RoPT09MSB8fCBkYXRhRHJpdmVuUmFuZ2UpIHtcbiAgICBzY2FsZS5yYW5nZShybmcpOyAvLyBjb2xvciBvciBzaGFwZSB2YWx1ZXNcbiAgfSBlbHNlIGlmIChkZWYucG9pbnRzKSB7XG4gICAgc2NhbGUucmFuZ2VQb2ludHMocm5nLCBkZWYucGFkZGluZ3x8MCk7XG4gIH0gZWxzZSBpZiAoZGVmLnJvdW5kIHx8IGRlZi5yb3VuZD09PXVuZGVmaW5lZCkge1xuICAgIHNjYWxlLnJhbmdlUm91bmRCYW5kcyhybmcsIGRlZi5wYWRkaW5nfHwwKTtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZS5yYW5nZUJhbmRzKHJuZywgZGVmLnBhZGRpbmd8fDApO1xuICB9XG5cbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXRhdGl2ZShzY2FsZSwgcm5nLCBncm91cCkge1xuICB2YXIgZGVmID0gdGhpcy5fZGVmLFxuICAgICAgcHJldiA9IHNjYWxlLl9wcmV2LFxuICAgICAgZG9tYWluLCBpbnRlcnZhbDtcblxuICAvLyBkb21haW5cbiAgZG9tYWluID0gKGRlZi50eXBlID09PSBDLlFVQU5USUxFKVxuICAgID8gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOLCBkZWYuZG9tYWluLCBzY2FsZSwgZ3JvdXApXG4gICAgOiBkb21haW5NaW5NYXguY2FsbCh0aGlzLCBzY2FsZSwgZ3JvdXApO1xuICBpZiAoZG9tYWluICYmICFkbC5lcXVhbChwcmV2LmRvbWFpbiwgZG9tYWluKSkge1xuICAgIHNjYWxlLmRvbWFpbihkb21haW4pO1xuICAgIHByZXYuZG9tYWluID0gZG9tYWluO1xuICAgIHRoaXMuX3VwZGF0ZWQgPSB0cnVlO1xuICB9IFxuXG4gIC8vIHJhbmdlXG4gIC8vIHZlcnRpY2FsIHNjYWxlcyBzaG91bGQgZmxpcCBieSBkZWZhdWx0LCBzbyB1c2UgWE9SIGhlcmVcbiAgaWYgKGRlZi5yYW5nZSA9PT0gXCJoZWlnaHRcIikgcm5nID0gcm5nLnJldmVyc2UoKTtcbiAgaWYgKGRsLmVxdWFsKHByZXYucmFuZ2UsIHJuZykpIHJldHVybjtcbiAgc2NhbGVbZGVmLnJvdW5kICYmIHNjYWxlLnJhbmdlUm91bmQgPyBcInJhbmdlUm91bmRcIiA6IFwicmFuZ2VcIl0ocm5nKTtcbiAgcHJldi5yYW5nZSA9IHJuZztcbiAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG5cbiAgLy8gVE9ETzogU3VwcG9ydCBzaWduYWxzIGZvciB0aGVzZSBwcm9wZXJ0aWVzLiBVbnRpbCB0aGVuLCBvbmx5IGV2YWxcbiAgLy8gdGhlbSBvbmNlLlxuICBpZiAodGhpcy5fc3RhbXAgPiAwKSByZXR1cm47XG4gIGlmIChkZWYuZXhwb25lbnQgJiYgZGVmLnR5cGU9PT1DLlBPV0VSKSBzY2FsZS5leHBvbmVudChkZWYuZXhwb25lbnQpO1xuICBpZiAoZGVmLmNsYW1wKSBzY2FsZS5jbGFtcCh0cnVlKTtcbiAgaWYgKGRlZi5uaWNlKSB7XG4gICAgaWYgKGRlZi50eXBlID09PSBDLlRJTUUpIHtcbiAgICAgIGludGVydmFsID0gZDMudGltZVtkZWYubmljZV07XG4gICAgICBpZiAoIWludGVydmFsKSBkbC5lcnJvcihcIlVucmVjb2duaXplZCBpbnRlcnZhbDogXCIgKyBpbnRlcnZhbCk7XG4gICAgICBzY2FsZS5uaWNlKGludGVydmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUubmljZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhUmVmKHdoaWNoLCBkZWYsIHNjYWxlLCBncm91cCkge1xuICBpZiAoZGVmID09IG51bGwpIHsgcmV0dXJuIFtdOyB9XG4gIGlmIChkbC5pc0FycmF5KGRlZikpIHJldHVybiBkZWYubWFwKHNpZ25hbC5iaW5kKHRoaXMpKTtcblxuICB2YXIgc2VsZiA9IHRoaXMsIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICByZWZzID0gZGVmLmZpZWxkcyB8fCBkbC5hcnJheShkZWYpLFxuICAgICAgdW5pcXVlcyA9IHNjYWxlLnR5cGUgPT09IEMuT1JESU5BTCB8fCBzY2FsZS50eXBlID09PSBDLlFVQU5USUxFLFxuICAgICAgY2sgPSBcIl9cIit3aGljaCxcbiAgICAgIGNhY2hlID0gc2NhbGVbY2tdLFxuICAgICAgY2FjaGVGaWVsZCA9IHtvcHM6IFtdfSwgIC8vIHRoZSBmaWVsZCBhbmQgbWVhc3VyZXMgaW4gdGhlIGFnZ3JlZ2F0b3JcbiAgICAgIHNvcnQgPSBkZWYuc29ydCxcbiAgICAgIGksIHJsZW4sIGosIGZsZW4sIHIsIGZpZWxkcywgZnJvbSwgZGF0YSwga2V5cztcblxuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBzY2FsZVtja10gPSBuZXcgQWdncmVnYXRlKGdyYXBoKTtcbiAgICBjYWNoZUZpZWxkLm9wcyA9IFtdO1xuICAgIGNhY2hlLnNpbmdsZXRvbih0cnVlKTtcbiAgICBpZiAodW5pcXVlcyAmJiBzb3J0KSBjYWNoZUZpZWxkLm9wcy5wdXNoKHNvcnQuc3RhdCk7XG4gIH1cblxuICBmb3IoaT0wLCBybGVuPXJlZnMubGVuZ3RoOyBpPHJsZW47ICsraSkge1xuICAgIHIgPSByZWZzW2ldO1xuICAgIGZyb20gPSByLmRhdGEgfHwgXCJ2Z19cIitncm91cC5kYXR1bS5faWQ7XG4gICAgZGF0YSA9IGdyYXBoLmRhdGEoZnJvbSlcbiAgICAgIC5yZXZpc2VzKHRydWUpXG4gICAgICAubGFzdCgpO1xuXG4gICAgaWYgKGRhdGEuc3RhbXAgPD0gdGhpcy5fc3RhbXApIGNvbnRpbnVlO1xuXG4gICAgZmllbGRzID0gZGwuYXJyYXkoci5maWVsZCkubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICAgIGlmIChmLnBhcmVudCkgcmV0dXJuIGRsLmFjY2Vzc29yKGYucGFyZW50KShncm91cC5kYXR1bSlcbiAgICAgIHJldHVybiBmOyAvLyBTdHJpbmcgb3Ige1wic2lnbmFsXCJ9XG4gICAgfSk7XG5cbiAgICBpZiAodW5pcXVlcykge1xuICAgICAgY2FjaGVGaWVsZC5uYW1lID0gc29ydCA/IHNvcnQuZmllbGQgOiBcIl9pZFwiO1xuICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKTtcbiAgICAgIGZvciAoaj0wLCBmbGVuPWZpZWxkcy5sZW5ndGg7IGo8ZmxlbjsgKytqKSB7XG4gICAgICAgIGNhY2hlLmdyb3VwX2J5LnNldChjYWNoZSwgZmllbGRzW2pdKVxuICAgICAgICAgIC5ldmFsdWF0ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqPTAsIGZsZW49ZmllbGRzLmxlbmd0aDsgajxmbGVuOyArK2opIHtcbiAgICAgICAgY2FjaGVGaWVsZC5uYW1lID0gZmllbGRzW2pdO1xuICAgICAgICBjYWNoZUZpZWxkLm9wcyAgPSBbQy5NSU4sIEMuTUFYXTtcbiAgICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKSAvLyBUcmVhdCBhcyBmbGF0IGRhdGFzb3VyY2VcbiAgICAgICAgICAuZXZhbHVhdGUoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuREFUQSwgZnJvbSk7XG4gICAgY2FjaGUuZGVwZW5kZW5jeShDLlNJR05BTFMpLmZvckVhY2goZnVuY3Rpb24ocykgeyBzZWxmLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzKSB9KTtcbiAgfVxuXG4gIGRhdGEgPSBjYWNoZS5kYXRhKCk7XG4gIGlmICh1bmlxdWVzKSB7XG4gICAga2V5cyA9IGRsLmtleXMoZGF0YSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaykgeyByZXR1cm4gZGF0YVtrXSAhPSBudWxsOyB9KTtcblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBzb3J0ID0gc29ydC5vcmRlci5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoc29ydC5vcmRlci5zaWduYWwpIDogc29ydC5vcmRlcjtcbiAgICAgIHNvcnQgPSAoc29ydCA9PSBDLkRFU0MgPyBcIi1cIiA6IFwiK1wiKSArIFwidHBsLlwiICsgY2FjaGVGaWVsZC5uYW1lO1xuICAgICAgc29ydCA9IGRsLmNvbXBhcmF0b3Ioc29ydCk7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4geyBrZXk6IGssIHRwbDogZGF0YVtrXS50cGwgfX0pXG4gICAgICAgIC5zb3J0KHNvcnQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gay5rZXk7IH0pO1xuICAgIC8vIH0gZWxzZSB7ICAvLyBcIkZpcnN0IHNlZW5cIiBvcmRlclxuICAgIC8vICAgc29ydCA9IGRsLmNvbXBhcmF0b3IoXCJ0cGwuX2lkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBkYXRhW1wiXCJdOyAvLyBVbnBhY2sgZmxhdCBhZ2dyZWdhdGlvblxuICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCkgPyBbXSA6IFtkYXRhW0MuU0lOR0xFVE9OXS5taW4sIGRhdGFbQy5TSU5HTEVUT05dLm1heF07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lnbmFsKHYpIHtcbiAgdmFyIHMgPSB2LnNpZ25hbCwgcmVmO1xuICBpZiAoIXMpIHJldHVybiB2O1xuICB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTLCAocmVmID0gZGwuZmllbGQocykpWzBdKTtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoLnNpZ25hbFJlZihyZWYpO1xufVxuXG5mdW5jdGlvbiBkb21haW5NaW5NYXgoc2NhbGUsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBkb21haW4gPSBbbnVsbCwgbnVsbF0sIHJlZnMsIHo7XG5cbiAgaWYgKGRlZi5kb21haW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGRvbWFpbiA9ICghZGwuaXNPYmplY3QoZGVmLmRvbWFpbikpID8gZG9tYWluIDpcbiAgICAgIGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuXG4gIHogPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgaWYgKGRlZi5kb21haW5NaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5pc09iamVjdChkZWYuZG9tYWluTWluKSkge1xuICAgICAgaWYgKGRlZi5kb21haW5NaW4uc2lnbmFsKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5kb21haW5NaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluWzBdID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOK0MuTUlOLCBkZWYuZG9tYWluTWluLCBzY2FsZSwgZ3JvdXApWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW5bMF0gPSBkZWYuZG9tYWluTWluO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLmRvbWFpbk1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NYXgpKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1heC5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluW3pdID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1heCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bel0gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4rQy5NQVgsIGRlZi5kb21haW5NYXgsIHNjYWxlLCBncm91cClbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblt6XSA9IGRlZi5kb21haW5NYXg7XG4gICAgfVxuICB9XG4gIGlmIChkZWYudHlwZSAhPT0gQy5MT0cgJiYgZGVmLnR5cGUgIT09IEMuVElNRSAmJiAoZGVmLnplcm8gfHwgZGVmLnplcm89PT11bmRlZmluZWQpKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oMCwgZG9tYWluWzBdKTtcbiAgICBkb21haW5bel0gPSBNYXRoLm1heCgwLCBkb21haW5bel0pO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHJhbmdlKGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBybmcgPSBbbnVsbCwgbnVsbF07XG5cbiAgaWYgKGRlZi5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYucmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoR1JPVVBfUFJPUEVSVFlbZGVmLnJhbmdlXSkge1xuICAgICAgICBybmcgPSBbMCwgZ3JvdXBbZGVmLnJhbmdlXV07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdKSB7XG4gICAgICAgIHJuZyA9IGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGwuZXJyb3IoXCJVbnJlY29naXplZCByYW5nZTogXCIrZGVmLnJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgICAgcm5nID0gZGVmLnJhbmdlLm1hcChzaWduYWwuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZWFybHkgZXhpdFxuICAgIH0gZWxzZSB7XG4gICAgICBybmcgPSBbMCwgZGVmLnJhbmdlXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nWzBdID0gZGVmLnJhbmdlTWluLnNpZ25hbCA/IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZU1pbikgOiBkZWYucmFuZ2VNaW47XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nW3JuZy5sZW5ndGgtMV0gPSBkZWYucmFuZ2VNYXguc2lnbmFsID8gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWF4KSA6IGRlZi5yYW5nZU1heDtcbiAgfVxuICBcbiAgaWYgKGRlZi5yZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmV2ID0gZGVmLnJldmVyc2U7XG4gICAgaWYgKGRsLmlzT2JqZWN0KHJldikpIHtcbiAgICAgIHJldiA9IGRsLmFjY2Vzc29yKHJldi5maWVsZCkoZ3JvdXAuZGF0dW0pO1xuICAgIH1cbiAgICBpZiAocmV2KSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICB9XG4gIFxuICByZXR1cm4gcm5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlOyIsInZhciB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgYm91bmRzQ2FsYyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzY2FsYycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBUcmFuc2l0aW9uKGR1cmF0aW9uLCBlYXNlKSB7XG4gIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbiB8fCA1MDA7XG4gIHRoaXMuZWFzZSA9IGVhc2UgJiYgZDMuZWFzZShlYXNlKSB8fCBkMy5lYXNlKFwiY3ViaWMtaW4tb3V0XCIpO1xuICB0aGlzLnVwZGF0ZXMgPSB7bmV4dDogbnVsbH07XG59XG5cbnZhciBwcm90b3R5cGUgPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxudmFyIHNraXAgPSB7XG4gIFwidGV4dFwiOiAxLFxuICBcInVybFwiOiAgMVxufTtcblxucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24oaXRlbSwgdmFsdWVzLCBzdGFtcCkge1xuICB2YXIga2V5LCBjdXJyLCBuZXh0LCBpbnRlcnAsIGxpc3QgPSBudWxsO1xuXG4gIGZvciAoa2V5IGluIHZhbHVlcykge1xuICAgIGN1cnIgPSBpdGVtW2tleV07XG4gICAgbmV4dCA9IHZhbHVlc1trZXldOyAgICAgIFxuICAgIGlmIChjdXJyICE9PSBuZXh0KSB7XG4gICAgICBpZiAoc2tpcFtrZXldIHx8IGN1cnIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBza2lwIGludGVycG9sYXRpb24gZm9yIHNwZWNpZmljIGtleXMgb3IgdW5kZWZpbmVkIHN0YXJ0IHZhbHVlc1xuICAgICAgICB0dXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGN1cnIgPT09IFwibnVtYmVyXCIgJiYgIWlzRmluaXRlKGN1cnIpKSB7XG4gICAgICAgIC8vIGZvciBOYU4gb3IgaW5maW5pdGUgbnVtZXJpYyB2YWx1ZXMsIHNraXAgdG8gZmluYWwgdmFsdWVcbiAgICAgICAgdHVwbGUuc2V0KGl0ZW0sIGtleSwgbmV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2UgbG9va3VwIGludGVycG9sYXRvclxuICAgICAgICBpbnRlcnAgPSBkMy5pbnRlcnBvbGF0ZShjdXJyLCBuZXh0KTtcbiAgICAgICAgaW50ZXJwLnByb3BlcnR5ID0ga2V5O1xuICAgICAgICAobGlzdCB8fCAobGlzdD1bXSkpLnB1c2goaW50ZXJwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobGlzdCA9PT0gbnVsbCAmJiBpdGVtLnN0YXR1cyA9PT0gQy5FWElUKSB7XG4gICAgbGlzdCA9IFtdOyAvLyBlbnN1cmUgZXhpdGluZyBpdGVtcyBhcmUgaW5jbHVkZWRcbiAgfVxuXG4gIGlmIChsaXN0ICE9IG51bGwpIHtcbiAgICBsaXN0Lml0ZW0gPSBpdGVtO1xuICAgIGxpc3QuZWFzZSA9IGl0ZW0ubWFyay5lYXNlIHx8IHRoaXMuZWFzZTtcbiAgICBsaXN0Lm5leHQgPSB0aGlzLnVwZGF0ZXMubmV4dDtcbiAgICB0aGlzLnVwZGF0ZXMubmV4dCA9IGxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgdCA9IHRoaXMsIHByZXYgPSB0LnVwZGF0ZXMsIGN1cnIgPSBwcmV2Lm5leHQ7XG4gIGZvciAoOyBjdXJyIT1udWxsOyBwcmV2PWN1cnIsIGN1cnI9cHJldi5uZXh0KSB7XG4gICAgaWYgKGN1cnIuaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkgY3Vyci5yZW1vdmUgPSB0cnVlO1xuICB9XG4gIHQuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgZDMudGltZXIoZnVuY3Rpb24oZWxhcHNlZCkgeyByZXR1cm4gc3RlcC5jYWxsKHQsIGVsYXBzZWQpOyB9KTtcbn07XG5cbmZ1bmN0aW9uIHN0ZXAoZWxhcHNlZCkge1xuICB2YXIgbGlzdCA9IHRoaXMudXBkYXRlcywgcHJldiA9IGxpc3QsIGN1cnIgPSBwcmV2Lm5leHQsXG4gICAgICBkdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24sXG4gICAgICBpdGVtLCBkZWxheSwgZiwgZSwgaSwgbiwgc3RvcCA9IHRydWU7XG5cbiAgZm9yICg7IGN1cnIhPW51bGw7IHByZXY9Y3VyciwgY3Vycj1wcmV2Lm5leHQpIHtcbiAgICBpdGVtID0gY3Vyci5pdGVtO1xuICAgIGRlbGF5ID0gaXRlbS5kZWxheSB8fCAwO1xuXG4gICAgZiA9IChlbGFwc2VkIC0gZGVsYXkpIC8gZHVyYXRpb247XG4gICAgaWYgKGYgPCAwKSB7IHN0b3AgPSBmYWxzZTsgY29udGludWU7IH1cbiAgICBpZiAoZiA+IDEpIGYgPSAxO1xuICAgIGUgPSBjdXJyLmVhc2UoZik7XG5cbiAgICBmb3IgKGk9MCwgbj1jdXJyLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGl0ZW1bY3VycltpXS5wcm9wZXJ0eV0gPSBjdXJyW2ldKGUpO1xuICAgIH1cbiAgICBpdGVtLnRvdWNoKCk7XG4gICAgYm91bmRzQ2FsYy5pdGVtKGl0ZW0pO1xuXG4gICAgaWYgKGYgPT09IDEpIHtcbiAgICAgIGlmIChjdXJyLnJlbW92ZSkgaXRlbS5yZW1vdmUoKTtcbiAgICAgIHByZXYubmV4dCA9IGN1cnIubmV4dDtcbiAgICAgIGN1cnIgPSBwcmV2O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5jYWxsYmFjaygpO1xuICByZXR1cm4gc3RvcDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbjsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIHRwbCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgcGFyc2VNYXJrID0gcmVxdWlyZSgnLi4vcGFyc2UvbWFyaycpO1xuXG5mdW5jdGlvbiBheHMobW9kZWwpIHtcbiAgdmFyIHNjYWxlLFxuICAgICAgb3JpZW50ID0gY29uZmlnLmF4aXMub3JpZW50LFxuICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgIHRpdGxlT2Zmc2V0ID0gY29uZmlnLmF4aXMudGl0bGVPZmZzZXQsXG4gICAgICBheGlzRGVmID0ge30sXG4gICAgICBsYXllciA9IFwiZnJvbnRcIixcbiAgICAgIGdyaWQgPSBmYWxzZSxcbiAgICAgIHRpdGxlID0gbnVsbCxcbiAgICAgIHRpY2tNYWpvclNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tNaW5vclNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tFbmRTaXplID0gY29uZmlnLmF4aXMudGlja1NpemUsXG4gICAgICB0aWNrUGFkZGluZyA9IGNvbmZpZy5heGlzLnBhZGRpbmcsXG4gICAgICB0aWNrVmFsdWVzID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXRTdHJpbmcgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXG4gICAgICB0aWNrU3ViZGl2aWRlID0gMCxcbiAgICAgIHRpY2tBcmd1bWVudHMgPSBbY29uZmlnLmF4aXMudGlja3NdLFxuICAgICAgZ3JpZExpbmVTdHlsZSA9IHt9LFxuICAgICAgdGlja0xhYmVsU3R5bGUgPSB7fSxcbiAgICAgIG1ham9yVGlja1N0eWxlID0ge30sXG4gICAgICBtaW5vclRpY2tTdHlsZSA9IHt9LFxuICAgICAgdGl0bGVTdHlsZSA9IHt9LFxuICAgICAgZG9tYWluU3R5bGUgPSB7fSxcbiAgICAgIG0gPSB7IC8vIEF4aXMgbWFya3MgYXMgcmVmZXJlbmNlcyBmb3IgdXBkYXRlc1xuICAgICAgICBncmlkTGluZXM6ICBudWxsLFxuICAgICAgICBtYWpvclRpY2tzOiBudWxsLFxuICAgICAgICBtaW5vclRpY2tzOiBudWxsLFxuICAgICAgICB0aWNrTGFiZWxzOiBudWxsLFxuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIHRpdGxlOiAgbnVsbFxuICAgICAgfTtcblxuICB2YXIgYXhpcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGF4aXNEZWYudHlwZSA9IG51bGw7XG4gIH07XG5cbiAgYXhpcy5kZWYgPSBmdW5jdGlvbigpIHtcbiAgICBpZighYXhpc0RlZi50eXBlKSBheGlzX2RlZihzY2FsZSk7XG5cbiAgICAvLyB0aWNrIGZvcm1hdFxuICAgIHRpY2tGb3JtYXQgPSAhdGlja0Zvcm1hdFN0cmluZyA/IG51bGwgOiAoKHNjYWxlLnR5cGUgPT09ICd0aW1lJylcbiAgICAgID8gZDMudGltZS5mb3JtYXQodGlja0Zvcm1hdFN0cmluZylcbiAgICAgIDogZDMuZm9ybWF0KHRpY2tGb3JtYXRTdHJpbmcpKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICAvLyBXZSBkb24ndCBfcmVhbGx5XyBuZWVkIHRvIG1vZGVsIHRoZXNlIGFzIHR1cGxlcyBhcyBubyBmdXJ0aGVyXG4gICAgLy8gZGF0YSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLiBTbyB3ZSBvcHRpbWl6ZSBmb3IgYSBoaWdoIGNodXJuIHJhdGUuIFxuICAgIHZhciBpbmplc3QgPSBmdW5jdGlvbihkKSB7IHJldHVybiB7ZGF0YTogZH07IH07XG4gICAgdmFyIG1ham9yID0gdGlja1ZhbHVlcyA9PSBudWxsXG4gICAgICA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKVxuICAgICAgOiB0aWNrVmFsdWVzO1xuICAgIHZhciBtaW5vciA9IHZnX2F4aXNTdWJkaXZpZGUoc2NhbGUsIG1ham9yLCB0aWNrU3ViZGl2aWRlKS5tYXAoaW5qZXN0KTtcbiAgICBtYWpvciA9IG1ham9yLm1hcChpbmplc3QpO1xuICAgIHZhciBmbXQgPSB0aWNrRm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiB0aWNrRm9ybWF0O1xuICAgIG1ham9yLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkLmxhYmVsID0gZm10KGQuZGF0YSk7IH0pO1xuICAgIHZhciB0ZGF0YSA9IHRpdGxlID8gW3RpdGxlXS5tYXAoaW5qZXN0KSA6IFtdO1xuXG4gICAgYXhpc0RlZi5tYXJrc1swXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBncmlkID8gbWFqb3IgOiBbXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1ham9yOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWlub3I7IH07XG4gICAgYXhpc0RlZi5tYXJrc1szXS5mcm9tID0gYXhpc0RlZi5tYXJrc1sxXS5mcm9tO1xuICAgIGF4aXNEZWYubWFya3NbNF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gWzFdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbNV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgYXhpc0RlZi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgYXhpc0RlZi5vcmllbnQgPSBvcmllbnQ7XG4gICAgYXhpc0RlZi5sYXllciA9IGxheWVyO1xuICAgIHJldHVybiBheGlzRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGF4aXNfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgc2NhbGUgbWFwcGluZ1xuICAgIHZhciBuZXdTY2FsZSwgb2xkU2NhbGUsIHJhbmdlO1xuICAgIGlmIChzY2FsZS50eXBlID09PSBcIm9yZGluYWxcIikge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjUgKyBzY2FsZS5yYW5nZUJhbmQoKS8yfTtcbiAgICAgIG9sZFNjYWxlID0gbmV3U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUsIG9mZnNldDogMC41fTtcbiAgICAgIG9sZFNjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUrXCI6cHJldlwiLCBvZmZzZXQ6IDAuNX07XG4gICAgfVxuICAgIHJhbmdlID0gdmdfYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpO1xuXG4gICAgLy8gc2V0dXAgYXhpcyBtYXJrc1xuICAgIGlmICghbS5ncmlkTGluZXMpICBtLmdyaWRMaW5lcyAgPSB2Z19heGlzVGlja3MoKTtcbiAgICBpZiAoIW0ubWFqb3JUaWNrcykgbS5tYWpvclRpY2tzID0gdmdfYXhpc1RpY2tzKCk7XG4gICAgaWYgKCFtLm1pbm9yVGlja3MpIG0ubWlub3JUaWNrcyA9IHZnX2F4aXNUaWNrcygpO1xuICAgIGlmICghbS50aWNrTGFiZWxzKSBtLnRpY2tMYWJlbHMgPSB2Z19heGlzVGlja0xhYmVscygpO1xuICAgIGlmICghbS5kb21haW4pIG0uZG9tYWluID0gdmdfYXhpc0RvbWFpbigpO1xuICAgIGlmICghbS50aXRsZSkgIG0udGl0bGUgID0gdmdfYXhpc1RpdGxlKCk7XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2UgPSB7dmFsdWU6IGNvbmZpZy5heGlzLmdyaWRDb2xvcn07XG5cbiAgICAvLyBleHRlbmQgYXhpcyBtYXJrcyBiYXNlZCBvbiBheGlzIG9yaWVudGF0aW9uXG4gICAgdmdfYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5ncmlkTGluZXMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgSW5maW5pdHkpO1xuICAgIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWFqb3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplKTtcbiAgICB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1pbm9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01pbm9yU2l6ZSk7XG4gICAgdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbS50aWNrTGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUsIHRpY2tQYWRkaW5nKTtcblxuICAgIHZnX2F4aXNEb21haW5FeHRlbmQob3JpZW50LCBtLmRvbWFpbiwgcmFuZ2UsIHRpY2tFbmRTaXplKTtcbiAgICB2Z19heGlzVGl0bGVFeHRlbmQob3JpZW50LCBtLnRpdGxlLCByYW5nZSwgdGl0bGVPZmZzZXQpOyAvLyBUT0RPIGdldCBvZmZzZXRcbiAgICBcbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JpZExpbmVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWFqb3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWFqb3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1pbm9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1pbm9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aWNrTGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB0aWNrTGFiZWxTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLCBkb21haW5TdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGl0bGUucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuXG4gICAgdmFyIG1hcmtzID0gW20uZ3JpZExpbmVzLCBtLm1ham9yVGlja3MsIG0ubWlub3JUaWNrcywgbS50aWNrTGFiZWxzLCBtLmRvbWFpbiwgbS50aXRsZV07XG4gICAgZGwuZXh0ZW5kKGF4aXNEZWYsIHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHsgXG4gICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19heGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGVuY29kZTogdmdfYXhpc1VwZGF0ZSxcbiAgICAgICAgICBzY2FsZXM6IFtzY2FsZS5zY2FsZU5hbWVdLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBkYXRhOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBheGlzRGVmLm1hcmtzID0gbWFya3MubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pO1xuICB9O1xuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgaWYgKHNjYWxlICE9PSB4KSB7IHNjYWxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSB4KSB7XG4gICAgICBvcmllbnQgPSB4IGluIHZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBjb25maWcuYXhpcy5vcmllbnQ7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIGlmICh0aXRsZSAhPT0geCkgeyB0aXRsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50cztcbiAgICB0aWNrQXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0U3RyaW5nO1xuICAgIGlmICh0aWNrRm9ybWF0U3RyaW5nICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrTWFqb3JTaXplO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgIG1ham9yID0gK3gsXG4gICAgICAgIG1pbm9yID0gbiA+IDEgPyAreSA6IHRpY2tNYWpvclNpemUsXG4gICAgICAgIGVuZCAgID0gbiA+IDAgPyArYXJndW1lbnRzW25dIDogdGlja01ham9yU2l6ZTtcblxuICAgIGlmICh0aWNrTWFqb3JTaXplICE9PSBtYWpvciB8fFxuICAgICAgICB0aWNrTWlub3JTaXplICE9PSBtaW5vciB8fFxuICAgICAgICB0aWNrRW5kU2l6ZSAhPT0gZW5kKSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHRpY2tNYWpvclNpemUgPSBtYWpvcjtcbiAgICB0aWNrTWlub3JTaXplID0gbWlub3I7XG4gICAgdGlja0VuZFNpemUgPSBlbmQ7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tTdWJkaXZpZGU7XG4gICAgdGlja1N1YmRpdmlkZSA9ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGRsLmlzT2JqZWN0KHgpID8geCA6ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgaWYgKHRpY2tQYWRkaW5nICE9PSAreCkgeyB0aWNrUGFkZGluZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZU9mZnNldDtcbiAgICBpZiAodGl0bGVPZmZzZXQgIT09ICt4KSB7IHRpdGxlT2Zmc2V0ID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmxheWVyID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxheWVyO1xuICAgIGlmIChsYXllciAhPT0geCkgeyBsYXllciA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmdyaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZDtcbiAgICBpZiAoZ3JpZCAhPT0geCkgeyBncmlkID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyaWRMaW5lU3R5bGU7XG4gICAgaWYgKGdyaWRMaW5lU3R5bGUgIT09IHgpIHsgZ3JpZExpbmVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFqb3JUaWNrU3R5bGU7XG4gICAgaWYgKG1ham9yVGlja1N0eWxlICE9PSB4KSB7IG1ham9yVGlja1N0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW5vclRpY2tTdHlsZTtcbiAgICBpZiAobWlub3JUaWNrU3R5bGUgIT09IHgpIHsgbWlub3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tMYWJlbFN0eWxlO1xuICAgIGlmICh0aWNrTGFiZWxTdHlsZSAhPT0geCkgeyB0aWNrTGFiZWxTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVN0eWxlO1xuICAgIGlmICh0aXRsZVN0eWxlICE9PSB4KSB7IHRpdGxlU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpblN0eWxlO1xuICAgIGlmIChkb21haW5TdHlsZSAhPT0geCkgeyBkb21haW5TdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgXG4gIGF4aXMucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gYXhpcztcbn07XG5cbnZhciB2Z19heGlzT3JpZW50cyA9IHt0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19heGlzU3ViZGl2aWRlKHNjYWxlLCB0aWNrcywgbSkge1xuICBzdWJ0aWNrcyA9IFtdO1xuICBpZiAobSAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGV4dGVudCA9IHZnX2F4aXNTY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksXG4gICAgICAgIHN1YnRpY2tzLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0aWNrcy5sZW5ndGgsXG4gICAgICAgIGQgPSAodGlja3NbMV0gLSB0aWNrc1swXSkgLyArK20sXG4gICAgICAgIGosXG4gICAgICAgIHY7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGZvciAoaiA9IG07IC0taiA+IDA7KSB7XG4gICAgICAgIGlmICgodiA9ICt0aWNrc1tpXSAtIGogKiBkKSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICBzdWJ0aWNrcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoLS1pLCBqID0gMDsgKytqIDwgbSAmJiAodiA9ICt0aWNrc1tpXSArIGogKiBkKSA8IGV4dGVudFsxXTspIHtcbiAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJ0aWNrcztcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1NjYWxlRXh0ZW50KGRvbWFpbikge1xuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNTY2FsZVJhbmdlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudFxuICAgID8gc2NhbGUucmFuZ2VFeHRlbnQoKVxuICAgIDogdmdfYXhpc1NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xufVxuXG52YXIgdmdfYXhpc0FsaWduID0ge1xuICBib3R0b206IFwiY2VudGVyXCIsXG4gIHRvcDogXCJjZW50ZXJcIixcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCJcbn07XG5cbnZhciB2Z19heGlzQmFzZWxpbmUgPSB7XG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiLFxuICBsZWZ0OiBcIm1pZGRsZVwiLFxuICByaWdodDogXCJtaWRkbGVcIlxufTtcblxuZnVuY3Rpb24gdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUsIHBhZCkge1xuICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCkgKyBwYWQ7XG4gIGlmIChvcmllbnQgPT09IFwibGVmdFwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIHNpemUgKj0gLTE7XG4gIH0gIFxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogb2xkU2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IG5ld1NjYWxlLFxuICAgICAgeToge3ZhbHVlOiBzaXplfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6IFwiY2VudGVyXCJ9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogdmdfYXhpc0Jhc2VsaW5lW29yaWVudF19XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogb2xkU2NhbGUsXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG5ld1NjYWxlLFxuICAgICAgYWxpZ246IHt2YWx1ZTogdmdfYXhpc0FsaWduW29yaWVudF19LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCB0aWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCBzaXplKSB7XG4gIHZhciBzaWduID0gKG9yaWVudCA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSA/IC0xIDogMTtcbiAgaWYgKHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgc2l6ZSA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKVxuICAgICAgPyB7ZmllbGQ6IHtncm91cDogXCJoZWlnaHRcIiwgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn1cbiAgICAgIDoge2ZpZWxkOiB7Z3JvdXA6IFwid2lkdGhcIiwgIGxldmVsOiAyfSwgbXVsdDogLXNpZ259O1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB7dmFsdWU6IHNpZ24gKiBzaXplfTtcbiAgfVxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAgb2xkU2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAgbmV3U2NhbGUsXG4gICAgICB5OiAge3ZhbHVlOiAwfSxcbiAgICAgIHkyOiBzaXplXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgIH0pOyAgICAgICAgXG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgb2xkU2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6ICB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHNpemUsXG4gICAgICB5OiAgbmV3U2NhbGVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5leGl0LCB7XG4gICAgICB5OiAgbmV3U2NhbGUsXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlRXh0ZW5kKG9yaWVudCwgdGl0bGUsIHJhbmdlLCBvZmZzZXQpIHtcbiAgdmFyIG1pZCA9IH5+KChyYW5nZVswXSArIHJhbmdlWzFdKSAvIDIpLFxuICAgICAgc2lnbiA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikgPyAtMSA6IDE7XG4gIFxuICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBtaWR9LFxuICAgICAgeToge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZCh0aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaWduKm9mZnNldH0sXG4gICAgICB5OiB7dmFsdWU6IG1pZH0sXG4gICAgICBhbmdsZToge3ZhbHVlOiAtOTB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmdfYXhpc0RvbWFpbkV4dGVuZChvcmllbnQsIGRvbWFpbiwgcmFuZ2UsIHNpemUpIHtcbiAgdmFyIHBhdGg7XG4gIGlmIChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImxlZnRcIikge1xuICAgIHNpemUgPSAtMSAqIHNpemU7XG4gIH1cbiAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICBwYXRoID0gXCJNXCIgKyByYW5nZVswXSArIFwiLFwiICsgc2l6ZSArIFwiVjBIXCIgKyByYW5nZVsxXSArIFwiVlwiICsgc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoID0gXCJNXCIgKyBzaXplICsgXCIsXCIgKyByYW5nZVswXSArIFwiSDBWXCIgKyByYW5nZVsxXSArIFwiSFwiICsgc2l6ZTtcbiAgfVxuICBkb21haW4ucHJvcGVydGllcy51cGRhdGUucGF0aCA9IHt2YWx1ZTogcGF0aH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNVcGRhdGUoaXRlbSwgZ3JvdXAsIHRyYW5zLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykge1xuICB2YXIgbyA9IHRyYW5zID8ge30gOiBpdGVtLFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHdpZHRoICA9IGdyb3VwLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gZ3JvdXAuaGVpZ2h0OyAvLyBUT0RPIGZhbGxiYWNrIHRvIGdsb2JhbCB3LGg/XG5cbiAgaWYgKGRsLmlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSAtZ3JvdXAuc2NhbGUob2Zmc2V0LnNjYWxlKShvZmZzZXQudmFsdWUpO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFwibGVmdFwiOiAgIHsgdHBsLnNldChvLCAneCcsIC1vZmZzZXQpOyB0cGwuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgY2FzZSBcInJpZ2h0XCI6ICB7IHRwbC5zZXQobywgJ3gnLCB3aWR0aCArIG9mZnNldCk7IHRwbC5zZXQobywgJ3knLCAwKTsgYnJlYWs7IH1cbiAgICBjYXNlIFwiYm90dG9tXCI6IHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgaGVpZ2h0ICsgb2Zmc2V0KTsgYnJlYWs7IH1cbiAgICBjYXNlIFwidG9wXCI6ICAgIHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgLW9mZnNldCk7IGJyZWFrOyB9XG4gICAgZGVmYXVsdDogICAgICAgeyB0cGwuc2V0KG8sICd4JywgMCk7IHRwbC5zZXQobywgJ3knLCAwKTsgfVxuICB9XG5cbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpY2tzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicnVsZVwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHN0cm9rZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrV2lkdGh9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja0xhYmVscygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbEZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250U2l6ZX0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJsYWJlbFwifVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpdGxlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVGb250V2VpZ2h0fSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUNvbG9yfSxcbiAgICAgICAgYWxpZ246IHt2YWx1ZTogXCJjZW50ZXJcIn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IFwibWlkZGxlXCJ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwiZGF0YVwifVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNEb21haW4oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwYXRoXCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgeToge3ZhbHVlOiAwLjV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMuYXhpc1dpZHRofVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZToge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXhzO1xuIiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgcGFyc2VQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vcGFyc2UvcHJvcGVydGllcycpLFxuICAgIHBhcnNlTWFyayA9IHJlcXVpcmUoJy4uL3BhcnNlL21hcmsnKSxcbiAgICBHcmFkaWVudCA9IHJlcXVpcmUoJy4uL3V0aWwvR3JhZGllbnQnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpO1xuXG5mdW5jdGlvbiBsZ25kKG1vZGVsKSB7XG4gIHZhciBzaXplID0gbnVsbCxcbiAgICAgIHNoYXBlID0gbnVsbCxcbiAgICAgIGZpbGwgPSBudWxsLFxuICAgICAgc3Ryb2tlID0gbnVsbCxcbiAgICAgIHNwYWNpbmcgPSBudWxsLFxuICAgICAgdmFsdWVzID0gbnVsbCxcbiAgICAgIGZvcm1hdCA9IG51bGwsXG4gICAgICBmb3JtYXRTdHJpbmcgPSBudWxsLFxuICAgICAgdGl0bGUgPSB1bmRlZmluZWQsXG4gICAgICBvcmllbnQgPSBcInJpZ2h0XCIsXG4gICAgICBvZmZzZXQgPSBjb25maWcubGVnZW5kLm9mZnNldCxcbiAgICAgIHBhZGRpbmcgPSBjb25maWcubGVnZW5kLnBhZGRpbmcsXG4gICAgICBsZWdlbmREZWYsXG4gICAgICB0aWNrQXJndW1lbnRzID0gWzVdLFxuICAgICAgbGVnZW5kU3R5bGUgPSB7fSxcbiAgICAgIHN5bWJvbFN0eWxlID0ge30sXG4gICAgICBncmFkaWVudFN0eWxlID0ge30sXG4gICAgICB0aXRsZVN0eWxlID0ge30sXG4gICAgICBsYWJlbFN0eWxlID0ge30sXG4gICAgICBtID0geyAvLyBMZWdlbmQgbWFya3MgYXMgcmVmZXJlbmNlcyBmb3IgdXBkYXRlc1xuICAgICAgICB0aXRsZXM6ICBudWxsLFxuICAgICAgICBzeW1ib2xzOiBudWxsLFxuICAgICAgICBsYWJlbHM6ICBudWxsLFxuICAgICAgICBncmFkaWVudDogbnVsbFxuICAgICAgfTtcblxuICB2YXIgbGVnZW5kID0ge30sXG4gICAgICBsZWdlbmREZWYgPSB7fTtcblxuICBmdW5jdGlvbiByZXNldCgpIHsgbGVnZW5kRGVmLnR5cGUgPSBudWxsOyB9XG4gIGZ1bmN0aW9uIGluZ2VzdChkLCBpKSB7IHJldHVybiB7ZGF0YTogZCwgaW5kZXg6IGl9IH1cblxuICBsZWdlbmQuZGVmID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlID0gc2l6ZSB8fCBzaGFwZSB8fCBmaWxsIHx8IHN0cm9rZTtcbiAgICBcbiAgICBmb3JtYXQgPSAhZm9ybWF0U3RyaW5nID8gbnVsbCA6ICgoc2NhbGUudHlwZSA9PT0gJ3RpbWUnKVxuICAgICAgPyBkMy50aW1lLmZvcm1hdChmb3JtYXRTdHJpbmcpXG4gICAgICA6IGQzLmZvcm1hdChmb3JtYXRTdHJpbmcpKTtcbiAgICBcbiAgICBpZiAoIWxlZ2VuZERlZi50eXBlKSB7XG4gICAgICBsZWdlbmREZWYgPSAoc2NhbGU9PT1maWxsIHx8IHNjYWxlPT09c3Ryb2tlKSAmJiAhZGlzY3JldGUoc2NhbGUudHlwZSlcbiAgICAgICAgPyBxdWFudERlZihzY2FsZSlcbiAgICAgICAgOiBvcmRpbmFsRGVmKHNjYWxlKTsgICAgICBcbiAgICB9XG4gICAgbGVnZW5kRGVmLm9yaWVudCA9IG9yaWVudDtcbiAgICBsZWdlbmREZWYub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIGxlZ2VuZERlZi5wYWRkaW5nID0gcGFkZGluZztcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRpc2NyZXRlKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZT09PVwib3JkaW5hbFwiIHx8IHR5cGU9PT1cInF1YW50aXplXCJcbiAgICAgIHx8IHR5cGU9PT1cInF1YW50aWxlXCIgfHwgdHlwZT09PVwidGhyZXNob2xkXCI7XG4gIH1cblxuICBmdW5jdGlvbiBvcmRpbmFsRGVmKHNjYWxlKSB7XG4gICAgdmFyIGRlZiA9IG9fbGVnZW5kX2RlZihzaXplLCBzaGFwZSwgZmlsbCwgc3Ryb2tlKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICB2YXIgZGF0YSA9ICh2YWx1ZXMgPT0gbnVsbFxuICAgICAgPyAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcy5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBzY2FsZS5kb21haW4oKSlcbiAgICAgIDogdmFsdWVzKS5tYXAoaW5nZXN0KTtcbiAgICB2YXIgZm10ID0gZm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiBmb3JtYXQ7XG4gICAgXG4gICAgLy8gZGV0ZXJtaW5lIHNwYWNpbmcgYmV0d2VlbiBsZWdlbmQgZW50cmllc1xuICAgIHZhciBmcywgcmFuZ2UsIG9mZnNldCwgcGFkPTUsIGRvbWFpbiA9IGQzLnJhbmdlKGRhdGEubGVuZ3RoKTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgcmFuZ2UgPSBkYXRhLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnNxcnQoc2l6ZSh4LmRhdGEpKTsgfSk7XG4gICAgICBvZmZzZXQgPSBkMy5tYXgocmFuZ2UpO1xuICAgICAgcmFuZ2UgPSByYW5nZS5yZWR1Y2UoZnVuY3Rpb24oYSxiLGkseikge1xuICAgICAgICAgIGlmIChpID4gMCkgYVtpXSA9IGFbaS0xXSArIHpbaS0xXS8yICsgcGFkO1xuICAgICAgICAgIHJldHVybiAoYVtpXSArPSBiLzIsIGEpOyB9LCBbMF0pLm1hcChNYXRoLnJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoY29uZmlnLmxlZ2VuZC5zeW1ib2xTaXplKSk7XG4gICAgICByYW5nZSA9IHNwYWNpbmdcbiAgICAgICAgfHwgKGZzID0gbGFiZWxTdHlsZS5mb250U2l6ZSkgJiYgKGZzLnZhbHVlICsgcGFkKVxuICAgICAgICB8fCAoY29uZmlnLmxlZ2VuZC5sYWJlbEZvbnRTaXplICsgcGFkKTtcbiAgICAgIHJhbmdlID0gZG9tYWluLm1hcChmdW5jdGlvbihkLGkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQob2Zmc2V0LzIgKyBpKnJhbmdlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGFjY291bnQgZm9yIHBhZGRpbmcgYW5kIHRpdGxlIHNpemVcbiAgICB2YXIgc3ogPSBwYWRkaW5nLCB0cztcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHRzID0gdGl0bGVTdHlsZS5mb250U2l6ZTtcbiAgICAgIHN6ICs9IDUgKyAoKHRzICYmIHRzLnZhbHVlKSB8fCBjb25maWcubGVnZW5kLnRpdGxlRm9udFNpemUpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpPTAsIG49cmFuZ2UubGVuZ3RoOyBpPG47ICsraSkgcmFuZ2VbaV0gKz0gc3o7XG4gICAgXG4gICAgLy8gYnVpbGQgc2NhbGUgZm9yIGxhYmVsIGxheW91dFxuICAgIHZhciBzY2FsZSA9IHtcbiAgICAgIG5hbWU6IFwibGVnZW5kXCIsXG4gICAgICB0eXBlOiBcIm9yZGluYWxcIixcbiAgICAgIHBvaW50czogdHJ1ZSxcbiAgICAgIGRvbWFpbjogZG9tYWluLFxuICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgfTtcbiAgICBcbiAgICAvLyB1cGRhdGUgbGVnZW5kIGRlZlxuICAgIHZhciB0ZGF0YSA9ICh0aXRsZSA/IFt0aXRsZV0gOiBbXSkubWFwKGluZ2VzdCk7XG4gICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGQubGFiZWwgPSBmbXQoZC5kYXRhKTtcbiAgICAgIGQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH0pO1xuICAgIGRlZi5zY2FsZXMgPSBbIHNjYWxlIF07XG4gICAgZGVmLm1hcmtzWzBdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRkYXRhOyB9O1xuICAgIGRlZi5tYXJrc1sxXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBkYXRhOyB9O1xuICAgIGRlZi5tYXJrc1syXS5mcm9tID0gZGVmLm1hcmtzWzFdLmZyb207XG5cbiAgICByZXR1cm4gZGVmO1xuICB9XG5cbiAgZnVuY3Rpb24gb19sZWdlbmRfZGVmKHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpIHtcbiAgICAvLyBzZXR1cCBsZWdlbmQgbWFya3NcbiAgICB2YXIgdGl0bGVzICA9IG0udGl0bGVzICB8fCAobS50aXRsZXMgID0gdmdfbGVnZW5kVGl0bGUoKSksXG4gICAgICAgIHN5bWJvbHMgPSBtLnN5bWJvbHMgfHwgKG0uc3ltYm9scyA9IHZnX2xlZ2VuZFN5bWJvbHMoKSksXG4gICAgICAgIGxhYmVscyAgPSBtLmxhYmVscyAgfHwgKG0ubGFiZWxzICA9IHZnX3ZMZWdlbmRMYWJlbHMoKSk7XG5cbiAgICAvLyBleHRlbmQgbGVnZW5kIG1hcmtzXG4gICAgdmdfbGVnZW5kU3ltYm9sRXh0ZW5kKHN5bWJvbHMsIHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpO1xuICAgIFxuICAgIC8vIGFkZCAvIG92ZXJyaWRlIGN1c3RvbSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgZGwuZXh0ZW5kKHRpdGxlcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgIHRpdGxlU3R5bGUpO1xuICAgIGRsLmV4dGVuZChzeW1ib2xzLnByb3BlcnRpZXMudXBkYXRlLCBzeW1ib2xTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwgIGxhYmVsU3R5bGUpO1xuXG4gICAgLy8gcGFkZGluZyBmcm9tIGxlZ2VuZCBib3JkZXJcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgdGl0bGVzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLngub2Zmc2V0ICs9IHBhZGRpbmcgKyAxO1xuICAgIHN5bWJvbHMucHJvcGVydGllcy5lbnRlci54Lm9mZnNldCA9IHBhZGRpbmcgKyAxO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS54Lm9mZnNldCArPSBwYWRkaW5nICsgMTtcbiAgICBzeW1ib2xzLnByb3BlcnRpZXMudXBkYXRlLngub2Zmc2V0ID0gcGFkZGluZyArIDE7XG5cbiAgICBkbC5leHRlbmQobGVnZW5kRGVmLCB7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVudGVyOiBwYXJzZVByb3BlcnRpZXMobW9kZWwsIFwiZ3JvdXBcIiwgbGVnZW5kU3R5bGUpLFxuICAgICAgICB2Z19sZWdlbmRQb3NpdGlvbjoge1xuICAgICAgICAgIGVuY29kZTogdmdfbGVnZW5kUG9zaXRpb24sXG4gICAgICAgICAgc2lnbmFsczogW10sIHNjYWxlczpbXSwgZGF0YTogW10sIGZpZWxkczogW11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGVnZW5kRGVmLm1hcmtzID0gW3RpdGxlcywgc3ltYm9scywgbGFiZWxzXS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSk7XG4gICAgcmV0dXJuIGxlZ2VuZERlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50RGVmKHNjYWxlKSB7XG4gICAgdmFyIGRlZiA9IHFfbGVnZW5kX2RlZihzY2FsZSksXG4gICAgICAgIGRvbSA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgICBkYXRhID0gZG9tLm1hcChpbmdlc3QpLFxuICAgICAgICB3aWR0aCA9IChncmFkaWVudFN0eWxlLndpZHRoICYmIGdyYWRpZW50U3R5bGUud2lkdGgudmFsdWUpIHx8IGNvbmZpZy5sZWdlbmQuZ3JhZGllbnRXaWR0aCxcbiAgICAgICAgZm10ID0gZm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiBmb3JtYXQ7XG5cbiAgICAvLyBidWlsZCBzY2FsZSBmb3IgbGFiZWwgbGF5b3V0XG4gICAgdmFyIGxheW91dCA9IHtcbiAgICAgIG5hbWU6IFwibGVnZW5kXCIsXG4gICAgICB0eXBlOiBzY2FsZS50eXBlLFxuICAgICAgcm91bmQ6IHRydWUsXG4gICAgICB6ZXJvOiBmYWxzZSxcbiAgICAgIGRvbWFpbjogW2RvbVswXSwgZG9tW2RvbS5sZW5ndGgtMV1dLFxuICAgICAgcmFuZ2U6IFtwYWRkaW5nLCB3aWR0aCtwYWRkaW5nXVxuICAgIH07XG4gICAgaWYgKHNjYWxlLnR5cGU9PT1cInBvd1wiKSBsYXlvdXQuZXhwb25lbnQgPSBzY2FsZS5leHBvbmVudCgpO1xuICAgIFxuICAgIC8vIHVwZGF0ZSBsZWdlbmQgZGVmXG4gICAgdmFyIHRkYXRhID0gKHRpdGxlID8gW3RpdGxlXSA6IFtdKS5tYXAoaW5nZXN0KTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCxpKSB7XG4gICAgICBkLmxhYmVsID0gZm10KGQuZGF0YSk7XG4gICAgICBkLmFsaWduID0gaT09KGRhdGEubGVuZ3RoLTEpID8gXCJyaWdodFwiIDogaT09MCA/IFwibGVmdFwiIDogXCJjZW50ZXJcIjtcbiAgICB9KTtcbiAgICBkZWYuc2NhbGVzID0gWyBsYXlvdXQgXTtcbiAgICBkZWYubWFya3NbMF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgZGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIFsxXTsgfTtcbiAgICBkZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZGF0YTsgfTtcbiAgICByZXR1cm4gZGVmO1xuICB9XG4gIFxuICBmdW5jdGlvbiBxX2xlZ2VuZF9kZWYoc2NhbGUpIHtcbiAgICAvLyBzZXR1cCBsZWdlbmQgbWFya3NcbiAgICB2YXIgdGl0bGVzID0gbS50aXRsZSB8fCAobS50aXRsZSA9IHZnX2xlZ2VuZFRpdGxlKCkpLFxuICAgICAgICBncmFkaWVudCA9IG0uZ3JhZGllbnQgfHwgKG0uZ3JhZGllbnQgPSB2Z19sZWdlbmRHcmFkaWVudCgpKSxcbiAgICAgICAgbGFiZWxzID0gbS5sYWJlbHMgfHwgKG0ubGFiZWxzID0gdmdfaExlZ2VuZExhYmVscygpKSxcbiAgICAgICAgZ3JhZCA9IG5ldyBHcmFkaWVudCgpO1xuXG4gICAgLy8gc2V0dXAgY29sb3IgZ3JhZGllbnRcbiAgICB2YXIgZG9tID0gc2NhbGUuZG9tYWluKCksXG4gICAgICAgIG1pbiA9IGRvbVswXSxcbiAgICAgICAgbWF4ID0gZG9tW2RvbS5sZW5ndGgtMV0sXG4gICAgICAgIGYgPSBzY2FsZS5jb3B5KCkuZG9tYWluKFttaW4sIG1heF0pLnJhbmdlKFswLDFdKTtcbiAgICAgICAgXG4gICAgdmFyIHN0b3BzID0gKHNjYWxlLnR5cGUgIT09IFwibGluZWFyXCIgJiYgc2NhbGUudGlja3MpXG4gICAgICA/IHNjYWxlLnRpY2tzLmNhbGwoc2NhbGUsIDE1KSA6IGRvbTtcbiAgICBpZiAobWluICE9PSBzdG9wc1swXSkgc3RvcHMudW5zaGlmdChtaW4pO1xuICAgIGlmIChtYXggIT09IHN0b3BzW3N0b3BzLmxlbmd0aC0xXSkgc3RvcHMucHVzaChtYXgpO1xuXG4gICAgZm9yICh2YXIgaT0wLCBuPXN0b3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGdyYWQuc3RvcChmKHN0b3BzW2ldKSwgc2NhbGUoc3RvcHNbaV0pKTtcbiAgICB9XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy5lbnRlci5maWxsID0ge3ZhbHVlOiBncmFkfTtcblxuICAgIC8vIGFkZCAvIG92ZXJyaWRlIGN1c3RvbSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgZGwuZXh0ZW5kKHRpdGxlcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgdGl0bGVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKGdyYWRpZW50LnByb3BlcnRpZXMudXBkYXRlLCBncmFkaWVudFN0eWxlKTtcbiAgICBkbC5leHRlbmQobGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCBsYWJlbFN0eWxlKTtcblxuICAgIC8vIGFjY291bnQgZm9yIGdyYWRpZW50IHNpemVcbiAgICB2YXIgZ3AgPSBncmFkaWVudC5wcm9wZXJ0aWVzLCBnaCA9IGdyYWRpZW50U3R5bGUuaGVpZ2h0LFxuICAgICAgICBoaCA9IChnaCAmJiBnaC52YWx1ZSkgfHwgZ3AuZW50ZXIuaGVpZ2h0LnZhbHVlO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgPSBoaDtcbiAgICBsYWJlbHMucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSA9IGhoO1xuXG4gICAgLy8gYWNjb3VudCBmb3IgdGl0bGUgc2l6ZSBhcyBuZWVkZWRcbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIHZhciB0cCA9IHRpdGxlcy5wcm9wZXJ0aWVzLCBmcyA9IHRpdGxlU3R5bGUuZm9udFNpemUsXG4gICAgICAgICAgc3ogPSA0ICsgKChmcyAmJiBmcy52YWx1ZSkgfHwgdHAuZW50ZXIuZm9udFNpemUudmFsdWUpO1xuICAgICAgZ3JhZGllbnQucHJvcGVydGllcy5lbnRlci55LnZhbHVlICs9IHN6O1xuICAgICAgbGFiZWxzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBzejtcbiAgICAgIGdyYWRpZW50LnByb3BlcnRpZXMudXBkYXRlLnkudmFsdWUgKz0gc3o7XG4gICAgICBsYWJlbHMucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSArPSBzejtcbiAgICB9XG4gICAgXG4gICAgLy8gcGFkZGluZyBmcm9tIGxlZ2VuZCBib3JkZXJcbiAgICB0aXRsZXMucHJvcGVydGllcy5lbnRlci54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgdGl0bGVzLnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGdyYWRpZW50LnByb3BlcnRpZXMuZW50ZXIueC52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGdyYWRpZW50LnByb3BlcnRpZXMuZW50ZXIueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLnkudmFsdWUgKz0gcGFkZGluZztcbiAgICBncmFkaWVudC5wcm9wZXJ0aWVzLnVwZGF0ZS54LnZhbHVlICs9IHBhZGRpbmc7XG4gICAgZ3JhZGllbnQucHJvcGVydGllcy51cGRhdGUueS52YWx1ZSArPSBwYWRkaW5nO1xuICAgIGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZS55LnZhbHVlICs9IHBhZGRpbmc7XG5cbiAgICBkbC5leHRlbmQobGVnZW5kRGVmLCB7XG4gICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGVudGVyOiBwYXJzZVByb3BlcnRpZXMobW9kZWwsIFwiZ3JvdXBcIiwgbGVnZW5kU3R5bGUpLFxuICAgICAgICB2Z19sZWdlbmRQb3NpdGlvbjoge1xuICAgICAgICAgIGVuY29kZTogdmdfbGVnZW5kUG9zaXRpb24sXG4gICAgICAgICAgc2lnbmFsczogW10sIHNjYWxlczogW10sIGRhdGE6IFtdLCBmaWVsZHM6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGxlZ2VuZERlZi5tYXJrcyA9IFt0aXRsZXMsIGdyYWRpZW50LCBsYWJlbHNdLm1hcChmdW5jdGlvbihtKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIG0pOyB9KTtcbiAgICByZXR1cm4gbGVnZW5kRGVmO1xuICB9XG5cbiAgbGVnZW5kLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2l6ZTtcbiAgICBpZiAoc2l6ZSAhPT0geCkgeyBzaXplID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNoYXBlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHNoYXBlO1xuICAgIGlmIChzaGFwZSAhPT0geCkgeyBzaGFwZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIGxlZ2VuZC5maWxsID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGZpbGw7XG4gICAgaWYgKGZpbGwgIT09IHgpIHsgZmlsbCA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuICBcbiAgbGVnZW5kLnN0cm9rZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzdHJva2U7XG4gICAgaWYgKHN0cm9rZSAhPT0geCkgeyBzdHJva2UgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudGl0bGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgaWYgKHRpdGxlICE9PSB4KSB7IHRpdGxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmZvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBmb3JtYXRTdHJpbmc7XG4gICAgaWYgKGZvcm1hdFN0cmluZyAhPT0geCkge1xuICAgICAgZm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnNwYWNpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3BhY2luZztcbiAgICBpZiAoc3BhY2luZyAhPT0gK3gpIHsgc3BhY2luZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBvcmllbnQgPSB4IGluIHZnX2xlZ2VuZE9yaWVudHMgPyB4ICsgXCJcIiA6IGNvbmZpZy5sZWdlbmQub3JpZW50O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gK3g7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQudmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZhbHVlcztcbiAgICB2YWx1ZXMgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxlZ2VuZFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGVnZW5kU3R5bGU7XG4gICAgbGVnZW5kU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLnN5bWJvbFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc3ltYm9sU3R5bGU7XG4gICAgc3ltYm9sU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmdyYWRpZW50UHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmFkaWVudFN0eWxlO1xuICAgIGdyYWRpZW50U3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG5cbiAgbGVnZW5kLmxhYmVsUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsYWJlbFN0eWxlO1xuICAgIGxhYmVsU3R5bGUgPSB4O1xuICAgIHJldHVybiBsZWdlbmQ7XG4gIH07XG4gIFxuICBsZWdlbmQudGl0bGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlU3R5bGU7XG4gICAgdGl0bGVTdHlsZSA9IHg7XG4gICAgcmV0dXJuIGxlZ2VuZDtcbiAgfTtcblxuICBsZWdlbmQucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gbGVnZW5kO1xufTtcblxudmFyIHZnX2xlZ2VuZE9yaWVudHMgPSB7cmlnaHQ6IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19sZWdlbmRQb3NpdGlvbihpdGVtLCBncm91cCwgdHJhbnMsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSB7XG4gIHZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW0sIGd4LFxuICAgICAgb2Zmc2V0ID0gaXRlbS5tYXJrLmRlZi5vZmZzZXQsXG4gICAgICBvcmllbnQgPSBpdGVtLm1hcmsuZGVmLm9yaWVudCxcbiAgICAgIHBhZCAgICA9IGl0ZW0ubWFyay5kZWYucGFkZGluZyAqIDIsXG4gICAgICBsdyAgICAgPSB+fml0ZW0uYm91bmRzLndpZHRoKCkgKyAoaXRlbS53aWR0aCA/IDAgOiBwYWQpLFxuICAgICAgbGggICAgID0gfn5pdGVtLmJvdW5kcy5oZWlnaHQoKSArIChpdGVtLmhlaWdodCA/IDAgOiBwYWQpLFxuICAgICAgcG9zID0gZ3JvdXAuX2xlZ2VuZFBvc2l0aW9ucyB8fCBcbiAgICAgICAgKGdyb3VwLl9sZWdlbmRQb3NpdGlvbnMgPSB7cmlnaHQ6IDAuNSwgbGVmdDogMC41fSk7XG5cbiAgby54ID0gMC41O1xuICBvLndpZHRoID0gbHc7XG4gIG8ueSA9IHBvc1tvcmllbnRdO1xuICBwb3Nbb3JpZW50XSArPSAoby5oZWlnaHQgPSBsaCk7XG5cbiAgLy8gSEFDSzogdXNlIHRvIGVzdGltYXRlIGdyb3VwIGJvdW5kcyBkdXJpbmcgYW5pbWF0ZWQgdHJhbnNpdGlvblxuICBpZiAoIXRyYW5zICYmIGdyb3VwLmJvdW5kcykge1xuICAgIGdyb3VwLmJvdW5kcy5kZWx0YSA9IGdyb3VwLmJvdW5kcy54MiAtIGdyb3VwLndpZHRoO1xuICB9XG5cbiAgc3dpdGNoIChvcmllbnQpIHtcbiAgICBjYXNlIFwibGVmdFwiOiAge1xuICAgICAgZ3ggPSBncm91cC5ib3VuZHMgPyBncm91cC5ib3VuZHMueDEgOiAwO1xuICAgICAgby54ICs9IGd4IC0gb2Zmc2V0IC0gbHc7XG4gICAgICBicmVhaztcbiAgICB9O1xuICAgIGNhc2UgXCJyaWdodFwiOiB7XG4gICAgICBneCA9IGdyb3VwLndpZHRoO1xuICAgICAgaWYgKGdyb3VwLmJvdW5kcykgZ3ggPSB0cmFuc1xuICAgICAgICA/IGdyb3VwLndpZHRoICsgZ3JvdXAuYm91bmRzLmRlbHRhXG4gICAgICAgIDogZ3JvdXAuYm91bmRzLngyO1xuICAgICAgby54ICs9IGd4ICsgb2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgfTtcbiAgfVxuICBcbiAgaWYgKHRyYW5zKSB0cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBvKTtcbiAgdmFyIGVuYyA9IGl0ZW0ubWFyay5kZWYucHJvcGVydGllcy5lbnRlci5lbmNvZGU7XG4gIGVuYy5jYWxsKGVuYywgaXRlbSwgZ3JvdXAsIHRyYW5zKTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kU3ltYm9sRXh0ZW5kKG1hcmssIHNpemUsIHNoYXBlLCBmaWxsLCBzdHJva2UpIHtcbiAgdmFyIGUgPSBtYXJrLnByb3BlcnRpZXMuZW50ZXIsXG4gICAgICB1ID0gbWFyay5wcm9wZXJ0aWVzLnVwZGF0ZTtcbiAgaWYgKHNpemUpICAgZS5zaXplICAgPSB1LnNpemUgICA9IHtzY2FsZTogc2l6ZS5zY2FsZU5hbWUsICAgZmllbGQ6IFwiZGF0YVwifTtcbiAgaWYgKHNoYXBlKSAgZS5zaGFwZSAgPSB1LnNoYXBlICA9IHtzY2FsZTogc2hhcGUuc2NhbGVOYW1lLCAgZmllbGQ6IFwiZGF0YVwifTtcbiAgaWYgKGZpbGwpICAgZS5maWxsICAgPSB1LmZpbGwgICA9IHtzY2FsZTogZmlsbC5zY2FsZU5hbWUsICAgZmllbGQ6IFwiZGF0YVwifTtcbiAgaWYgKHN0cm9rZSkgZS5zdHJva2UgPSB1LnN0cm9rZSA9IHtzY2FsZTogc3Ryb2tlLnNjYWxlTmFtZSwgZmllbGQ6IFwiZGF0YVwifTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kVGl0bGUoKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICAgIHk6IHt2YWx1ZTogMH0sXG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY2ZnLnRpdGxlQ29sb3J9LFxuICAgICAgICBmb250OiB7dmFsdWU6IGNmZy50aXRsZUZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjZmcudGl0bGVGb250U2l6ZX0sXG4gICAgICAgIGZvbnRXZWlnaHQ6IHt2YWx1ZTogY2ZnLnRpdGxlRm9udFdlaWdodH0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IFwidG9wXCJ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwiZGF0YVwifSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kU3ltYm9scygpIHtcbiAgdmFyIGNmZyA9IGNvbmZpZy5sZWdlbmQ7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiBcImRhdGFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7ZmllbGQ6IFwib2Zmc2V0XCIsIG11bHQ6IDAuNX0sXG4gICAgICAgIHk6IHtzY2FsZTogXCJsZWdlbmRcIiwgZmllbGQ6IFwiaW5kZXhcIn0sXG4gICAgICAgIHNoYXBlOiB7dmFsdWU6IGNmZy5zeW1ib2xTaGFwZX0sXG4gICAgICAgIHNpemU6IHt2YWx1ZTogY2ZnLnN5bWJvbFNpemV9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY2ZnLnN5bWJvbENvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY2ZnLnN5bWJvbFN0cm9rZVdpZHRofSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHtmaWVsZDogXCJvZmZzZXRcIiwgbXVsdDogMC41fSxcbiAgICAgICAgeToge3NjYWxlOiBcImxlZ2VuZFwiLCBmaWVsZDogXCJpbmRleFwifSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfdkxlZ2VuZExhYmVscygpIHtcbiAgdmFyIGNmZyA9IGNvbmZpZy5sZWdlbmQ7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIGtleTogXCJkYXRhXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge2ZpZWxkOiBcIm9mZnNldFwiLCBvZmZzZXQ6IDV9LFxuICAgICAgICB5OiB7c2NhbGU6IFwibGVnZW5kXCIsIGZpZWxkOiBcImluZGV4XCJ9LFxuICAgICAgICBmaWxsOiB7dmFsdWU6IGNmZy5sYWJlbENvbG9yfSxcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjZmcubGFiZWxGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udFNpemV9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiBjZmcubGFiZWxBbGlnbn0sXG4gICAgICAgIGJhc2VsaW5lOiB7dmFsdWU6IGNmZy5sYWJlbEJhc2VsaW5lfSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiBcImxhYmVsXCJ9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgICAgeDoge2ZpZWxkOiBcIm9mZnNldFwiLCBvZmZzZXQ6IDV9LFxuICAgICAgICB5OiB7c2NhbGU6IFwibGVnZW5kXCIsIGZpZWxkOiBcImluZGV4XCJ9LFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfbGVnZW5kR3JhZGllbnQoKSB7XG4gIHZhciBjZmcgPSBjb25maWcubGVnZW5kO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicmVjdFwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgICB3aWR0aDoge3ZhbHVlOiBjZmcuZ3JhZGllbnRXaWR0aH0sXG4gICAgICAgIGhlaWdodDoge3ZhbHVlOiBjZmcuZ3JhZGllbnRIZWlnaHR9LFxuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY2ZnLmdyYWRpZW50U3Ryb2tlQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjZmcuZ3JhZGllbnRTdHJva2VXaWR0aH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZToge1xuICAgICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDF9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19oTGVnZW5kTGFiZWxzKCkge1xuICB2YXIgY2ZnID0gY29uZmlnLmxlZ2VuZDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiBcImRhdGFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7c2NhbGU6IFwibGVnZW5kXCIsIGZpZWxkOiBcImRhdGFcIn0sXG4gICAgICAgIHk6IHt2YWx1ZTogMjB9LFxuICAgICAgICBkeToge3ZhbHVlOiAyfSxcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjZmcubGFiZWxDb2xvcn0sXG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY2ZnLmxhYmVsRm9udH0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IGNmZy5sYWJlbEZvbnRTaXplfSxcbiAgICAgICAgYWxpZ246IHtmaWVsZDogXCJhbGlnblwifSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJ0b3BcIn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJsYWJlbFwifSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIHg6IHtzY2FsZTogXCJsZWdlbmRcIiwgZmllbGQ6IFwiZGF0YVwifSxcbiAgICAgICAgeToge3ZhbHVlOiAyMH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMX1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGduZDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgbWVhcyA9IHJlcXVpcmUoJy4vbWVhc3VyZXMnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gQWdncmVnYXRlKGdyYXBoKSB7XG4gIEdyb3VwQnkucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cF9ieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcImNvdW50XCI6ICAgIFwiY291bnRcIixcbiAgICBcImF2Z1wiOiAgICAgIFwiYXZnXCIsXG4gICAgXCJtaW5cIjogICAgICBcIm1pblwiLFxuICAgIFwibWF4XCI6ICAgICAgXCJtYXhcIixcbiAgICBcInN1bVwiOiAgICAgIFwic3VtXCIsXG4gICAgXCJtZWFuXCI6ICAgICBcIm1lYW5cIixcbiAgICBcInZhclwiOiAgICAgIFwidmFyXCIsXG4gICAgXCJzdGRldlwiOiAgICBcInN0ZGV2XCIsXG4gICAgXCJ2YXJwXCI6ICAgICBcInZhcnBcIixcbiAgICBcInN0ZGV2cFwiOiAgIFwic3RkZXZwXCIsXG4gICAgXCJtZWRpYW5cIjogICBcIm1lZGlhblwiXG4gIH07XG5cbiAgLy8gQWdncmVnYXRvcnMgcGFyYW1ldGVyIGhhbmRsZWQgbWFudWFsbHkuXG4gIHRoaXMuX2ZpZWxkc0RlZiAgID0gbnVsbDtcbiAgdGhpcy5fQWdncmVnYXRvcnMgPSBudWxsO1xuICB0aGlzLl9zaW5nbGV0b24gICA9IGZhbHNlOyAgLy8gSWYgdHJ1ZSwgYWxsIGZpZWxkcyBhZ2dyZWdhdGVkIHdpdGhpbiBhIHNpbmdsZSBtb25vaWRcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEFnZ3JlZ2F0ZS5wcm90b3R5cGUgPSBuZXcgR3JvdXBCeSgpKTtcblxucHJvdG8uZmllbGRzID0ge1xuICBzZXQ6IGZ1bmN0aW9uKHRyYW5zZm9ybSwgZmllbGRzKSB7XG4gICAgdmFyIGksIGxlbiwgZiwgc2lnbmFscyA9IHt9O1xuICAgIGZvcihpPTAsIGxlbj1maWVsZHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBmID0gZmllbGRzW2ldO1xuICAgICAgaWYoZi5uYW1lLnNpZ25hbCkgc2lnbmFsc1tmLm5hbWUuc2lnbmFsXSA9IDE7XG4gICAgICBkbC5hcnJheShmLm9wcykuZm9yRWFjaChmdW5jdGlvbihvKXsgaWYoby5zaWduYWwpIHNpZ25hbHNbby5zaWduYWxdID0gMSB9KTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0uX2ZpZWxkc0RlZiA9IGZpZWxkcztcbiAgICB0cmFuc2Zvcm0uX0FnZ3JlZ2F0b3JzID0gbnVsbDtcbiAgICB0cmFuc2Zvcm0uYWdncygpO1xuICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgZGwua2V5cyhzaWduYWxzKSk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgfVxufTtcblxucHJvdG8uc2luZ2xldG9uID0gZnVuY3Rpb24oYykge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3NpbmdsZXRvbjtcbiAgdGhpcy5fc2luZ2xldG9uID0gYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hZ2dzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSB0aGlzLFxuICAgICAgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIGZpZWxkcyA9IHRoaXMuX2ZpZWxkc0RlZixcbiAgICAgIGFnZ3MgPSB0aGlzLl9BZ2dyZWdhdG9ycyxcbiAgICAgIGYsIGksIGssIG5hbWUsIG9wcywgbWVhc3VyZXM7XG5cbiAgaWYoYWdncykgcmV0dXJuIGFnZ3M7XG4gIGVsc2UgYWdncyA9IHRoaXMuX0FnZ3JlZ2F0b3JzID0gW107IFxuXG4gIGZvciAoaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBmID0gZmllbGRzW2ldO1xuICAgIGlmIChmLm9wcy5sZW5ndGggPT09IDApIGNvbnRpbnVlO1xuXG4gICAgbmFtZSA9IGYubmFtZS5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoZi5uYW1lLnNpZ25hbCkgOiBmLm5hbWU7XG4gICAgb3BzICA9IGRsLmFycmF5KGYub3BzLnNpZ25hbCA/IGdyYXBoLnNpZ25hbFJlZihmLm9wcy5zaWduYWwpIDogZi5vcHMpO1xuICAgIG1lYXN1cmVzID0gb3BzLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICBhID0gYS5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoYS5zaWduYWwpIDogYTtcbiAgICAgIHJldHVybiBtZWFzW2FdKG5hbWUgKyAnXycgKyB0cmFuc2Zvcm0uX291dHB1dFthXSk7XG4gICAgfSk7XG4gICAgYWdncy5wdXNoKHtcbiAgICAgIGFjY2Vzc29yOiBkbC5hY2Nlc3NvcihuYW1lKSxcbiAgICAgIGZpZWxkOiB0aGlzLl9zaW5nbGV0b24gPyBDLlNJTkdMRVRPTiA6IG5hbWUsXG4gICAgICBtZWFzdXJlczogbWVhcy5jcmVhdGUobWVhc3VyZXMpXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYWdncztcbn07XG5cbnByb3RvLl9yZXNldCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQpIHtcbiAgdGhpcy5fQWdncmVnYXRvcnMgPSBudWxsOyAvLyByZWJ1aWxkIGFnZ3JlZ2F0b3JzXG4gIHRoaXMuYWdncygpO1xuICByZXR1cm4gR3JvdXBCeS5wcm90b3R5cGUuX3Jlc2V0LmNhbGwodGhpcywgaW5wdXQsIG91dHB1dCk7XG59O1xuXG5wcm90by5fa2V5cyA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHRoaXMuX2diLmZpZWxkcy5sZW5ndGggPyBcbiAgICBHcm91cEJ5LnByb3RvdHlwZS5fa2V5cy5jYWxsKHRoaXMsIHgpIDoge2tleXM6IFtdLCBrZXk6IFwiXCJ9O1xufTtcblxucHJvdG8uX25ld19jZWxsID0gZnVuY3Rpb24oeCwgaykge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9uZXdfY2VsbC5jYWxsKHRoaXMsIHgsIGspLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgaSA9IDAsIGxlbiA9IGFnZ3MubGVuZ3RoLCBcbiAgICAgIGFnZztcblxuICBmb3IoOyBpPGxlbjsgaSsrKSB7XG4gICAgYWdnID0gYWdnc1tpXTtcbiAgICBjZWxsW2FnZy5maWVsZF0gPSBuZXcgYWdnLm1lYXN1cmVzKGNlbGwsIGNlbGwudHBsKTtcbiAgfVxuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGMgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgaSA9IDAsIGxlbiA9IGFnZ3MubGVuZ3RoLFxuICAgICAgYWdnO1xuXG4gIGMuY250Kys7XG4gIGZvcig7IGk8bGVuOyBpKyspIHtcbiAgICBhZ2cgPSBhZ2dzW2ldO1xuICAgIGNbYWdnLmZpZWxkXS5hZGQoYWdnLmFjY2Vzc29yKHgpKTtcbiAgfVxuICBjLmZsZyB8PSBDLk1PRF9DRUxMO1xufTtcblxucHJvdG8uX3JlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGMgPSB0aGlzLl9jZWxsKHgpLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgaSA9IDAsIGxlbiA9IGFnZ3MubGVuZ3RoLFxuICAgICAgYWdnO1xuXG4gIGMuY250LS07XG4gIGZvcig7IGk8bGVuOyBpKyspIHtcbiAgICBhZ2cgPSBhZ2dzW2ldO1xuICAgIGNbYWdnLmZpZWxkXS5yZW0oYWdnLmFjY2Vzc29yKHgpKTtcbiAgfVxuICBjLmZsZyB8PSBDLk1PRF9DRUxMO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJhZ2dyZWdhdGVcIl0pO1xuXG4gIHRoaXMuX2diID0gdGhpcy5ncm91cF9ieS5nZXQodGhpcy5fZ3JhcGgpO1xuXG4gIHZhciBvdXRwdXQgPSBHcm91cEJ5LnByb3RvdHlwZS50cmFuc2Zvcm0uY2FsbCh0aGlzLCBpbnB1dCwgcmVzZXQpLFxuICAgICAgYWdncyA9IHRoaXMuYWdncygpLFxuICAgICAgbGVuID0gYWdncy5sZW5ndGgsXG4gICAgICBpLCBrLCBjO1xuXG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKCFjKSBjb250aW51ZTtcbiAgICBmb3IoaT0wOyBpPGxlbjsgaSsrKSB7XG4gICAgICBjW2FnZ3NbaV0uZmllbGRdLnNldCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQmF0Y2hUcmFuc2Zvcm0oKSB7XG59XG5cbnZhciBwcm90byA9IChCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLlxuICAvLyBUT0RPOiBlZmZpY2llbnRseSBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG4gIHZhciBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKTtcbiAgcmV0dXJuIHRoaXMuYmF0Y2hUcmFuc2Zvcm0oaW5wdXQsIGRhdGEpO1xufTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFRyYW5zZm9ybTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gQmluKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBtaW46IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIG1heDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgc3RlcDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgbWF4Ymluczoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMjB9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcImJpblwiOiBcImJpblwifTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChCaW4ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQuYmluO1xuICAgICAgXG4gIHZhciBiID0gZGwuYmlucyh7XG4gICAgbWluOiB0aGlzLm1pbi5nZXQoKSxcbiAgICBtYXg6IHRoaXMubWF4LmdldCgpLFxuICAgIHN0ZXA6IHRoaXMuc3RlcC5nZXQoKSxcbiAgICBtYXhiaW5zOiB0aGlzLm1heGJpbnMuZ2V0KClcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGQpIHtcbiAgICB2YXIgdiA9IHRyYW5zZm9ybS5maWVsZC5nZXQoKS5hY2Nlc3NvcihkKTtcbiAgICB2ID0gdiA9PSBudWxsID8gbnVsbFxuICAgICAgOiBiLnN0YXJ0ICsgYi5zdGVwICogfn4oKHYgLSBiLnN0YXJ0KSAvIGIuc3RlcCk7XG4gICAgdHVwbGUuc2V0KGQsIG91dHB1dCwgdiwgaW5wdXQuc3RhbXApO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW47XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIENyb3NzKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgZGlhZ29uYWw6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwidHJ1ZVwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XCJsZWZ0XCI6IFwiYVwiLCBcInJpZ2h0XCI6IFwiYlwifTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHRoaXMuX2xhc3RSZW0gID0gbnVsbDsgLy8gTW9zdCByZWNlbnQgc3RhbXAgdGhhdCByZW0gb2NjdXJlZC4gXG4gIHRoaXMuX2xhc3RXaXRoID0gbnVsbDsgLy8gTGFzdCB0aW1lIHdlIGNyb3NzZWQgdy93aXRoZHMuXG4gIHRoaXMuX2lkcyAgID0ge307XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQ3Jvc3MucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuLy8gRWFjaCBjYWNoZWQgaW5jb21pbmcgdHVwbGUgYWxzbyBoYXMgYSBzdGFtcCB0byB0cmFjayBpZiB3ZSBuZWVkIHRvIGRvXG4vLyBsYXp5IGZpbHRlcmluZyBvZiByZW1vdmVkIHR1cGxlcy5cbmZ1bmN0aW9uIGNhY2hlKHgsIHQpIHtcbiAgdmFyIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwge2M6IFtdLCBzOiB0aGlzLl9zdGFtcH07XG4gIGMuYy5wdXNoKHQpO1xufVxuXG5mdW5jdGlvbiBhZGQob3V0cHV0LCBsZWZ0LCB3ZGF0YSwgZGlhZywgeCkge1xuICB2YXIgZGF0YSA9IGxlZnQgPyB3ZGF0YSA6IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksIC8vIExlZnQgdHVwbGVzIGNyb3NzIHcvcmlnaHQuXG4gICAgICBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBwcmV2ICA9IHguX3ByZXYgIT09IHVuZGVmaW5lZCA/IG51bGwgOiB1bmRlZmluZWQsIFxuICAgICAgdCwgeSwgaWQ7XG5cbiAgZm9yKDsgaTxsZW47ICsraSkge1xuICAgIHkgPSBkYXRhW2ldO1xuICAgIGlkID0gbGVmdCA/IHguX2lkK1wiX1wiK3kuX2lkIDogeS5faWQrXCJfXCIreC5faWQ7XG4gICAgaWYodGhpcy5faWRzW2lkXSkgY29udGludWU7XG4gICAgaWYoeC5faWQgPT0geS5faWQgJiYgIWRpYWcpIGNvbnRpbnVlO1xuXG4gICAgdCA9IHR1cGxlLmluZ2VzdCh7fSwgcHJldik7XG4gICAgdFt0aGlzLl9vdXRwdXQubGVmdF0gID0gbGVmdCA/IHggOiB5O1xuICAgIHRbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IGxlZnQgPyB5IDogeDtcbiAgICBvdXRwdXQuYWRkLnB1c2godCk7XG4gICAgY2FjaGUuY2FsbCh0aGlzLCB4LCB0KTtcbiAgICBjYWNoZS5jYWxsKHRoaXMsIHksIHQpO1xuICAgIHRoaXMuX2lkc1tpZF0gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vZChvdXRwdXQsIGxlZnQsIHgpIHtcbiAgdmFyIGNyb3NzID0gdGhpcyxcbiAgICAgIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF07XG5cbiAgaWYodGhpcy5fbGFzdFJlbSA+IGMucykgeyAgLy8gUmVtb3ZlZCB0dXBsZXMgaGF2ZW4ndCBiZWVuIGZpbHRlcmVkIHlldFxuICAgIGMuYyA9IGMuYy5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIHQgPSB5W2Nyb3NzLl9vdXRwdXRbbGVmdCA/IFwicmlnaHRcIiA6IFwibGVmdFwiXV07XG4gICAgICByZXR1cm4gY3Jvc3MuX2NhY2hlW3QuX2lkXSAhPT0gbnVsbDtcbiAgICB9KTtcbiAgICBjLnMgPSB0aGlzLl9sYXN0UmVtO1xuICB9XG5cbiAgb3V0cHV0Lm1vZC5wdXNoLmFwcGx5KG91dHB1dC5tb2QsIGMuYyk7XG59XG5cbmZ1bmN0aW9uIHJlbShvdXRwdXQsIHgpIHtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW3guX2lkXS5jKTtcbiAgdGhpcy5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgdGhpcy5fbGFzdFJlbSA9IHRoaXMuX3N0YW1wO1xufVxuXG5mdW5jdGlvbiB1cEZpZWxkcyhpbnB1dCwgb3V0cHV0KSB7XG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmxlZnRdICA9IDE7IFxuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IDE7XG4gIH1cbn1cblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImNyb3NzaW5nXCJdKTtcblxuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLiBUT0RPOiBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG5cbiAgdmFyIHcgPSB0aGlzLndpdGguZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGRpYWcgPSB0aGlzLmRpYWdvbmFsLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBzZWxmQ3Jvc3MgPSAoIXcubmFtZSksXG4gICAgICBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSxcbiAgICAgIHdvdXRwdXQgPSBzZWxmQ3Jvc3MgPyBpbnB1dCA6IHcuc291cmNlLmxhc3QoKSxcbiAgICAgIHdkYXRhICAgPSBzZWxmQ3Jvc3MgPyBkYXRhIDogdy5zb3VyY2UudmFsdWVzKCksXG4gICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICByID0gcmVtLmJpbmQodGhpcywgb3V0cHV0KTsgXG5cbiAgaW5wdXQucmVtLmZvckVhY2gocik7XG4gIGlucHV0LmFkZC5mb3JFYWNoKGFkZC5iaW5kKHRoaXMsIG91dHB1dCwgdHJ1ZSwgd2RhdGEsIGRpYWcpKTtcblxuICBpZighc2VsZkNyb3NzICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0V2l0aCkge1xuICAgIHdvdXRwdXQucmVtLmZvckVhY2gocik7XG4gICAgd291dHB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlLCBkYXRhLCBkaWFnKSk7XG4gICAgd291dHB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlKSk7XG4gICAgdXBGaWVsZHMuY2FsbCh0aGlzLCB3b3V0cHV0LCBvdXRwdXQpO1xuICAgIHRoaXMuX2xhc3RXaXRoID0gd291dHB1dC5zdGFtcDtcbiAgfVxuXG4gIC8vIE1vZHMgbmVlZCB0byBjb21lIGFmdGVyIGFsbCByZW1vdmFscyBoYXZlIGJlZW4gcnVuLlxuICBpbnB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUpKTtcbiAgdXBGaWVsZHMuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcm9zczsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmFjZXQoZ3JhcGgpIHtcbiAgR3JvdXBCeS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge2tleXM6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSB9KTtcblxuICB0aGlzLl9waXBlbGluZSA9IFtdO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZhY2V0LnByb3RvdHlwZSA9IG5ldyBHcm91cEJ5KCkpO1xuXG5wcm90by5waXBlbGluZSA9IGZ1bmN0aW9uKHBpcGVsaW5lKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGlwZWxpbmU7XG4gIHRoaXMuX3BpcGVsaW5lID0gcGlwZWxpbmU7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB2YXIgaywgYztcbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoIWMpIGNvbnRpbnVlO1xuICAgIG91dHB1dC5yZW0ucHVzaChjLnRwbCk7XG4gICAgYy5kZWxldGUoKTtcbiAgfVxuICB0aGlzLl9jZWxscyA9IHt9O1xufTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgcmV0dXJuIHR1cGxlLmluZ2VzdChrLCBudWxsKTtcbn07XG5cbnByb3RvLl9uZXdfY2VsbCA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgLy8gUmF0aGVyIHRoYW4gc2hhcmluZyB0aGUgcGlwZWxpbmUgYmV0d2VlbiBhbGwgbm9kZXMsXG4gIC8vIGdpdmUgZWFjaCBjZWxsIGl0cyBpbmRpdmlkdWFsIHBpcGVsaW5lLiBUaGlzIGFsbG93c1xuICAvLyBkeW5hbWljYWxseSBhZGRlZCBjb2xsZWN0b3JzIHRvIGRvIHRoZSByaWdodCB0aGluZ1xuICAvLyB3aGVuIHdpcmluZyB1cCB0aGUgcGlwZWxpbmVzLlxuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9uZXdfY2VsbC5jYWxsKHRoaXMsIHgsIGspLFxuICAgICAgcGlwZWxpbmUgPSB0aGlzLl9waXBlbGluZS5tYXAoZnVuY3Rpb24obikgeyByZXR1cm4gbi5jbG9uZSgpOyB9KSxcbiAgICAgIGZhY2V0ID0gdGhpcyxcbiAgICAgIHQgPSBjZWxsLnRwbDtcblxuICBjZWxsLmRzID0gdGhpcy5fZ3JhcGguZGF0YShcInZnX1wiK3QuX2lkLCBwaXBlbGluZSwgdCk7XG4gIGNlbGwuZGVsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoe30sIFtcImRlbGV0aW5nIGNlbGxcIiwgay5rZXldKTtcbiAgICBmYWNldC5yZW1vdmVMaXN0ZW5lcihwaXBlbGluZVswXSk7XG4gICAgZmFjZXQuX2dyYXBoLmRpc2Nvbm5lY3QocGlwZWxpbmUpO1xuICB9O1xuXG4gIHRoaXMuYWRkTGlzdGVuZXIocGlwZWxpbmVbMF0pO1xuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSBHcm91cEJ5LnByb3RvdHlwZS5fYWRkLmNhbGwodGhpcywgeCk7XG4gIGNlbGwuZHMuX2lucHV0LmFkZC5wdXNoKHgpO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9tb2QgPSBmdW5jdGlvbih4LCByZXNldCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9tb2QuY2FsbCh0aGlzLCB4LCByZXNldCk7XG4gIGlmKCEoY2VsbC5mbGcgJiBDLkFERF9DRUxMKSkgY2VsbC5kcy5faW5wdXQubW9kLnB1c2goeCk7IC8vIFByb3BhZ2F0ZSB0dXBsZXNcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9yZW0uY2FsbCh0aGlzLCB4KTtcbiAgY2VsbC5kcy5faW5wdXQucmVtLnB1c2goeCk7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmYWNldGluZ1wiXSk7XG5cbiAgdGhpcy5fZ2IgPSB0aGlzLmtleXMuZ2V0KHRoaXMuX2dyYXBoKTtcblxuICB2YXIgb3V0cHV0ID0gR3JvdXBCeS5wcm90b3R5cGUudHJhbnNmb3JtLmNhbGwodGhpcywgaW5wdXQsIHJlc2V0KSxcbiAgICAgIGssIGM7XG5cbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoYyA9PSBudWxsKSBjb250aW51ZTtcbiAgICBpZihjLmNudCA9PT0gMCkge1xuICAgICAgYy5kZWxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvcGFnYXRlIHNvcnQsIHNpZ25hbHMsIGZpZWxkcywgZXRjLlxuICAgICAgY2hhbmdlc2V0LmNvcHkoaW5wdXQsIGMuZHMuX2lucHV0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNldDsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmlsdGVyKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge3Rlc3Q6IHt0eXBlOiBcImV4cHJcIn0gfSk7XG5cbiAgdGhpcy5fc2tpcCA9IHt9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZpbHRlci5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiB0ZXN0KHgpIHtcbiAgcmV0dXJuIGV4cHIuZXZhbCh0aGlzLl9ncmFwaCwgdGhpcy50ZXN0LmdldCh0aGlzLl9ncmFwaCksIFxuICAgIHgsIG51bGwsIG51bGwsIG51bGwsIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMpKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmaWx0ZXJpbmdcIl0pO1xuICB2YXIgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBza2lwID0gdGhpcy5fc2tpcCxcbiAgICAgIGYgPSB0aGlzO1xuXG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoc2tpcFt4Ll9pZF0gIT09IDEpIG91dHB1dC5yZW0ucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMDtcbiAgfSk7XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmICh0ZXN0LmNhbGwoZiwgeCkpIG91dHB1dC5hZGQucHVzaCh4KTtcbiAgICBlbHNlIHNraXBbeC5faWRdID0gMTtcbiAgfSk7XG5cbiAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciBiID0gdGVzdC5jYWxsKGYsIHgpLFxuICAgICAgICBzID0gKHNraXBbeC5faWRdID09PSAxKTtcbiAgICBpZiAoYiAmJiBzKSB7XG4gICAgICBza2lwW3guX2lkXSA9IDA7XG4gICAgICBvdXRwdXQuYWRkLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmIChiICYmICFzKSB7XG4gICAgICBvdXRwdXQubW9kLnB1c2goeCk7XG4gICAgfSBlbHNlIGlmICghYiAmJiBzKSB7XG4gICAgICAvLyBkbyBub3RoaW5nLCBrZWVwIHNraXAgdHJ1ZVxuICAgIH0gZWxzZSB7IC8vICFiICYmICFzXG4gICAgICBvdXRwdXQucmVtLnB1c2goeCk7XG4gICAgICBza2lwW3guX2lkXSA9IDE7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWx0ZXI7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksIFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIEZvbGQoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGRzOiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0gXG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtrZXk6IFwia2V5XCIsIHZhbHVlOiBcInZhbHVlXCJ9O1xuICB0aGlzLl9jYWNoZSA9IHt9O1xuXG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKS5yZXZpc2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoRm9sZC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiByc3QoaW5wdXQsIG91dHB1dCkgeyBcbiAgZm9yKHZhciBpZCBpbiB0aGlzLl9jYWNoZSkgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW2lkXSk7XG4gIHRoaXMuX2NhY2hlID0ge307XG59O1xuXG5mdW5jdGlvbiBnZXRfdHVwbGUoeCwgaSwgbGVuKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5fY2FjaGVbeC5faWRdIHx8ICh0aGlzLl9jYWNoZVt4Ll9pZF0gPSBBcnJheShsZW4pKTtcbiAgcmV0dXJuIGxpc3RbaV0gfHwgKGxpc3RbaV0gPSB0dXBsZS5kZXJpdmUoeCwgeC5fcHJldikpO1xufTtcblxuZnVuY3Rpb24gZm4oZGF0YSwgZmllbGRzLCBhY2Nlc3NvcnMsIG91dCwgc3RhbXApIHtcbiAgdmFyIGkgPSAwLCBkbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBqLCBmbGVuID0gZmllbGRzLmxlbmd0aCxcbiAgICAgIGQsIHQ7XG5cbiAgZm9yKDsgaTxkbGVuOyArK2kpIHtcbiAgICBkID0gZGF0YVtpXTtcbiAgICBmb3Ioaj0wOyBqPGZsZW47ICsraikge1xuICAgICAgdCA9IGdldF90dXBsZS5jYWxsKHRoaXMsIGQsIGosIGZsZW4pOyAgXG4gICAgICB0dXBsZS5zZXQodCwgdGhpcy5fb3V0cHV0LmtleSwgZmllbGRzW2pdKTtcbiAgICAgIHR1cGxlLnNldCh0LCB0aGlzLl9vdXRwdXQudmFsdWUsIGFjY2Vzc29yc1tqXShkKSk7XG4gICAgICBvdXQucHVzaCh0KTtcbiAgICB9ICAgICAgXG4gIH1cbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiZm9sZGluZ1wiXSk7XG5cbiAgdmFyIGZvbGQgPSB0aGlzLFxuICAgICAgb24gPSB0aGlzLmZpZWxkcy5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgZmllbGRzID0gb24uZmllbGRzLCBhY2Nlc3NvcnMgPSBvbi5hY2Nlc3NvcnMsXG4gICAgICBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICBpZihyZXNldCkgcnN0LmNhbGwodGhpcywgaW5wdXQsIG91dHB1dCk7XG5cbiAgZm4uY2FsbCh0aGlzLCBpbnB1dC5hZGQsIGZpZWxkcywgYWNjZXNzb3JzLCBvdXRwdXQuYWRkLCBpbnB1dC5zdGFtcCk7XG4gIGZuLmNhbGwodGhpcywgaW5wdXQubW9kLCBmaWVsZHMsIGFjY2Vzc29ycywgcmVzZXQgPyBvdXRwdXQuYWRkIDogb3V0cHV0Lm1vZCwgaW5wdXQuc3RhbXApO1xuICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIGZvbGQuX2NhY2hlW3guX2lkXSk7XG4gICAgZm9sZC5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgfSk7XG5cbiAgLy8gSWYgd2UncmUgb25seSBwcm9wYWdhdGluZyB2YWx1ZXMsIGRvbid0IG1hcmsga2V5L3ZhbHVlIGFzIHVwZGF0ZWQuXG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCB8fCBcbiAgICBmaWVsZHMuc29tZShmdW5jdGlvbihmKSB7IHJldHVybiAhIWlucHV0LmZpZWxkc1tmXTsgfSkpXG4gICAgICBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC5rZXldID0gMSwgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQudmFsdWVdID0gMTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9sZDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gRm9yY2UoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc2l6ZToge3R5cGU6IFwiYXJyYXk8dmFsdWU+XCIsIGRlZmF1bHQ6IFs1MDAsIDUwMF19LFxuICAgIGxpbmtzOiB7dHlwZTogXCJkYXRhXCJ9LFxuICAgIGxpbmtEaXN0YW5jZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMjB9LFxuICAgIGxpbmtTdHJlbmd0aDoge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogMX0sXG4gICAgY2hhcmdlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAzMH0sXG4gICAgY2hhcmdlRGlzdGFuY2U6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IEluZmluaXR5fSxcbiAgICBpdGVyYXRpb25zOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiA1MDB9LFxuICAgIGZyaWN0aW9uOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjl9LFxuICAgIHRoZXRhOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjh9LFxuICAgIGdyYXZpdHk6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMX0sXG4gICAgYWxwaGE6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMX1cbiAgfSk7XG5cbiAgdGhpcy5fbm9kZXMgPSBbXTtcbiAgdGhpcy5fbGlua3MgPSBbXTtcbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LmZvcmNlKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiBcImxheW91dDp4XCIsXG4gICAgXCJ5XCI6IFwibGF5b3V0OnlcIixcbiAgICBcInNvdXJjZVwiOiBcIl9zb3VyY2VcIixcbiAgICBcInRhcmdldFwiOiBcIl90YXJnZXRcIlxuICB9O1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRm9yY2UucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gZ2V0KHRyYW5zZm9ybSwgbmFtZSkge1xuICB2YXIgdiA9IHRyYW5zZm9ybVtuYW1lXS5nZXQodHJhbnNmb3JtLl9ncmFwaCk7XG4gIHJldHVybiB2LmFjY2Vzc29yXG4gICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiB2LmFjY2Vzc29yKHgudHVwbGUpOyB9XG4gICAgOiB2LmZpZWxkO1xufVxuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihub2RlSW5wdXQpIHtcbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgbGlua0lucHV0ID0gdGhpcy5saW5rcy5nZXQoZykuc291cmNlLmxhc3QoKSxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIG5vZGVzID0gdGhpcy5fbm9kZXMsXG4gICAgICBsaW5rcyA9IHRoaXMuX2xpbmtzLFxuICAgICAgaXRlciA9IHRoaXMuaXRlcmF0aW9ucy5nZXQoZyk7XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBub2Rlc1xuICBub2RlSW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIG5vZGVzLnB1c2goe3R1cGxlOiBufSk7XG4gIH0pO1xuXG4gIC8vIHByb2Nlc3MgYWRkZWQgZWRnZXNcbiAgbGlua0lucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgbGluayA9IHtcbiAgICAgIHR1cGxlOiBsLFxuICAgICAgc291cmNlOiBub2Rlc1tsLnNvdXJjZV0sXG4gICAgICB0YXJnZXQ6IG5vZGVzW2wudGFyZ2V0XVxuICAgIH07XG4gICAgdHVwbGUuc2V0KGwsIG91dHB1dC5zb3VyY2UsIGxpbmsuc291cmNlLnR1cGxlKTtcbiAgICB0dXBsZS5zZXQobCwgb3V0cHV0LnRhcmdldCwgbGluay50YXJnZXQudHVwbGUpO1xuICAgIGxpbmtzLnB1c2gobGluayk7XG4gIH0pO1xuXG4gIC8vIFRPRE8gcHJvY2VzcyBcIm1vZFwiIG9mIGVkZ2Ugc291cmNlIG9yIHRhcmdldD9cblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zaXplKHRoaXMuc2l6ZS5nZXQoZykpXG4gICAgLmxpbmtEaXN0YW5jZShnZXQodGhpcywgXCJsaW5rRGlzdGFuY2VcIikpXG4gICAgLmxpbmtTdHJlbmd0aChnZXQodGhpcywgXCJsaW5rU3RyZW5ndGhcIikpXG4gICAgLmNoYXJnZShnZXQodGhpcywgXCJjaGFyZ2VcIikpXG4gICAgLmNoYXJnZURpc3RhbmNlKGdldCh0aGlzLCBcImNoYXJnZURpc3RhbmNlXCIpKVxuICAgIC5mcmljdGlvbih0aGlzLmZyaWN0aW9uLmdldChnKSlcbiAgICAudGhldGEodGhpcy50aGV0YS5nZXQoZykpXG4gICAgLmdyYXZpdHkodGhpcy5ncmF2aXR5LmdldChnKSlcbiAgICAuYWxwaGEodGhpcy5hbHBoYS5nZXQoZykpXG4gICAgLm5vZGVzKG5vZGVzKVxuICAgIC5saW5rcyhsaW5rcyk7XG5cbiAgLy8gcnVuIGxheW91dFxuICBsYXlvdXQuc3RhcnQoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGl0ZXI7ICsraSkge1xuICAgIGxheW91dC50aWNrKCk7XG4gIH1cbiAgbGF5b3V0LnN0b3AoKTtcblxuICAvLyBjb3B5IGxheW91dCB2YWx1ZXMgdG8gbm9kZXNcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdHVwbGUuc2V0KG4udHVwbGUsIG91dHB1dC54LCBuLngpO1xuICAgIHR1cGxlLnNldChuLnR1cGxlLCBvdXRwdXQueSwgbi55KTtcbiAgfSk7XG5cbiAgLy8gcHJvY2VzcyByZW1vdmVkIG5vZGVzXG4gIGlmIChub2RlSW5wdXQucmVtLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgbm9kZUlkcyA9IHR1cGxlLmlkTWFwKG5vZGVJbnB1dC5yZW0pO1xuICAgIHRoaXMuX25vZGVzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uKG4pIHsgcmV0dXJuICFub2RlSWRzW24udHVwbGUuX2lkXTsgfSk7XG4gIH1cblxuICAvLyBwcm9jZXNzIHJlbW92ZWQgZWRnZXNcbiAgaWYgKGxpbmtJbnB1dC5yZW0ubGVuZ3RoID4gMCkge1xuICAgIHZhciBsaW5rSWRzID0gdHVwbGUuaWRNYXAobGlua0lucHV0LnJlbSk7XG4gICAgdGhpcy5fbGlua3MgPSBsaW5rcy5maWx0ZXIoZnVuY3Rpb24obCkgeyByZXR1cm4gIWxpbmtJZHNbbC50dXBsZS5faWRdOyB9KTtcbiAgfVxuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgbm9kZUlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBub2RlSW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBub2RlSW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSwgXG4gICAgZXhwcmVzc2lvbiA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRm9ybXVsYShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgZXhwcjogIHt0eXBlOiBcImV4cHJcIn1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGb3JtdWxhLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmb3JtdWxhdGluZ1wiXSk7XG4gIHZhciB0ID0gdGhpcywgXG4gICAgICBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBmaWVsZCA9IHRoaXMuZmllbGQuZ2V0KGcpLFxuICAgICAgZXhwciA9IHRoaXMuZXhwci5nZXQoZyksXG4gICAgICBkZXBzID0gdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG4gIFxuICBmdW5jdGlvbiBzZXQoeCkge1xuICAgIHZhciB2YWwgPSBleHByZXNzaW9uLmV2YWwoZywgZXhwciwgeCwgbnVsbCwgbnVsbCwgbnVsbCwgZGVwcyk7XG4gICAgdHVwbGUuc2V0KHgsIGZpZWxkLCB2YWwpO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgXG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tmaWVsZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcm11bGE7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIEdlbyhncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGxvbjoge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgbGF0OiB7dHlwZTogXCJmaWVsZFwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6IFwiZ2VvOnhcIixcbiAgICBcInlcIjogXCJnZW86eVwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgTm9uZVxuXG5HZW8uUGFyYW1ldGVycyA9IHtcbiAgcHJvamVjdGlvbjoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJtZXJjYXRvclwifSxcbiAgY2VudGVyOiAgICAge3R5cGU6IFwiYXJyYXlbdmFsdWVdXCJ9LFxuICB0cmFuc2xhdGU6ICB7dHlwZTogXCJhcnJheVt2YWx1ZV1cIn0sXG4gIHJvdGF0ZTogICAgIHt0eXBlOiBcImFycmF5W3ZhbHVlXVwifSxcbiAgc2NhbGU6ICAgICAge3R5cGU6IFwidmFsdWVcIn0sXG4gIHByZWNpc2lvbjogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICBjbGlwQW5nbGU6ICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgY2xpcEV4dGVudDoge3R5cGU6IFwidmFsdWVcIn1cbn07XG5cbkdlby5kM1Byb2plY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIHAgPSB0aGlzLnByb2plY3Rpb24uZ2V0KGcpLFxuICAgICAgcGFyYW0gPSBHZW8uUGFyYW1ldGVycyxcbiAgICAgIHByb2osIG5hbWUsIHZhbHVlO1xuXG4gIGlmIChwICE9PSB0aGlzLl9tb2RlKSB7XG4gICAgdGhpcy5fbW9kZSA9IHA7XG4gICAgdGhpcy5fcHJvamVjdGlvbiA9IGQzLmdlb1twXSgpO1xuICB9XG4gIHByb2ogPSB0aGlzLl9wcm9qZWN0aW9uO1xuXG4gIGZvciAobmFtZSBpbiBwYXJhbSkge1xuICAgIGlmIChuYW1lID09PSBcInByb2plY3Rpb25cIiB8fCAhcHJvaltuYW1lXSkgY29udGludWU7XG4gICAgdmFsdWUgPSB0aGlzW25hbWVdLmdldChnKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCAoZGwuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gcHJvaltuYW1lXSgpKSB7XG4gICAgICBwcm9qW25hbWVdKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvajtcbn07XG5cbnZhciBwcm90byA9IChHZW8ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGxvbiA9IHRoaXMubG9uLmdldChnKS5hY2Nlc3NvcixcbiAgICAgIGxhdCA9IHRoaXMubGF0LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHByb2ogPSBHZW8uZDNQcm9qZWN0aW9uLmNhbGwodGhpcyk7XG5cbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgbGwgPSBbbG9uKHQpLCBsYXQodCldO1xuICAgIHZhciB4eSA9IHByb2oobGwpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQueCwgeHlbMF0pO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQueSwgeHlbMV0pO1xuICB9XG5cbiAgaW5wdXQuYWRkLmZvckVhY2goc2V0KTtcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICAgIGlucHV0LnJlbS5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgR2VvID0gcmVxdWlyZSgnLi9HZW8nKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gR2VvUGF0aChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIEdlby5QYXJhbWV0ZXJzKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHZhbHVlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBudWxsfSxcbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwicGF0aFwiOiBcImdlbzpwYXRoXCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHZW9QYXRoLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBnZW9qc29uID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IgfHwgZGwuaWRlbnRpdHksXG4gICAgICBwcm9qID0gR2VvLmQzUHJvamVjdGlvbi5jYWxsKHRoaXMpLFxuICAgICAgcGF0aCA9IGQzLmdlby5wYXRoKCkucHJvamVjdGlvbihwcm9qKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aChnZW9qc29uKHQpKSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQucGF0aF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb1BhdGg7XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnkoZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIHRoaXMuaW5pdChncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoR3JvdXBCeS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdGhpcy5fZ2IgPSBudWxsOyAvLyBmaWVsZHMrYWNjZXNzb3JzIHRvIGdyb3VwYnkgZmllbGRzXG4gIHRoaXMuX2NlbGxzID0ge307XG4gIHJldHVybiBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpLnJldmlzZXModHJ1ZSk7XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jZWxsczsgfTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB2YXIgaywgYztcbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBpZighKGMgPSB0aGlzLl9jZWxsc1trXSkpIGNvbnRpbnVlO1xuICAgIG91dHB1dC5yZW0ucHVzaChjLnRwbCk7XG4gIH1cbiAgdGhpcy5fY2VsbHMgPSB7fTtcbn07XG5cbnByb3RvLl9rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYWNjID0gdGhpcy5fZ2IuYWNjZXNzb3JzIHx8IFt0aGlzLl9nYi5hY2Nlc3Nvcl07XG4gIHZhciBrZXlzID0gYWNjLnJlZHVjZShmdW5jdGlvbihnLCBmKSB7XG4gICAgcmV0dXJuICgodiA9IGYoeCkpICE9PSB1bmRlZmluZWQpID8gKGcucHVzaCh2KSwgZykgOiBnO1xuICB9LCBbXSksIGsgPSBrZXlzLmpvaW4oXCJ8XCIpLCB2O1xuICByZXR1cm4ga2V5cy5sZW5ndGggPiAwID8ge2tleXM6IGtleXMsIGtleToga30gOiB1bmRlZmluZWQ7XG59O1xuXG5wcm90by5fY2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGsgPSB0aGlzLl9rZXlzKHgpO1xuICByZXR1cm4gdGhpcy5fY2VsbHNbay5rZXldIHx8ICh0aGlzLl9jZWxsc1trLmtleV0gPSB0aGlzLl9uZXdfY2VsbCh4LCBrKSk7XG59O1xuXG5wcm90by5fbmV3X2NlbGwgPSBmdW5jdGlvbih4LCBrKSB7XG4gIHJldHVybiB7XG4gICAgY250OiAwLFxuICAgIHRwbDogdGhpcy5fbmV3X3R1cGxlKHgsIGspLFxuICAgIGZsZzogQy5BRERfQ0VMTFxuICB9O1xufTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgdmFyIGdiID0gdGhpcy5fZ2IsXG4gICAgICBmaWVsZHMgPSBnYi5maWVsZHMgfHwgW2diLmZpZWxkXSxcbiAgICAgIGFjYyA9IGdiLmFjY2Vzc29ycyB8fCBbZ2IuYWNjZXNzb3JdLFxuICAgICAgdCA9IHt9LCBpLCBsZW47XG5cbiAgZm9yKGk9MCwgbGVuPWZpZWxkcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB0W2ZpZWxkc1tpXV0gPSBhY2NbaV0oeCk7XG4gIH0gXG5cbiAgcmV0dXJuIHR1cGxlLmluZ2VzdCh0LCBudWxsKTtcbn07XG5cbnByb3RvLl9hZGQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KTtcbiAgY2VsbC5jbnQgKz0gMTtcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCk7XG4gIGNlbGwuY250IC09IDE7XG4gIGNlbGwuZmxnIHw9IEMuTU9EX0NFTEw7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX21vZCA9IGZ1bmN0aW9uKHgsIHJlc2V0KSB7XG4gIGlmKHguX3ByZXYgJiYgeC5fcHJldiAhPT0gQy5TRU5USU5FTCAmJiB0aGlzLl9rZXlzKHguX3ByZXYpICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLl9yZW0oeC5fcHJldik7XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh4KTtcbiAgfSBlbHNlIGlmKHJlc2V0KSB7IC8vIFNpZ25hbCBjaGFuZ2UgdHJpZ2dlcmVkIHJlZmxvd1xuICAgIHJldHVybiB0aGlzLl9hZGQoeCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2NlbGwoeCk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgdmFyIGdyb3VwQnkgPSB0aGlzLFxuICAgICAgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICBrLCBjLCBmLCB0O1xuXG4gIGlmKHJlc2V0KSB0aGlzLl9yZXNldChpbnB1dCwgb3V0cHV0KTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7IGdyb3VwQnkuX2FkZCh4KTsgfSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgZ3JvdXBCeS5fbW9kKHgsIHJlc2V0KTsgfSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBpZih4Ll9wcmV2ICYmIHguX3ByZXYgIT09IEMuU0VOVElORUwgJiYgZ3JvdXBCeS5fa2V5cyh4Ll9wcmV2KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBncm91cEJ5Ll9yZW0oeC5fcHJldik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwQnkuX3JlbSh4KTtcbiAgICB9XG4gIH0pO1xuXG4gIGZvcihrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgYyA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGlmKCFjKSBjb250aW51ZTtcbiAgICBmID0gYy5mbGc7XG4gICAgdCA9IGMudHBsO1xuXG4gICAgaWYoYy5jbnQgPT09IDApIHtcbiAgICAgIGlmKGYgPT09IEMuTU9EX0NFTEwpIG91dHB1dC5yZW0ucHVzaCh0KTtcbiAgICAgIHRoaXMuX2NlbGxzW2tdID0gbnVsbDtcbiAgICB9IGVsc2UgaWYoZiAmIEMuQUREX0NFTEwpIHtcbiAgICAgIG91dHB1dC5hZGQucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYoZiAmIEMuTU9EX0NFTEwpIHtcbiAgICAgIG91dHB1dC5tb2QucHVzaCh0KTtcbiAgICB9XG4gICAgYy5mbGcgPSAwO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JvdXBCeTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIExpbmtQYXRoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHNvdXJjZTogIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiX3NvdXJjZVwifSxcbiAgICB0YXJnZXQ6ICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcIl90YXJnZXRcIn0sXG4gICAgeDogICAgICAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJsYXlvdXQ6eFwifSxcbiAgICB5OiAgICAgICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImxheW91dDp5XCJ9LFxuICAgIHRlbnNpb246IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuMn0sXG4gICAgc2hhcGU6ICAge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJsaW5lXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcInBhdGhcIjogXCJsaW5rOnBhdGhcIn07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoTGlua1BhdGgucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gbGluZShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KTtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkxcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxuZnVuY3Rpb24gY3VydmUoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBkeCA9IHR4IC0gc3gsXG4gICAgICBkeSA9IHR5IC0gc3ksXG4gICAgICBpeCA9IHRlbnNpb24gKiAoZHggKyBkeSksXG4gICAgICBpeSA9IHRlbnNpb24gKiAoZHkgLSBkeCk7XG4gIHJldHVybiBcIk1cIiArIHN4ICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCJDXCIgKyAoc3graXgpICsgXCIsXCIgKyAoc3kraXkpXG4gICAgICAgKyBcIiBcIiArICh0eCtpeSkgKyBcIixcIiArICh0eS1peClcbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFgoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBtID0gKHN4ICsgdHgpIC8gMjtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIG0gICsgXCIsXCIgKyBzeVxuICAgICAgICsgXCIgXCIgKyBtICArIFwiLFwiICsgdHlcbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBkaWFnb25hbFkoZCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pIHtcbiAgdmFyIHMgPSBzb3VyY2UoZCksIHN4ID0geChzKSwgc3kgPSB5KHMpLFxuICAgICAgdCA9IHRhcmdldChkKSwgdHggPSB4KHQpLCB0eSA9IHkodCksXG4gICAgICBtID0gKHN5ICsgdHkpIC8gMjtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIHN4ICsgXCIsXCIgKyBtXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyBtXG4gICAgICAgKyBcIiBcIiArIHR4ICsgXCIsXCIgKyB0eTtcbn1cblxudmFyIHNoYXBlcyA9IHtcbiAgbGluZTogICAgICBsaW5lLFxuICBjdXJ2ZTogICAgIGN1cnZlLFxuICBkaWFnb25hbDogIGRpYWdvbmFsWCxcbiAgZGlhZ29uYWxYOiBkaWFnb25hbFgsXG4gIGRpYWdvbmFsWTogZGlhZ29uYWxZXG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgc2hhcGUgPSBzaGFwZXNbdGhpcy5zaGFwZS5nZXQoZyldIHx8IHNoYXBlcy5saW5lLFxuICAgICAgc291cmNlID0gdGhpcy5zb3VyY2UuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgeCA9IHRoaXMueC5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB5ID0gdGhpcy55LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHRlbnNpb24gPSB0aGlzLnRlbnNpb24uZ2V0KGcpO1xuICBcbiAgZnVuY3Rpb24gc2V0KHQpIHtcbiAgICB2YXIgcGF0aCA9IHNoYXBlKHQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKVxuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQucGF0aCwgcGF0aCk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnBhdGhdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rUGF0aDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIGFycmF5VHlwZSA9IC9hcnJheS9pLFxuICAgIGRhdGFUeXBlICA9IC9kYXRhL2ksXG4gICAgZmllbGRUeXBlID0gL2ZpZWxkL2ksXG4gICAgZXhwclR5cGUgID0gL2V4cHIvaTtcblxuZnVuY3Rpb24gUGFyYW1ldGVyKG5hbWUsIHR5cGUpIHtcbiAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIHRoaXMuX3R5cGUgPSB0eXBlO1xuXG4gIC8vIElmIHBhcmFtZXRlciBpcyBkZWZpbmVkIHcvc2lnbmFscywgaXQgbXVzdCBiZSByZXNvbHZlZFxuICAvLyBvbiBldmVyeSBwdWxzZS5cbiAgdGhpcy5fdmFsdWUgPSBbXTtcbiAgdGhpcy5fYWNjZXNzb3JzID0gW107XG4gIHRoaXMuX3Jlc29sdXRpb24gPSBmYWxzZTtcbiAgdGhpcy5fc2lnbmFscyA9IHt9O1xufVxuXG52YXIgcHJvdG8gPSBQYXJhbWV0ZXIucHJvdG90eXBlO1xuXG5wcm90by5fZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpc0FycmF5ID0gYXJyYXlUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICBpZiAoaXNEYXRhKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB7IG5hbWVzOiB0aGlzLl92YWx1ZSwgc291cmNlczogdGhpcy5fYWNjZXNzb3JzIH0gOlxuICAgICAgeyBuYW1lOiB0aGlzLl92YWx1ZVswXSwgc291cmNlOiB0aGlzLl9hY2Nlc3NvcnNbMF0gfTtcbiAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkgPyB7IGZpZWxkczogdGhpcy5fdmFsdWUsIGFjY2Vzc29yczogdGhpcy5fYWNjZXNzb3JzIH0gOlxuICAgICAgeyBmaWVsZDogdGhpcy5fdmFsdWVbMF0sIGFjY2Vzc29yOiB0aGlzLl9hY2Nlc3NvcnNbMF0gfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHRoaXMuX3ZhbHVlIDogdGhpcy5fdmFsdWVbMF07XG4gIH1cbn07XG5cbnByb3RvLmdldCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHZhciBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIHMsIGlkeCwgdmFsO1xuXG4gIC8vIElmIHdlIGRvbid0IHJlcXVpcmUgcmVzb2x1dGlvbiwgcmV0dXJuIHRoZSB2YWx1ZSBpbW1lZGlhdGVseS5cbiAgaWYgKCF0aGlzLl9yZXNvbHV0aW9uKSByZXR1cm4gdGhpcy5fZ2V0KCk7XG5cbiAgaWYgKGlzRGF0YSkge1xuICAgIHRoaXMuX2FjY2Vzc29ycyA9IHRoaXMuX3ZhbHVlLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBncmFwaC5kYXRhKHYpOyB9KTtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KCk7IC8vIFRPRE86IHN1cHBvcnQgc2lnbmFsIGFzIGRhdGFUeXBlc1xuICB9XG5cbiAgZm9yKHMgaW4gdGhpcy5fc2lnbmFscykge1xuICAgIGlkeCAgPSB0aGlzLl9zaWduYWxzW3NdO1xuICAgIHZhbCAgPSBncmFwaC5zaWduYWxSZWYocyk7XG5cbiAgICBpZiAoaXNGaWVsZCkge1xuICAgICAgdGhpcy5fYWNjZXNzb3JzW2lkeF0gPSB0aGlzLl92YWx1ZVtpZHhdICE9IHZhbCA/IFxuICAgICAgICBkbC5hY2Nlc3Nvcih2YWwpIDogdGhpcy5fYWNjZXNzb3JzW2lkeF07XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWVbaWR4XSA9IHZhbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9nZXQoKTtcbn07XG5cbnByb3RvLnNldCA9IGZ1bmN0aW9uKHRyYW5zZm9ybSwgdmFsdWUpIHtcbiAgdmFyIHBhcmFtID0gdGhpcywgXG4gICAgICBpc0V4cHIgPSBleHByVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNEYXRhICA9IGRhdGFUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0ZpZWxkID0gZmllbGRUeXBlLnRlc3QodGhpcy5fdHlwZSk7XG5cbiAgdGhpcy5fdmFsdWUgPSBkbC5hcnJheSh2YWx1ZSkubWFwKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcodikpIHtcbiAgICAgIGlmIChpc0V4cHIpIHtcbiAgICAgICAgdmFyIGUgPSBleHByKHYpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgIGUuZmllbGRzKTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBlLnNpZ25hbHMpO1xuICAgICAgICByZXR1cm4gZS5mbjtcbiAgICAgIH0gZWxzZSBpZiAoaXNGaWVsZCkgeyAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgcGFyYW0uX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLkZJRUxEUywgdik7XG4gICAgICB9IGVsc2UgaWYgKGlzRGF0YSkge1xuICAgICAgICBwYXJhbS5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuREFUQSwgdik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdjtcbiAgICB9IGVsc2UgaWYgKHYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHYudmFsdWU7XG4gICAgfSBlbHNlIGlmICh2LmZpZWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmFtLl9hY2Nlc3NvcnNbaV0gPSBkbC5hY2Nlc3Nvcih2LmZpZWxkKTtcbiAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCB2LmZpZWxkKTtcbiAgICAgIHJldHVybiB2LmZpZWxkO1xuICAgIH0gZWxzZSBpZiAodi5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW0uX3Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgcGFyYW0uX3NpZ25hbHNbdi5zaWduYWxdID0gaTtcbiAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdi5zaWduYWwpO1xuICAgICAgcmV0dXJuIHYuc2lnbmFsO1xuICAgIH1cblxuICAgIHJldHVybiB2O1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNmb3JtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJhbWV0ZXI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBCYXRjaFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vQmF0Y2hUcmFuc2Zvcm0nKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyk7XG5cbmZ1bmN0aW9uIFBpZShncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHZhbHVlOiAgICAgIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIHN0YXJ0QW5nbGU6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDB9LFxuICAgIGVuZEFuZ2xlOiAgIHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDIgKiBNYXRoLlBJfSxcbiAgICBzb3J0OiAgICAgICB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBmYWxzZX1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwic3RhcnRcIjogXCJsYXlvdXQ6c3RhcnRcIixcbiAgICBcInN0b3BcIjogIFwibGF5b3V0OnN0b3BcIixcbiAgICBcIm1pZFwiOiAgIFwibGF5b3V0Om1pZFwiXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChQaWUucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBvbmVzKCkgeyByZXR1cm4gMTsgfVxuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWUuZ2V0KGcpLmFjY2Vzc29yIHx8IG9uZXMsXG4gICAgICBzdGFydCA9IHRoaXMuc3RhcnRBbmdsZS5nZXQoZyksXG4gICAgICBzdG9wID0gdGhpcy5lbmRBbmdsZS5nZXQoZyksXG4gICAgICBzb3J0ID0gdGhpcy5zb3J0LmdldChnKTtcblxuICB2YXIgdmFsdWVzID0gZGF0YS5tYXAodmFsdWUpLFxuICAgICAgYSA9IHN0YXJ0LFxuICAgICAgayA9IChzdG9wIC0gc3RhcnQpIC8gZDMuc3VtKHZhbHVlcyksXG4gICAgICBpbmRleCA9IGRsLnJhbmdlKGRhdGEubGVuZ3RoKSxcbiAgICAgIGksIHQsIHY7XG5cbiAgaWYgKHNvcnQpIHtcbiAgICBpbmRleC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiB2YWx1ZXNbYV0gLSB2YWx1ZXNbYl07XG4gICAgfSk7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxpbmRleC5sZW5ndGg7ICsraSkge1xuICAgIHQgPSBkYXRhW2luZGV4W2ldXTtcbiAgICB2ID0gdmFsdWVzW2luZGV4W2ldXTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0LnN0YXJ0LCBhKTtcbiAgICB0dXBsZS5zZXQodCwgb3V0cHV0Lm1pZCwgKGEgKyAwLjUgKiB2ICogaykpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQuc3RvcCwgKGEgKz0gdiAqIGspKTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdG9wXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQubWlkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGllO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4uL3BhcnNlL2V4cHInKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxuZnVuY3Rpb24gU29ydChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtieToge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9IH0pO1xuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChTb3J0LnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJzb3J0aW5nXCJdKTtcblxuICBpZihpbnB1dC5hZGQubGVuZ3RoIHx8IGlucHV0Lm1vZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIGlucHV0LnNvcnQgPSBkbC5jb21wYXJhdG9yKHRoaXMuYnkuZ2V0KHRoaXMuX2dyYXBoKS5maWVsZHMpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb3J0OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gU3RhY2soZ3JhcGgpIHtcbiAgQmF0Y2hUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBncm91cGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0sXG4gICAgc29ydGJ5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0sXG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCJ9LFxuICAgIG9mZnNldDoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJ6ZXJvXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInN0YXJ0XCI6IFwibGF5b3V0OnN0YXJ0XCIsXG4gICAgXCJzdG9wXCI6ICBcImxheW91dDpzdG9wXCIsXG4gICAgXCJtaWRcIjogICBcImxheW91dDptaWRcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFN0YWNrLnByb3RvdHlwZSA9IG5ldyBCYXRjaFRyYW5zZm9ybSgpKTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgZ3JvdXBieSA9IHRoaXMuZ3JvdXBieS5nZXQoZykuYWNjZXNzb3JzLFxuICAgICAgc29ydGJ5ID0gZGwuY29tcGFyYXRvcih0aGlzLnNvcnRieS5nZXQoZykuZmllbGRzKSxcbiAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IsXG4gICAgICBvZmZzZXQgPSB0aGlzLm9mZnNldC5nZXQoZyksXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQ7XG5cbiAgLy8gcGFydGl0aW9uLCBzdW0sIGFuZCBzb3J0IHRoZSBzdGFjayBncm91cHNcbiAgdmFyIGdyb3VwcyA9IHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBzb3J0YnksIHZhbHVlKTtcblxuICAvLyBjb21wdXRlIHN0YWNrIGxheW91dHMgcGVyIGdyb3VwXG4gIGZvciAodmFyIGk9MCwgbWF4PWdyb3Vwcy5tYXg7IGk8Z3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldLFxuICAgICAgICBzdW0gPSBncm91cC5zdW0sXG4gICAgICAgIG9mZiA9IG9mZnNldD09PVwiY2VudGVyXCIgPyAobWF4IC0gc3VtKS8yIDogMCxcbiAgICAgICAgc2NhbGUgPSBvZmZzZXQ9PT1cIm5vcm1hbGl6ZVwiID8gKDEvc3VtKSA6IDEsXG4gICAgICAgIGksIHgsIGEsIGIgPSBvZmYsIHYgPSAwO1xuXG4gICAgLy8gc2V0IHN0YWNrIGNvb3JkaW5hdGVzIGZvciBlYWNoIGRhdHVtIGluIGdyb3VwXG4gICAgZm9yIChqPTA7IGo8Z3JvdXAubGVuZ3RoOyArK2opIHtcbiAgICAgIHggPSBncm91cFtqXTtcbiAgICAgIGEgPSBiOyAvLyB1c2UgcHJldmlvdXMgdmFsdWUgZm9yIHN0YXJ0IHBvaW50XG4gICAgICB2ICs9IHZhbHVlKHgpO1xuICAgICAgYiA9IHNjYWxlICogdiArIG9mZjsgLy8gY29tcHV0ZSBlbmQgcG9pbnRcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5zdG9wLCBiKTtcbiAgICAgIHR1cGxlLnNldCh4LCBvdXRwdXQubWlkLCAwLjUgKiAoYSArIGIpKTtcbiAgICB9XG4gIH1cblxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0YXJ0XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RvcF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0Lm1pZF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBwYXJ0aXRpb24oZGF0YSwgZ3JvdXBieSwgc29ydGJ5LCB2YWx1ZSkge1xuICB2YXIgZ3JvdXBzID0gW10sXG4gICAgICBtYXAsIGksIHgsIGssIGcsIHMsIG1heDtcblxuICAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBzdGFjayBncm91cHNcbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEuc2xpY2UoKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXA9e30sIGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICB4ID0gZGF0YVtpXTtcbiAgICAgIGsgPSAoZ3JvdXBieS5tYXAoZnVuY3Rpb24oZikgeyByZXR1cm4gZih4KTsgfSkpO1xuICAgICAgZyA9IG1hcFtrXSB8fCAoZ3JvdXBzLnB1c2gobWFwW2tdID0gW10pLCBtYXBba10pO1xuICAgICAgZy5wdXNoKHgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbXB1dGUgc3VtcyBvZiBncm91cHMsIHNvcnQgZ3JvdXBzIGFzIG5lZWRlZFxuICBmb3IgKGs9MCwgbWF4PTA7IGs8Z3JvdXBzLmxlbmd0aDsgKytrKSB7XG4gICAgZyA9IGdyb3Vwc1trXTtcbiAgICBmb3IgKGk9MCwgcz0wOyBpPGcubGVuZ3RoOyArK2kpIHtcbiAgICAgIHMgKz0gdmFsdWUoZ1tpXSk7XG4gICAgfVxuICAgIGcuc3VtID0gcztcbiAgICBpZiAocyA+IG1heCkgbWF4ID0gcztcbiAgICBpZiAoc29ydGJ5ICE9IG51bGwpIGcuc29ydChzb3J0YnkpO1xuICB9XG4gIGdyb3Vwcy5tYXggPSBtYXg7XG5cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTdGFjazsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBQYXJhbWV0ZXIgPSByZXF1aXJlKCcuL1BhcmFtZXRlcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG5UcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyA9IGZ1bmN0aW9uKHByb3RvLCBwYXJhbXMpIHtcbiAgdmFyIHA7XG4gIGZvciAodmFyIG5hbWUgaW4gcGFyYW1zKSB7XG4gICAgcCA9IHBhcmFtc1tuYW1lXTtcbiAgICBwcm90b1tuYW1lXSA9IG5ldyBQYXJhbWV0ZXIobmFtZSwgcC50eXBlKTtcbiAgICBpZiAocC5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSBwcm90b1tuYW1lXS5zZXQocHJvdG8sIHAuZGVmYXVsdCk7XG4gIH1cbiAgcHJvdG8uX3BhcmFtZXRlcnMgPSBwYXJhbXM7XG59O1xuXG52YXIgcHJvdG8gPSAoVHJhbnNmb3JtLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IE5vZGUucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gIG4udHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG4gIG4uX3BhcmFtZXRlcnMgPSB0aGlzLl9wYXJhbWV0ZXJzO1xuICBmb3IodmFyIGsgaW4gdGhpcykgeyBcbiAgICBpZihuW2tdKSBjb250aW51ZTtcbiAgICBuW2tdID0gdGhpc1trXTsgXG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHsgcmV0dXJuIGlucHV0OyB9O1xucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYW55IHRyYW5zZm9ybXMgc3RvcmUgY2FjaGVzIHRoYXQgbXVzdCBiZSBpbnZhbGlkYXRlZCBpZlxuICAvLyBhIHNpZ25hbCB2YWx1ZSBoYXMgY2hhbmdlZC4gXG4gIHZhciByZXNldCA9IHRoaXMuX3N0YW1wIDwgaW5wdXQuc3RhbXAgJiYgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUykuc29tZShmdW5jdGlvbihzKSB7IFxuICAgIHJldHVybiAhIWlucHV0LnNpZ25hbHNbc10gXG4gIH0pO1xuXG4gIHJldHVybiB0aGlzLnRyYW5zZm9ybShpbnB1dCwgcmVzZXQpO1xufTtcblxucHJvdG8ub3V0cHV0ID0gZnVuY3Rpb24obWFwKSB7XG4gIGZvciAodmFyIGtleSBpbiB0aGlzLl9vdXRwdXQpIHtcbiAgICBpZiAobWFwW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fb3V0cHV0W2tleV0gPSBtYXBba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gVHJlZW1hcChncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIC8vIGhpZXJhcmNoeSBwYXJhbWV0ZXJzXG4gICAgc29ydDoge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCIsIGRlZmF1bHQ6IFtcIi12YWx1ZVwiXX0sXG4gICAgY2hpbGRyZW46IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiY2hpbGRyZW5cIn0sXG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwidmFsdWVcIn0sXG4gICAgLy8gdHJlZW1hcCBwYXJhbWV0ZXJzXG4gICAgc2l6ZToge3R5cGU6IFwiYXJyYXk8dmFsdWU+XCIsIGRlZmF1bHQ6IFs1MDAsIDUwMF19LFxuICAgIHJvdW5kOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiB0cnVlfSxcbiAgICBzdGlja3k6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IGZhbHNlfSxcbiAgICByYXRpbzoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC41ICogKDEgKyBNYXRoLnNxcnQoNSkpfSxcbiAgICBwYWRkaW5nOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBudWxsfSxcbiAgICBtb2RlOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcInNxdWFyaWZ5XCJ9XG4gIH0pO1xuXG4gIHRoaXMuX2xheW91dCA9IGQzLmxheW91dC50cmVlbWFwKCk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwieFwiOiAgICAgIFwibGF5b3V0OnhcIixcbiAgICBcInlcIjogICAgICBcImxheW91dDp5XCIsXG4gICAgXCJ3aWR0aFwiOiAgXCJsYXlvdXQ6d2lkdGhcIixcbiAgICBcImhlaWdodFwiOiBcImxheW91dDpoZWlnaHRcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFRyZWVtYXAucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIC8vIGdldCB2YXJpYWJsZXNcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGxheW91dCA9IHRoaXMuX2xheW91dCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dDtcblxuICAvLyBjb25maWd1cmUgbGF5b3V0XG4gIGxheW91dFxuICAgIC5zb3J0KGRsLmNvbXBhcmF0b3IodGhpcy5zb3J0LmdldChnKS5maWVsZHMpKVxuICAgIC5jaGlsZHJlbih0aGlzLmNoaWxkcmVuLmdldChnKS5hY2Nlc3NvcilcbiAgICAudmFsdWUodGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IpXG4gICAgLnNpemUodGhpcy5zaXplLmdldChnKSlcbiAgICAucm91bmQodGhpcy5yb3VuZC5nZXQoZykpXG4gICAgLnN0aWNreSh0aGlzLnN0aWNreS5nZXQoZykpXG4gICAgLnJhdGlvKHRoaXMucmF0aW8uZ2V0KGcpKVxuICAgIC5wYWRkaW5nKHRoaXMucGFkZGluZy5nZXQoZykpXG4gICAgLm1vZGUodGhpcy5tb2RlLmdldChnKSlcbiAgICAubm9kZXMoZGF0YVswXSk7XG5cbiAgLy8gY29weSBsYXlvdXQgdmFsdWVzIHRvIG5vZGVzXG4gIGRhdGEuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC54LCBuLngpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQueSwgbi55KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LndpZHRoLCBuLmR4KTtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LmhlaWdodCwgbi5keSk7XG4gIH0pO1xuXG4gIC8vIHJldHVybiBjaGFuZ2VzZXRcbiAgaW5wdXQuZmllbGRzW291dHB1dC54XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueV0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LndpZHRoXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuaGVpZ2h0XSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJlZW1hcDsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBHcm91cEJ5ID0gcmVxdWlyZSgnLi9Hcm91cEJ5JyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBVbmlxdWUoZ3JhcGgpIHtcbiAgR3JvdXBCeS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBhczoge3R5cGU6IFwidmFsdWVcIn1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChVbmlxdWUucHJvdG90eXBlID0gbmV3IEdyb3VwQnkoKSk7XG5cbnByb3RvLl9uZXdfdHVwbGUgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBvICA9IHt9LFxuICAgICAgb24gPSB0aGlzLmZpZWxkLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBhcyA9IHRoaXMuYXMuZ2V0KHRoaXMuX2dyYXBoKTtcblxuICBvW2FzXSA9IG9uLmFjY2Vzc29yKHgpO1xuICByZXR1cm4gdHVwbGUuaW5nZXN0KG8sIG51bGwpO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJ1bmlxdWVzXCJdKTtcbiAgdGhpcy5fZ2IgPSB0aGlzLmZpZWxkLmdldCh0aGlzLl9ncmFwaCk7XG4gIHJldHVybiBHcm91cEJ5LnByb3RvdHlwZS50cmFuc2Zvcm0uY2FsbCh0aGlzLCBpbnB1dCwgcmVzZXQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlxdWU7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvQ29sbGVjdG9yJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbmZ1bmN0aW9uIFppcChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICB3aXRoOiB7dHlwZTogXCJkYXRhXCJ9LFxuICAgIGFzOiAge3R5cGU6IFwidmFsdWVcIn0sXG4gICAga2V5OiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImRhdGFcIn0sXG4gICAgd2l0aEtleToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogbnVsbH0sXG4gICAgZGVmYXVsdDoge3R5cGU6IFwidmFsdWVcIn1cbiAgfSk7XG5cbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpO1xuICB0aGlzLl9sYXN0Sm9pbiA9IDA7XG5cbiAgcmV0dXJuIHRoaXMucmV2aXNlcyh0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKFppcC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBtcChrKSB7XG4gIHJldHVybiB0aGlzLl9tYXBba10gfHwgKHRoaXMuX21hcFtrXSA9IFtdKTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciB3ID0gdGhpcy53aXRoLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICB3ZHMgPSB3LnNvdXJjZSxcbiAgICAgIHdvdXRwdXQgPSB3ZHMubGFzdCgpLFxuICAgICAgd2RhdGEgPSB3ZHMudmFsdWVzKCksXG4gICAgICBrZXkgPSB0aGlzLmtleS5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgd2l0aEtleSA9IHRoaXMud2l0aEtleS5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgYXMgPSB0aGlzLmFzLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBkZmx0ID0gdGhpcy5kZWZhdWx0LmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBtYXAgPSBtcC5iaW5kKHRoaXMpLFxuICAgICAgcmVtID0ge307XG5cbiAgZGVidWcoaW5wdXQsIFtcInppcHBpbmdcIiwgdy5uYW1lXSk7XG5cbiAgaWYod2l0aEtleS5maWVsZCkge1xuICAgIGlmKHdvdXRwdXQgJiYgd291dHB1dC5zdGFtcCA+IHRoaXMuX2xhc3RKb2luKSB7XG4gICAgICB3b3V0cHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIG0gPSBtYXAod2l0aEtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgIGlmKG1bMF0pIG1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0gZGZsdCB9KTtcbiAgICAgICAgbVsxXSA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgd291dHB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7IFxuICAgICAgICB2YXIgbSA9IG1hcCh3aXRoS2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgaWYobVswXSkgbVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSB4IH0pO1xuICAgICAgICBtWzFdID0geDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBPbmx5IHByb2Nlc3Mgd291dHB1dC5tb2QgdHVwbGVzIGlmIHRoZSBqb2luIGtleSBoYXMgY2hhbmdlZC5cbiAgICAgIC8vIE90aGVyIGZpZWxkIHVwZGF0ZXMgd2lsbCBhdXRvLXByb3BhZ2F0ZSB2aWEgcHJvdG90eXBlLlxuICAgICAgaWYod291dHB1dC5maWVsZHNbd2l0aEtleS5maWVsZF0pIHtcbiAgICAgICAgd291dHB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdmFyIHByZXY7XG4gICAgICAgICAgaWYoIXguX3ByZXYgfHwgKHByZXYgPSB3aXRoS2V5LmFjY2Vzc29yKHguX3ByZXYpKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgdmFyIHByZXZtID0gbWFwKHByZXYpO1xuICAgICAgICAgIGlmKHByZXZtWzBdKSBwcmV2bVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSBkZmx0IH0pO1xuICAgICAgICAgIHByZXZtWzFdID0gbnVsbDtcblxuICAgICAgICAgIHZhciBtID0gbWFwKHdpdGhLZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICAgIGlmKG1bMF0pIG1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0geCB9KTtcbiAgICAgICAgICBtWzFdID0geDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xhc3RKb2luID0gd291dHB1dC5zdGFtcDtcbiAgICB9XG4gIFxuICAgIGlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBtID0gbWFwKGtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICB4W2FzXSA9IG1bMV0gfHwgZGZsdDtcbiAgICAgIChtWzBdPW1bMF18fFtdKS5wdXNoKHgpO1xuICAgIH0pO1xuXG4gICAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkgeyBcbiAgICAgIHZhciBrID0ga2V5LmFjY2Vzc29yKHgpO1xuICAgICAgKHJlbVtrXT1yZW1ba118fHt9KVt4Ll9pZF0gPSAxO1xuICAgIH0pO1xuXG4gICAgaWYoaW5wdXQuZmllbGRzW2tleS5maWVsZF0pIHtcbiAgICAgIGlucHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIHByZXY7XG4gICAgICAgIGlmKCF4Ll9wcmV2IHx8IChwcmV2ID0ga2V5LmFjY2Vzc29yKHguX3ByZXYpKSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgICAgICAgdmFyIG0gPSBtYXAoa2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgeFthc10gPSBtWzFdIHx8IGRmbHQ7XG4gICAgICAgIChtWzBdPW1bMF18fFtdKS5wdXNoKHgpO1xuICAgICAgICAocmVtW3ByZXZdPXJlbVtwcmV2XXx8e30pW3guX2lkXSA9IDE7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkbC5rZXlzKHJlbSkuZm9yRWFjaChmdW5jdGlvbihrKSB7IFxuICAgICAgdmFyIG0gPSBtYXAoayk7XG4gICAgICBpZighbVswXSkgcmV0dXJuO1xuICAgICAgbVswXSA9IG1bMF0uZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbVtrXVt4Ll9pZF0gIT09IDEgfSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIHJ1biBhIG5vbi1rZXktam9pbiBhZ2FpbiBpZiB3ZSd2ZSBnb3QgYW55IGFkZC9yZW1cbiAgICAvLyBvbiBpbnB1dCBvciB3b3V0cHV0XG4gICAgaWYoaW5wdXQuYWRkLmxlbmd0aCA9PSAwICYmIGlucHV0LnJlbS5sZW5ndGggPT0gMCAmJiBcbiAgICAgICAgd291dHB1dC5hZGQubGVuZ3RoID09IDAgJiYgd291dHB1dC5yZW0ubGVuZ3RoID09IDApIHJldHVybiBpbnB1dDtcblxuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBrZXktam9pbiwgdGhlbiB3ZSBuZWVkIHRvIG1hdGVyaWFsaXplIGJvdGhcbiAgICAvLyBkYXRhIHNvdXJjZXMgdG8gaXRlcmF0ZSB0aHJvdWdoIHRoZW0uIFxuICAgIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksIFxuICAgICAgICB3bGVuID0gd2RhdGEubGVuZ3RoLCBpO1xuXG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykgeyBkYXRhW2ldW2FzXSA9IHdkYXRhW2kld2xlbl07IH1cbiAgfVxuXG4gIGlucHV0LmZpZWxkc1thc10gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFppcDsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWdncmVnYXRlOiAgcmVxdWlyZSgnLi9BZ2dyZWdhdGUnKSxcbiAgYmluOiAgICAgICAgcmVxdWlyZSgnLi9CaW4nKSxcbiAgY3Jvc3M6ICAgICAgcmVxdWlyZSgnLi9Dcm9zcycpLFxuICBsaW5rcGF0aDogICByZXF1aXJlKCcuL0xpbmtQYXRoJyksXG4gIGZhY2V0OiAgICAgIHJlcXVpcmUoJy4vRmFjZXQnKSxcbiAgZmlsdGVyOiAgICAgcmVxdWlyZSgnLi9GaWx0ZXInKSxcbiAgZm9sZDogICAgICAgcmVxdWlyZSgnLi9Gb2xkJyksXG4gIGZvcmNlOiAgICAgIHJlcXVpcmUoJy4vRm9yY2UnKSxcbiAgZm9ybXVsYTogICAgcmVxdWlyZSgnLi9Gb3JtdWxhJyksXG4gIGdlbzogICAgICAgIHJlcXVpcmUoJy4vR2VvJyksXG4gIGdlb3BhdGg6ICAgIHJlcXVpcmUoJy4vR2VvUGF0aCcpLFxuICBwaWU6ICAgICAgICByZXF1aXJlKCcuL1BpZScpLFxuICBzb3J0OiAgICAgICByZXF1aXJlKCcuL1NvcnQnKSxcbiAgc3RhY2s6ICAgICAgcmVxdWlyZSgnLi9TdGFjaycpLFxuICB0cmVlbWFwOiAgICByZXF1aXJlKCcuL1RyZWVtYXAnKSxcbiAgdW5pcXVlOiAgICAgcmVxdWlyZSgnLi9VbmlxdWUnKSxcbiAgemlwOiAgICAgICAgcmVxdWlyZSgnLi9aaXAnKVxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIHF1aWNrc2VsZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9xdWlja3NlbGVjdCcpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgdHlwZXMgPSB7XG4gIFwiY291bnRcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJjb3VudFwiLFxuICAgIGluaXQ6IFwiXCIsXG4gICAgYWRkOiAgXCJcIixcbiAgICByZW06ICBcIlwiLFxuICAgIHNldDogIFwidGhpcy5jZWxsLmNudFwiXG4gIH0pLFxuICBcIl9jb3VudHNcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJfY291bnRzXCIsXG4gICAgaW5pdDogXCJ0aGlzLmNudHMgPSB7fTtcIixcbiAgICBhZGQ6ICBcInRoaXMuY250c1t2XSA9ICsrdGhpcy5jbnRzW3ZdIHx8IDE7XCIsXG4gICAgcmVtOiAgXCJ0aGlzLmNudHNbdl0gPSAtLXRoaXMuY250c1t2XSA8IDAgPyAwIDogdGhpcy5jbnRzW3ZdO1wiLFxuICAgIHNldDogIFwiXCIsXG4gICAgcmVxOiAgW1wiY291bnRcIl1cbiAgfSksXG4gIFwic3VtXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwic3VtXCIsXG4gICAgaW5pdDogXCJ0aGlzLnN1bSA9IDA7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLnN1bSArPSB2O1wiLFxuICAgIHJlbTogIFwidGhpcy5zdW0gLT0gdjtcIixcbiAgICBzZXQ6ICBcInRoaXMuc3VtXCJcbiAgfSksXG4gIFwiYXZnXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwiYXZnXCIsXG4gICAgaW5pdDogXCJ0aGlzLmF2ZyA9IDA7XCIsXG4gICAgYWRkOiAgXCJ2YXIgZCA9IHYgLSB0aGlzLmF2ZzsgdGhpcy5hdmcgKz0gZCAvIHRoaXMuY2VsbC5jbnQ7XCIsXG4gICAgcmVtOiAgXCJ2YXIgZCA9IHYgLSB0aGlzLmF2ZzsgdGhpcy5hdmcgLT0gZCAvIHRoaXMuY2VsbC5jbnQ7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLmF2Z1wiLFxuICAgIHJlcTogIFtcImNvdW50XCJdLCBpZHg6IDFcbiAgfSksXG4gIFwidmFyXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwidmFyXCIsXG4gICAgaW5pdDogXCJ0aGlzLmRldiA9IDA7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLmRldiArPSBkICogKHYgLSB0aGlzLmF2Zyk7XCIsXG4gICAgcmVtOiAgXCJ0aGlzLmRldiAtPSBkICogKHYgLSB0aGlzLmF2Zyk7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLmRldiAvICh0aGlzLmNlbGwuY250LTEpXCIsXG4gICAgcmVxOiAgW1wiYXZnXCJdLCBpZHg6IDJcbiAgfSksXG4gIFwidmFycFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInZhcnBcIixcbiAgICBpbml0OiBcIlwiLFxuICAgIGFkZDogIFwiXCIsXG4gICAgcmVtOiAgXCJcIixcbiAgICBzZXQ6ICBcInRoaXMuZGV2IC8gdGhpcy5jZWxsLmNudFwiLFxuICAgIHJlcTogIFtcInZhclwiXSwgaWR4OiAzXG4gIH0pLFxuICBcInN0ZGV2XCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwic3RkZXZcIixcbiAgICBpbml0OiBcIlwiLFxuICAgIGFkZDogIFwiXCIsXG4gICAgcmVtOiAgXCJcIixcbiAgICBzZXQ6ICBcIk1hdGguc3FydCh0aGlzLmRldiAvICh0aGlzLmNlbGwuY250LTEpKVwiLFxuICAgIHJlcTogIFtcInZhclwiXSwgaWR4OiA0XG4gIH0pLFxuICBcInN0ZGV2cFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcInN0ZGV2cFwiLFxuICAgIGluaXQ6IFwiXCIsXG4gICAgYWRkOiAgXCJcIixcbiAgICByZW06ICBcIlwiLFxuICAgIHNldDogIFwiTWF0aC5zcXJ0KHRoaXMuZGV2IC8gdGhpcy5jZWxsLmNudClcIixcbiAgICByZXE6ICBbXCJ2YXJcIl0sIGlkeDogNVxuICB9KSxcbiAgXCJtaW5cIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJtaW5cIixcbiAgICBpbml0OiBcInRoaXMubWluID0gK0luZmluaXR5O1wiLFxuICAgIGFkZDogIFwidGhpcy5taW4gPSB2IDwgdGhpcy5taW4gPyB2IDogdGhpcy5taW47XCIsXG4gICAgcmVtOiAgXCJ2YXIgc2VsZiA9IHRoaXM7IHRoaXMubWluID0gdiA9PSB0aGlzLm1pbiBcIiArXG4gICAgICAgICAgXCI/IHRoaXMua2V5cyh0aGlzLmNudHMpLnJlZHVjZShmdW5jdGlvbihtLCB2KSB7IFwiICtcbiAgICAgICAgICBcIiAgIHJldHVybiBzZWxmLmNudHNbKHYgPSArdildID4gMCAmJiB2IDwgbSA/IHYgOiBtIH0sICtJbmZpbml0eSkgXCIgKyBcbiAgICAgICAgICBcIjogdGhpcy5taW47XCIsXG4gICAgc2V0OiAgXCJ0aGlzLm1pblwiLFxuICAgIHJlcTogW1wiX2NvdW50c1wiXSwgaWR4OiA2XG4gIH0pLFxuICBcIm1heFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcIm1heFwiLFxuICAgIGluaXQ6IFwidGhpcy5tYXggPSAtSW5maW5pdHk7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLm1heCA9IHYgPiB0aGlzLm1heCA/IHYgOiB0aGlzLm1heDtcIixcbiAgICByZW06ICBcInZhciBzZWxmID0gdGhpczsgdGhpcy5tYXggPSB2ID09IHRoaXMubWF4IFwiICtcbiAgICAgICAgICBcIj8gdGhpcy5rZXlzKHRoaXMuY250cykucmVkdWNlKGZ1bmN0aW9uKG0sIHYpIHsgXCIgK1xuICAgICAgICAgIFwiICAgcmV0dXJuIHNlbGYuY250c1sodiA9ICt2KV0gPiAwICYmIHYgPiBtID8gdiA6IG0gfSwgLUluZmluaXR5KSBcIiArIFxuICAgICAgICAgIFwiOiB0aGlzLm1heDtcIixcbiAgICBzZXQ6ICBcInRoaXMubWF4XCIsXG4gICAgcmVxOiBbXCJfY291bnRzXCJdLCBpZHg6IDdcbiAgfSksXG4gIFwibWVkaWFuXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwibWVkaWFuXCIsXG4gICAgaW5pdDogXCJ0aGlzLnZhbHMgPSBbXTsgXCIsXG4gICAgYWRkOiAgXCJpZih0aGlzLnZhbHMpIHRoaXMudmFscy5wdXNoKHYpOyBcIixcbiAgICByZW06ICBcInRoaXMudmFscyA9IG51bGw7XCIsXG4gICAgc2V0OiAgXCJ0aGlzLmNlbGwuY250ICUgMiA/IHRoaXMuc2VsKH5+KHRoaXMuY2VsbC5jbnQvMiksIHRoaXMudmFscywgdGhpcy5jbnRzKSA6IFwiK1xuICAgICAgICAgIFwiMC41ICogKHRoaXMuc2VsKH5+KHRoaXMuY2VsbC5jbnQvMiktMSwgdGhpcy52YWxzLCB0aGlzLmNudHMpICsgdGhpcy5zZWwofn4odGhpcy5jZWxsLmNudC8yKSwgdGhpcy52YWxzLCB0aGlzLmNudHMpKVwiLFxuICAgIHJlcTogW1wiX2NvdW50c1wiXSwgaWR4OiA4XG4gIH0pXG59O1xuXG5mdW5jdGlvbiBtZWFzdXJlKGJhc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG91dCkge1xuICAgIHZhciBtID0gT2JqZWN0LmNyZWF0ZShiYXNlKTtcbiAgICBtLm91dCA9IG91dCB8fCBiYXNlLm5hbWU7XG4gICAgaWYgKCFtLmlkeCkgbS5pZHggPSAwO1xuICAgIHJldHVybiBtO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGFnZykge1xuICBmdW5jdGlvbiBjb2xsZWN0KG0sIGEpIHtcbiAgICAoYS5yZXEgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgaWYgKCFtW3JdKSBjb2xsZWN0KG0sIG1bcl0gPSB0eXBlc1tyXSgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICB2YXIgbWFwID0gYWdnLnJlZHVjZShjb2xsZWN0LFxuICAgIGFnZy5yZWR1Y2UoZnVuY3Rpb24obSwgYSkgeyByZXR1cm4gKG1bYS5uYW1lXSA9IGEsIG0pOyB9LCB7fSkpO1xuICB2YXIgYWxsID0gW107XG4gIGZvciAodmFyIGsgaW4gbWFwKSBhbGwucHVzaChtYXBba10pO1xuICBhbGwuc29ydChmdW5jdGlvbihhLGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pO1xuICByZXR1cm4gYWxsO1xufVxuXG5mdW5jdGlvbiBjb21waWxlKGFnZykge1xuICB2YXIgYWxsID0gcmVzb2x2ZShhZ2cpLFxuICAgICAgY3RyID0gXCJ0aGlzLnRwbCA9IHQ7IHRoaXMuY2VsbCA9IGM7XCIsXG4gICAgICBhZGQgPSBcIlwiLFxuICAgICAgcmVtID0gXCJcIixcbiAgICAgIHNldCA9IFwidmFyIHQgPSB0aGlzLnRwbDtcIjtcblxuICBhbGwuZm9yRWFjaChmdW5jdGlvbihhKSB7IGN0ciArPSBhLmluaXQ7IGFkZCArPSBhLmFkZDsgcmVtICs9IGEucmVtOyB9KTtcbiAgYWdnLmZvckVhY2goZnVuY3Rpb24oYSkgeyBzZXQgKz0gXCJ0aGlzLnR1cGxlLnNldCh0LCdcIithLm91dCtcIicsXCIrYS5zZXQrXCIpO1wiOyB9KTtcbiAgc2V0ICs9IFwicmV0dXJuIHQ7XCI7XG5cbiAgY3RyID0gRnVuY3Rpb24oXCJjXCIsIFwidFwiLCBjdHIpO1xuICBjdHIucHJvdG90eXBlLmFkZCA9IEZ1bmN0aW9uKFwidlwiLCBhZGQpO1xuICBjdHIucHJvdG90eXBlLnJlbSA9IEZ1bmN0aW9uKFwidlwiLCByZW0pO1xuICBjdHIucHJvdG90eXBlLnNldCA9IEZ1bmN0aW9uKFwic3RhbXBcIiwgc2V0KTtcbiAgY3RyLnByb3RvdHlwZS5tb2QgPSBtb2Q7XG4gIGN0ci5wcm90b3R5cGUua2V5cyA9IGRsLmtleXM7XG4gIGN0ci5wcm90b3R5cGUuc2VsID0gcXVpY2tzZWxlY3Q7XG4gIGN0ci5wcm90b3R5cGUudHVwbGUgPSB0dXBsZTtcbiAgcmV0dXJuIGN0cjtcbn1cblxuZnVuY3Rpb24gbW9kKHZfbmV3LCB2X29sZCkge1xuICBpZiAodl9vbGQgPT09IHVuZGVmaW5lZCB8fCB2X29sZCA9PT0gdl9uZXcpIHJldHVybjtcbiAgdGhpcy5yZW0odl9vbGQpO1xuICB0aGlzLmFkZCh2X25ldyk7XG59O1xuXG50eXBlcy5jcmVhdGUgICA9IGNvbXBpbGU7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVzOyIsInZhciBib3VuZHMgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59O1xuXG52YXIgcHJvdG90eXBlID0gYm91bmRzLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLngyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueTIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG4gIHRoaXMueDIgPSB4MjtcbiAgdGhpcy55MiA9IHkyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gIGlmICh5IDwgdGhpcy55MSkgdGhpcy55MSA9IHk7XG4gIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgdGhpcy54MSAtPSBkO1xuICB0aGlzLnkxIC09IGQ7XG4gIHRoaXMueDIgKz0gZDtcbiAgdGhpcy55MiArPSBkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLngxID0gTWF0aC5mbG9vcih0aGlzLngxKTtcbiAgdGhpcy55MSA9IE1hdGguZmxvb3IodGhpcy55MSk7XG4gIHRoaXMueDIgPSBNYXRoLmNlaWwodGhpcy54Mik7XG4gIHRoaXMueTIgPSBNYXRoLmNlaWwodGhpcy55Mik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICB0aGlzLngxICs9IGR4O1xuICB0aGlzLngyICs9IGR4O1xuICB0aGlzLnkxICs9IGR5O1xuICB0aGlzLnkyICs9IGR5O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgeCwgeSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgY3ggPSB4IC0geCpjb3MgKyB5KnNpbixcbiAgICAgIGN5ID0geSAtIHgqc2luIC0geSpjb3MsXG4gICAgICB4MSA9IHRoaXMueDEsIHgyID0gdGhpcy54MixcbiAgICAgIHkxID0gdGhpcy55MSwgeTIgPSB0aGlzLnkyO1xuXG4gIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MSArIGN4LCAgc2luKngxICsgY29zKnkxICsgY3kpXG4gICAgLmFkZChjb3MqeDEgLSBzaW4qeTIgKyBjeCwgIHNpbip4MSArIGNvcyp5MiArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkxICsgY3gsICBzaW4qeDIgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MiAtIHNpbip5MiArIGN4LCAgc2luKngyICsgY29zKnkyICsgY3kpO1xufVxuXG5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihiKSB7XG4gIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmVuY2xvc2VzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAoXG4gICAgdGhpcy54MSA8PSBiLngxICYmXG4gICAgdGhpcy54MiA+PSBiLngyICYmXG4gICAgdGhpcy55MSA8PSBiLnkxICYmXG4gICAgdGhpcy55MiA+PSBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIGIgJiYgIShcbiAgICB0aGlzLngyIDwgYi54MSB8fFxuICAgIHRoaXMueDEgPiBiLngyIHx8XG4gICAgdGhpcy55MiA8IGIueTEgfHxcbiAgICB0aGlzLnkxID4gYi55MlxuICApO1xufTtcblxucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gIShcbiAgICB4IDwgdGhpcy54MSB8fFxuICAgIHggPiB0aGlzLngyIHx8XG4gICAgeSA8IHRoaXMueTEgfHxcbiAgICB5ID4gdGhpcy55MlxuICApO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZHM7IiwidmFyIHZnX2dyYWRpZW50X2lkID0gMDtcblxuZnVuY3Rpb24gZ3JhZGllbnQodHlwZSkge1xuICB0aGlzLmlkID0gXCJncmFkX1wiICsgKHZnX2dyYWRpZW50X2lkKyspO1xuICB0aGlzLnR5cGUgPSB0eXBlIHx8IFwibGluZWFyXCI7XG4gIHRoaXMuc3RvcHMgPSBbXTtcbiAgdGhpcy54MSA9IDA7XG4gIHRoaXMueDIgPSAxO1xuICB0aGlzLnkxID0gMDtcbiAgdGhpcy55MiA9IDA7XG59O1xuXG52YXIgcHJvdG90eXBlID0gZ3JhZGllbnQucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKG9mZnNldCwgY29sb3IpIHtcbiAgdGhpcy5zdG9wcy5wdXNoKHtcbiAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICBjb2xvcjogY29sb3JcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBncmFkaWVudDsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi91dGlsL0JvdW5kcycpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvcGF0aCcpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbnZhciBwYXJzZSA9IGNhbnZhcy5wYXJzZSxcbiAgICBib3VuZFBhdGggPSBjYW52YXMuYm91bmRzLFxuICAgIGFyZWFQYXRoID0gY2FudmFzLmFyZWEsXG4gICAgbGluZVBhdGggPSBjYW52YXMubGluZSxcbiAgICBoYWxmcGkgPSBNYXRoLlBJIC8gMixcbiAgICBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCksXG4gICAgZ2Z4ID0gbnVsbDtcblxuZnVuY3Rpb24gZm9udFN0cmluZyhvKSB7XG4gIHJldHVybiAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCB8fCBjb25maWcucmVuZGVyLmZvbnQpO1xufVxuXG5mdW5jdGlvbiBjb250ZXh0KCkge1xuICAvLyBUT0RPOiBob3cgdG8gY2hlY2sgaWYgbm9kZUpTIGluIHJlcXVpcmVKUz9cbiAgcmV0dXJuIGdmeCB8fCAoZ2Z4ID0gKC8qY29uZmlnLmlzTm9kZVxuICAgID8gbmV3IChyZXF1aXJlKFwiY2FudmFzXCIpKSgxLDEpXG4gICAgOiAqL2QzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwiY2FudmFzXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ2ZWdhX2hpZGRlblwiKVxuICAgICAgICAuYXR0cihcIndpZHRoXCIsIDEpXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIDEpXG4gICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgIC5ub2RlKCkpXG4gICAgLmdldENvbnRleHQoXCIyZFwiKSk7XG59XG5cbmZ1bmN0aW9uIHBhdGhCb3VuZHMobywgcGF0aCwgYm91bmRzKSB7XG4gIGlmIChwYXRoID09IG51bGwpIHtcbiAgICBib3VuZHMuc2V0KDAsIDAsIDAsIDApO1xuICB9IGVsc2Uge1xuICAgIGJvdW5kUGF0aChwYXRoLCBib3VuZHMpO1xuICAgIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHBhdGgobywgYm91bmRzKSB7XG4gIHZhciBwID0gby5wYXRoXG4gICAgPyBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShvLnBhdGgpKVxuICAgIDogbnVsbDtcbiAgcmV0dXJuIHBhdGhCb3VuZHMobywgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gYXJlYShvLCBib3VuZHMpIHtcbiAgdmFyIGl0ZW1zID0gby5tYXJrLml0ZW1zLCBvID0gaXRlbXNbMF07XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2UoYXJlYVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW1zWzBdLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBsaW5lKG8sIGJvdW5kcykge1xuICB2YXIgaXRlbXMgPSBvLm1hcmsuaXRlbXMsIG8gPSBpdGVtc1swXTtcbiAgdmFyIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShsaW5lUGF0aChpdGVtcykpKTtcbiAgcmV0dXJuIHBhdGhCb3VuZHMoaXRlbXNbMF0sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIHJlY3QobywgYm91bmRzKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICB3ID0gKHggKyBvLndpZHRoKSB8fCAwLFxuICAgICAgaCA9ICh5ICsgby5oZWlnaHQpIHx8IDA7XG4gIGJvdW5kcy5zZXQoeCwgeSwgdywgaCk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8sIGJvdW5kcykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwLFxuICAgICAgeCA9IChvLnh8fDApIC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IChvLnl8fDApIC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKTtcbiAgcmV0dXJuIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xufVxuXG5mdW5jdGlvbiBydWxlKG8sIGJvdW5kcykge1xuICB2YXIgeDEsIHkxO1xuICBib3VuZHMuc2V0KFxuICAgIHgxID0gby54IHx8IDAsXG4gICAgeTEgPSBvLnkgfHwgMCxcbiAgICBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgby55MiAhPSBudWxsID8gby55MiA6IHkxXG4gICk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIGFyYyhvLCBib3VuZHMpIHtcbiAgdmFyIGN4ID0gby54IHx8IDAsXG4gICAgICBjeSA9IG8ueSB8fCAwLFxuICAgICAgaXIgPSBvLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IG8ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIHNhID0gKG8uc3RhcnRBbmdsZSB8fCAwKSAtIGhhbGZwaSxcbiAgICAgIGVhID0gKG8uZW5kQW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICB4bWluID0gSW5maW5pdHksIHhtYXggPSAtSW5maW5pdHksXG4gICAgICB5bWluID0gSW5maW5pdHksIHltYXggPSAtSW5maW5pdHksXG4gICAgICBhLCBpLCBuLCB4LCB5LCBpeCwgaXksIG94LCBveTtcblxuICB2YXIgYW5nbGVzID0gW3NhLCBlYV0sXG4gICAgICBzID0gc2EgLSAoc2ElaGFsZnBpKTtcbiAgZm9yIChpPTA7IGk8NCAmJiBzPGVhOyArK2ksIHMrPWhhbGZwaSkge1xuICAgIGFuZ2xlcy5wdXNoKHMpO1xuICB9XG5cbiAgZm9yIChpPTAsIG49YW5nbGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBhID0gYW5nbGVzW2ldO1xuICAgIHggPSBNYXRoLmNvcyhhKTsgaXggPSBpcip4OyBveCA9IG9yKng7XG4gICAgeSA9IE1hdGguc2luKGEpOyBpeSA9IGlyKnk7IG95ID0gb3IqeTtcbiAgICB4bWluID0gTWF0aC5taW4oeG1pbiwgaXgsIG94KTtcbiAgICB4bWF4ID0gTWF0aC5tYXgoeG1heCwgaXgsIG94KTtcbiAgICB5bWluID0gTWF0aC5taW4oeW1pbiwgaXksIG95KTtcbiAgICB5bWF4ID0gTWF0aC5tYXgoeW1heCwgaXksIG95KTtcbiAgfVxuXG4gIGJvdW5kcy5zZXQoY3greG1pbiwgY3kreW1pbiwgY3greG1heCwgY3kreW1heCk7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvLCBib3VuZHMpIHtcbiAgdmFyIHNpemUgPSBvLnNpemUgIT0gbnVsbCA/IG8uc2l6ZSA6IDEwMCxcbiAgICAgIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIHIsIHQsIHJ4LCByeTtcblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlIFwiY3Jvc3NcIjpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBib3VuZHMuc2V0KHgtdCwgeS1yLCB4K3QsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiB0YW4zMCkpO1xuICAgICAgcnggPSByeSAqIHRhbjMwO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yLCB5LXIsIHgrciwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLWRvd25cIjpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLXVwXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUvTWF0aC5QSSk7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gIH1cbiAgaWYgKG8uc3Ryb2tlICYmIG8ub3BhY2l0eSAhPT0gMCAmJiBvLnN0cm9rZVdpZHRoID4gMCkge1xuICAgIGJvdW5kcy5leHBhbmQoby5zdHJva2VXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gdGV4dChvLCBib3VuZHMsIG5vUm90YXRlKSB7XG4gIHZhciB4ID0gKG8ueCB8fCAwKSArIChvLmR4IHx8IDApLFxuICAgICAgeSA9IChvLnkgfHwgMCkgKyAoby5keSB8fCAwKSxcbiAgICAgIGggPSBvLmZvbnRTaXplIHx8IGNvbmZpZy5yZW5kZXIuZm9udFNpemUsXG4gICAgICBhID0gby5hbGlnbixcbiAgICAgIGIgPSBvLmJhc2VsaW5lLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICBnID0gY29udGV4dCgpLCB3LCB0O1xuXG4gIGcuZm9udCA9IGZvbnRTdHJpbmcobyk7XG4gIGcudGV4dEFsaWduID0gYSB8fCBcImxlZnRcIjtcbiAgZy50ZXh0QmFzZWxpbmUgPSBiIHx8IFwiYWxwaGFiZXRpY1wiO1xuICB3ID0gZy5tZWFzdXJlVGV4dChvLnRleHQgfHwgXCJcIikud2lkdGg7XG5cbiAgaWYgKHIpIHtcbiAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICAvLyBob3Jpem9udGFsXG4gIGlmIChhID09PSBcImNlbnRlclwiKSB7XG4gICAgeCA9IHggLSAodyAvIDIpO1xuICB9IGVsc2UgaWYgKGEgPT09IFwicmlnaHRcIikge1xuICAgIHggPSB4IC0gdztcbiAgfSBlbHNlIHtcbiAgICAvLyBsZWZ0IGJ5IGRlZmF1bHQsIGRvIG5vdGhpbmdcbiAgfVxuXG4gIC8vLyBUT0RPIGZpbmQgYSByb2J1c3Qgc29sdXRpb24gZm9yIGhlaWdodHMuXG4gIC8vLyBUaGVzZSBvZmZzZXRzIHdvcmsgZm9yIHNvbWUgYnV0IG5vdCBhbGwgZm9udHMuXG5cbiAgLy8gdmVydGljYWxcbiAgaWYgKGIgPT09IFwidG9wXCIpIHtcbiAgICB5ID0geSArIChoLzUpO1xuICB9IGVsc2UgaWYgKGIgPT09IFwiYm90dG9tXCIpIHtcbiAgICB5ID0geSAtIGg7XG4gIH0gZWxzZSBpZiAoYiA9PT0gXCJtaWRkbGVcIikge1xuICAgIHkgPSB5IC0gKGgvMikgKyAoaC8xMCk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IHkgLSA0KmgvNTsgLy8gYWxwaGFiZXRpYyBieSBkZWZhdWx0XG4gIH1cbiAgXG4gIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xuICBpZiAoby5hbmdsZSAmJiAhbm9Sb3RhdGUpIHtcbiAgICBib3VuZHMucm90YXRlKG8uYW5nbGUqTWF0aC5QSS8xODAsIG8ueHx8MCwgby55fHwwKTtcbiAgfVxuICByZXR1cm4gYm91bmRzLmV4cGFuZChub1JvdGF0ZSA/IDAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAoZywgYm91bmRzLCBpbmNsdWRlTGVnZW5kcykge1xuICB2YXIgYXhlcyA9IGcuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgbGVnZW5kcyA9IGcubGVnZW5kSXRlbXMgfHwgW10sIGosIG07XG5cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgYm91bmRzLnVuaW9uKGF4ZXNbal0uYm91bmRzKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1nLml0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBib3VuZHMudW5pb24oZy5pdGVtc1tqXS5ib3VuZHMpO1xuICB9XG4gIGlmIChpbmNsdWRlTGVnZW5kcykge1xuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgYm91bmRzLnVuaW9uKGxlZ2VuZHNbal0uYm91bmRzKTtcbiAgICB9XG4gICAgaWYgKGcud2lkdGggIT0gbnVsbCAmJiBnLmhlaWdodCAhPSBudWxsKSB7XG4gICAgICBib3VuZHMuYWRkKGcud2lkdGgsIGcuaGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKGcueCAhPSBudWxsICYmIGcueSAhPSBudWxsKSB7XG4gICAgICBib3VuZHMuYWRkKDAsIDApO1xuICAgIH1cbiAgfVxuICBib3VuZHMudHJhbnNsYXRlKGcueHx8MCwgZy55fHwwKTtcbiAgcmV0dXJuIGJvdW5kcztcbn1cblxudmFyIG1ldGhvZHMgPSB7XG4gIGdyb3VwOiAgZ3JvdXAsXG4gIHN5bWJvbDogc3ltYm9sLFxuICBpbWFnZTogIGltYWdlLFxuICByZWN0OiAgIHJlY3QsXG4gIHJ1bGU6ICAgcnVsZSxcbiAgYXJjOiAgICBhcmMsXG4gIHRleHQ6ICAgdGV4dCxcbiAgcGF0aDogICBwYXRoLFxuICBhcmVhOiAgIGFyZWEsXG4gIGxpbmU6ICAgbGluZVxufTtcblxuZnVuY3Rpb24gaXRlbUJvdW5kcyhpdGVtLCBmdW5jLCBvcHQpIHtcbiAgZnVuYyA9IGZ1bmMgfHwgbWV0aG9kc1tpdGVtLm1hcmsubWFya3R5cGVdO1xuICBpZiAoIWl0ZW0uYm91bmRzX3ByZXYpIGl0ZW1bJ2JvdW5kczpwcmV2J10gPSBuZXcgQm91bmRzKCk7XG4gIHZhciBiID0gaXRlbS5ib3VuZHMsIHBiID0gaXRlbVsnYm91bmRzOnByZXYnXTtcbiAgaWYgKGIpIHBiLmNsZWFyKCkudW5pb24oYik7XG4gIGl0ZW0uYm91bmRzID0gZnVuYyhpdGVtLCBiID8gYi5jbGVhcigpIDogbmV3IEJvdW5kcygpLCBvcHQpO1xuICBpZiAoIWIpIHBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpO1xuICByZXR1cm4gaXRlbS5ib3VuZHM7XG59XG5cbmZ1bmN0aW9uIG1hcmtCb3VuZHMobWFyaywgYm91bmRzLCBvcHQpIHtcbiAgYm91bmRzID0gYm91bmRzIHx8IG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNsZWFyKCkgfHwgbmV3IEJvdW5kcygpO1xuICB2YXIgdHlwZSAgPSBtYXJrLm1hcmt0eXBlLFxuICAgICAgZnVuYyAgPSBtZXRob2RzW3R5cGVdLFxuICAgICAgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgICAgaXRlbSwgaSwgbGVuO1xuICAgICAgXG4gIGlmICh0eXBlPT09XCJhcmVhXCIgfHwgdHlwZT09PVwibGluZVwiKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgaXRlbXNbMF0uYm91bmRzID0gZnVuYyhpdGVtc1swXSwgYm91bmRzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGJvdW5kcy51bmlvbihpdGVtQm91bmRzKGl0ZW1zW2ldLCBmdW5jLCBvcHQpKTtcbiAgICB9XG4gIH1cbiAgbWFyay5ib3VuZHMgPSBib3VuZHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtYXJrOiAgbWFya0JvdW5kcyxcbiAgaXRlbTogIGl0ZW1Cb3VuZHMsXG4gIHRleHQ6ICB0ZXh0LFxuICBncm91cDogZ3JvdXBcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgY29uZmlnID0ge307XG5cbmNvbmZpZy5kZWJ1ZyA9IGZhbHNlO1xuXG5jb25maWcubG9hZCA9IHtcbiAgLy8gYmFzZSB1cmwgZm9yIGxvYWRpbmcgZXh0ZXJuYWwgZGF0YSBmaWxlc1xuICAvLyB1c2VkIG9ubHkgZm9yIHNlcnZlci1zaWRlIG9wZXJhdGlvblxuICBiYXNlVVJMOiBcIlwiLFxuICAvLyBBbGxvd3MgZG9tYWluIHJlc3RyaWN0aW9uIHdoZW4gdXNpbmcgZGF0YSBsb2FkaW5nIHZpYSBYSFIuXG4gIC8vIFRvIGVuYWJsZSwgc2V0IGl0IHRvIGEgbGlzdCBvZiBhbGxvd2VkIGRvbWFpbnNcbiAgLy8gZS5nLiwgWyd3aWtpcGVkaWEub3JnJywgJ2VmZi5vcmcnXVxuICBkb21haW5XaGl0ZUxpc3Q6IGZhbHNlXG59O1xuXG4vLyB2ZXJzaW9uIGFuZCBuYW1lcHNhY2VzIGZvciBleHBvcnRlZCBzdmdcbmNvbmZpZy5zdmdOYW1lc3BhY2UgPVxuICAndmVyc2lvbj1cIjEuMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAnICtcbiAgJ3htbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiJztcblxuLy8gaW5zZXQgcGFkZGluZyBmb3IgYXV0b21hdGljIHBhZGRpbmcgY2FsY3VsYXRpb25cbmNvbmZpZy5hdXRvcGFkSW5zZXQgPSA1O1xuXG4vLyBleHRlbnNpYmxlIHNjYWxlIGxvb2t1cCB0YWJsZVxuLy8gYWxsIGQzLnNjYWxlLiogaW5zdGFuY2VzIGFsc28gc3VwcG9ydGVkXG5jb25maWcuc2NhbGUgPSB7XG4gIHRpbWU6IGQzLnRpbWUuc2NhbGUsXG4gIHV0YzogIGQzLnRpbWUuc2NhbGUudXRjXG59O1xuXG4vLyBkZWZhdWx0IHJlbmRlcmluZyBzZXR0aW5nc1xuY29uZmlnLnJlbmRlciA9IHtcbiAgbGluZVdpZHRoOiAxLFxuICBsaW5lQ2FwOiAgIFwiYnV0dFwiLFxuICBmb250OiAgICAgIFwic2Fucy1zZXJpZlwiLFxuICBmb250U2l6ZTogIDExXG59O1xuXG4vLyBkZWZhdWx0IGF4aXMgcHJvcGVydGllc1xuY29uZmlnLmF4aXMgPSB7XG4gIG9yaWVudDogXCJib3R0b21cIixcbiAgdGlja3M6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBheGlzQ29sb3I6IFwiIzAwMFwiLFxuICBncmlkQ29sb3I6IFwiI2Q4ZDhkOFwiLFxuICB0aWNrQ29sb3I6IFwiIzAwMFwiLFxuICB0aWNrTGFiZWxDb2xvcjogXCIjMDAwXCIsXG4gIGF4aXNXaWR0aDogMSxcbiAgdGlja1dpZHRoOiAxLFxuICB0aWNrU2l6ZTogNixcbiAgdGlja0xhYmVsRm9udFNpemU6IDExLFxuICB0aWNrTGFiZWxGb250OiBcInNhbnMtc2VyaWZcIixcbiAgdGl0bGVDb2xvcjogXCIjMDAwXCIsXG4gIHRpdGxlRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIHRpdGxlRm9udFNpemU6IDExLFxuICB0aXRsZUZvbnRXZWlnaHQ6IFwiYm9sZFwiLFxuICB0aXRsZU9mZnNldDogMzVcbn07XG5cbi8vIGRlZmF1bHQgbGVnZW5kIHByb3BlcnRpZXNcbmNvbmZpZy5sZWdlbmQgPSB7XG4gIG9yaWVudDogXCJyaWdodFwiLFxuICBvZmZzZXQ6IDEwLFxuICBwYWRkaW5nOiAzLFxuICBncmFkaWVudFN0cm9rZUNvbG9yOiBcIiM4ODhcIixcbiAgZ3JhZGllbnRTdHJva2VXaWR0aDogMSxcbiAgZ3JhZGllbnRIZWlnaHQ6IDE2LFxuICBncmFkaWVudFdpZHRoOiAxMDAsXG4gIGxhYmVsQ29sb3I6IFwiIzAwMFwiLFxuICBsYWJlbEZvbnRTaXplOiAxMCxcbiAgbGFiZWxGb250OiBcInNhbnMtc2VyaWZcIixcbiAgbGFiZWxBbGlnbjogXCJsZWZ0XCIsXG4gIGxhYmVsQmFzZWxpbmU6IFwibWlkZGxlXCIsXG4gIGxhYmVsT2Zmc2V0OiA4LFxuICBzeW1ib2xTaGFwZTogXCJjaXJjbGVcIixcbiAgc3ltYm9sU2l6ZTogNTAsXG4gIHN5bWJvbENvbG9yOiBcIiM4ODhcIixcbiAgc3ltYm9sU3Ryb2tlV2lkdGg6IDEsXG4gIHRpdGxlQ29sb3I6IFwiIzAwMFwiLFxuICB0aXRsZUZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiBcImJvbGRcIlxufTtcblxuLy8gZGVmYXVsdCBjb2xvciB2YWx1ZXNcbmNvbmZpZy5jb2xvciA9IHtcbiAgcmdiOiBbMTI4LCAxMjgsIDEyOF0sXG4gIGxhYjogWzUwLCAwLCAwXSxcbiAgaGNsOiBbMCwgMCwgNTBdLFxuICBoc2w6IFswLCAwLCAwLjVdXG59O1xuXG4vLyBkZWZhdWx0IHNjYWxlIHJhbmdlc1xuY29uZmlnLnJhbmdlID0ge1xuICBjYXRlZ29yeTEwOiBbXG4gICAgXCIjMWY3N2I0XCIsXG4gICAgXCIjZmY3ZjBlXCIsXG4gICAgXCIjMmNhMDJjXCIsXG4gICAgXCIjZDYyNzI4XCIsXG4gICAgXCIjOTQ2N2JkXCIsXG4gICAgXCIjOGM1NjRiXCIsXG4gICAgXCIjZTM3N2MyXCIsXG4gICAgXCIjN2Y3ZjdmXCIsXG4gICAgXCIjYmNiZDIyXCIsXG4gICAgXCIjMTdiZWNmXCJcbiAgXSxcbiAgY2F0ZWdvcnkyMDogW1xuICAgIFwiIzFmNzdiNFwiLFxuICAgIFwiI2FlYzdlOFwiLFxuICAgIFwiI2ZmN2YwZVwiLFxuICAgIFwiI2ZmYmI3OFwiLFxuICAgIFwiIzJjYTAyY1wiLFxuICAgIFwiIzk4ZGY4YVwiLFxuICAgIFwiI2Q2MjcyOFwiLFxuICAgIFwiI2ZmOTg5NlwiLFxuICAgIFwiIzk0NjdiZFwiLFxuICAgIFwiI2M1YjBkNVwiLFxuICAgIFwiIzhjNTY0YlwiLFxuICAgIFwiI2M0OWM5NFwiLFxuICAgIFwiI2UzNzdjMlwiLFxuICAgIFwiI2Y3YjZkMlwiLFxuICAgIFwiIzdmN2Y3ZlwiLFxuICAgIFwiI2M3YzdjN1wiLFxuICAgIFwiI2JjYmQyMlwiLFxuICAgIFwiI2RiZGI4ZFwiLFxuICAgIFwiIzE3YmVjZlwiLFxuICAgIFwiIzllZGFlNVwiXG4gIF0sXG4gIHNoYXBlczogW1xuICAgIFwiY2lyY2xlXCIsXG4gICAgXCJjcm9zc1wiLFxuICAgIFwiZGlhbW9uZFwiLFxuICAgIFwic3F1YXJlXCIsXG4gICAgXCJ0cmlhbmdsZS1kb3duXCIsXG4gICAgXCJ0cmlhbmdsZS11cFwiXG4gIF1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZmlnOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBBRERfQ0VMTDogMSxcbiAgTU9EX0NFTEw6IDIsXG5cbiAgREFUQTogXCJkYXRhXCIsXG4gIEZJRUxEUzogIFwiZmllbGRzXCIsXG4gIFNDQUxFUzogIFwic2NhbGVzXCIsXG4gIFNJR05BTDogIFwic2lnbmFsXCIsXG4gIFNJR05BTFM6IFwic2lnbmFsc1wiLFxuXG4gIEdST1VQOiBcImdyb3VwXCIsXG5cbiAgRU5URVI6IFwiZW50ZXJcIixcbiAgVVBEQVRFOiBcInVwZGF0ZVwiLFxuICBFWElUOiBcImV4aXRcIixcblxuICBTRU5USU5FTDoge1wic2VudGluZWxcIjogMX0sXG4gIFNJTkdMRVRPTjogXCJfc2luZ2xldG9uXCIsXG5cbiAgQUREOiBcImFkZFwiLFxuICBSRU1PVkU6IFwicmVtb3ZlXCIsXG4gIFRPR0dMRTogXCJ0b2dnbGVcIixcbiAgQ0xFQVI6IFwiY2xlYXJcIixcblxuICBMSU5FQVI6IFwibGluZWFyXCIsXG4gIE9SRElOQUw6IFwib3JkaW5hbFwiLFxuICBMT0c6IFwibG9nXCIsXG4gIFBPV0VSOiBcInBvd1wiLFxuICBUSU1FOiBcInRpbWVcIixcbiAgUVVBTlRJTEU6IFwicXVhbnRpbGVcIixcblxuICBET01BSU46IFwiZG9tYWluXCIsXG4gIFJBTkdFOiBcInJhbmdlXCIsXG5cbiAgTUFSSzogXCJtYXJrXCIsXG4gIEFYSVM6IFwiYXhpc1wiLFxuICBMRUdFTkQ6IFwibGVnZW5kXCIsXG5cbiAgQ09VTlQ6IFwiY291bnRcIixcbiAgTUlOOiBcIm1pblwiLFxuICBNQVg6IFwibWF4XCIsXG5cbiAgQVNDOiBcImFzY1wiLFxuICBERVNDOiBcImRlc2NcIlxufTsiLCJ2YXIgY29uZmlnID0gcmVxdWlyZSgnLi9jb25maWcnKTtcbnZhciB0cztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbnB1dCwgYXJncykge1xuICBpZiAoIWNvbmZpZy5kZWJ1ZykgcmV0dXJuO1xuICB2YXIgbG9nID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gIGFyZ3MudW5zaGlmdChpbnB1dC5zdGFtcHx8LTEpO1xuICBhcmdzLnVuc2hpZnQoRGF0ZS5ub3coKSAtIHRzKTtcbiAgaWYoaW5wdXQuYWRkKSBhcmdzLnB1c2goaW5wdXQuYWRkLmxlbmd0aCwgaW5wdXQubW9kLmxlbmd0aCwgaW5wdXQucmVtLmxlbmd0aCwgISFpbnB1dC5yZWZsb3cpO1xuICBsb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gIHRzID0gRGF0ZS5ub3coKTtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHF1aWNrc2VsZWN0KGssIHgsIGMpIHtcbiAgZnVuY3Rpb24gc3dhcChhLCBiKSB7XG4gICAgdmFyIHQgPSB4W2FdO1xuICAgIHhbYV0gPSB4W2JdO1xuICAgIHhbYl0gPSB0O1xuICB9XG5cbiAgLy8geCBtYXkgYmUgbnVsbCwgaW4gd2hpY2ggY2FzZSBhc3NlbWJsZSBhbiBhcnJheSBmcm9tIGMgKGNvdW50cylcbiAgaWYoeCA9PT0gbnVsbCkge1xuICAgIHggPSBbXTtcbiAgICBkbC5rZXlzKGMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGkgPSAwLCBsZW4gPSBjW2tdO1xuICAgICAgayA9ICtrIHx8IGs7XG4gICAgICBmb3IoOyBpPGxlbjsgKytpKSB4LnB1c2goayk7XG4gICAgfSk7XG4gIH1cbiAgXG4gIHZhciBsZWZ0ID0gMCxcbiAgICAgIHJpZ2h0ID0geC5sZW5ndGggLSAxLFxuICAgICAgcG9zLCBpLCBwaXZvdDtcbiAgXG4gIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICBwaXZvdCA9IHhba107XG4gICAgc3dhcChrLCByaWdodCk7XG4gICAgZm9yIChpID0gcG9zID0gbGVmdDsgaSA8IHJpZ2h0OyArK2kpIHtcbiAgICAgIGlmICh4W2ldIDwgcGl2b3QpIHsgc3dhcChpLCBwb3MrKyk7IH1cbiAgICB9XG4gICAgc3dhcChyaWdodCwgcG9zKTtcbiAgICBpZiAocG9zID09PSBrKSBicmVhaztcbiAgICBpZiAocG9zIDwgaykgbGVmdCA9IHBvcyArIDE7XG4gICAgZWxzZSByaWdodCA9IHBvcyAtIDE7XG4gIH1cbiAgcmV0dXJuIHhba107XG59OyJdfQ==\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x));\n};\n\nproto._newcell = function(x) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      if (cell.collect) {\n        cell.data.values();\n      }\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      result.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function() {\n  var changes = {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === Flags.MOD_CELL) {\n        changes.rem.push(cell.tuple);\n      }\n      delete this._cells[k];\n    } else if (flag & Flags.ADD_CELL) {\n      changes.add.push(cell.tuple);\n    } else if (flag & Flags.MOD_CELL) {\n      changes.mod.push(cell.tuple);\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;","var util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return (this._get = null, this._add);\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  this._get = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m ? get(m) : +Infinity;\n};\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;","var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n","var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;","var util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;","var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;","var util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\ntemplate.source = source;\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n","var STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","var dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n","var Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n","var Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;","var dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;","var dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;","var Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;","var C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};","var dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};","var dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};","module.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};","var datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;","var dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n","/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};","var dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;","var dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}","var lgnd = require('../scene/legend'),\n    config = require('../util/config');\n\nfunction legends(model, spec, legends, group) {\n  (spec || []).forEach(function(def, index) {\n    legends[index] = legends[index] || lgnd(model);\n    legend(def, index, legends[index], group);\n  });\n};\n\nfunction legend(def, index, legend, group) {\n  // legend scales\n  legend.size  (def.size   ? group.scale(def.size)   : null);\n  legend.shape (def.shape  ? group.scale(def.shape)  : null);\n  legend.fill  (def.fill   ? group.scale(def.fill)   : null);\n  legend.stroke(def.stroke ? group.scale(def.stroke) : null);\n\n  // legend orientation\n  if (def.orient) legend.orient(def.orient);\n\n  // legend offset\n  if (def.offset != null) legend.offset(def.offset);\n\n  // legend title\n  legend.title(def.title || null);\n\n  // legend values\n  legend.values(def.values || null);\n\n  // legend label formatting\n  legend.format(def.format !== undefined ? def.format : null);\n\n  // style properties\n  var p = def.properties;\n  legend.titleProperties(p && p.title || {});\n  legend.labelProperties(p && p.labels || {});\n  legend.legendProperties(p && p.legend || {});\n  legend.symbolProperties(p && p.symbols || {});\n  legend.gradientProperties(p && p.gradient || {});\n}\n\nmodule.exports = legends;","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};","var parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}","var dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}","var dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;","var expr = require('./expr'),\n    C = require('../util/constants');\n\nfunction parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init);\n\n    if(s.init && s.init.expr) {\n      s.init.expr = expr(s.init.expr);\n      signal.value(exprVal(model, s.init));\n    }\n\n    if(s.expr) {\n      s.expr = expr(s.expr);\n      signal.evaluate = function(input) {\n        signal.value(exprVal(model, s));\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, s.expr.signals);\n      s.expr.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n\nfunction exprVal(model, spec) {\n  var e = spec.expr,\n      val = expr.eval(model, e.fn, null, null, null, null, e.signals);\n  return spec.scale ? scale(model, spec, val) : val;\n}\n\nparseSignals.scale = function scale(model, spec, value) {\n  var def = spec.scale,\n      name  = def.name || def.signal || def,\n      scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n  if(!scope || !scope.scale) {\n    scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n  }\n\n  var scale = scope.scale(name);\n  if(!scale) return value;\n  return def.invert ? scale.invert(value) : scale(value);\n}\n\nmodule.exports = parseSignals;","var dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    parseSignals = require('./signals'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = parseSignals.scale(model, spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = parseSignals.scale(model, h.spec, val);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../util/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;","module.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};","var Bounds = require('../../util/Bounds'),\n    boundsCalc = require('../../util/boundscalc'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../util/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n","module.exports = {\n  Renderer: require('./Renderer')\n};\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n","var dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder = require('./Encoder'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n  var i, ilen, j, jlen, group, legend;\n      hasLegends = this._mark.marktype == C.GROUP \n        && dl.array(this._mark.def.legends).length > 0;\n\n  bounds.mark(this._mark, null, !hasLegends);\n\n  if(hasLegends) {\n    for(i=0, ilen=this._mark.items.length; i<ilen; ++i) {\n      group = this._mark.items[i];\n      group._legendPositions = null;\n      for(j=0, jlen=group.legendItems.length; j<jlen; ++j) {\n        legend = group.legendItems[j];\n        Encoder.update(this._graph, input.trans, \"vg_legendPosition\", legend.items);\n        bounds.mark(legend, null, true);\n      }\n    }\n\n    bounds.mark(this._mark, null, true);\n  }\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/boundscalc'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    parseLegends = require('../parse/legends'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n\n  scales = (def.legends||[]).reduce(function(acc, x) {\n    return (acc[x.size || x.shape || x.fill || x.stroke], acc);\n  }, scales);\n\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = dl.array(this._def.marks).length > 0,\n      hasAxes = dl.array(this._def.axes).length > 0,\n      hasLegends = dl.array(this._def.legends).length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n    if(hasLegends) buildLegends.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }\n\n    // Update legend data defs\n    if(hasLegends) {\n      parseLegends(builder._graph, builder._def.legends, group.legends, group);\n      group.legends.forEach(function(l, i) { l.def() });\n    }   \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n\n  group.legends = group.legends || [];\n  group.legendItems = group.legendItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nfunction buildLegends(input, group) {\n  var legends = group.legends,\n      legendItems = group.legendItems,\n      builder = this;\n\n  parseLegends(this._graph, this._def.legends, legends, group);\n  legends.forEach(function(l, i) {\n    var scale = l.size() || l.shape() || l.fill() || l.stroke(),\n        def = l.def(),\n        b = null;\n\n    legendItems[i] = {group: group, legendDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, legendItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.LEGEND, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.parent) return dl.accessor(f.parent)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;","var tuple = require('../dataflow/tuple'),\n    boundsCalc = require('../util/boundscalc'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    boundsCalc.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines:  null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title:  null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    parseProperties = require('../parse/properties'),\n    parseMark = require('../parse/mark'),\n    Gradient = require('../util/Gradient'),\n    config = require('../util/config');\n\nfunction lgnd(model) {\n  var size = null,\n      shape = null,\n      fill = null,\n      stroke = null,\n      spacing = null,\n      values = null,\n      format = null,\n      formatString = null,\n      title = undefined,\n      orient = \"right\",\n      offset = config.legend.offset,\n      padding = config.legend.padding,\n      legendDef,\n      tickArguments = [5],\n      legendStyle = {},\n      symbolStyle = {},\n      gradientStyle = {},\n      titleStyle = {},\n      labelStyle = {},\n      m = { // Legend marks as references for updates\n        titles:  null,\n        symbols: null,\n        labels:  null,\n        gradient: null\n      };\n\n  var legend = {},\n      legendDef = {};\n\n  function reset() { legendDef.type = null; }\n  function ingest(d, i) { return {data: d, index: i} }\n\n  legend.def = function() {\n    var scale = size || shape || fill || stroke;\n    \n    format = !formatString ? null : ((scale.type === 'time')\n      ? d3.time.format(formatString)\n      : d3.format(formatString));\n    \n    if (!legendDef.type) {\n      legendDef = (scale===fill || scale===stroke) && !discrete(scale.type)\n        ? quantDef(scale)\n        : ordinalDef(scale);      \n    }\n    legendDef.orient = orient;\n    legendDef.offset = offset;\n    legendDef.padding = padding;\n    return legendDef;\n  };\n\n  function discrete(type) {\n    return type===\"ordinal\" || type===\"quantize\"\n      || type===\"quantile\" || type===\"threshold\";\n  }\n\n  function ordinalDef(scale) {\n    var def = o_legend_def(size, shape, fill, stroke);\n\n    // generate data\n    var data = (values == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : values).map(ingest);\n    var fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n    \n    // determine spacing between legend entries\n    var fs, range, offset, pad=5, domain = d3.range(data.length);\n    if (size) {\n      range = data.map(function(x) { return Math.sqrt(size(x.data)); });\n      offset = d3.max(range);\n      range = range.reduce(function(a,b,i,z) {\n          if (i > 0) a[i] = a[i-1] + z[i-1]/2 + pad;\n          return (a[i] += b/2, a); }, [0]).map(Math.round);\n    } else {\n      offset = Math.round(Math.sqrt(config.legend.symbolSize));\n      range = spacing\n        || (fs = labelStyle.fontSize) && (fs.value + pad)\n        || (config.legend.labelFontSize + pad);\n      range = domain.map(function(d,i) {\n        return Math.round(offset/2 + i*range);\n      });\n    }\n\n    // account for padding and title size\n    var sz = padding, ts;\n    if (title) {\n      ts = titleStyle.fontSize;\n      sz += 5 + ((ts && ts.value) || config.legend.titleFontSize);\n    }\n    for (var i=0, n=range.length; i<n; ++i) range[i] += sz;\n    \n    // build scale for label layout\n    var scale = {\n      name: \"legend\",\n      type: \"ordinal\",\n      points: true,\n      domain: domain,\n      range: range\n    };\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d) {\n      d.label = fmt(d.data);\n      d.offset = offset;\n    });\n    def.scales = [ scale ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return data; };\n    def.marks[2].from = def.marks[1].from;\n\n    return def;\n  }\n\n  function o_legend_def(size, shape, fill, stroke) {\n    // setup legend marks\n    var titles  = m.titles  || (m.titles  = vg_legendTitle()),\n        symbols = m.symbols || (m.symbols = vg_legendSymbols()),\n        labels  = m.labels  || (m.labels  = vg_vLegendLabels());\n\n    // extend legend marks\n    vg_legendSymbolExtend(symbols, size, shape, fill, stroke);\n    \n    // add / override custom style properties\n    dl.extend(titles.properties.update,  titleStyle);\n    dl.extend(symbols.properties.update, symbolStyle);\n    dl.extend(labels.properties.update,  labelStyle);\n\n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    labels.properties.enter.x.offset += padding + 1;\n    symbols.properties.enter.x.offset = padding + 1;\n    labels.properties.update.x.offset += padding + 1;\n    symbols.properties.update.x.offset = padding + 1;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales:[], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, symbols, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  function quantDef(scale) {\n    var def = q_legend_def(scale),\n        dom = scale.domain(),\n        data = dom.map(ingest),\n        width = (gradientStyle.width && gradientStyle.width.value) || config.legend.gradientWidth,\n        fmt = format==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : format;\n\n    // build scale for label layout\n    var layout = {\n      name: \"legend\",\n      type: scale.type,\n      round: true,\n      zero: false,\n      domain: [dom[0], dom[dom.length-1]],\n      range: [padding, width+padding]\n    };\n    if (scale.type===\"pow\") layout.exponent = scale.exponent();\n    \n    // update legend def\n    var tdata = (title ? [title] : []).map(ingest);\n    data.forEach(function(d,i) {\n      d.label = fmt(d.data);\n      d.align = i==(data.length-1) ? \"right\" : i==0 ? \"left\" : \"center\";\n    });\n    def.scales = [ layout ];\n    def.marks[0].from = function() { return tdata; };\n    def.marks[1].from = function() { return [1]; };\n    def.marks[2].from = function() { return data; };\n    return def;\n  }\n  \n  function q_legend_def(scale) {\n    // setup legend marks\n    var titles = m.title || (m.title = vg_legendTitle()),\n        gradient = m.gradient || (m.gradient = vg_legendGradient()),\n        labels = m.labels || (m.labels = vg_hLegendLabels()),\n        grad = new Gradient();\n\n    // setup color gradient\n    var dom = scale.domain(),\n        min = dom[0],\n        max = dom[dom.length-1],\n        f = scale.copy().domain([min, max]).range([0,1]);\n        \n    var stops = (scale.type !== \"linear\" && scale.ticks)\n      ? scale.ticks.call(scale, 15) : dom;\n    if (min !== stops[0]) stops.unshift(min);\n    if (max !== stops[stops.length-1]) stops.push(max);\n\n    for (var i=0, n=stops.length; i<n; ++i) {\n      grad.stop(f(stops[i]), scale(stops[i]));\n    }\n    gradient.properties.enter.fill = {value: grad};\n\n    // add / override custom style properties\n    dl.extend(titles.properties.update, titleStyle);\n    dl.extend(gradient.properties.update, gradientStyle);\n    dl.extend(labels.properties.update, labelStyle);\n\n    // account for gradient size\n    var gp = gradient.properties, gh = gradientStyle.height,\n        hh = (gh && gh.value) || gp.enter.height.value;\n    labels.properties.enter.y.value = hh;\n    labels.properties.update.y.value = hh;\n\n    // account for title size as needed\n    if (title) {\n      var tp = titles.properties, fs = titleStyle.fontSize,\n          sz = 4 + ((fs && fs.value) || tp.enter.fontSize.value);\n      gradient.properties.enter.y.value += sz;\n      labels.properties.enter.y.value += sz;\n      gradient.properties.update.y.value += sz;\n      labels.properties.update.y.value += sz;\n    }\n    \n    // padding from legend border\n    titles.properties.enter.x.value += padding;\n    titles.properties.enter.y.value += padding;\n    gradient.properties.enter.x.value += padding;\n    gradient.properties.enter.y.value += padding;\n    labels.properties.enter.y.value += padding;\n    gradient.properties.update.x.value += padding;\n    gradient.properties.update.y.value += padding;\n    labels.properties.update.y.value += padding;\n\n    dl.extend(legendDef, {\n      type: \"group\",\n      interactive: false,\n      properties: {\n        enter: parseProperties(model, \"group\", legendStyle),\n        vg_legendPosition: {\n          encode: vg_legendPosition,\n          signals: [], scales: [], data: [], fields: []\n        }\n      }\n    });\n\n    legendDef.marks = [titles, gradient, labels].map(function(m) { return parseMark(model, m); });\n    return legendDef;\n  }\n\n  legend.size = function(x) {\n    if (!arguments.length) return size;\n    if (size !== x) { size = x; reset(); }\n    return legend;\n  };\n\n  legend.shape = function(x) {\n    if (!arguments.length) return shape;\n    if (shape !== x) { shape = x; reset(); }\n    return legend;\n  };\n\n  legend.fill = function(x) {\n    if (!arguments.length) return fill;\n    if (fill !== x) { fill = x; reset(); }\n    return legend;\n  };\n  \n  legend.stroke = function(x) {\n    if (!arguments.length) return stroke;\n    if (stroke !== x) { stroke = x; reset(); }\n    return legend;\n  };\n\n  legend.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return legend;\n  };\n\n  legend.format = function(x) {\n    if (!arguments.length) return formatString;\n    if (formatString !== x) {\n      formatString = x;\n      reset();\n    }\n    return legend;\n  };\n\n  legend.spacing = function(x) {\n    if (!arguments.length) return spacing;\n    if (spacing !== +x) { spacing = +x; reset(); }\n    return legend;\n  };\n\n  legend.orient = function(x) {\n    if (!arguments.length) return orient;\n    orient = x in vg_legendOrients ? x + \"\" : config.legend.orient;\n    return legend;\n  };\n\n  legend.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = +x;\n    return legend;\n  };\n\n  legend.values = function(x) {\n    if (!arguments.length) return values;\n    values = x;\n    return legend;\n  };\n\n  legend.legendProperties = function(x) {\n    if (!arguments.length) return legendStyle;\n    legendStyle = x;\n    return legend;\n  };\n\n  legend.symbolProperties = function(x) {\n    if (!arguments.length) return symbolStyle;\n    symbolStyle = x;\n    return legend;\n  };\n\n  legend.gradientProperties = function(x) {\n    if (!arguments.length) return gradientStyle;\n    gradientStyle = x;\n    return legend;\n  };\n\n  legend.labelProperties = function(x) {\n    if (!arguments.length) return labelStyle;\n    labelStyle = x;\n    return legend;\n  };\n  \n  legend.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    titleStyle = x;\n    return legend;\n  };\n\n  legend.reset = function() { reset(); };\n\n  return legend;\n};\n\nvar vg_legendOrients = {right: 1, left: 1};\n\nfunction vg_legendPosition(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item, gx,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      pad    = item.mark.def.padding * 2,\n      lw     = ~~item.bounds.width() + (item.width ? 0 : pad),\n      lh     = ~~item.bounds.height() + (item.height ? 0 : pad),\n      pos = group._legendPositions || \n        (group._legendPositions = {right: 0.5, left: 0.5});\n\n  o.x = 0.5;\n  o.width = lw;\n  o.y = pos[orient];\n  pos[orient] += (o.height = lh);\n\n  // HACK: use to estimate group bounds during animated transition\n  if (!trans && group.bounds) {\n    group.bounds.delta = group.bounds.x2 - group.width;\n  }\n\n  switch (orient) {\n    case \"left\":  {\n      gx = group.bounds ? group.bounds.x1 : 0;\n      o.x += gx - offset - lw;\n      break;\n    };\n    case \"right\": {\n      gx = group.width;\n      if (group.bounds) gx = trans\n        ? group.width + group.bounds.delta\n        : group.bounds.x2;\n      o.x += gx + offset;\n      break;\n    };\n  }\n  \n  if (trans) trans.interpolate(item, o);\n  var enc = item.mark.def.properties.enter.encode;\n  enc.call(enc, item, group, trans);\n}\n\nfunction vg_legendSymbolExtend(mark, size, shape, fill, stroke) {\n  var e = mark.properties.enter,\n      u = mark.properties.update;\n  if (size)   e.size   = u.size   = {scale: size.scaleName,   field: \"data\"};\n  if (shape)  e.shape  = u.shape  = {scale: shape.scaleName,  field: \"data\"};\n  if (fill)   e.fill   = u.fill   = {scale: fill.scaleName,   field: \"data\"};\n  if (stroke) e.stroke = u.stroke = {scale: stroke.scaleName, field: \"data\"};\n}\n\nfunction vg_legendTitle() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        fill: {value: cfg.titleColor},\n        font: {value: cfg.titleFont},\n        fontSize: {value: cfg.titleFontSize},\n        fontWeight: {value: cfg.titleFontWeight},\n        baseline: {value: \"top\"},\n        text: {field: \"data\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_legendSymbols() {\n  var cfg = config.legend;\n  return {\n    type: \"symbol\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        shape: {value: cfg.symbolShape},\n        size: {value: cfg.symbolSize},\n        stroke: {value: cfg.symbolColor},\n        strokeWidth: {value: cfg.symbolStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {field: \"offset\", mult: 0.5},\n        y: {scale: \"legend\", field: \"index\"},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_vLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {value: cfg.labelAlign},\n        baseline: {value: cfg.labelBaseline},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        opacity: {value: 1},\n        x: {field: \"offset\", offset: 5},\n        y: {scale: \"legend\", field: \"index\"},\n      }\n    }\n  };\n}\n\nfunction vg_legendGradient() {\n  var cfg = config.legend;\n  return {\n    type: \"rect\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0},\n        y: {value: 0},\n        width: {value: cfg.gradientWidth},\n        height: {value: cfg.gradientHeight},\n        stroke: {value: cfg.gradientStrokeColor},\n        strokeWidth: {value: cfg.gradientStrokeWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {value: 0},\n        y: {value: 0},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nfunction vg_hLegendLabels() {\n  var cfg = config.legend;\n  return {\n    type: \"text\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        dy: {value: 2},\n        fill: {value: cfg.labelColor},\n        font: {value: cfg.labelFont},\n        fontSize: {value: cfg.labelFontSize},\n        align: {field: \"align\"},\n        baseline: {value: \"top\"},\n        text: {field: \"label\"},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: {\n        x: {scale: \"legend\", field: \"data\"},\n        y: {value: 20},\n        opacity: {value: 1}\n      }\n    }\n  };\n}\n\nmodule.exports = lgnd;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;","var Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;","var Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;","var dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;","var Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;","module.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};","var dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;","var bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;","var vg_gradient_id = 0;\n\nfunction gradient(type) {\n  this.id = \"grad_\" + (vg_gradient_id++);\n  this.type = type || \"linear\";\n  this.stops = [];\n  this.x1 = 0;\n  this.x2 = 1;\n  this.y1 = 0;\n  this.y2 = 0;\n};\n\nvar prototype = gradient.prototype;\n\nprototype.stop = function(offset, color) {\n  this.stops.push({\n    offset: offset,\n    color: color\n  });\n  return this;\n};\n\nmodule.exports = gradient;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../util/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;","module.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n  LEGEND: \"legend\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};","var config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};","var dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};"],"sourceRoot":"/source/"}