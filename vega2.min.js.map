{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index","vega2.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/aggregate/aggregator.js","node_modules/datalib/src/aggregate/collector.js","node_modules/datalib/src/aggregate/groupby.js","node_modules/datalib/src/aggregate/measures.js","node_modules/datalib/src/bins/bins.js","node_modules/datalib/src/bins/histogram.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/formats/dsv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/import/readers.js","node_modules/datalib/src/import/type.js","node_modules/datalib/src/index.js","node_modules/datalib/src/print.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/template.js","node_modules/datalib/src/time-units.js","node_modules/datalib/src/util.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","src/core/Bounds.js","src/core/HeadlessView.js","src/core/Model.js","src/core/View.js","src/dataflow/Collector.js","src/dataflow/Datasource.js","src/dataflow/Graph.js","src/dataflow/Node.js","src/dataflow/Signal.js","src/dataflow/changeset.js","src/dataflow/tuple.js","src/expression/codegen.js","src/expression/constants.js","src/expression/functions.js","src/expression/index.js","src/expression/parser.js","src/parse/axes.js","src/parse/data.js","src/parse/events.js","src/parse/expr.js","src/parse/interactors.js","src/parse/mark.js","src/parse/marks.js","src/parse/modify.js","src/parse/padding.js","src/parse/predicates.js","src/parse/properties.js","src/parse/signals.js","src/parse/spec.js","src/parse/streams.js","src/parse/transforms.js","src/render/canvas/Handler.js","src/render/canvas/Renderer.js","src/render/canvas/index.js","src/render/canvas/marks.js","src/render/canvas/path.js","src/render/svg-headless/Renderer.js","src/render/svg-headless/index.js","src/render/svg-headless/svg.js","src/render/svg/Handler.js","src/render/svg/Renderer.js","src/render/svg/marks.js","src/scene/Bounder.js","src/scene/Builder.js","src/scene/Encoder.js","src/scene/GroupBuilder.js","src/scene/Item.js","src/scene/Scale.js","src/scene/Transition.js","src/scene/axis.js","src/transforms/Aggregate.js","src/transforms/BatchTransform.js","src/transforms/Bin.js","src/transforms/Cross.js","src/transforms/Facet.js","src/transforms/Facetor.js","src/transforms/Filter.js","src/transforms/Fold.js","src/transforms/Force.js","src/transforms/Formula.js","src/transforms/Geo.js","src/transforms/GeoPath.js","src/transforms/LinkPath.js","src/transforms/Parameter.js","src/transforms/Pie.js","src/transforms/Sort.js","src/transforms/Stack.js","src/transforms/Transform.js","src/transforms/Treemap.js","src/transforms/Zip.js","src/transforms/index.js","src/util/bounds.js","src/util/config.js","src/util/constants.js","src/util/debug.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vg","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"core","View","dataflow","changeset","Datasource","Graph","Node","parse","spec","scene","Builder","GroupBuilder","transforms","config","util","./src/core/View","./src/dataflow/Datasource","./src/dataflow/Graph","./src/dataflow/Node","./src/dataflow/changeset","./src/parse/spec","./src/scene/Builder","./src/scene/GroupBuilder","./src/transforms/index","./src/util/config","datalib",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"Aggregator","_cells","_aggr","_stream","summarize_args","fields","isArray","ops","array","Measures","Collector","Flags","ADD_CELL","MOD_CELL","proto","prototype","stream","v","key","_key","$","groupby","dims","_dims","map","d","isString","get","isFunction","clear","summarize","_count","m","j","op","as","aggr","identity","measures","create","_assign","count","*","object","value","_cellkey","x","k","String","_cell","_newcell","cell","num","tuple","_newtuple","flag","aggs","collect","data","_ingest","_add","add","_rem","rem","_mod","curr","prev","cell0","cell1","isObject","result","values","set","_rems","changes","mod","execute","input","insert","_consolidate","remove","../util","./collector","./measures",5,"_last","stats","REM","_get","Array","toMap","hasOwnProperty","extent","_ext","index","argmin","argmax","min","Infinity","max","quartile","_q","q1","q2","q3","../stats",6,"args","reduce","arguments","concat","./aggregator",7,"measure","base","out","extend","init","idx","resolve","agg","helper","types","req","forEach","str","vals","sort","b","accessor","mutator","all","ctr","slice","Function","assign","distinct","isValid","v_new","v_old","undefined","missing","valid","sum","mean","average","variance","variancep","stdev","stdevp","median","modeskew",8,"bins","opt","step","level","minstep","precision","eps","maxb","maxbins","logb","Math","log","div","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","lo","hi","mid","cmp","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","raw","../time-units",9,"$bin","options","$func","histogram","numerical","categorical","type","qtype","ext","h","gen","range","isFinite","unique","c","comparator","integer","number","../generate","../import/type","./bins",10,"repeat","val","zeros","random","uniform","samples","normal","next","rds","y","sqrt",11,"dsv","format","header","join","delimiter","d3","delim","fmt","../../util",12,"json","topojson","treejson","csv","tsv","./dsv","./json","./topojson","./treejson",13,"isBuffer","JSON","property",14,"obj","feature","objects","features","mesh",15,"toTable","root","childrenField","visit","node","table","children",16,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","test","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","lastIndexOf","load","callback","error","err","indexOf","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","filename","fs","readFile","readFileSync","body","statusCode","getBody","sync-request",17,"read","formats","cols","parsers","clen","inferAll","duplicate","keys","annotation","./formats","./type",18,"./load","./read",19,"TYPES","isDate","isNumber","isBoolean","typeAll","infer","TESTS","splice","PARSERS","boolean","string","isNaN","Date",20,"dl","print","template","timeunits","./aggregate/groupby","./bins/bins","./bins/histogram","./generate","./import/load","./import/read","./import/readers","./import/type","./print","./stats","./template","./time-units","./util",21,"printQuantitativeProfile","p","printCategoricalProfile","list","top","FMT","POS","separator","minwidth","maxwidth","limit","lens","head","truncate","pad","tmpl","summary","__summary__","field",22,"results","filter","quantile","q","H","delta","M2","avg","med","std","dot","Number","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","L2","abs","R","M","entropy","counts","LN2","mutual","z","px","py","I","info","profile","sd",23,"text","src","source","bind","context","variable","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","stringCast","filters","split","prop","shift","trim","pidx","template_format","time","template_escapes","pattern","format_map","clearFormatCache","'","\\","\r","\n"," "," ",24,"STEPS","entries","UTC","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",25,"util_escape_str","escape_str_re","strrep","truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","Buffer","stderr","FNAME","namedfunc","stringify","equal","keystr","toString","Object","apply","$valid","$length","$year","$month","$date","$day","$hour","$minute","$in","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","searchString","pos","padchar","word","ellipsis","l1","l2","_process","buffer",26,"./lib/heap",27,"Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","item","lastelt","returnitem","pop","_ref","_i","_len","_ref1","_results","_results1","_j","elem","los","startpos","newitem","parent","parentpos","childpos","endpos","rightpos","nodes","pushpop","peek","contains","empty","size","clone","heap","toArray","front","has","copy","factory",28,"bounds","union","x1","MAX_VALUE","y1","x2","y2","expand","translate","dx","dy","rotate","angle","cos","sin","cx","cy","encloses","intersects","width","height",29,"canvas","svg","HeadlessView","model","_el","_type","_renderers","_canvas","renderer","canvasAsync","wait","pendingImages","view","render","_renderer","initialize","_width","_height","_padding","_viewport","left","right","bottom","_io","Renderer","initSVG","initCanvas","Canvas","tw","th","ctx","getContext","setAttribute","setTransform","resize","../render/canvas/index","../render/svg-headless/index","../util/debug","./View",30,"Model","_defs","_predicates","_scene","_node","_builder","predicates","defs","pipeline","predicate","disconnect","marks","connect","fire","cs","propagate","../dataflow/Graph","../dataflow/Node","../dataflow/changeset","../scene/GroupBuilder",31,"streaming","ds","_model","listener","streamer","_streamer","_changeset","api","signals","_api","update","build","_renderNode","router","evaluate","debug","trans","items","revises","finalize","last","parseStreams","Encoder","Transition","el","__width","__height","_autopad","_handler","dataValues","signal","setter","signalValues","reflow","_strict","padding","autopad","inset","autopadInset","viewport","_build","prevHandler","parentNode","select","append","attr","style","Handler","handlers","handler","duration","ease","props","listeners","onSignal","offSignal","../parse/streams","../render/svg/index","../scene/Encoder","../scene/Transition","../util/config","./HeadlessView",32,"graph","_data","collector","ids","_id","../util/constants","./Node","./changeset",33,"facet","_graph","_name","_source","_facet","_input","_output","_pipeline","_collector","_revises","set_prev","_prev","C","SENTINEL","ingest","where","func","idMap","unshift","output","dest","_srcMap","derive","./Collector","./tuple",34,"_signals","forEachNode","branch","Signal","_stamp","_rank","doNotPropagate","db","names","sg","signalRef","ref","schedule","pulse","reflowed","pq","stamp","_listeners","dependency","DATA","SIGNALS","reevaluate","run","./Datasource","./Signal",35,"REEVAL","FIELDS","SCALES","node_id","_registered","_deps","scales","_isRouter","_isCollector","deps","bool","cur","foundSending","reeval",36,"_value","_handlers",37,"reset_prev",38,"datum","tuple_id","has_prev","reset",39,"codegen_wrap","ast","retval","codegen","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","DATUM","SIGNAL_PREFIX","Literal","Identifier","id","Program","MemberExpression","computed","CallExpression","callee","ArrayExpression","elements","BinaryExpression","operator","UnaryExpression","argument","UpdateExpression","prefix","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","Property","ExpressionStatement","expression","./constants","./functions",40,"E","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2",41,"fncall","cast","DATE","STRING","REGEXP","acos","asin","atan","atan2","tan","now","datetime","hours","minutes","seconds","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseFloat","parseInt","upper","lower","substring","if",42,"parser","./codegen","./parser",43,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","charCodeAt","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","token","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","EOF","collectToken","entry","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","msg","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","expr","state","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",44,"axes","group","def","axs","axis","scale","orient","ORIENT","layer","grid","titleOffset","tickValues","tickFormat","tickSubdivide","subdivide","tickPadding","tickSize","ts","tickSizeMajor","tickSizeMinor","tickSizeEnd","ticks","majorTickProperties","majorTicks","minorTickProperties","minorTicks","tickLabelProperties","labels","titleProperties","gridLineProperties","domainProperties","../scene/axis",45,"parseTransforms","parseModify","parseData","loaded","datasource","transform","modify","./modify","./transforms",46,"peg$subclass","child","ctor","constructor","SyntaxError","expected","peg$computePosDetails","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","buildMessage","stringEscape","hex","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","peg$parsemerged","s1","s2","s3","s4","s5","peg$parseordered","peg$FAILED","peg$parsesep","peg$c1","peg$silentFails","peg$c2","peg$reportedPos","peg$c3","peg$c0","peg$c4","s6","s7","s8","s9","s10","s11","s12","s13","peg$c5","peg$c6","peg$parsefiltered","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$parsestream","peg$parsefilter","peg$c13","peg$c14","peg$parseclass","peg$parseid","peg$c15","peg$parseeventType","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$parsevalue","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$result","peg$startRuleFunctions","peg$startRuleFunction","f1","f2","middle","event","target","startRule",47,"eval","../expression",48,"defFactory","interactor","inject","pd","nsSignals","nsPredicates","nsMarks","mk","injectMarks","from","ENTER","UPDATE","EXIT","ns","streams","operands","nsOperand","nsProperties","enter","exit","propset","rule","interactors",49,"parseProperties","parseMark","mark","delay","./properties",50,"./mark",51,"signalName","ADD","REMOVE","TOGGLE","CLEAR","../dataflow/tuple",52,53,"parseSignal","parseOperands","decl","arg","pred","parseComparator","parseLogical","parseIn","parseScale","scope","invert","=","==","!=",">",">=","<","<=","and","&&","or","||","in",54,"compile","vars","valueRef","DEPS","hasPath","encoder","tpl","encode","path","tension","rules","inputs","predName","colorRef","sgRef","fRef","sRef","fieldRef","scaleRef","band","mult","xx","color","yy","zz","nested","fr",55,"dep","./expr",56,"parsePadding","parseMarks","parseSignals","parsePredicates","parseInteractors","viewFactory","../core/Model","../core/View","../parse/data","../parse/interactors","../parse/marks","../parse/padding","../parse/predicates","../parse/signals",57,"changset","selector","START","MIDDLE","END","sig","register","orderedStream","trueFn","sp","mergedStream","sel","evt","filtered","preventDefault","mouse","./events",58,"tx","../transforms/index",59,"eventName","_active","_obj","that","events","addEventListener","touchmove","mousemove","getBoundingClientRect","clientX","clientY","pick","touchend","mouseout","DOMMouseScroll","gx","gy","marktype","picker","./marks",60,"scaleCanvas","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","initializeLineDash","vgLineDash","NODASH","setLineDash","dash","vgLineDashOffset","lineDashOffset","webkitLineDash","webkitLineDashOffset","mozDash","translatedBounds","Bounds","getBounds","setBounds","bbox","beginPath","rect","clip","_ctx","_imgload","selectAll","_ratio","element","bb2","save","clearRect","draw","renderAsync","_async_id","clearTimeout","loadImage","uri","image","Image","../../core/Bounds","../../util/config",61,"./Handler","./Renderer",62,"fontString","fontStyle","fontVariant","fontWeight","fontSize","font","arcPath","ir","innerRadius","outerRadius","startAngle","ea","endAngle","moveTo","arc","closePath","areaPath","pathCache","parsePath","area","renderPath","linePath","pathPath","symbolPath","rx","ry","shape","lineTo","tan30","sqrt3","lineStroke","lw","strokeWidth","lc","strokeCap","lineWidth","lineCap","ruleStroke","drawPathOne","opac","fill","stroke","opacity","globalAlpha","fillOpacity","fillStyle","strokeOpacity","strokeStyle","strokeDash","strokeDashOffset","drawPathAll","drawRect","fillRect","strokeRect","drawRule","drawImage","align","baseline","drawText","textAlign","textBaseline","radius","theta","fillText","strokeText","drawAll","pathFunc","drawOne","drawGroup","legends","axisItems","legendItems","gradient","grad","createLinearGradient","stops","addColorStop","pickGroup","subscene","hit","interactive","pickAll","hitTests","pickArea","pickLine","textHit","boundsCalc","tmpBounds","isPointInStroke","isPointInPath","symbol","../../util/bounds","./path",63,"currentPath","chunks","parsed","re","chunksParsed","jlen","command","commandLength","cmdLength","klen","drawArc","coords","rot","large","sweep","ex","ey","segs","arcToSegments","bez","segmentToBezier","bezierCurveTo","boundArc","rotateX","ox","oy","argsStr","arcToSegmentsCache","sin_th","cos_th","pl","a00","a01","a10","a11","x0","y0","sfactor_sq","sfactor","xc","yc","th0","th1","th_arc","segments","th2","th3","segmentToBezierCache","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","current","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","quadraticCurveTo",64,"SVGBuilder","./svg",65,66,"tag","close","escape_text","escape_font","group_bg","styl","class","clip_id","clipping","arc_path","area_path_h","area_path_v","line_path","symbol_path","xlink:href","text-anchor","cssClass","cls","xw","yh","styleProps","styles","_gid","_text","foot","svgNamespace","buildDefs","dgrad","dclip","stop-color","meta","MARKS","sty","nest","center",67,"svgHandler","__data__","_svg","dom","removeEventListener",68,"updateDefs","each","grd","cr","renderItems",69,"dup",70,"setProperty","removeProperty","area_path","setAttributeNS","removeAttribute","textContent","drawMark","evts","grps","childNodes","notG","mark_id",71,"Bounder","_mark","GROUP","../util/bounds",72,"inlineDs","sibling","_def","geom","_parent_id","_from","_ds","_isSuper","_bounder","newItem","Item","keyf","_map","joinDatasource","fullUpdate","keyFunction","joinValues","_items","parent_id","inheritFrom","_parent","_encoder","builder","fcs","./Bounder","./Encoder","./Item",73,"preds","enc","EMPTY",74,"_children","_scaler","_recursor","_scales","recurse","hasMarks","hasAxes","inline","buildMarks","buildAxes","MARK","parseAxes","buildGroup","inherit","axisDef","AXIS","Scale","acc","group_id","../dataflow/Collector","../parse/axes","./Builder","./Scale",75,"hasPropertySet","cousin","iidx","midx","touch",76,"_updated","instance","ORDINAL","ordinal","quantitative","rng","LINEAR","scaleName","dataDrivenRange","dataRef","RANGE","DOMAIN","points","rangePoints","rangeRoundBands","rangeBands","interval","QUANTILE","domainMinMax","rangeRound","exponent","POWER","clamp","nice","TIME","isUniques","getRefs","getFields","aggrType","refs","Aggregate","TUPLE","MULTI","VALUE","getCache","which","atype","uniques","ck","cache","GROUPBY","COUNT","stat","MIN","MAX","rlen","flen","accessors","order","DESC","domainMin","domainMax","LOG","zero","GROUP_PROPERTY","rangeMin","rangeMax","SIGNAL","../transforms/Aggregate",77,"updates","elapsed","calcBounds","skip","interp","timer",78,"axis_def","newScale","oldScale","rangeBand","vg_axisScaleRange","gridLines","vg_axisTicks","tickLabels","vg_axisTickLabels","vg_axisDomain","vg_axisTitle","gridColor","vg_axisTicksExtend","tickMajorSize","tickMinorSize","vg_axisLabelExtend","vg_axisDomainExtend","tickEndSize","vg_axisTitleExtend","gridLineStyle","majorTickStyle","minorTickStyle","tickLabelStyle","domainStyle","titleStyle","vg_axisUpdate","tickFormatString","tickArguments","injest","major","minor","vg_axisSubdivide","label","tdata","vg_axisOrients","subticks","vg_axisScaleExtent","rangeExtent","vg_axisBaseline","vg_axisAlign","tickColor","tickWidth","tickLabelColor","tickLabelFont","tickLabelFontSize","titleFont","titleFontSize","titleFontWeight","titleColor","axisColor","axisWidth","../parse/mark",79,"Transform","addParameters","_fieldsDef","_acc","_cache","standardize","spoof_prev","Facetor","_reset","./Facetor","./Transform",80,"BatchTransform","batchTransform",81,"Bin","default","bin",82,"Cross","with","diagonal","_lastRem","_lastWith","_ids","wdata","diag","cross","upFields","selfCross","woutput",83,"Facet","../parse/transforms","./Aggregate",84,"disconnect_cell",85,"Filter","_skip","../parse/expr",86,"Fold","rst","get_tuple","dlen","fold",87,"Force","links","linkDistance","linkStrength","charge","chargeDistance","iterations","friction","gravity","alpha","_nodes","_links","_layout","layout","force","nodeInput","linkInput","iter","link","tick","nodeIds","linkIds",88,"Formula",89,"Geo","Parameters","lon","lat","projection","clipAngle","clipExtent","d3Projection","proj","param","_mode","_projection","geo","ll","xy",90,"GeoPath","geojson","./Geo",91,"LinkPath","sx","sy","ty","curve","ix","iy","diagonalX","diagonalY","shapes",92,"Parameter","_accessors","_resolution","arrayType","dataType","fieldType","exprType","isData","isField","sources","isExpr",93,"Pie","ones","./BatchTransform",94,"Sort","by",95,"Stack","sortby","partition","groups",96,"params","_parameters","./Parameter",97,"Treemap","sticky","mode","treemap",98,"Zip","withKey","_lastJoin","mp","wds","dflt","prevm","wlen",99,"aggregate","linkpath","formula","geopath","pie","zip","./Bin","./Cross","./Facet","./Filter","./Fold","./Force","./Formula","./GeoPath","./LinkPath","./Pie","./Sort","./Stack","./Treemap","./Zip",100,"gfx","pathBounds","boundPath","halfpi","xmin","xmax","ymin","ymax","angles","noRotate","measureText","includeLegends","itemBounds","methods","bounds_prev","pb","markBounds","../core/Bounds","../render/canvas/path","./config",101,"utc","legend","gradientStrokeColor","gradientStrokeWidth","gradientHeight","gradientWidth","labelColor","labelFontSize","labelFont","labelAlign","labelBaseline","labelOffset","symbolShape","symbolSize","symbolColor","symbolStrokeWidth","rgb","lab","hcl","hsl","category10","category20",102,"ID","sentinel","SINGLETON","SORT","ASC",103,"console"],"mappings":"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","file":"vega2.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  core: {\n    View: require('./src/core/View')\n  },\n  dataflow: {\n    changeset: require('./src/dataflow/changeset'),\n    Datasource: require('./src/dataflow/Datasource'),\n    Graph: require('./src/dataflow/Graph'),\n    Node: require('./src/dataflow/Node')\n  },\n  parse: {\n    spec: require('./src/parse/spec')\n  },\n  scene: {\n    Builder: require('./src/scene/Builder'),\n    GroupBuilder: require('./src/scene/GroupBuilder')\n  },\n  transforms: require('./src/transforms/index'),\n  config: require('./src/util/config'),\n  util: require('datalib')\n};\n},{\"./src/core/View\":31,\"./src/dataflow/Datasource\":33,\"./src/dataflow/Graph\":34,\"./src/dataflow/Node\":35,\"./src/dataflow/changeset\":37,\"./src/parse/spec\":56,\"./src/scene/Builder\":72,\"./src/scene/GroupBuilder\":74,\"./src/transforms/index\":99,\"./src/util/config\":101,\"datalib\":20}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x));\n};\n\nproto._newcell = function(x) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      if (cell.collect) {\n        cell.data.values();\n      }\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      result.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function() {\n  var changes = {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === Flags.MOD_CELL) {\n        changes.rem.push(cell.tuple);\n      }\n      delete this._cells[k];\n    } else if (flag & Flags.ADD_CELL) {\n      changes.add.push(cell.tuple);\n    } else if (flag & Flags.MOD_CELL) {\n      changes.mod.push(cell.tuple);\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;\n},{\"../util\":25,\"./collector\":5,\"./measures\":7}],5:[function(require,module,exports){\nvar util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return (this._get = null, this._add);\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  this._get = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m ? get(m) : +Infinity;\n};\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;\n},{\"../stats\":22,\"../util\":25}],6:[function(require,module,exports){\nvar util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n\n},{\"../util\":25,\"./aggregator\":4}],7:[function(require,module,exports){\nvar util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;\n},{\"../stats\":22,\"../util\":25}],8:[function(require,module,exports){\nvar util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n\n},{\"../time-units\":24,\"../util\":25}],9:[function(require,module,exports){\nvar stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};\n},{\"../generate\":10,\"../import/type\":19,\"../stats\":22,\"../util\":25,\"./bins\":8}],10:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n},{}],11:[function(require,module,exports){\n(function (global){\nvar util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util\":25}],12:[function(require,module,exports){\nvar dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};\n},{\"./dsv\":11,\"./json\":13,\"./topojson\":14,\"./treejson\":15}],13:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":25}],14:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":13}],15:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":13}],16:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":25,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],17:[function(require,module,exports){\nvar util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n\n},{\"../util\":25,\"./formats\":12,\"./type\":19}],18:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":25,\"./load\":16,\"./read\":17}],19:[function(require,module,exports){\nvar util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n},{\"../util\":25}],20:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;\n},{\"./aggregate/groupby\":6,\"./bins/bins\":8,\"./bins/histogram\":9,\"./generate\":10,\"./import/load\":16,\"./import/read\":17,\"./import/readers\":18,\"./import/type\":19,\"./print\":21,\"./stats\":22,\"./template\":23,\"./time-units\":24,\"./util\":25}],21:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}\n},{\"./import/type\":19,\"./stats\":22,\"./template\":23,\"./util\":25}],22:[function(require,module,exports){\nvar util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;\n},{\"./generate\":10,\"./import/type\":19,\"./util\":25}],23:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\ntemplate.source = source;\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util\":25}],24:[function(require,module,exports){\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{}],25:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"./time-units\":24,\"_process\":3,\"buffer\":2}],26:[function(require,module,exports){\nmodule.exports = require('./lib/heap');\n\n},{\"./lib/heap\":27}],27:[function(require,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n},{}],28:[function(require,module,exports){\nvar bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;\n},{}],29:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../render/canvas/index\":61,\"../render/svg-headless/index\":65,\"../util/debug\":103,\"./View\":31,\"datalib\":20}],30:[function(require,module,exports){\nvar Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;\n},{\"../dataflow/Graph\":34,\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../scene/GroupBuilder\":74,\"datalib\":20}],31:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../parse/streams\":57,\"../render/canvas/index\":61,\"../render/svg/index\":69,\"../scene/Encoder\":73,\"../scene/Transition\":77,\"../util/config\":101,\"../util/debug\":103,\"./HeadlessView\":29,\"datalib\":20}],32:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"../util/constants\":102,\"../util/debug\":103,\"./Node\":35,\"./changeset\":37}],33:[function(require,module,exports){\nvar dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;\n},{\"../util/constants\":102,\"../util/debug\":103,\"./Collector\":32,\"./Node\":35,\"./changeset\":37,\"./tuple\":38,\"datalib\":20}],34:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;\n},{\"../util/constants\":102,\"../util/debug\":103,\"./Datasource\":33,\"./Signal\":36,\"./changeset\":37,\"datalib\":20,\"heap\":26}],35:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;\n},{\"../util/constants\":102,\"datalib\":20}],36:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;\n},{\"./Node\":35,\"./changeset\":37}],37:[function(require,module,exports){\nvar C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};\n},{\"../util/constants\":102}],38:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction has_prev(t) {\n  return t._prev && t._prev !== C.SENTINEL;\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  set_prev: set_prev,\n  has_prev: has_prev,\n  reset:  reset,\n  idMap:  idMap\n};\n},{\"../util/constants\":102,\"datalib\":20}],39:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};\n},{\"./constants\":40,\"./functions\":41,\"datalib\":20}],40:[function(require,module,exports){\nmodule.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};\n},{}],41:[function(require,module,exports){\nvar datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};\n},{\"datalib\":20}],42:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n\n},{\"./codegen\":39,\"./parser\":43}],43:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],44:[function(require,module,exports){\nvar dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;\n},{\"../scene/axis\":78,\"../util/config\":101,\"datalib\":20}],45:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n\n},{\"../util/config\":101,\"./modify\":51,\"./transforms\":58,\"datalib\":20}],46:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};\n},{}],47:[function(require,module,exports){\nvar dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;\n},{\"../expression\":42,\"datalib\":20}],48:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}\n},{\"../util/config\":101,\"../util/constants\":102,\"datalib\":20}],49:[function(require,module,exports){\nvar dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};\n},{\"./properties\":54,\"datalib\":20}],50:[function(require,module,exports){\nvar parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};\n},{\"./mark\":49}],51:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}\n},{\"../dataflow/Node\":35,\"../dataflow/tuple\":38,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],52:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}\n},{\"datalib\":20}],53:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n},{\"datalib\":20}],54:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"../util/config\":101,\"datalib\":20}],55:[function(require,module,exports){\nvar expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n},{\"../util/constants\":102,\"./expr\":47}],56:[function(require,module,exports){\nvar dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n\n},{\"../core/Model\":30,\"../core/View\":31,\"../parse/data\":45,\"../parse/interactors\":48,\"../parse/marks\":50,\"../parse/padding\":52,\"../parse/predicates\":53,\"../parse/signals\":55,\"datalib\":20}],57:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../util/constants\":102,\"./events\":46,\"./expr\":47,\"datalib\":20}],58:[function(require,module,exports){\nvar dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  \n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};\n},{\"../transforms/index\":99,\"datalib\":20}],59:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":62,\"datalib\":20}],60:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":28,\"../../util/config\":101,\"./marks\":62,\"datalib\":20}],61:[function(require,module,exports){\nmodule.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};\n},{\"./Handler\":59,\"./Renderer\":60}],62:[function(require,module,exports){\nvar Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};\n},{\"../../core/Bounds\":28,\"../../util/bounds\":100,\"../../util/config\":101,\"./path\":63}],63:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":28}],64:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":101,\"./svg\":66,\"datalib\":20}],65:[function(require,module,exports){\nmodule.exports = {\n  Renderer: require('./Renderer')\n};\n\n},{\"./Renderer\":64}],66:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":101,\"datalib\":20}],67:[function(require,module,exports){\nvar dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;\n},{\"datalib\":20}],68:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":70,\"datalib\":20}],69:[function(require,module,exports){\narguments[4][61][0].apply(exports,arguments)\n},{\"./Handler\":67,\"./Renderer\":68,\"dup\":61}],70:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":101,\"datalib\":20}],71:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;\n},{\"../dataflow/Node\":35,\"../util/bounds\":100,\"../util/constants\":102,\"../util/debug\":103}],72:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../parse/data\":45,\"../util/constants\":102,\"../util/debug\":103,\"./Bounder\":71,\"./Encoder\":73,\"./Item\":75,\"datalib\":20}],73:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;\n},{\"../dataflow/Node\":35,\"../util/bounds\":100,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],74:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n},{\"../dataflow/Collector\":32,\"../dataflow/Node\":35,\"../parse/axes\":44,\"../util/constants\":102,\"../util/debug\":103,\"./Builder\":72,\"./Scale\":76,\"datalib\":20}],75:[function(require,module,exports){\nfunction Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;\n},{}],76:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction isUniques(scale) { \n  return scale.type === C.ORDINAL || scale.type === C.QUANTILE; \n}\n\nfunction getRefs(def) { \n  return def.fields || dl.array(def);\n}\n\nfunction getFields(ref, group) {\n  return dl.array(ref.field).map(function(f) {\n    if (f.parent) return dl.accessor(f.parent)(group.datum)\n    return f; // String or {\"signal\"}\n  });\n}\n\n// Scale datarefs can be computed over multiple schema types. \n// This function determines the type of aggregator created, and\n// what data is sent to it: values, tuples, or multi-tuples that must\n// be standardized into a consistent schema. \nfunction aggrType(def, scale) {\n  var refs = getRefs(def);\n\n  // If we're operating over only a single domain, send full tuples\n  // through for efficiency (fewer accessor creations/calls)\n  if(refs.length == 1 && dl.array(refs[0].field).length == 1) {\n    return Aggregate.TYPES.TUPLE;\n  }\n\n  // With quantitative scales, we only care about min/max.\n  if(!isUniques(scale)) return Aggregate.TYPES.VALUE;\n\n  // If we don't sort, then we can send values directly to aggrs as well\n  if(!def.sort) return Aggregate.TYPES.VALUE;\n\n  return Aggregate.TYPES.MULTI;\n}\n\nfunction getCache(which, def, scale, group) {\n  var refs = getRefs(def),\n      atype = aggrType(def, scale),\n      uniques = isUniques(scale),\n      sort = def.sort,\n      ck = \"_\"+which,\n      fields = getFields(refs[0], group),\n      i, rlen, j, flen, ref, field;\n\n  if(scale[ck]) return scale[ck];\n\n  var cache = scale[ck] = new Aggregate(this._graph).type(atype),\n      groupby, summarize;\n\n  if(uniques) {\n    if(atype === Aggregate.TYPES.VALUE) {\n      groupby = [{ name: C.GROUPBY, get: dl.identity }];\n      summarize = {\"*\": C.COUNT};\n    } else if(atype === Aggregate.TYPES.TUPLE) {\n      groupby = [{ name: C.GROUPBY, get: dl.$(fields[0]) }];\n      summarize = sort ? [{\n        name: C.VALUE,\n        get:  dl.$(ref.sort || sort.field),\n        ops: [sort.stat]\n      }] : {\"*\": C.COUNT};\n    } else {  // atype === Aggregate.TYPES.MULTI\n      groupby   = C.GROUPBY;\n      summarize = [{ name: C.VALUE, ops: [sort.stat] }]; \n    }\n  } else {\n    groupby = [];\n    summarize = [{\n      name: C.VALUE,\n      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,\n      ops: [C.MIN, C.MAX],\n      as:  [C.MIN, C.MAX]\n    }];\n  }\n\n  cache.groupby.set(cache, groupby)\n    .summarize.set(cache, summarize);\n\n  return cache;\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = getRefs(def),\n      atype = aggrType(def, scale),\n      cache = getCache.apply(this, arguments),\n      sort  = def.sort,\n      uniques = isUniques(scale),\n      i, rlen, j, flen, ref, fields, field;\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    ref = refs[i];\n    from = ref.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = getFields(ref, group);\n    for(j=0, flen=fields.length; j<flen; ++j) {\n      field = fields[j];\n\n      if(atype === Aggregate.TYPES.VALUE) {\n        cache.accessors(null, field);\n      } else if(atype === Aggregate.TYPES.MULTI) {\n        cache.accessors(field, ref.sort || sort.field);\n      } // Else (Tuple-case) is handled by the aggregator accessors by default\n\n      cache.evaluate(data);\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.aggr().result();\n  if (uniques) {\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + C.VALUE;\n      sort = dl.comparator(sort);\n      data = data.sort(sort);\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return data.map(function(d) { return d[C.GROUPBY]; });\n  } else {\n    data = data[0];\n    return !dl.isValid(data) ? [] : [data[C.MIN], data[C.MAX]];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":35,\"../dataflow/changeset\":37,\"../transforms/Aggregate\":79,\"../util/config\":101,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],77:[function(require,module,exports){\nvar tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;\n},{\"../dataflow/tuple\":38,\"../util/bounds\":100,\"../util/constants\":102}],78:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"../parse/mark\":49,\"../util/config\":101,\"datalib\":20}],79:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Facetor = require('./Facetor'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"}\n  });\n\n  this._fieldsDef = [];\n  this._aggr = null;  // dl.Aggregator\n\n  this._type = TYPES.TUPLE; \n  this._acc = {groupby: dl.true, value: dl.true}\n  this._cache = {};     // And cache them as aggregators expect original tuples.\n\n  // Aggregator needs a full instantiation of the previous tuple. \n  // Cache them to reduce creation costs\n  this._prev = {}; \n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new Transform());\n\nvar TYPES = Aggregate.TYPES = {\n  VALUE: 1, \n  TUPLE: 2, \n  MULTI: 3\n};\n\nproto.summarize = {\n  set: function(transform, summarize) {\n    var i, len, f, fields, name, ops, signals = {};\n    if(!dl.isArray(fields = summarize)) { // Object syntax from dl\n      fields = [];\n      for (name in summarize) {\n        ops = dl.array(summarize[name]);\n        fields.push({name: name, ops: ops});\n      }\n    }\n\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._aggr = null;\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.type = function(type) { \n  return (this._type = type, this); \n};\n\nproto.accessors = function(groupby, value) {\n  var acc = this._acc;\n  acc.groupby = dl.$(groupby) || dl.true;\n  acc.value = dl.$(value) || dl.true;\n};\n\nfunction standardize(x) {\n  var acc = this._acc;\n  if(this._type === TYPES.TUPLE) {\n    return x;\n  } else if(this._type === TYPES.VALUE) {\n    return acc.value(x);\n  } else {\n    return this._cache[x._id] || (this._cache[x._id] = {\n      _id: x._id,\n      groupby: acc.groupby(x),\n      value: acc.value(x)\n    });\n  }\n}\n\nproto.aggr = function() {\n  if(this._aggr) return this._aggr;\n\n  var graph = this._graph,\n      groupby = this.groupby.get(graph).fields;\n\n  var fields = this._fieldsDef.map(function(field) {\n    var f  = dl.duplicate(field);\n    if(field.get) f.get = field.get;\n\n    f.name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    f.ops  = f.ops.signal ? graph.signalRef(f.ops.signal) : dl.array(f.ops).map(function(o) {\n      return o.signal ? graph.signalRef(o.signal) : o;\n    });\n\n    return f;\n  });\n\n  var aggr = this._aggr = new Facetor()\n    .groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  if(this._type !== TYPES.VALUE) aggr.key(\"_id\");\n  return aggr;\n};\n\nproto._reset = function(input, output) {\n  output.rem.push.apply(output.rem, this.aggr().result());\n  this.aggr().clear();\n  this._aggr = null;\n};\n\nfunction spoof_prev(x) {\n  var prev = this._prev[x._id] || (this._prev[x._id] = Object.create(x));\n  return dl.extend(prev, x._prev);\n}\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  var output = changeset.create(input);\n  if(reset) this._reset(input, output);\n\n  var t = this,\n      tpl  = this._type === TYPES.TUPLE, // reduce calls to standardize\n      aggr = this.aggr();\n\n  input.add.forEach(function(x) {\n    aggr._add(tpl ? x : standardize.call(t, x));\n  });\n\n  input.mod.forEach(function(x) {\n    if(reset) {\n      aggr._add(tpl ? x : standardize.call(t, x));  // Signal change triggered reflow\n    } else if(tuple.has_prev(x)) {\n      var prev = spoof_prev.call(t, x);\n      aggr._mod(tpl ? x : standardize.call(t, x), \n        tpl ? prev : standardize.call(t, prev));\n    }\n  });\n\n  input.rem.forEach(function(x) {\n    var y = tuple.has_prev(x) ? spoof_prev.call(t, x) : x;\n    aggr._rem(tpl ? y : standardize.call(t, y));\n    t._cache[x._id] = t._prev[x._id] = null;\n  });\n\n  return aggr.changes(input, output);\n}\n\nmodule.exports = Aggregate;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/constants\":102,\"../util/debug\":103,\"./Facetor\":84,\"./Transform\":96,\"datalib\":20}],80:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n\n},{\"../dataflow/Collector\":32,\"./Transform\":96}],81:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n\n},{\"../dataflow/tuple\":38,\"./Transform\":96,\"datalib\":20}],82:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;\n},{\"../dataflow/Collector\":32,\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/debug\":103,\"./Transform\":96}],83:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Aggregate = require('./Aggregate');\n\nfunction Facet(graph) {\n  this._pipeline = [];\n  return Aggregate.call(this, graph);\n}\n\nvar proto = (Facet.prototype = Object.create(Aggregate.prototype));\n\nproto.pipeline = {\n  set: function(facet, pipeline) {\n    facet._pipeline = pipeline;\n    return facet;\n  },\n  get: function(model, facet) {\n    var parse = require('../parse/transforms');\n    return facet._pipeline.map(function(t) { return parse(model, t) });\n  }\n};\n\nproto.aggr = function() {\n  return Aggregate.prototype.aggr.call(this).facet(this);\n};\n\nmodule.exports = Facet;\n},{\"../parse/transforms\":58,\"./Aggregate\":79,\"./Transform\":96}],84:[function(require,module,exports){\nvar dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facetor() {\n  Aggregator.constructor.call(this);\n  this._facet = null;\n}\n\nvar Aggregator = dl.groupby();\nvar proto = (Facetor.prototype = Object.create(Aggregator));\n\nproto.facet = function(f) {\n  if(!arguments.length) return this._facet;\n  return (this._facet = f, this);\n};\n\nproto._ingest = function(t) { \n  return tuple.ingest(t, null) \n};\n\nproto._assign = tuple.set;\n\nfunction disconnect_cell(facet) {\n  debug({}, [\"deleting cell\", this.tuple._id]);\n  var pipeline = this.ds.pipeline();\n  facet.removeListener(pipeline[0]);\n  facet._graph.disconnect(pipeline);\n}\n\nproto._newcell = function(x) {\n  var cell  = Aggregator._newcell.call(this, x),\n      facet = this._facet,\n      tuple = cell.tuple,\n      graph, pipeline;\n\n  if(this._facet !== null) {\n    graph = facet._graph;\n    pipeline = facet.pipeline.get(graph, facet);\n    cell.ds  = graph.data(\"vg_\"+tuple._id, pipeline, tuple);\n    cell.delete = disconnect_cell;\n    facet.addListener(pipeline[0]);\n  }\n\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var t = Aggregator._newtuple.call(this, x);\n  if(this._facet !== null) {\n    tuple.set(t, \"key\", this._cellkey(x));\n  }\n  return t;\n};\n\nproto.clear = function() {\n  if(this._facet !== null) for (var k in this._cells) {\n    this._cells[k].delete(this._facet);\n  }\n  return Aggregator.clear.call(this);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  Aggregator._add.call(this, x);\n  if(this._facet !== null) cell.ds._input.add.push(x);\n};\n\nproto._mod = function(x, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(x);\n\n  Aggregator._mod.call(this, x, prev);\n  if(this._facet !== null) {  // Propagate tuples\n    if(cell0 === cell1) {\n      cell0.ds._input.mod.push(x);\n    } else {\n      cell0.ds._input.rem.push(x);\n      cell1.ds._input.add.push(x);\n    }\n  }\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  Aggregator._rem.call(this, x);\n  if(this._facet !== null) cell.ds._input.rem.push(x);  \n};\n\nproto.changes = function(input, output) {\n  var aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === C.MOD_CELL) {\n        output.rem.push(cell.tuple);\n      }\n      if(this._facet !== null) cell.delete(this._facet);\n      delete this._cells[k];\n    } else {\n      if(this._facet !== null) {\n        // propagate sort, signals, fields, etc.\n        changeset.copy(input, cell.ds._input);\n      }\n\n      if (flag & C.ADD_CELL) {\n        output.add.push(cell.tuple);\n      } else if (flag & C.MOD_CELL) {\n        output.mod.push(cell.tuple);\n      }\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return output;\n};\n\nmodule.exports = Facetor;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/constants\":102,\"../util/debug\":103,\"datalib\":20}],85:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n},{\"../dataflow/changeset\":37,\"../parse/expr\":47,\"../util/constants\":102,\"../util/debug\":103,\"./Transform\":96}],86:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;\n},{\"../dataflow/changeset\":37,\"../dataflow/tuple\":38,\"../util/debug\":103,\"./Transform\":96}],87:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./Transform\":96}],88:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n},{\"../dataflow/tuple\":38,\"../parse/expr\":47,\"../util/constants\":102,\"../util/debug\":103,\"./Transform\":96}],89:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./Transform\":96,\"datalib\":20}],90:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./Geo\":89,\"./Transform\":96,\"datalib\":20}],91:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n},{\"../dataflow/tuple\":38,\"./Transform\":96}],92:[function(require,module,exports){\nvar dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":47,\"../util/constants\":102,\"datalib\":20}],93:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./BatchTransform\":80,\"./Transform\":96,\"datalib\":20}],94:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;\n},{\"../parse/expr\":47,\"../util/debug\":103,\"./Transform\":96,\"datalib\":20}],95:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n},{\"../dataflow/tuple\":38,\"./BatchTransform\":80,\"./Transform\":96,\"datalib\":20}],96:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"../dataflow/Node\":35,\"../util/constants\":102,\"./Parameter\":92}],97:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":38,\"./BatchTransform\":80,\"./Transform\":96,\"datalib\":20}],98:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;\n},{\"../dataflow/Collector\":32,\"../util/debug\":103,\"./Transform\":96,\"datalib\":20}],99:[function(require,module,exports){\nmodule.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  zip:        require('./Zip')\n};\n},{\"./Aggregate\":79,\"./Bin\":81,\"./Cross\":82,\"./Facet\":83,\"./Filter\":85,\"./Fold\":86,\"./Force\":87,\"./Formula\":88,\"./Geo\":89,\"./GeoPath\":90,\"./LinkPath\":91,\"./Pie\":93,\"./Sort\":94,\"./Stack\":95,\"./Treemap\":97,\"./Zip\":98}],100:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../core/Bounds\":28,\"../render/canvas/path\":63,\"./config\":101}],101:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],102:[function(require,module,exports){\nmodule.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  ID: \"_id\",\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  GROUPBY: \"groupby\",\n  MIN: \"min\",\n  MAX: \"max\",\n  VALUE: \"value\",\n\n  SORT: \"sort\",\n  ASC: \"asc\",\n  DESC: \"desc\"\n};\n},{}],103:[function(require,module,exports){\nvar config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};\n},{\"./config\":101}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJpbmRleCIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9hZ2dyZWdhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2FnZ3JlZ2F0ZS9jb2xsZWN0b3IuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL2dyb3VwYnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvYWdncmVnYXRlL21lYXN1cmVzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2JpbnMvYmlucy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW5zL2hpc3RvZ3JhbS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy9kc3YuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90b3BvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvZm9ybWF0cy90cmVlanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9wcmludC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90aW1lLXVuaXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwic3JjL2NvcmUvQm91bmRzLmpzIiwic3JjL2NvcmUvSGVhZGxlc3NWaWV3LmpzIiwic3JjL2NvcmUvTW9kZWwuanMiLCJzcmMvY29yZS9WaWV3LmpzIiwic3JjL2RhdGFmbG93L0NvbGxlY3Rvci5qcyIsInNyYy9kYXRhZmxvdy9EYXRhc291cmNlLmpzIiwic3JjL2RhdGFmbG93L0dyYXBoLmpzIiwic3JjL2RhdGFmbG93L05vZGUuanMiLCJzcmMvZGF0YWZsb3cvU2lnbmFsLmpzIiwic3JjL2RhdGFmbG93L2NoYW5nZXNldC5qcyIsInNyYy9kYXRhZmxvdy90dXBsZS5qcyIsInNyYy9leHByZXNzaW9uL2NvZGVnZW4uanMiLCJzcmMvZXhwcmVzc2lvbi9jb25zdGFudHMuanMiLCJzcmMvZXhwcmVzc2lvbi9mdW5jdGlvbnMuanMiLCJzcmMvZXhwcmVzc2lvbi9pbmRleC5qcyIsInNyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsInNyYy9wYXJzZS9heGVzLmpzIiwic3JjL3BhcnNlL2RhdGEuanMiLCJzcmMvcGFyc2UvZXZlbnRzLmpzIiwic3JjL3BhcnNlL2V4cHIuanMiLCJzcmMvcGFyc2UvaW50ZXJhY3RvcnMuanMiLCJzcmMvcGFyc2UvbWFyay5qcyIsInNyYy9wYXJzZS9tYXJrcy5qcyIsInNyYy9wYXJzZS9tb2RpZnkuanMiLCJzcmMvcGFyc2UvcGFkZGluZy5qcyIsInNyYy9wYXJzZS9wcmVkaWNhdGVzLmpzIiwic3JjL3BhcnNlL3Byb3BlcnRpZXMuanMiLCJzcmMvcGFyc2Uvc2lnbmFscy5qcyIsInNyYy9wYXJzZS9zcGVjLmpzIiwic3JjL3BhcnNlL3N0cmVhbXMuanMiLCJzcmMvcGFyc2UvdHJhbnNmb3Jtcy5qcyIsInNyYy9yZW5kZXIvY2FudmFzL0hhbmRsZXIuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvY2FudmFzL2luZGV4LmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3MuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9wYXRoLmpzIiwic3JjL3JlbmRlci9zdmctaGVhZGxlc3MvUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy1oZWFkbGVzcy9pbmRleC5qcyIsInNyYy9yZW5kZXIvc3ZnLWhlYWRsZXNzL3N2Zy5qcyIsInNyYy9yZW5kZXIvc3ZnL0hhbmRsZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvc3ZnL21hcmtzLmpzIiwic3JjL3NjZW5lL0JvdW5kZXIuanMiLCJzcmMvc2NlbmUvQnVpbGRlci5qcyIsInNyYy9zY2VuZS9FbmNvZGVyLmpzIiwic3JjL3NjZW5lL0dyb3VwQnVpbGRlci5qcyIsInNyYy9zY2VuZS9JdGVtLmpzIiwic3JjL3NjZW5lL1NjYWxlLmpzIiwic3JjL3NjZW5lL1RyYW5zaXRpb24uanMiLCJzcmMvc2NlbmUvYXhpcy5qcyIsInNyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsInNyYy90cmFuc2Zvcm1zL0JhdGNoVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvQmluLmpzIiwic3JjL3RyYW5zZm9ybXMvQ3Jvc3MuanMiLCJzcmMvdHJhbnNmb3Jtcy9GYWNldC5qcyIsInNyYy90cmFuc2Zvcm1zL0ZhY2V0b3IuanMiLCJzcmMvdHJhbnNmb3Jtcy9GaWx0ZXIuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb2xkLmpzIiwic3JjL3RyYW5zZm9ybXMvRm9yY2UuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb3JtdWxhLmpzIiwic3JjL3RyYW5zZm9ybXMvR2VvLmpzIiwic3JjL3RyYW5zZm9ybXMvR2VvUGF0aC5qcyIsInNyYy90cmFuc2Zvcm1zL0xpbmtQYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvUGFyYW1ldGVyLmpzIiwic3JjL3RyYW5zZm9ybXMvUGllLmpzIiwic3JjL3RyYW5zZm9ybXMvU29ydC5qcyIsInNyYy90cmFuc2Zvcm1zL1N0YWNrLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJlZW1hcC5qcyIsInNyYy90cmFuc2Zvcm1zL1ppcC5qcyIsInNyYy90cmFuc2Zvcm1zL2luZGV4LmpzIiwic3JjL3V0aWwvYm91bmRzLmpzIiwic3JjL3V0aWwvY29uZmlnLmpzIiwic3JjL3V0aWwvY29uc3RhbnRzLmpzIiwic3JjL3V0aWwvZGVidWcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9UQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeFhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqMEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvcmU6IHtcbiAgICBWaWV3OiByZXF1aXJlKCcuL3NyYy9jb3JlL1ZpZXcnKVxuICB9LFxuICBkYXRhZmxvdzoge1xuICAgIGNoYW5nZXNldDogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgRGF0YXNvdXJjZTogcmVxdWlyZSgnLi9zcmMvZGF0YWZsb3cvRGF0YXNvdXJjZScpLFxuICAgIEdyYXBoOiByZXF1aXJlKCcuL3NyYy9kYXRhZmxvdy9HcmFwaCcpLFxuICAgIE5vZGU6IHJlcXVpcmUoJy4vc3JjL2RhdGFmbG93L05vZGUnKVxuICB9LFxuICBwYXJzZToge1xuICAgIHNwZWM6IHJlcXVpcmUoJy4vc3JjL3BhcnNlL3NwZWMnKVxuICB9LFxuICBzY2VuZToge1xuICAgIEJ1aWxkZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0J1aWxkZXInKSxcbiAgICBHcm91cEJ1aWxkZXI6IHJlcXVpcmUoJy4vc3JjL3NjZW5lL0dyb3VwQnVpbGRlcicpXG4gIH0sXG4gIHRyYW5zZm9ybXM6IHJlcXVpcmUoJy4vc3JjL3RyYW5zZm9ybXMvaW5kZXgnKSxcbiAgY29uZmlnOiByZXF1aXJlKCcuL3NyYy91dGlsL2NvbmZpZycpLFxuICB1dGlsOiByZXF1aXJlKCdkYXRhbGliJylcbn07IixudWxsLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gICAgTWVhc3VyZXMgPSByZXF1aXJlKCcuL21lYXN1cmVzJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi9jb2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQWdncmVnYXRvcigpIHtcbiAgdGhpcy5fY2VsbHMgPSB7fTtcbiAgdGhpcy5fYWdnciA9IFtdO1xuICB0aGlzLl9zdHJlYW0gPSBmYWxzZTtcbn1cblxudmFyIEZsYWdzID0gQWdncmVnYXRvci5GbGFncyA9IHtcbiAgQUREX0NFTEw6IDEsXG4gIE1PRF9DRUxMOiAyXG59O1xuXG52YXIgcHJvdG8gPSBBZ2dyZWdhdG9yLnByb3RvdHlwZTtcblxuLy8gUGFyYW1ldGVyc1xuXG5wcm90by5zdHJlYW0gPSBmdW5jdGlvbih2KSB7XG4gIGlmICh2ID09IG51bGwpIHJldHVybiB0aGlzLl9zdHJlYW07XG4gIHRoaXMuX3N0cmVhbSA9ICEhdjtcbiAgdGhpcy5fYWdnciA9IFtdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGtleSBhY2Nlc3NvciB0byB1c2UgZm9yIHN0cmVhbWluZyByZW1vdmVzXG5wcm90by5rZXkgPSBmdW5jdGlvbihrZXkpIHtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gdGhpcy5fa2V5O1xuICB0aGlzLl9rZXkgPSB1dGlsLiQoa2V5KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBJbnB1dDogYXJyYXkgb2Ygb2JqZWN0cyBvZiB0aGUgZm9ybVxuLy8ge25hbWU6IHN0cmluZywgZ2V0OiBmdW5jdGlvbn1cbnByb3RvLmdyb3VwYnkgPSBmdW5jdGlvbihkaW1zKSB7XG4gIHRoaXMuX2RpbXMgPSB1dGlsLmFycmF5KGRpbXMpLm1hcChmdW5jdGlvbihkLCBpKSB7XG4gICAgZCA9IHV0aWwuaXNTdHJpbmcoZCkgPyB7bmFtZTogZCwgZ2V0OiB1dGlsLiQoZCl9XG4gICAgICA6IHV0aWwuaXNGdW5jdGlvbihkKSA/IHtuYW1lOiB1dGlsLm5hbWUoZCkgfHwgZC5uYW1lIHx8ICgnXycgKyBpKSwgZ2V0OiBkfVxuICAgICAgOiAoZC5uYW1lICYmIHV0aWwuaXNGdW5jdGlvbihkLmdldCkpID8gZCA6IG51bGw7XG4gICAgaWYgKGQgPT0gbnVsbCkgdGhyb3cgJ0ludmFsaWQgZ3JvdXBieSBhcmd1bWVudDogJyArIGQ7XG4gICAgcmV0dXJuIGQ7XG4gIH0pO1xuICByZXR1cm4gdGhpcy5jbGVhcigpO1xufTtcblxuLy8gSW5wdXQ6IGFycmF5IG9mIG9iamVjdHMgb2YgdGhlIGZvcm1cbi8vIHtuYW1lOiBzdHJpbmcsIG9wczogW3N0cmluZywgLi4uXX1cbnByb3RvLnN1bW1hcml6ZSA9IGZ1bmN0aW9uKGZpZWxkcykge1xuICBmaWVsZHMgPSBzdW1tYXJpemVfYXJncyhmaWVsZHMpO1xuICB0aGlzLl9jb3VudCA9IHRydWU7XG4gIHZhciBhZ2dyID0gKHRoaXMuX2FnZ3IgPSBbXSksXG4gICAgICBtLCBmLCBpLCBqLCBvcCwgYXMsIGdldDtcblxuICBmb3IgKGk9MDsgaTxmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICBmb3IgKGo9MCwgbT1bXSwgZj1maWVsZHNbaV07IGo8Zi5vcHMubGVuZ3RoOyArK2opIHtcbiAgICAgIG9wID0gZi5vcHNbal07XG4gICAgICBpZiAob3AgIT09ICdjb3VudCcpIHRoaXMuX2NvdW50ID0gZmFsc2U7XG4gICAgICBhcyA9IChmLmFzICYmIGYuYXNbal0pIHx8IChvcCArIChmLm5hbWU9PT0nKicgPyAnJyA6ICdfJytmLm5hbWUpKTtcbiAgICAgIG0ucHVzaChNZWFzdXJlc1tvcF0oYXMpKTtcbiAgICB9XG4gICAgZ2V0ID0gZi5nZXQgJiYgdXRpbC4kKGYuZ2V0KSB8fFxuICAgICAgKGYubmFtZSA9PT0gJyonID8gdXRpbC5pZGVudGl0eSA6IHV0aWwuJChmLm5hbWUpKTtcbiAgICBhZ2dyLnB1c2goe1xuICAgICAgbmFtZTogZi5uYW1lLFxuICAgICAgbWVhc3VyZXM6IE1lYXN1cmVzLmNyZWF0ZShcbiAgICAgICAgbSxcbiAgICAgICAgdGhpcy5fc3RyZWFtLCAvLyBzdHJlYW1pbmcgcmVtb3ZlIGZsYWdcbiAgICAgICAgZ2V0LCAgICAgICAgICAvLyBpbnB1dCB0dXBsZSBnZXR0ZXJcbiAgICAgICAgdGhpcy5fYXNzaWduKSAvLyBvdXRwdXQgdHVwbGUgc2V0dGVyXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byBzdW1tYXJpemUgYnkgY291bnRcbnByb3RvLmNvdW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnN1bW1hcml6ZSh7JyonOidjb3VudCd9KTtcbn07XG5cbi8vIE92ZXJyaWRlIHRvIHBlcmZvcm0gY3VzdG9tIHR1cGxlIHZhbHVlIGFzc2lnbm1lbnRcbnByb3RvLl9hc3NpZ24gPSBmdW5jdGlvbihvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gc3VtbWFyaXplX2FyZ3MoZmllbGRzKSB7XG4gIGlmICh1dGlsLmlzQXJyYXkoZmllbGRzKSkgeyByZXR1cm4gZmllbGRzOyB9XG4gIGlmIChmaWVsZHMgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgdmFyIGEgPSBbXSwgbmFtZSwgb3BzO1xuICBmb3IgKG5hbWUgaW4gZmllbGRzKSB7XG4gICAgb3BzID0gdXRpbC5hcnJheShmaWVsZHNbbmFtZV0pO1xuICAgIGEucHVzaCh7bmFtZTogbmFtZSwgb3BzOiBvcHN9KTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLy8gQ2VsbCBNYW5hZ2VtZW50XG5cbnByb3RvLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAodGhpcy5fY2VsbHMgPSB7fSwgdGhpcyk7XG59O1xuXG5wcm90by5fY2VsbGtleSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGQgPSB0aGlzLl9kaW1zLFxuICAgICAgbiA9IGQubGVuZ3RoLCBpLFxuICAgICAgayA9IFN0cmluZyhkWzBdLmdldCh4KSk7XG4gIGZvciAoaT0xOyBpPG47ICsraSkge1xuICAgIGsgKz0gJ3wnICsgZFtpXS5nZXQoeCk7XG4gIH1cbiAgcmV0dXJuIGs7XG59O1xuXG5wcm90by5fY2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGtleSA9IHRoaXMuX2RpbXMubGVuZ3RoID8gdGhpcy5fY2VsbGtleSh4KSA6ICcnO1xuICByZXR1cm4gdGhpcy5fY2VsbHNba2V5XSB8fCAodGhpcy5fY2VsbHNba2V5XSA9IHRoaXMuX25ld2NlbGwoeCkpO1xufTtcblxucHJvdG8uX25ld2NlbGwgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0ge1xuICAgIG51bTogICAwLFxuICAgIHR1cGxlOiB0aGlzLl9uZXd0dXBsZSh4KSxcbiAgICBmbGFnOiAgRmxhZ3MuQUREX0NFTEwsXG4gICAgYWdnczogIHt9XG4gIH07XG5cbiAgdmFyIGFnZ3IgPSB0aGlzLl9hZ2dyLCBpO1xuICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0gPSBuZXcgYWdncltpXS5tZWFzdXJlcyhjZWxsLCBjZWxsLnR1cGxlKTtcbiAgfVxuICBpZiAoY2VsbC5jb2xsZWN0KSB7XG4gICAgY2VsbC5kYXRhID0gbmV3IENvbGxlY3Rvcih0aGlzLl9rZXkpO1xuICB9XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX25ld3R1cGxlID0gZnVuY3Rpb24oeCkge1xuICB2YXIgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICB0ID0ge30sIGksIG47XG4gIGZvciAoaT0wLCBuPWRpbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHRbZGltc1tpXS5uYW1lXSA9IGRpbXNbaV0uZ2V0KHgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9pbmdlc3QodCk7XG59O1xuXG4vLyBPdmVycmlkZSB0byBwZXJmb3JtIGN1c3RvbSB0dXBsZSBpbmdlc3Rpb25cbnByb3RvLl9pbmdlc3QgPSB1dGlsLmlkZW50aXR5O1xuXG4vLyBQcm9jZXNzIFR1cGxlc1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSArPSAxO1xuICBpZiAoIXRoaXMuX2NvdW50KSB7IC8vIHNraXAgaWYgY291bnQtb25seVxuICAgIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5hZGQoeCk7XG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uYWRkKHgpO1xuICAgIH1cbiAgfVxuICBjZWxsLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dyID0gdGhpcy5fYWdnciwgaTtcblxuICBjZWxsLm51bSAtPSAxO1xuICBpZiAoIXRoaXMuX2NvdW50KSB7IC8vIHNraXAgaWYgY291bnQtb25seVxuICAgIGlmIChjZWxsLmNvbGxlY3QpIGNlbGwuZGF0YS5yZW0oeCk7XG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0ucmVtKHgpO1xuICAgIH1cbiAgfVxuICBjZWxsLmZsYWcgfD0gRmxhZ3MuTU9EX0NFTEw7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oY3VyciwgcHJldikge1xuICB2YXIgY2VsbDAgPSB0aGlzLl9jZWxsKHByZXYpLFxuICAgICAgY2VsbDEgPSB0aGlzLl9jZWxsKGN1cnIpLFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsIGk7XG5cbiAgaWYgKGNlbGwwICE9PSBjZWxsMSkge1xuICAgIGNlbGwwLm51bSAtPSAxO1xuICAgIGNlbGwxLm51bSArPSAxO1xuICAgIGlmIChjZWxsMC5jb2xsZWN0KSBjZWxsMC5kYXRhLnJlbShwcmV2KTtcbiAgICBpZiAoY2VsbDEuY29sbGVjdCkgY2VsbDEuZGF0YS5hZGQoY3Vycik7XG4gIH0gZWxzZSBpZiAoY2VsbDAuY29sbGVjdCAmJiAhdXRpbC5pc09iamVjdChjdXJyKSkge1xuICAgIGNlbGwwLmRhdGEucmVtKHByZXYpO1xuICAgIGNlbGwwLmRhdGEuYWRkKGN1cnIpO1xuICB9XG5cbiAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgIGNlbGwwLmFnZ3NbYWdncltpXS5uYW1lXS5yZW0ocHJldik7XG4gICAgY2VsbDEuYWdnc1thZ2dyW2ldLm5hbWVdLmFkZChjdXJyKTtcbiAgfVxuICBjZWxsMC5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xuICBjZWxsMS5mbGFnIHw9IEZsYWdzLk1PRF9DRUxMO1xufTtcblxucHJvdG8ucmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGFnZ3IgPSB0aGlzLl9hZ2dyLFxuICAgICAgY2VsbCwgaSwgaztcblxuICBmb3IgKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjZWxsID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYgKGNlbGwubnVtID4gMCkge1xuICAgICAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgICAgICBjZWxsLmRhdGEudmFsdWVzKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGk9MDsgaTxhZ2dyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goY2VsbC50dXBsZSk7XG4gICAgfVxuICAgIGNlbGwuZmxhZyA9IDA7XG4gIH1cblxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5wcm90by5jaGFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjaGFuZ2VzID0ge2FkZDpbXSwgcmVtOltdLCBtb2Q6W119LFxuICAgICAgYWdnciA9IHRoaXMuX2FnZ3IsXG4gICAgICBjZWxsLCBmbGFnLCBpLCBrO1xuXG4gIGZvciAoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGNlbGwgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBmbGFnID0gY2VsbC5mbGFnO1xuXG4gICAgLy8gY29uc29saWRhdGUgY29sbGVjdG9yIHZhbHVlc1xuICAgIGlmIChjZWxsLmNvbGxlY3QpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdHVwbGUgcHJvcGVydGllc1xuICAgIGZvciAoaT0wOyBpPGFnZ3IubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNlbGwuYWdnc1thZ2dyW2ldLm5hbWVdLnNldCgpO1xuICAgIH1cblxuICAgIC8vIG9yZ2FuaXplIG91dHB1dCB0dXBsZXNcbiAgICBpZiAoY2VsbC5udW0gPD0gMCkge1xuICAgICAgaWYgKGZsYWcgPT09IEZsYWdzLk1PRF9DRUxMKSB7XG4gICAgICAgIGNoYW5nZXMucmVtLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fY2VsbHNba107XG4gICAgfSBlbHNlIGlmIChmbGFnICYgRmxhZ3MuQUREX0NFTEwpIHtcbiAgICAgIGNoYW5nZXMuYWRkLnB1c2goY2VsbC50dXBsZSk7XG4gICAgfSBlbHNlIGlmIChmbGFnICYgRmxhZ3MuTU9EX0NFTEwpIHtcbiAgICAgIGNoYW5nZXMubW9kLnB1c2goY2VsbC50dXBsZSk7XG4gICAgfVxuXG4gICAgY2VsbC5mbGFnID0gMDtcbiAgfVxuXG4gIHRoaXMuX3JlbXMgPSBmYWxzZTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5wcm90by5leGVjdXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgcmV0dXJuIHRoaXMuY2xlYXIoKS5pbnNlcnQoaW5wdXQpLnJlc3VsdCgpO1xufTtcblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdGhpcy5fY29uc29saWRhdGUoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGlucHV0Lmxlbmd0aDsgKytpKSB7XG4gICAgdGhpcy5fYWRkKGlucHV0W2ldKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGlmICghdGhpcy5fc3RyZWFtKSB7XG4gICAgdGhyb3cgJ0FnZ3JlZ2F0b3Igbm90IGNvbmZpZ3VyZWQgZm9yIHN0cmVhbWluZyByZW1vdmVzLicgK1xuICAgICAgJyBDYWxsIHN0cmVhbSh0cnVlKSBwcmlvciB0byBjYWxsaW5nIHN1bW1hcml6ZS4nO1xuICB9XG4gIGZvciAodmFyIGk9MDsgaTxpbnB1dC5sZW5ndGg7ICsraSkge1xuICAgIHRoaXMuX3JlbShpbnB1dFtpXSk7XG4gIH1cbiAgdGhpcy5fcmVtcyA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gY29uc29saWRhdGUgcmVtb3ZhbHNcbnByb3RvLl9jb25zb2xpZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3JlbXMpIHJldHVybjtcbiAgZm9yICh2YXIgayBpbiB0aGlzLl9jZWxscykge1xuICAgIGlmICh0aGlzLl9jZWxsc1trXS5jb2xsZWN0KSB7XG4gICAgICB0aGlzLl9jZWxsc1trXS5kYXRhLnZhbHVlcygpO1xuICAgIH1cbiAgfVxuICB0aGlzLl9yZW1zID0gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuLi9zdGF0cycpO1xuXG52YXIgUkVNID0gJ19fZGxfcmVtX18nO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3Ioa2V5KSB7XG4gIHRoaXMuX2FkZCA9IFtdO1xuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fa2V5ID0ga2V5IHx8IG51bGw7XG4gIHRoaXMuX2xhc3QgPSBudWxsO1xufVxuXG52YXIgcHJvdG8gPSBDb2xsZWN0b3IucHJvdG90eXBlO1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMuX2FkZC5wdXNoKHYpO1xufTtcblxucHJvdG8ucmVtID0gZnVuY3Rpb24odikge1xuICB0aGlzLl9yZW0ucHVzaCh2KTtcbn07XG5cbnByb3RvLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fcmVtLmxlbmd0aCA9PT0gMCkgcmV0dXJuICh0aGlzLl9nZXQgPSBudWxsLCB0aGlzLl9hZGQpO1xuICB2YXIgYSA9IHRoaXMuX2FkZCxcbiAgICAgIHIgPSB0aGlzLl9yZW0sXG4gICAgICBrID0gdGhpcy5fa2V5LFxuICAgICAgeCA9IEFycmF5KGEubGVuZ3RoIC0gci5sZW5ndGgpLFxuICAgICAgaSwgaiwgbiwgbTtcblxuICBpZiAoIXV0aWwuaXNPYmplY3QoclswXSkpIHtcbiAgICAvLyBwcm9jZXNzaW5nIHJhdyB2YWx1ZXNcbiAgICBtID0gc3RhdHMuY291bnQubWFwKHIpO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAobVthW2ldXSA+IDApIHtcbiAgICAgICAgbVthW2ldXSAtPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeFtqKytdID0gYVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaykge1xuICAgIC8vIGhhcyB1bmlxdWUga2V5IGZpZWxkLCBzbyB1c2UgdGhhdFxuICAgIG0gPSB1dGlsLnRvTWFwKHIsIGspO1xuICAgIGZvciAoaT0wLCBqPTAsIG49YS5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpZiAoIW0uaGFzT3duUHJvcGVydHkoayhhW2ldKSkpIHsgeFtqKytdID0gYVtpXTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBubyB1bmlxdWUga2V5LCBtYXJrIHR1cGxlcyBkaXJlY3RseVxuICAgIGZvciAoaT0wLCBuPXIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgcltpXVtSRU1dID0gMTtcbiAgICB9XG4gICAgZm9yIChpPTAsIGo9MCwgbj1hLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmICghYVtpXVtSRU1dKSB7IHhbaisrXSA9IGFbaV07IH1cbiAgICB9XG4gICAgZm9yIChpPTAsIG49ci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBkZWxldGUgcltpXVtSRU1dO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX3JlbSA9IFtdO1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICByZXR1cm4gKHRoaXMuX2FkZCA9IHgpO1xufTtcblxuLy8gbWVtb2l6aW5nIHN0YXRpc3RpY3MgbWV0aG9kc1xuXG5wcm90by5leHRlbnQgPSBmdW5jdGlvbihnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9leHQpIHtcbiAgICB2YXIgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICAgIGkgPSBzdGF0cy5leHRlbnQuaW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0OyAgICBcbiAgfVxuICByZXR1cm4gdGhpcy5fZXh0O1xufTtcblxucHJvdG8uYXJnbWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzBdO1xufTtcblxucHJvdG8uYXJnbWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdO1xufTtcblxucHJvdG8ubWluID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVswXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiArSW5maW5pdHk7XG59O1xucHJvdG8ubWF4ID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHZhciBtID0gdGhpcy5leHRlbnQoZ2V0KVsxXTtcbiAgcmV0dXJuIG0gPyBnZXQobSkgOiAtSW5maW5pdHk7XG59O1xuXG5wcm90by5xdWFydGlsZSA9IGZ1bmN0aW9uKGdldCkge1xuICBpZiAodGhpcy5fZ2V0ICE9PSBnZXQgfHwgIXRoaXMuX3EpIHtcbiAgICB0aGlzLl9xID0gc3RhdHMucXVhcnRpbGUodGhpcy52YWx1ZXMoKSwgZ2V0KTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7ICAgIFxuICB9XG4gIHJldHVybiB0aGlzLl9xO1xufTtcblxucHJvdG8ucTEgPSBmdW5jdGlvbihnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVswXTtcbn07XG5cbnByb3RvLnEyID0gZnVuY3Rpb24oZ2V0KSB7XG4gIHJldHVybiB0aGlzLnF1YXJ0aWxlKGdldClbMV07XG59O1xuXG5wcm90by5xMyA9IGZ1bmN0aW9uKGdldCkge1xuICByZXR1cm4gdGhpcy5xdWFydGlsZShnZXQpWzJdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xsZWN0b3I7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgQWdncmVnYXRvciA9IHJlcXVpcmUoJy4vYWdncmVnYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAvLyBmbGF0dGVuIGFyZ3VtZW50cyBpbnRvIGEgc2luZ2xlIGFycmF5XG4gIHZhciBhcmdzID0gW10ucmVkdWNlLmNhbGwoYXJndW1lbnRzLCBmdW5jdGlvbihhLCB4KSB7XG4gICAgcmV0dXJuIGEuY29uY2F0KHV0aWwuYXJyYXkoeCkpO1xuICB9LCBbXSk7XG4gIC8vIGNyZWF0ZSBhbmQgcmV0dXJuIGFuIGFnZ3JlZ2F0b3JcbiAgcmV0dXJuIG5ldyBBZ2dyZWdhdG9yKClcbiAgICAuZ3JvdXBieShhcmdzKVxuICAgIC5zdW1tYXJpemUoeycqJzondmFsdWVzJ30pO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgdHlwZXMgPSB7XG4gICd2YWx1ZXMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFsdWVzJyxcbiAgICBpbml0OiAnY2VsbC5jb2xsZWN0ID0gdHJ1ZTsnLFxuICAgIHNldDogICdjZWxsLmRhdGEudmFsdWVzKCknLCBpZHg6IC0xXG4gIH0pLFxuICAnY291bnQnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnY291bnQnLFxuICAgIHNldDogICdjZWxsLm51bSdcbiAgfSksXG4gICdtaXNzaW5nJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21pc3NpbmcnLFxuICAgIHNldDogICd0aGlzLm1pc3NpbmcnXG4gIH0pLFxuICAndmFsaWQnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAndmFsaWQnLFxuICAgIHNldDogICd0aGlzLnZhbGlkJ1xuICB9KSxcbiAgJ3N1bSc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdW0nLFxuICAgIGluaXQ6ICd0aGlzLnN1bSA9IDA7JyxcbiAgICBhZGQ6ICAndGhpcy5zdW0gKz0gdjsnLFxuICAgIHJlbTogICd0aGlzLnN1bSAtPSB2OycsXG4gICAgc2V0OiAgJ3RoaXMuc3VtJ1xuICB9KSxcbiAgJ21lYW4nOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWVhbicsXG4gICAgaW5pdDogJ3RoaXMubWVhbiA9IDA7JyxcbiAgICBhZGQ6ICAndmFyIGQgPSB2IC0gdGhpcy5tZWFuOyB0aGlzLm1lYW4gKz0gZCAvIHRoaXMudmFsaWQ7JyxcbiAgICByZW06ICAndmFyIGQgPSB2IC0gdGhpcy5tZWFuOyB0aGlzLm1lYW4gLT0gZCAvIHRoaXMudmFsaWQ7JyxcbiAgICBzZXQ6ICAndGhpcy5tZWFuJ1xuICB9KSxcbiAgJ2F2ZXJhZ2UnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnYXZlcmFnZScsXG4gICAgc2V0OiAgJ3RoaXMubWVhbicsXG4gICAgcmVxOiAgWydtZWFuJ10sIGlkeDogMVxuICB9KSxcbiAgJ3ZhcmlhbmNlJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhcmlhbmNlJyxcbiAgICBpbml0OiAndGhpcy5kZXYgPSAwOycsXG4gICAgYWRkOiAgJ3RoaXMuZGV2ICs9IGQgKiAodiAtIHRoaXMubWVhbik7JyxcbiAgICByZW06ICAndGhpcy5kZXYgLT0gZCAqICh2IC0gdGhpcy5tZWFuKTsnLFxuICAgIHNldDogICd0aGlzLmRldiAvICh0aGlzLnZhbGlkLTEpJyxcbiAgICByZXE6ICBbJ21lYW4nXSwgaWR4OiAxXG4gIH0pLFxuICAndmFyaWFuY2VwJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ZhcmlhbmNlcCcsXG4gICAgc2V0OiAgJ3RoaXMuZGV2IC8gdGhpcy52YWxpZCcsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdzdGRldic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdzdGRldicsXG4gICAgc2V0OiAgJ01hdGguc3FydCh0aGlzLmRldiAvICh0aGlzLnZhbGlkLTEpKScsXG4gICAgcmVxOiAgWyd2YXJpYW5jZSddLCBpZHg6IDJcbiAgfSksXG4gICdzdGRldnAnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnc3RkZXZwJyxcbiAgICBzZXQ6ICAnTWF0aC5zcXJ0KHRoaXMuZGV2IC8gdGhpcy52YWxpZCknLFxuICAgIHJlcTogIFsndmFyaWFuY2UnXSwgaWR4OiAyXG4gIH0pLFxuICAnbWVkaWFuJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ21lZGlhbicsXG4gICAgc2V0OiAgJ2NlbGwuZGF0YS5xMih0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ3ExJzogbWVhc3VyZSh7XG4gICAgbmFtZTogJ3ExJyxcbiAgICBzZXQ6ICAnY2VsbC5kYXRhLnExKHRoaXMuZ2V0KScsXG4gICAgcmVxOiAgWyd2YWx1ZXMnXSwgaWR4OiAzXG4gIH0pLFxuICAncTMnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAncTMnLFxuICAgIHNldDogICdjZWxsLmRhdGEucTModGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ3ZhbHVlcyddLCBpZHg6IDNcbiAgfSksXG4gICdkaXN0aW5jdCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdkaXN0aW5jdCcsXG4gICAgc2V0OiAgJ3RoaXMuZGlzdGluY3QoY2VsbC5kYXRhLnZhbHVlcygpLCB0aGlzLmdldCknLFxuICAgIHJlcTogIFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtaW4nLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLmFyZ21pbiA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMuYXJnbWluID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21pbiA9IHRoaXMuYXJnbWluIHx8IGNlbGwuZGF0YS5hcmdtaW4odGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21pbiddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ2FyZ21heCc6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdhcmdtYXgnLFxuICAgIGFkZDogICdpZiAodiA+IHRoaXMubWF4KSB0aGlzLmFyZ21heCA9IHQ7JyxcbiAgICByZW06ICAnaWYgKHYgPj0gdGhpcy5tYXgpIHRoaXMuYXJnbWF4ID0gbnVsbDsnLFxuICAgIHNldDogICd0aGlzLmFyZ21heCA9IHRoaXMuYXJnbWF4IHx8IGNlbGwuZGF0YS5hcmdtYXgodGhpcy5nZXQpJyxcbiAgICByZXE6ICBbJ21heCddLCBzdHI6IFsndmFsdWVzJ10sIGlkeDogM1xuICB9KSxcbiAgJ21pbic6IG1lYXN1cmUoe1xuICAgIG5hbWU6ICdtaW4nLFxuICAgIGluaXQ6ICd0aGlzLm1pbiA9ICtJbmZpbml0eTsnLFxuICAgIGFkZDogICdpZiAodiA8IHRoaXMubWluKSB0aGlzLm1pbiA9IHY7JyxcbiAgICByZW06ICAnaWYgKHYgPD0gdGhpcy5taW4pIHRoaXMubWluID0gTmFOOycsXG4gICAgc2V0OiAgJ3RoaXMubWluID0gKGlzTmFOKHRoaXMubWluKSA/IGNlbGwuZGF0YS5taW4odGhpcy5nZXQpIDogdGhpcy5taW4pJyxcbiAgICBzdHI6ICBbJ3ZhbHVlcyddLCBpZHg6IDRcbiAgfSksXG4gICdtYXgnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbWF4JyxcbiAgICBpbml0OiAndGhpcy5tYXggPSAtSW5maW5pdHk7JyxcbiAgICBhZGQ6ICAnaWYgKHYgPiB0aGlzLm1heCkgdGhpcy5tYXggPSB2OycsXG4gICAgcmVtOiAgJ2lmICh2ID49IHRoaXMubWF4KSB0aGlzLm1heCA9IE5hTjsnLFxuICAgIHNldDogICd0aGlzLm1heCA9IChpc05hTih0aGlzLm1heCkgPyBjZWxsLmRhdGEubWF4KHRoaXMuZ2V0KSA6IHRoaXMubWF4KScsXG4gICAgc3RyOiAgWyd2YWx1ZXMnXSwgaWR4OiA0XG4gIH0pLFxuICAnbW9kZXNrZXcnOiBtZWFzdXJlKHtcbiAgICBuYW1lOiAnbW9kZXNrZXcnLFxuICAgIHNldDogICd0aGlzLmRldj09PTAgPyAwIDogKHRoaXMubWVhbiAtIGNlbGwuZGF0YS5xMih0aGlzLmdldCkpIC8gTWF0aC5zcXJ0KHRoaXMuZGV2Lyh0aGlzLnZhbGlkLTEpKScsXG4gICAgcmVxOiAgWydtZWFuJywgJ3N0ZGV2JywgJ21lZGlhbiddLCBpZHg6IDVcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIG1lYXN1cmUoYmFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob3V0KSB7XG4gICAgdmFyIG0gPSB1dGlsLmV4dGVuZCh7aW5pdDonJywgYWRkOicnLCByZW06JycsIGlkeDowfSwgYmFzZSk7XG4gICAgbS5vdXQgPSBvdXQgfHwgYmFzZS5uYW1lO1xuICAgIHJldHVybiBtO1xuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlKGFnZywgc3RyZWFtKSB7XG4gIGZ1bmN0aW9uIGNvbGxlY3QobSwgYSkge1xuICAgIGZ1bmN0aW9uIGhlbHBlcihyKSB7IGlmICghbVtyXSkgY29sbGVjdChtLCBtW3JdID0gdHlwZXNbcl0oKSk7IH1cbiAgICBpZiAoYS5yZXEpIGEucmVxLmZvckVhY2goaGVscGVyKTtcbiAgICBpZiAoc3RyZWFtICYmIGEuc3RyKSBhLnN0ci5mb3JFYWNoKGhlbHBlcik7XG4gICAgcmV0dXJuIG07XG4gIH1cbiAgdmFyIG1hcCA9IGFnZy5yZWR1Y2UoXG4gICAgY29sbGVjdCxcbiAgICBhZ2cucmVkdWNlKGZ1bmN0aW9uKG0sIGEpIHsgcmV0dXJuIChtW2EubmFtZV0gPSBhLCBtKTsgfSwge30pXG4gICk7XG4gIHJldHVybiB1dGlsLnZhbHMobWFwKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEuaWR4IC0gYi5pZHg7IH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGUoYWdnLCBzdHJlYW0sIGFjY2Vzc29yLCBtdXRhdG9yKSB7XG4gIHZhciBhbGwgPSByZXNvbHZlKGFnZywgc3RyZWFtKSxcbiAgICAgIGN0ciA9ICd0aGlzLmNlbGwgPSBjZWxsOyB0aGlzLnR1cGxlID0gdDsgdGhpcy52YWxpZCA9IDA7IHRoaXMubWlzc2luZyA9IDA7JyxcbiAgICAgIGFkZCA9ICdpZiAodj09bnVsbCkgdGhpcy5taXNzaW5nKys7IGlmICghdGhpcy5pc1ZhbGlkKHYpKSByZXR1cm47IHRoaXMudmFsaWQrKzsnLFxuICAgICAgcmVtID0gJ2lmICh2PT1udWxsKSB0aGlzLm1pc3NpbmctLTsgaWYgKCF0aGlzLmlzVmFsaWQodikpIHJldHVybjsgdGhpcy52YWxpZC0tOycsXG4gICAgICBzZXQgPSAndmFyIHQgPSB0aGlzLnR1cGxlOyB2YXIgY2VsbCA9IHRoaXMuY2VsbDsnO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICBpZiAoYS5pZHggPCAwKSB7XG4gICAgICBjdHIgPSBhLmluaXQgKyBjdHI7XG4gICAgICBhZGQgPSBhLmFkZCArIGFkZDtcbiAgICAgIHJlbSA9IGEucmVtICsgcmVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHIgKz0gYS5pbml0O1xuICAgICAgYWRkICs9IGEuYWRkO1xuICAgICAgcmVtICs9IGEucmVtO1xuICAgIH1cbiAgfSk7XG4gIGFnZy5zbGljZSgpXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSlcbiAgICAuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBzZXQgKz0gJ3RoaXMuYXNzaWduKHQsXFwnJythLm91dCsnXFwnLCcrYS5zZXQrJyk7JztcbiAgICB9KTtcbiAgc2V0ICs9ICdyZXR1cm4gdDsnO1xuXG4gIC8qIGpzaGludCBldmlsOiB0cnVlICovXG4gIGN0ciA9IEZ1bmN0aW9uKCdjZWxsJywgJ3QnLCBjdHIpO1xuICBjdHIucHJvdG90eXBlLmFzc2lnbiA9IG11dGF0b3I7XG4gIGN0ci5wcm90b3R5cGUuYWRkID0gRnVuY3Rpb24oJ3QnLCAndmFyIHYgPSB0aGlzLmdldCh0KTsnICsgYWRkKTtcbiAgY3RyLnByb3RvdHlwZS5yZW0gPSBGdW5jdGlvbigndCcsICd2YXIgdiA9IHRoaXMuZ2V0KHQpOycgKyByZW0pO1xuICBjdHIucHJvdG90eXBlLnNldCA9IEZ1bmN0aW9uKHNldCk7XG4gIGN0ci5wcm90b3R5cGUuZ2V0ID0gYWNjZXNzb3I7XG4gIGN0ci5wcm90b3R5cGUubW9kID0gbW9kO1xuICBjdHIucHJvdG90eXBlLmRpc3RpbmN0ID0gcmVxdWlyZSgnLi4vc3RhdHMnKS5jb3VudC5kaXN0aW5jdDtcbiAgY3RyLnByb3RvdHlwZS5pc1ZhbGlkID0gdXRpbC5pc1ZhbGlkO1xuICByZXR1cm4gY3RyO1xufVxuXG5mdW5jdGlvbiBtb2Qodl9uZXcsIHZfb2xkKSB7XG4gIGlmICh2X29sZCA9PT0gdW5kZWZpbmVkIHx8IHZfb2xkID09PSB2X25ldykgcmV0dXJuO1xuICB0aGlzLnJlbSh2X29sZCk7XG4gIHRoaXMuYWRkKHZfbmV3KTtcbn1cblxudHlwZXMuY3JlYXRlID0gY3JlYXRlO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlczsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB1bml0cyA9IHJlcXVpcmUoJy4uL3RpbWUtdW5pdHMnKTtcbnZhciBFUFNJTE9OID0gMWUtMTU7XG5cbmZ1bmN0aW9uIGJpbnMob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgdmFyIG1heGIgPSBvcHQubWF4YmlucyB8fCAxNSxcbiAgICAgIGJhc2UgPSBvcHQuYmFzZSB8fCAxMCxcbiAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgIGRpdiA9IG9wdC5kaXYgfHwgWzUsIDJdLCAgICAgIFxuICAgICAgbWluID0gb3B0Lm1pbixcbiAgICAgIG1heCA9IG9wdC5tYXgsXG4gICAgICBzcGFuID0gbWF4IC0gbWluLFxuICAgICAgc3RlcCwgbGV2ZWwsIG1pbnN0ZXAsIHByZWNpc2lvbiwgdiwgaSwgZXBzO1xuXG4gIGlmIChvcHQuc3RlcCkge1xuICAgIC8vIGlmIHN0ZXAgc2l6ZSBpcyBleHBsaWNpdGx5IGdpdmVuLCB1c2UgdGhhdFxuICAgIHN0ZXAgPSBvcHQuc3RlcDtcbiAgfSBlbHNlIGlmIChvcHQuc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHN0ZXAgPSBvcHQuc3RlcHNbTWF0aC5taW4oXG4gICAgICBvcHQuc3RlcHMubGVuZ3RoIC0gMSxcbiAgICAgIGJpc2VjdChvcHQuc3RlcHMsIHNwYW4vbWF4YiwgMCwgb3B0LnN0ZXBzLmxlbmd0aClcbiAgICApXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHVzZSBzcGFuIHRvIGRldGVybWluZSBzdGVwIHNpemVcbiAgICBsZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZyhtYXhiKSAvIGxvZ2IpO1xuICAgIG1pbnN0ZXAgPSBvcHQubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChcbiAgICAgIG1pbnN0ZXAsXG4gICAgICBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbClcbiAgICApO1xuICAgIFxuICAgIC8vIGluY3JlYXNlIHN0ZXAgc2l6ZSBpZiB0b28gbWFueSBiaW5zXG4gICAgZG8geyBzdGVwICo9IGJhc2U7IH0gd2hpbGUgKE1hdGguY2VpbChzcGFuL3N0ZXApID4gbWF4Yik7XG5cbiAgICAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuICAgIGZvciAoaT0wOyBpPGRpdi5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHN0ZXAgLyBkaXZbaV07XG4gICAgICBpZiAodiA+PSBtaW5zdGVwICYmIHNwYW4gLyB2IDw9IG1heGIpIHN0ZXAgPSB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcmVjaXNpb24sIG1pbiBhbmQgbWF4XG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxO1xuICBlcHMgPSBNYXRoLnBvdyhiYXNlLCAtcHJlY2lzaW9uIC0gMSk7XG4gIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5mbG9vcihtaW4gLyBzdGVwICsgZXBzKSAqIHN0ZXApO1xuICBtYXggPSBNYXRoLmNlaWwobWF4IC8gc3RlcCkgKiBzdGVwO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiAgbWF4LFxuICAgIHN0ZXA6ICBzdGVwLFxuICAgIHVuaXQ6ICB7cHJlY2lzaW9uOiBwcmVjaXNpb259LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpbmRleDogaW5kZXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmlzZWN0KGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmICh1dGlsLmNtcChhW21pZF0sIHgpIDwgMCkgeyBsbyA9IG1pZCArIDE7IH1cbiAgICBlbHNlIHsgaGkgPSBtaWQ7IH1cbiAgfVxuICByZXR1cm4gbG87XG59XG5cbmZ1bmN0aW9uIHZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMuc3RlcCAqIE1hdGguZmxvb3IodiAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBpbmRleCh2KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKCh2IC0gdGhpcy5zdGFydCkgLyB0aGlzLnN0ZXAgKyBFUFNJTE9OKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV92YWx1ZSh2KSB7XG4gIHJldHVybiB0aGlzLnVuaXQuZGF0ZSh2YWx1ZS5jYWxsKHRoaXMsIHYpKTtcbn1cblxuZnVuY3Rpb24gZGF0ZV9pbmRleCh2KSB7XG4gIHJldHVybiBpbmRleC5jYWxsKHRoaXMsIHRoaXMudW5pdC51bml0KHYpKTtcbn1cblxuYmlucy5kYXRlID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBmaW5kIHRpbWUgc3RlcCwgdGhlbiBiaW5cbiAgdmFyIGRtaW4gPSBvcHQubWluLFxuICAgICAgZG1heCA9IG9wdC5tYXgsXG4gICAgICBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMjAsXG4gICAgICBtaW5iID0gb3B0Lm1pbmJpbnMgfHwgNCxcbiAgICAgIHNwYW4gPSAoK2RtYXgpIC0gKCtkbWluKSxcbiAgICAgIHVuaXQgPSBvcHQudW5pdCA/IHVuaXRzW29wdC51bml0XSA6IHVuaXRzLmZpbmQoc3BhbiwgbWluYiwgbWF4YiksXG4gICAgICBzcGVjID0gYmlucyh7XG4gICAgICAgIG1pbjogICAgIHVuaXQubWluICE9IG51bGwgPyB1bml0Lm1pbiA6IHVuaXQudW5pdChkbWluKSxcbiAgICAgICAgbWF4OiAgICAgdW5pdC5tYXggIT0gbnVsbCA/IHVuaXQubWF4IDogdW5pdC51bml0KGRtYXgpLFxuICAgICAgICBtYXhiaW5zOiBtYXhiLFxuICAgICAgICBtaW5zdGVwOiB1bml0Lm1pbnN0ZXAsXG4gICAgICAgIHN0ZXBzOiAgIHVuaXQuc3RlcFxuICAgICAgfSk7XG5cbiAgc3BlYy51bml0ID0gdW5pdDtcbiAgc3BlYy5pbmRleCA9IGRhdGVfaW5kZXg7XG4gIGlmICghb3B0LnJhdykgc3BlYy52YWx1ZSA9IGRhdGVfdmFsdWU7XG4gIHJldHVybiBzcGVjO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5zO1xuIiwidmFyIHN0YXRzID0gcmVxdWlyZSgnLi4vc3RhdHMnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi4vaW1wb3J0L3R5cGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIGdlbiA9IHJlcXVpcmUoJy4uL2dlbmVyYXRlJyk7XG52YXIgYmlucyA9IHJlcXVpcmUoJy4vYmlucycpO1xuXG52YXIgcXR5cGUgPSB7XG4gICdpbnRlZ2VyJzogMSxcbiAgJ251bWJlcic6IDEsXG4gICdkYXRlJzogMVxufTtcblxuZnVuY3Rpb24gJGJpbih2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiAhYiA/IChvcHQuYWNjZXNzb3IgfHwgdXRpbC5pZGVudGl0eSkgOlxuICAgIHV0aWwuJGZ1bmMoJ2JpbicsIGIudW5pdC51bml0ID9cbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoYi51bml0LnVuaXQoeCkpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGIudmFsdWUoeCk7IH1cbiAgICApKG9wdC5hY2Nlc3Nvcik7XG59XG5cbmZ1bmN0aW9uIGhpc3RvZ3JhbSh2YWx1ZXMsIGYsIG9wdCkge1xuICBvcHQgPSBvcHRpb25zKHZhbHVlcywgZiwgb3B0KTtcbiAgdmFyIGIgPSBzcGVjKG9wdCk7XG4gIHJldHVybiBiID9cbiAgICBudW1lcmljYWwodmFsdWVzLCBvcHQuYWNjZXNzb3IsIGIpIDpcbiAgICBjYXRlZ29yaWNhbCh2YWx1ZXMsIG9wdC5hY2Nlc3Nvciwgb3B0ICYmIG9wdC5zb3J0KTtcbn1cblxuZnVuY3Rpb24gc3BlYyhvcHQpIHtcbiAgdmFyIHQgPSBvcHQudHlwZSwgYiA9IG51bGw7XG4gIGlmICh0ID09IG51bGwgfHwgcXR5cGVbdF0pIHtcbiAgICBpZiAodCA9PT0gJ2ludGVnZXInICYmIG9wdC5taW5zdGVwID09IG51bGwpIG9wdC5taW5zdGVwID0gMTtcbiAgICBiID0gKHQgPT09ICdkYXRlJykgPyBiaW5zLmRhdGUob3B0KSA6IGJpbnMob3B0KTtcbiAgfVxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gb3B0aW9ucygpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHMsXG4gICAgICBpID0gMCxcbiAgICAgIHZhbHVlcyA9IHV0aWwuaXNBcnJheShhW2ldKSA/IGFbaSsrXSA6IG51bGwsXG4gICAgICBmID0gdXRpbC5pc0Z1bmN0aW9uKGFbaV0pIHx8IHV0aWwuaXNTdHJpbmcoYVtpXSkgPyB1dGlsLiQoYVtpKytdKSA6IG51bGwsXG4gICAgICBvcHQgPSB1dGlsLmV4dGVuZCh7fSwgYVtpXSk7XG4gIFxuICBpZiAodmFsdWVzKSB7XG4gICAgb3B0LnR5cGUgPSBvcHQudHlwZSB8fCB0eXBlKHZhbHVlcywgZik7XG4gICAgaWYgKHF0eXBlW29wdC50eXBlXSkge1xuICAgICAgdmFyIGV4dCA9IHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpO1xuICAgICAgb3B0ID0gdXRpbC5leHRlbmQoe21pbjogZXh0WzBdLCBtYXg6IGV4dFsxXX0sIG9wdCk7XG4gICAgfVxuICB9XG4gIGlmIChmKSB7IG9wdC5hY2Nlc3NvciA9IGY7IH1cbiAgcmV0dXJuIG9wdDtcbn1cblxuZnVuY3Rpb24gbnVtZXJpY2FsKHZhbHVlcywgZiwgYikge1xuICB2YXIgaCA9IGdlbi5yYW5nZShiLnN0YXJ0LCBiLnN0b3AgKyBiLnN0ZXAvMiwgYi5zdGVwKVxuICAgIC5tYXAoZnVuY3Rpb24odikgeyByZXR1cm4ge3ZhbHVlOiBiLnZhbHVlKHYpLCBjb3VudDogMH07IH0pO1xuXG4gIGZvciAodmFyIGk9MCwgdiwgajsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7XG4gICAgICBqID0gYi5pbmRleCh2KTtcbiAgICAgIGlmIChqIDwgMCB8fCBqID49IGgubGVuZ3RoIHx8ICFpc0Zpbml0ZShqKSkgY29udGludWU7XG4gICAgICBoW2pdLmNvdW50ICs9IDE7XG4gICAgfVxuICB9XG4gIGguYmlucyA9IGI7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBjYXRlZ29yaWNhbCh2YWx1ZXMsIGYsIHNvcnQpIHtcbiAgdmFyIHUgPSBzdGF0cy51bmlxdWUodmFsdWVzLCBmKSxcbiAgICAgIGMgPSBzdGF0cy5jb3VudC5tYXAodmFsdWVzLCBmKTtcbiAgcmV0dXJuIHUubWFwKGZ1bmN0aW9uKGspIHsgcmV0dXJuIHt2YWx1ZTogaywgY291bnQ6IGNba119OyB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcihzb3J0ID8gJy1jb3VudCcgOiAnK3ZhbHVlJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgJGJpbjogJGJpbixcbiAgaGlzdG9ncmFtOiBoaXN0b2dyYW1cbn07IiwidmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmdlbi5yZXBlYXQgPSBmdW5jdGlvbih2YWwsIG4pIHtcbiAgdmFyIGEgPSBBcnJheShuKSwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBhW2ldID0gdmFsO1xuICByZXR1cm4gYTtcbn07XG5cbmdlbi56ZXJvcyA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuIGdlbi5yZXBlYXQoMCwgbik7XG59O1xuXG5nZW4ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICBzdGVwID0gMTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKChzdG9wIC0gc3RhcnQpIC8gc3RlcCA9PSBJbmZpbml0eSkgdGhyb3cgbmV3IEVycm9yKCdJbmZpbml0ZSByYW5nZScpO1xuICB2YXIgcmFuZ2UgPSBbXSwgaSA9IC0xLCBqO1xuICBpZiAoc3RlcCA8IDApIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPiBzdG9wKSByYW5nZS5wdXNoKGopO1xuICBlbHNlIHdoaWxlICgoaiA9IHN0YXJ0ICsgc3RlcCAqICsraSkgPCBzdG9wKSByYW5nZS5wdXNoKGopO1xuICByZXR1cm4gcmFuZ2U7XG59O1xuXG5nZW4ucmFuZG9tID0ge307XG5cbmdlbi5yYW5kb20udW5pZm9ybSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgIG1heCA9IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG4gIHZhciBkID0gbWF4IC0gbWluO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBtaW4gKyBkICogTWF0aC5yYW5kb20oKTtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLmludGVnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChiID09PSB1bmRlZmluZWQpIHtcbiAgICBiID0gYTtcbiAgICBhID0gMDtcbiAgfVxuICB2YXIgZCA9IGIgLSBhO1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhICsgTWF0aC5mbG9vcihkICogTWF0aC5yYW5kb20oKSk7XG4gIH07XG4gIGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG4gIHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5ub3JtYWwgPSBmdW5jdGlvbihtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2IHx8IDE7XG4gIHZhciBuZXh0O1xuICB2YXIgZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB4ID0gMCwgeSA9IDAsIHJkcywgYztcbiAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB4ID0gbmV4dDtcbiAgICAgIG5leHQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgeCA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgeSA9IE1hdGgucmFuZG9tKCkqMi0xO1xuICAgICAgcmRzID0geCp4ICsgeSp5O1xuICAgIH0gd2hpbGUgKHJkcyA9PT0gMCB8fCByZHMgPiAxKTtcbiAgICBjID0gTWF0aC5zcXJ0KC0yKk1hdGgubG9nKHJkcykvcmRzKTsgLy8gQm94LU11bGxlciB0cmFuc2Zvcm1cbiAgICBuZXh0ID0gbWVhbiArIHkqYypzdGRldjtcbiAgICByZXR1cm4gbWVhbiArIHgqYypzdGRldjtcbiAgfTtcbiAgZi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcbiAgcmV0dXJuIGY7XG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xudmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCk7XG5cbmZ1bmN0aW9uIGRzdihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICB2YXIgaCA9IGZvcm1hdC5oZWFkZXI7XG4gICAgZGF0YSA9IChoID8gaC5qb2luKGZvcm1hdC5kZWxpbWl0ZXIpICsgJ1xcbicgOiAnJykgKyBkYXRhO1xuICB9XG4gIHJldHVybiBkMy5kc3YoZm9ybWF0LmRlbGltaXRlcikucGFyc2UoZGF0YSk7XG59XG5cbmRzdi5kZWxpbWl0ZXIgPSBmdW5jdGlvbihkZWxpbSkge1xuICB2YXIgZm10ID0ge2RlbGltaXRlcjogZGVsaW19O1xuICByZXR1cm4gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGRzdihkYXRhLCBmb3JtYXQgPyB1dGlsLmV4dGVuZChmb3JtYXQsIGZtdCkgOiBmbXQpO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkc3Y7IiwidmFyIGRzdiA9IHJlcXVpcmUoJy4vZHN2Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBqc29uOiByZXF1aXJlKCcuL2pzb24nKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKSxcbiAgZHN2OiBkc3YsXG4gIGNzdjogZHN2LmRlbGltaXRlcignLCcpLFxuICB0c3Y6IGRzdi5kZWxpbWl0ZXIoJ1xcdCcpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IHV0aWwuaXNPYmplY3QoZGF0YSkgJiYgIXV0aWwuaXNCdWZmZXIoZGF0YSkgP1xuICAgIGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5wcm9wZXJ0eSkge1xuICAgIGQgPSB1dGlsLmFjY2Vzc29yKGZvcm1hdC5wcm9wZXJ0eSkoZCk7XG4gIH1cbiAgcmV0dXJuIGQ7XG59O1xuIiwidmFyIGpzb24gPSByZXF1aXJlKCcuL2pzb24nKTtcbnZhciB0b3BvanNvbiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LnRvcG9qc29uIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC50b3BvanNvbiA6IG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBpZiAodG9wb2pzb24gPT0gbnVsbCkgeyB0aHJvdyBFcnJvcignVG9wb0pTT04gbGlicmFyeSBub3QgbG9hZGVkLicpOyB9XG5cbiAgdmFyIHQgPSBqc29uKGRhdGEsIGZvcm1hdCksIG9iajtcblxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5mZWF0dXJlKSB7XG4gICAgaWYgKChvYmogPSB0Lm9iamVjdHNbZm9ybWF0LmZlYXR1cmVdKSkge1xuICAgICAgcmV0dXJuIHRvcG9qc29uLmZlYXR1cmUodCwgb2JqKS5mZWF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnK2Zvcm1hdC5mZWF0dXJlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ICYmIGZvcm1hdC5tZXNoKSB7XG4gICAgaWYgKChvYmogPSB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKSkge1xuICAgICAgcmV0dXJuIFt0b3BvanNvbi5tZXNoKHQsIHQub2JqZWN0c1tmb3JtYXQubWVzaF0pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnICsgZm9ybWF0Lm1lc2gpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcignTWlzc2luZyBUb3BvSlNPTiBmZWF0dXJlIG9yIG1lc2ggcGFyYW1ldGVyLicpO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIGRhdGEgPSBqc29uKGRhdGEsIGZvcm1hdCk7XG4gIHJldHVybiB0b1RhYmxlKGRhdGEsIChmb3JtYXQgJiYgZm9ybWF0LmNoaWxkcmVuKSk7XG59O1xuXG5mdW5jdGlvbiB0b1RhYmxlKHJvb3QsIGNoaWxkcmVuRmllbGQpIHtcbiAgY2hpbGRyZW5GaWVsZCA9IGNoaWxkcmVuRmllbGQgfHwgJ2NoaWxkcmVuJztcbiAgdmFyIHRhYmxlID0gW107XG4gIFxuICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgdGFibGUucHVzaChub2RlKTtcbiAgICB2YXIgY2hpbGRyZW4gPSBub2RlW2NoaWxkcmVuRmllbGRdO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZpc2l0KGNoaWxkcmVuW2ldLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIHZpc2l0KHJvb3QsIG51bGwpO1xuICByZXR1cm4gKHRhYmxlLnJvb3QgPSByb290LCB0YWJsZSk7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8vIE1hdGNoZXMgYWJzb2x1dGUgVVJMcyB3aXRoIG9wdGlvbmFsIHByb3RvY29sXG4vLyAgIGh0dHBzOi8vLi4uICAgIGZpbGU6Ly8uLi4gICAgLy8uLi5cbnZhciBwcm90b2NvbF9yZSA9IC9eKFtBLVphLXpdKzopP1xcL1xcLy87XG5cbi8vIFNwZWNpYWwgdHJlYXRtZW50IGluIG5vZGUuanMgZm9yIHRoZSBmaWxlOiBwcm90b2NvbFxudmFyIGZpbGVQcm90b2NvbCA9ICdmaWxlOi8vJztcblxuLy8gVmFsaWRhdGUgYW5kIGNsZWFudXAgVVJMIHRvIGVuc3VyZSB0aGF0IGl0IGlzIGFsbG93ZWQgdG8gYmUgYWNjZXNzZWRcbi8vIFJldHVybnMgY2xlYW5lZCB1cCBVUkwsIG9yIGZhbHNlIGlmIGFjY2VzcyBpcyBub3QgYWxsb3dlZFxuZnVuY3Rpb24gc2FuaXRpemVVcmwob3B0KSB7XG4gIHZhciB1cmwgPSBvcHQudXJsO1xuICBpZiAoIXVybCAmJiBvcHQuZmlsZSkgeyByZXR1cm4gZmlsZVByb3RvY29sICsgb3B0LmZpbGU7IH1cblxuICAvLyBJbiBjYXNlIHRoaXMgaXMgYSByZWxhdGl2ZSB1cmwgKGhhcyBubyBob3N0KSwgcHJlcGVuZCBvcHQuYmFzZVVSTFxuICBpZiAob3B0LmJhc2VVUkwgJiYgIXByb3RvY29sX3JlLnRlc3QodXJsKSkge1xuICAgIGlmICghdXRpbC5zdGFydHNXaXRoKHVybCwgJy8nKSAmJiBvcHQuYmFzZVVSTFtvcHQuYmFzZVVSTC5sZW5ndGgtMV0gIT09ICcvJykge1xuICAgICAgdXJsID0gJy8nICsgdXJsOyAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhIHNsYXNoIGJldHdlZW4gdGhlIGJhc2VVUkwgKGUuZy4gaG9zdG5hbWUpIGFuZCB1cmxcbiAgICB9XG4gICAgdXJsID0gb3B0LmJhc2VVUkwgKyB1cmw7XG4gIH1cbiAgLy8gcmVsYXRpdmUgcHJvdG9jb2wsIHN0YXJ0cyB3aXRoICcvLydcbiAgaWYgKHV0aWwuaXNOb2RlICYmIHV0aWwuc3RhcnRzV2l0aCh1cmwsICcvLycpKSB7XG4gICAgdXJsID0gKG9wdC5kZWZhdWx0UHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6JyArIHVybDtcbiAgfVxuICAvLyBJZiBvcHQuZG9tYWluV2hpdGVMaXN0IGlzIHNldCwgb25seSBhbGxvd3MgdXJsLCB3aG9zZSBob3N0bmFtZVxuICAvLyAqIElzIHRoZSBzYW1lIGFzIHRoZSBvcmlnaW4gKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSlcbiAgLy8gKiBFcXVhbHMgb25lIG9mIHRoZSB2YWx1ZXMgaW4gdGhlIHdoaXRlbGlzdFxuICAvLyAqIElzIGEgcHJvcGVyIHN1YmRvbWFpbiBvZiBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIGlmIChvcHQuZG9tYWluV2hpdGVMaXN0KSB7XG4gICAgdmFyIGRvbWFpbiwgb3JpZ2luO1xuICAgIGlmICh1dGlsLmlzTm9kZSkge1xuICAgICAgLy8gcmVsYXRpdmUgcHJvdG9jb2wgaXMgYnJva2VuOiBodHRwczovL2dpdGh1Yi5jb20vZGVmdW5jdHpvbWJpZS9ub2RlLXVybC9pc3N1ZXMvNVxuICAgICAgdmFyIHBhcnRzID0gcmVxdWlyZSgndXJsJykucGFyc2UodXJsKTtcbiAgICAgIGRvbWFpbiA9IHBhcnRzLmhvc3RuYW1lO1xuICAgICAgb3JpZ2luID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBhLmhyZWYgPSB1cmw7XG4gICAgICAvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM2NTEzL2hvdy1kby1pLXBhcnNlLWEtdXJsLWludG8taG9zdG5hbWUtYW5kLXBhdGgtaW4tamF2YXNjcmlwdFxuICAgICAgLy8gSUUgZG9lc24ndCBwb3B1bGF0ZSBhbGwgbGluayBwcm9wZXJ0aWVzIHdoZW4gc2V0dGluZyAuaHJlZiB3aXRoIGEgcmVsYXRpdmUgVVJMLFxuICAgICAgLy8gaG93ZXZlciAuaHJlZiB3aWxsIHJldHVybiBhbiBhYnNvbHV0ZSBVUkwgd2hpY2ggdGhlbiBjYW4gYmUgdXNlZCBvbiBpdHNlbGZcbiAgICAgIC8vIHRvIHBvcHVsYXRlIHRoZXNlIGFkZGl0aW9uYWwgZmllbGRzLlxuICAgICAgaWYgKGEuaG9zdCA9PT0gJycpIHtcbiAgICAgICAgYS5ocmVmID0gYS5ocmVmO1xuICAgICAgfVxuICAgICAgZG9tYWluID0gYS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikge1xuICAgICAgdmFyIHdoaXRlTGlzdGVkID0gb3B0LmRvbWFpbldoaXRlTGlzdC5zb21lKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIGlkeCA9IGRvbWFpbi5sZW5ndGggLSBkLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGQgPT09IGRvbWFpbiB8fFxuICAgICAgICAgIChpZHggPiAxICYmIGRvbWFpbltpZHgtMV0gPT09ICcuJyAmJiBkb21haW4ubGFzdEluZGV4T2YoZCkgPT09IGlkeCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghd2hpdGVMaXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgJ1VSTCBpcyBub3Qgd2hpdGVsaXN0ZWQ6ICcgKyB1cmw7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbmZ1bmN0aW9uIGxvYWQob3B0LCBjYWxsYmFjaykge1xuICB2YXIgZXJyb3IgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlKSB7IHRocm93IGU7IH0sIHVybDtcblxuICB0cnkge1xuICAgIHVybCA9IGxvYWQuc2FuaXRpemVVcmwob3B0KTsgLy8gZW5hYmxlIG92ZXJyaWRlXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF1cmwpIHtcbiAgICBlcnJvcignSW52YWxpZCBVUkw6ICcgKyB1cmwpO1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTm9kZSkge1xuICAgIC8vIGluIGJyb3dzZXIsIHVzZSB4aHJcbiAgICByZXR1cm4geGhyKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHV0aWwuc3RhcnRzV2l0aCh1cmwsIGZpbGVQcm90b2NvbCkpIHtcbiAgICAvLyBpbiBub2RlLmpzLCBpZiB1cmwgc3RhcnRzIHdpdGggJ2ZpbGU6Ly8nLCBzdHJpcCBpdCBhbmQgbG9hZCBmcm9tIGZpbGVcbiAgICByZXR1cm4gZmlsZSh1cmwuc2xpY2UoZmlsZVByb3RvY29sLmxlbmd0aCksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmICh1cmwuaW5kZXhPZignOi8vJykgPCAwKSB7IC8vIFRPRE8gYmV0dGVyIHByb3RvY29sIGNoZWNrP1xuICAgIC8vIGlmIG5vZGUuanMsIGlmIG5vIHByb3RvY29sIGFzc3VtZSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZm9yIHJlZ3VsYXIgVVJMcyBpbiBub2RlLmpzXG4gICAgcmV0dXJuIGh0dHAodXJsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24geGhySGFzUmVzcG9uc2UocmVxdWVzdCkge1xuICB2YXIgdHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICByZXR1cm4gdHlwZSAmJiB0eXBlICE9PSAndGV4dCcgP1xuICAgIHJlcXVlc3QucmVzcG9uc2UgOiAvLyBudWxsIG9uIGVycm9yXG4gICAgcmVxdWVzdC5yZXNwb25zZVRleHQ7IC8vICcnIG9uIGVycm9yXG59XG5cbmZ1bmN0aW9uIHhocih1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIC8vIElmIElFIGRvZXMgbm90IHN1cHBvcnQgQ09SUywgdXNlIFhEb21haW5SZXF1ZXN0IChjb3BpZWQgZnJvbSBkMy54aHIpXG4gIGlmICh0aGlzLlhEb21haW5SZXF1ZXN0ICYmXG4gICAgICAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG5cbiAgZnVuY3Rpb24gcmVzcG9uZCgpIHtcbiAgICB2YXIgc3RhdHVzID0gcmVxdWVzdC5zdGF0dXM7XG4gICAgaWYgKCFzdGF0dXMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkgfHwgc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2socmVxdWVzdCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGFzeW5jKSB7XG4gICAgaWYgKCdvbmxvYWQnIGluIHJlcXVlc3QpIHtcbiAgICAgIHJlcXVlc3Qub25sb2FkID0gcmVxdWVzdC5vbmVycm9yID0gcmVzcG9uZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSA+IDMpIHJlc3BvbmQoKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIFxuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgYXN5bmMpO1xuICByZXF1ZXN0LnNlbmQoKTtcbiAgXG4gIGlmICghYXN5bmMgJiYgeGhySGFzUmVzcG9uc2UocmVxdWVzdCkpIHtcbiAgICByZXR1cm4gcmVxdWVzdC5yZXNwb25zZVRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlsZShmaWxlbmFtZSwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4Jyk7XG4gIH1cbiAgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZShmaWxlbmFtZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBodHRwKHVybCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiByZXF1aXJlKCdzeW5jLXJlcXVlc3QnKSgnR0VUJywgdXJsKS5nZXRCb2R5KCk7XG4gIH1cbiAgcmVxdWlyZSgncmVxdWVzdCcpKHVybCwgZnVuY3Rpb24oZXJyb3IsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgaWYgKCFlcnJvciAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSAyMDApIHtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxubG9hZC5zYW5pdGl6ZVVybCA9IHNhbml0aXplVXJsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciB0eXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG5mdW5jdGlvbiByZWFkKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgdHlwZSA9IChmb3JtYXQgJiYgZm9ybWF0LnR5cGUpIHx8ICdqc29uJztcbiAgZGF0YSA9IGZvcm1hdHNbdHlwZV0oZGF0YSwgZm9ybWF0KTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucGFyc2UpIHBhcnNlKGRhdGEsIGZvcm1hdC5wYXJzZSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcykge1xuICB2YXIgY29scywgcGFyc2VycywgZCwgaSwgaiwgY2xlbiwgbGVuID0gZGF0YS5sZW5ndGg7XG5cbiAgdHlwZXMgPSAodHlwZXM9PT0nYXV0bycpID8gdHlwZS5pbmZlckFsbChkYXRhKSA6IHV0aWwuZHVwbGljYXRlKHR5cGVzKTtcbiAgY29scyA9IHV0aWwua2V5cyh0eXBlcyk7XG4gIHBhcnNlcnMgPSBjb2xzLm1hcChmdW5jdGlvbihjKSB7IHJldHVybiB0eXBlLnBhcnNlcnNbdHlwZXNbY11dOyB9KTtcblxuICBmb3IgKGk9MCwgY2xlbj1jb2xzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvciAoaj0wOyBqPGNsZW47ICsraikge1xuICAgICAgZFtjb2xzW2pdXSA9IHBhcnNlcnNbal0oZFtjb2xzW2pdXSk7XG4gICAgfVxuICB9XG4gIHR5cGUuYW5ub3RhdGlvbihkYXRhLCB0eXBlcyk7XG59XG5cbnJlYWQuZm9ybWF0cyA9IGZvcm1hdHM7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBsb2FkID0gcmVxdWlyZSgnLi9sb2FkJyk7XG52YXIgcmVhZCA9IHJlcXVpcmUoJy4vcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxcbiAgLmtleXMocmVhZC5mb3JtYXRzKVxuICAucmVkdWNlKGZ1bmN0aW9uKG91dCwgdHlwZSkge1xuICAgIG91dFt0eXBlXSA9IGZ1bmN0aW9uKG9wdCwgZm9ybWF0LCBjYWxsYmFjaykge1xuICAgICAgLy8gcHJvY2VzcyBhcmd1bWVudHNcbiAgICAgIGlmICh1dGlsLmlzU3RyaW5nKG9wdCkpIHsgb3B0ID0ge3VybDogb3B0fTsgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdXRpbC5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHJlYWQgZm9ybWF0XG4gICAgICBmb3JtYXQgPSB1dGlsLmV4dGVuZCh7cGFyc2U6ICdhdXRvJ30sIGZvcm1hdCk7XG4gICAgICBmb3JtYXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIGxvYWQgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBsb2FkKG9wdCwgY2FsbGJhY2sgPyBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChhc3luYylcbiAgICAgICAgICBkYXRhID0gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoc3luYylcbiAgICAgIGlmIChkYXRhKSByZXR1cm4gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbiAgfSwge30pO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBUWVBFUyA9ICdfX3R5cGVzX18nO1xuXG52YXIgUEFSU0VSUyA9IHtcbiAgYm9vbGVhbjogdXRpbC5ib29sZWFuLFxuICBpbnRlZ2VyOiB1dGlsLm51bWJlcixcbiAgbnVtYmVyOiAgdXRpbC5udW1iZXIsXG4gIGRhdGU6ICAgIHV0aWwuZGF0ZSxcbiAgc3RyaW5nOiAgZnVuY3Rpb24oeCkgeyByZXR1cm4geD09PScnID8gbnVsbCA6IHg7IH1cbn07XG5cbnZhciBURVNUUyA9IHtcbiAgYm9vbGVhbjogZnVuY3Rpb24oeCkgeyByZXR1cm4geD09PSd0cnVlJyB8fCB4PT09J2ZhbHNlJyB8fCB1dGlsLmlzQm9vbGVhbih4KTsgfSxcbiAgaW50ZWdlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gVEVTVFMubnVtYmVyKHgpICYmICh4PSt4KSA9PT0gfn54OyB9LFxuICBudW1iZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTigreCkgJiYgIXV0aWwuaXNEYXRlKHgpOyB9LFxuICBkYXRlOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oRGF0ZS5wYXJzZSh4KSk7IH1cbn07XG5cbmZ1bmN0aW9uIGFubm90YXRpb24oZGF0YSwgdHlwZXMpIHtcbiAgaWYgKCF0eXBlcykgcmV0dXJuIGRhdGEgJiYgZGF0YVtUWVBFU10gfHwgbnVsbDtcbiAgZGF0YVtUWVBFU10gPSB0eXBlcztcbn1cblxuZnVuY3Rpb24gdHlwZSh2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHYsIGksIG47XG5cbiAgLy8gaWYgZGF0YSBhcnJheSBoYXMgdHlwZSBhbm5vdGF0aW9ucywgdXNlIHRoZW1cbiAgaWYgKHZhbHVlc1tUWVBFU10pIHtcbiAgICB2ID0gZih2YWx1ZXNbVFlQRVNdKTtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2KSkgcmV0dXJuIHY7XG4gIH1cblxuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyAhdXRpbC5pc1ZhbGlkKHYpICYmIGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gIH1cblxuICByZXR1cm4gdXRpbC5pc0RhdGUodikgPyAnZGF0ZScgOlxuICAgIHV0aWwuaXNOdW1iZXIodikgICAgPyAnbnVtYmVyJyA6XG4gICAgdXRpbC5pc0Jvb2xlYW4odikgICA/ICdib29sZWFuJyA6XG4gICAgdXRpbC5pc1N0cmluZyh2KSAgICA/ICdzdHJpbmcnIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gdHlwZUFsbChkYXRhLCBmaWVsZHMpIHtcbiAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuO1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHJldHVybiAodHlwZXNbZl0gPSB0eXBlKGRhdGEsIGYpLCB0eXBlcyk7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gaW5mZXIodmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBpLCBqLCB2O1xuXG4gIC8vIHR5cGVzIHRvIHRlc3QgZm9yLCBpbiBwcmVjZWRlbmNlIG9yZGVyXG4gIHZhciB0eXBlcyA9IFsnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlcicsICdkYXRlJ107XG5cbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IG5leHQgdmFsdWUgdG8gdGVzdFxuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIC8vIHRlc3QgdmFsdWUgYWdhaW5zdCByZW1haW5pbmcgdHlwZXNcbiAgICBmb3IgKGo9MDsgajx0eXBlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHV0aWwuaXNWYWxpZCh2KSAmJiAhVEVTVFNbdHlwZXNbal1dKHYpKSB7XG4gICAgICAgIHR5cGVzLnNwbGljZShqLCAxKTtcbiAgICAgICAgaiAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBubyB0eXBlcyBsZWZ0LCByZXR1cm4gJ3N0cmluZydcbiAgICBpZiAodHlwZXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICByZXR1cm4gdHlwZXNbMF07XG59XG5cbmZ1bmN0aW9uIGluZmVyQWxsKGRhdGEsIGZpZWxkcykge1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuICByZXR1cm4gZmllbGRzLnJlZHVjZShmdW5jdGlvbih0eXBlcywgZikge1xuICAgIHZhciB0eXBlID0gaW5mZXIoZGF0YSwgZik7XG4gICAgaWYgKFBBUlNFUlNbdHlwZV0pIHR5cGVzW2ZdID0gdHlwZTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH0sIHt9KTtcbn1cblxudHlwZS5hbm5vdGF0aW9uID0gYW5ub3RhdGlvbjtcbnR5cGUuYWxsID0gdHlwZUFsbDtcbnR5cGUuaW5mZXIgPSBpbmZlcjtcbnR5cGUuaW5mZXJBbGwgPSBpbmZlckFsbDtcbnR5cGUucGFyc2VycyA9IFBBUlNFUlM7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGU7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIGRsID0ge1xuICBsb2FkOiAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L2xvYWQnKSxcbiAgcmVhZDogICAgICByZXF1aXJlKCcuL2ltcG9ydC9yZWFkJyksXG4gIHR5cGU6ICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvdHlwZScpLFxuICBiaW5zOiAgICAgIHJlcXVpcmUoJy4vYmlucy9iaW5zJyksXG4gICRiaW46ICAgICAgcmVxdWlyZSgnLi9iaW5zL2hpc3RvZ3JhbScpLiRiaW4sXG4gIGdyb3VwYnk6ICAgcmVxdWlyZSgnLi9hZ2dyZWdhdGUvZ3JvdXBieScpLFxuICBoaXN0b2dyYW06IHJlcXVpcmUoJy4vYmlucy9oaXN0b2dyYW0nKS5oaXN0b2dyYW0sXG4gIHByaW50OiAgICAgcmVxdWlyZSgnLi9wcmludCcpLFxuICB0ZW1wbGF0ZTogIHJlcXVpcmUoJy4vdGVtcGxhdGUnKSxcbiAgdGltZXVuaXRzOiByZXF1aXJlKCcuL3RpbWUtdW5pdHMnKVxufTtcblxudXRpbC5leHRlbmQoZGwsIHV0aWwpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vZ2VuZXJhdGUnKSk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9zdGF0cycpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL2ltcG9ydC9yZWFkZXJzJykpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRsOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcbnZhciB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKTtcblxudmFyIEZNVCA9IHtcbiAgJ2RhdGUnOiAgICAnfHRpbWU6XCIlbS8lZC8lWSAlSDolTTolU1wiJyxcbiAgJ251bWJlcic6ICAnfG51bWJlcjpcIi40ZlwiJyxcbiAgJ2ludGVnZXInOiAnfG51bWJlcjpcImRcIidcbn07XG5cbnZhciBQT1MgPSB7XG4gICdudW1iZXInOiAgJ2xlZnQnLFxuICAnaW50ZWdlcic6ICdsZWZ0J1xufTtcblxubW9kdWxlLmV4cG9ydHMudGFibGUgPSBmdW5jdGlvbihkYXRhLCBvcHQpIHtcbiAgb3B0ID0gdXRpbC5leHRlbmQoe3NlcGFyYXRvcjonICcsIG1pbndpZHRoOiA4LCBtYXh3aWR0aDogMTV9LCBvcHQpO1xuICB2YXIgZmllbGRzID0gb3B0LmZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSksXG4gICAgICB0eXBlcyA9IHR5cGUuYWxsKGRhdGEpO1xuXG4gIGlmIChvcHQuc3RhcnQgfHwgb3B0LmxpbWl0KSB7XG4gICAgdmFyIGEgPSBvcHQuc3RhcnQgfHwgMCxcbiAgICAgICAgYiA9IG9wdC5saW1pdCA/IGEgKyBvcHQubGltaXQgOiBkYXRhLmxlbmd0aDtcbiAgICBkYXRhID0gZGF0YS5zbGljZShhLCBiKTtcbiAgfVxuXG4gIC8vIGRldGVybWluZSBjaGFyIHdpZHRoIG9mIGZpZWxkc1xuICB2YXIgbGVucyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBmb3JtYXQgPSBGTVRbdHlwZXNbbmFtZV1dIHx8ICcnLFxuICAgICAgICB0ID0gdGVtcGxhdGUoJ3t7JyArIG5hbWUgKyBmb3JtYXQgKyAnfX0nKSxcbiAgICAgICAgbCA9IHN0YXRzLm1heChkYXRhLCBmdW5jdGlvbih4KSB7IHJldHVybiB0KHgpLmxlbmd0aDsgfSk7XG4gICAgbCA9IE1hdGgubWF4KE1hdGgubWluKG5hbWUubGVuZ3RoLCBvcHQubWlud2lkdGgpLCBsKTtcbiAgICByZXR1cm4gb3B0Lm1heHdpZHRoID4gMCA/IE1hdGgubWluKGwsIG9wdC5tYXh3aWR0aCkgOiBsO1xuICB9KTtcblxuICAvLyBwcmludCBoZWFkZXIgcm93XG4gIHZhciBoZWFkID0gZmllbGRzLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIHV0aWwudHJ1bmNhdGUodXRpbC5wYWQobmFtZSwgbGVuc1tpXSwgJ2NlbnRlcicpLCBsZW5zW2ldKTtcbiAgfSkuam9pbihvcHQuc2VwYXJhdG9yKTtcblxuICAvLyBidWlsZCB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgZWFjaCByb3dcbiAgdmFyIHRtcGwgPSB0ZW1wbGF0ZShmaWVsZHMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gJ3t7JyArXG4gICAgICBuYW1lICtcbiAgICAgIChGTVRbdHlwZXNbbmFtZV1dIHx8ICcnKSArXG4gICAgICAoJ3xwYWQ6JyArIGxlbnNbaV0gKyAnLCcgKyBQT1NbdHlwZXNbbmFtZV1dIHx8ICdyaWdodCcpICtcbiAgICAgICgnfHRydW5jYXRlOicgKyBsZW5zW2ldKSArXG4gICAgJ319JztcbiAgfSkuam9pbihvcHQuc2VwYXJhdG9yKSk7XG5cbiAgLy8gcHJpbnQgdGFibGVcbiAgcmV0dXJuIGhlYWQgKyBcIlxcblwiICsgZGF0YS5tYXAodG1wbCkuam9pbignXFxuJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5zdW1tYXJ5ID0gZnVuY3Rpb24ocykge1xuICBzID0gcyA/IHMuX19zdW1tYXJ5X18gPyBzIDogc3RhdHMuc3VtbWFyeShzKSA6IHRoaXM7XG4gIHZhciBzdHIgPSBbXSwgaSwgbjtcbiAgZm9yIChpPTAsIG49cy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgc3RyLnB1c2goJy0tICcgKyBzW2ldLmZpZWxkICsgJyAtLScpO1xuICAgIGlmIChzW2ldLnR5cGUgPT09ICdzdHJpbmcnIHx8IHNbaV0uZGlzdGluY3QgPCAxMCkge1xuICAgICAgc3RyLnB1c2gocHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUoc1tpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIucHVzaChwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUoc1tpXSkpO1xuICAgIH1cbiAgICBzdHIucHVzaCgnJyk7XG4gIH1cbiAgcmV0dXJuIHN0ci5qb2luKCdcXG4nKTtcbn07XG5cbmZ1bmN0aW9uIHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShwKSB7XG4gIHJldHVybiBbXG4gICAgJ3ZhbGlkOiAgICAnICsgcC52YWxpZCxcbiAgICAnbWlzc2luZzogICcgKyBwLm1pc3NpbmcsXG4gICAgJ2Rpc3RpbmN0OiAnICsgcC5kaXN0aW5jdCxcbiAgICAnbWluOiAgICAgICcgKyBwLm1pbixcbiAgICAnbWF4OiAgICAgICcgKyBwLm1heCxcbiAgICAnbWVkaWFuOiAgICcgKyBwLm1lZGlhbixcbiAgICAnbWVhbjogICAgICcgKyBwLm1lYW4sXG4gICAgJ3N0ZGV2OiAgICAnICsgcC5zdGRldixcbiAgICAnbW9kZXNrZXc6ICcgKyBwLm1vZGVza2V3XG4gIF0uam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHApIHtcbiAgdmFyIGxpc3QgPSBbXG4gICAgJ3ZhbGlkOiAgICAnICsgcC52YWxpZCxcbiAgICAnbWlzc2luZzogICcgKyBwLm1pc3NpbmcsXG4gICAgJ2Rpc3RpbmN0OiAnICsgcC5kaXN0aW5jdCxcbiAgICAndG9wIHZhbHVlczogJ1xuICBdO1xuICB2YXIgdSA9IHAudW5pcXVlO1xuICB2YXIgdG9wID0gdXRpbC5rZXlzKHUpXG4gICAgLnNvcnQoZnVuY3Rpb24oYSxiKSB7IHJldHVybiB1W2JdIC0gdVthXTsgfSlcbiAgICAuc2xpY2UoMCwgNilcbiAgICAubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuICcgXFwnJyArIHYgKyAnXFwnICgnICsgdVt2XSArICcpJzsgfSk7XG4gIHJldHVybiBsaXN0LmNvbmNhdCh0b3ApLmpvaW4oJ1xcbicpO1xufSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgdHlwZSA9IHJlcXVpcmUoJy4vaW1wb3J0L3R5cGUnKTtcbnZhciBnZW4gPSByZXF1aXJlKCcuL2dlbmVyYXRlJyk7XG52YXIgc3RhdHMgPSB7fTtcblxuLy8gQ29sbGVjdCB1bmlxdWUgdmFsdWVzLlxuLy8gT3V0cHV0OiBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBmaXJzdC1vYnNlcnZlZCBvcmRlclxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICB2YXIgdSA9IHt9LCB2LCBpLCBuO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnB1dCBhcnJheS5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCB8fCAwO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBub24tbnVsbCwgbm9uLXVuZGVmaW5lZCwgbm9uLU5hTiB2YWx1ZXMuXG5zdGF0cy5jb3VudC52YWxpZCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgdiwgaSwgbiwgdmFsaWQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHZhbGlkICs9IDE7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5taXNzaW5nID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciB2LCBpLCBuLCBjb3VudCA9IDA7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgPT0gbnVsbCkgY291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IHZhbHVlcy5cbi8vIE51bGwsIHVuZGVmaW5lZCBhbmQgTmFOIGFyZSBlYWNoIGNvbnNpZGVyZWQgZGlzdGluY3QgdmFsdWVzLlxuc3RhdHMuY291bnQuZGlzdGluY3QgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgbiwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ29uc3RydWN0IGEgbWFwIGZyb20gZGlzdGluY3QgdmFsdWVzIHRvIG9jY3VycmVuY2UgY291bnRzLlxuc3RhdHMuY291bnQubWFwID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBtYXAgPSB7fSwgdiwgaSwgbjtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBtYXBbdl0gPSAodiBpbiBtYXApID8gbWFwW3ZdICsgMSA6IDE7XG4gIH1cbiAgcmV0dXJuIG1hcDtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lZGlhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmIChmKSB2YWx1ZXMgPSB2YWx1ZXMubWFwKHV0aWwuJChmKSk7XG4gIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIodXRpbC5pc1ZhbGlkKS5zb3J0KHV0aWwuY21wKTtcbiAgcmV0dXJuIHN0YXRzLnF1YW50aWxlKHZhbHVlcywgMC41KTtcbn07XG5cbi8vIENvbXB1dGVzIHRoZSBxdWFydGlsZSBib3VuZGFyaWVzIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5xdWFydGlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcCh1dGlsLiQoZikpO1xuICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKHV0aWwuaXNWYWxpZCkuc29ydCh1dGlsLmNtcCk7XG4gIHZhciBxID0gc3RhdHMucXVhbnRpbGU7XG4gIHJldHVybiBbcSh2YWx1ZXMsIDAuMjUpLCBxKHZhbHVlcywgMC41MCksIHEodmFsdWVzLCAwLjc1KV07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBxdWFudGlsZSBvZiBhIHNvcnRlZCBhcnJheSBvZiBudW1iZXJzLlxuLy8gQWRhcHRlZCBmcm9tIHRoZSBEMy5qcyBpbXBsZW1lbnRhdGlvbi5cbnN0YXRzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmLCBwKSB7XG4gIGlmIChwID09PSB1bmRlZmluZWQpIHsgcCA9IGY7IGYgPSB1dGlsLmlkZW50aXR5OyB9XG4gIGYgPSB1dGlsLiQoZik7XG4gIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLFxuICAgICAgaCA9IE1hdGguZmxvb3IoSCksXG4gICAgICB2ID0gK2YodmFsdWVzW2ggLSAxXSksXG4gICAgICBlID0gSCAtIGg7XG4gIHJldHVybiBlID8gdiArIGUgKiAoZih2YWx1ZXNbaF0pIC0gdikgOiB2O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc3VtIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdW0gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgZiA9IHV0aWwuJChmKTtcbiAgZm9yICh2YXIgc3VtPTAsIGk9MCwgbj12YWx1ZXMubGVuZ3RoLCB2OyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHN1bSArPSB2O1xuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtZWFuIChhdmVyYWdlKSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgbWVhbiA9IDAsIGRlbHRhLCBpLCBuLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lYW47XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgdmFyaWFuY2Ugb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGYgPSB1dGlsLiQoZik7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgbWVhbiA9IDAsIE0yID0gMCwgZGVsdGEsIGksIGMsIHY7XG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgZGVsdGEgPSB2IC0gbWVhbjtcbiAgICAgIG1lYW4gPSBtZWFuICsgZGVsdGEgLyAoKytjKTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh2IC0gbWVhbik7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoYyAtIDEpO1xuICByZXR1cm4gTTI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBzYW1wbGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5zdGRldiA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHN0YXRzLnZhcmlhbmNlKHZhbHVlcywgZikpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgUGVhcnNvbiBtb2RlIHNrZXduZXNzICgobWVkaWFuLW1lYW4pL3N0ZGV2KSBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubW9kZXNrZXcgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGF2ZyA9IHN0YXRzLm1lYW4odmFsdWVzLCBmKSxcbiAgICAgIG1lZCA9IHN0YXRzLm1lZGlhbih2YWx1ZXMsIGYpLFxuICAgICAgc3RkID0gc3RhdHMuc3RkZXYodmFsdWVzLCBmKTtcbiAgcmV0dXJuIHN0ZCA9PT0gMCA/IDAgOiAoYXZnIC0gbWVkKSAvIHN0ZDtcbn07XG5cbi8vIEZpbmQgdGhlIG1pbmltdW0gdmFsdWUgaW4gYW4gYXJyYXkuXG5zdGF0cy5taW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgcmV0dXJuIHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpWzBdO1xufTtcblxuLy8gRmluZCB0aGUgbWF4aW11bSB2YWx1ZSBpbiBhbiBhcnJheS5cbnN0YXRzLm1heCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICByZXR1cm4gc3RhdHMuZXh0ZW50KHZhbHVlcywgZilbMV07XG59O1xuXG4vLyBGaW5kIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG9mIGFuIGFycmF5IG9mIHZhbHVlcy5cbnN0YXRzLmV4dGVudCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgYSwgYiwgdiwgaSwgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHsgYSA9IGIgPSB2OyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGlmICh2IDwgYSkgYSA9IHY7XG4gICAgICBpZiAodiA+IGIpIGIgPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gW2EsIGJdO1xufTtcblxuLy8gRmluZCB0aGUgaW50ZWdlciBpbmRpY2VzIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcy5cbnN0YXRzLmV4dGVudC5pbmRleCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgeCA9IC0xLCB5ID0gLTEsIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodXRpbC5pc1ZhbGlkKHYpKSB7IGEgPSBiID0gdjsgeCA9IHkgPSBpOyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzVmFsaWQodikpIHtcbiAgICAgIGlmICh2IDwgYSkgeyBhID0gdjsgeCA9IGk7IH1cbiAgICAgIGlmICh2ID4gYikgeyBiID0gdjsgeSA9IGk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmRvdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgc3VtID0gMCwgaSwgdjtcbiAgaWYgKCFiKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXJyYXkgbGVuZ3RocyBtdXN0IG1hdGNoLicpO1xuICAgIH1cbiAgICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaV0gKiBhW2ldO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odikpIHN1bSArPSB2O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gdXRpbC4kKGEpO1xuICAgIGIgPSB1dGlsLiQoYik7XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gYSh2YWx1ZXNbaV0pICogYih2YWx1ZXNbaV0pO1xuICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odikpIHN1bSArPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufTtcblxuLy8gQ29tcHV0ZSBhc2NlbmRpbmcgcmFuayBzY29yZXMgZm9yIGFuIGFycmF5IG9mIHZhbHVlcy5cbi8vIFRpZXMgYXJlIGFzc2lnbmVkIHRoZWlyIGNvbGxlY3RpdmUgbWVhbiByYW5rLlxuc3RhdHMucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBmID0gdXRpbC4kKGYpIHx8IHV0aWwuaWRlbnRpdHk7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge2lkeDogaSwgdmFsOiBmKHYpfTtcbiAgICB9KVxuICAgIC5zb3J0KHV0aWwuY29tcGFyYXRvcigndmFsJykpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG4gIGEgPSBmbiA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcztcblxuICB2YXIgZG90ID0gc3RhdHMuZG90KGEsIGIpLFxuICAgICAgbXVhID0gc3RhdHMubWVhbihhKSxcbiAgICAgIG11YiA9IHN0YXRzLm1lYW4oYiksXG4gICAgICBzZGEgPSBzdGF0cy5zdGRldihhKSxcbiAgICAgIHNkYiA9IHN0YXRzLnN0ZGV2KGIpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgcmV0dXJuIChkb3QgLSBuKm11YSptdWIpIC8gKChuLTEpICogc2RhICogc2RiKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNwZWFybWFuIHJhbmsgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiB2YWx1ZXMuXG5zdGF0cy5jb3IucmFuayA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgcmEgPSBiID8gc3RhdHMucmFuayh2YWx1ZXMsIHV0aWwuJChhKSkgOiBzdGF0cy5yYW5rKHZhbHVlcyksXG4gICAgICByYiA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgdXRpbC4kKGIpKSA6IHN0YXRzLnJhbmsoYSksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgaSwgcywgZDtcblxuICBmb3IgKGk9MCwgcz0wOyBpPG47ICsraSkge1xuICAgIGQgPSByYVtpXSAtIHJiW2ldO1xuICAgIHMgKz0gZCAqIGQ7XG4gIH1cblxuICByZXR1cm4gMSAtIDYqcyAvIChuICogKG4qbi0xKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBkaXN0YW5jZSBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Rpc3RhbmNlX2NvcnJlbGF0aW9uXG5zdGF0cy5jb3IuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgWCA9IGIgPyB2YWx1ZXMubWFwKHV0aWwuJChhKSkgOiB2YWx1ZXMsXG4gICAgICBZID0gYiA/IHZhbHVlcy5tYXAodXRpbC4kKGIpKSA6IGE7XG5cbiAgdmFyIEEgPSBzdGF0cy5kaXN0Lm1hdChYKSxcbiAgICAgIEIgPSBzdGF0cy5kaXN0Lm1hdChZKSxcbiAgICAgIG4gPSBBLmxlbmd0aCxcbiAgICAgIGksIGFhLCBiYiwgYWI7XG5cbiAgZm9yIChpPTAsIGFhPTAsIGJiPTAsIGFiPTA7IGk8bjsgKytpKSB7XG4gICAgYWEgKz0gQVtpXSpBW2ldO1xuICAgIGJiICs9IEJbaV0qQltpXTtcbiAgICBhYiArPSBBW2ldKkJbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGFiIC8gTWF0aC5zcXJ0KGFhKmJiKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSB2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBEZWZhdWx0IGlzIEV1Y2xpZGVhbiAoZXhwPTIpIGRpc3RhbmNlLCBjb25maWd1cmFibGUgdmlhIGV4cCBhcmd1bWVudC5cbnN0YXRzLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGV4cCkge1xuICB2YXIgZiA9IHV0aWwuaXNGdW5jdGlvbihiKSB8fCB1dGlsLmlzU3RyaW5nKGIpLFxuICAgICAgWCA9IHZhbHVlcyxcbiAgICAgIFkgPSBmID8gdmFsdWVzIDogYSxcbiAgICAgIGUgPSBmID8gZXhwIDogYixcbiAgICAgIEwyID0gZSA9PT0gMiB8fCBlID09IG51bGwsXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgcyA9IDAsIGQsIGk7XG4gIGlmIChmKSB7XG4gICAgYSA9IHV0aWwuJChhKTtcbiAgICBiID0gdXRpbC4kKGIpO1xuICB9XG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGQgPSBmID8gKGEoWFtpXSktYihZW2ldKSkgOiAoWFtpXS1ZW2ldKTtcbiAgICBzICs9IEwyID8gZCpkIDogTWF0aC5wb3coTWF0aC5hYnMoZCksIGUpO1xuICB9XG4gIHJldHVybiBMMiA/IE1hdGguc3FydChzKSA6IE1hdGgucG93KHMsIDEvZSk7XG59O1xuXG4vLyBDb25zdHJ1Y3QgYSBtZWFuLWNlbnRlcmVkIGRpc3RhbmNlIG1hdHJpeCBmb3IgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLmRpc3QubWF0ID0gZnVuY3Rpb24oWCkge1xuICB2YXIgbiA9IFgubGVuZ3RoLFxuICAgICAgbSA9IG4qbixcbiAgICAgIEEgPSBBcnJheShtKSxcbiAgICAgIFIgPSBnZW4uemVyb3MobiksXG4gICAgICBNID0gMCwgdiwgaSwgajtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBBW2kqbitpXSA9IDA7XG4gICAgZm9yIChqPWkrMTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdID0gKHYgPSBNYXRoLmFicyhYW2ldIC0gWFtqXSkpO1xuICAgICAgQVtqKm4raV0gPSB2O1xuICAgICAgUltpXSArPSB2O1xuICAgICAgUltqXSArPSB2O1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIE0gKz0gUltpXTtcbiAgICBSW2ldIC89IG47XG4gIH1cbiAgTSAvPSBtO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIGZvciAoaj1pOyBqPG47ICsraikge1xuICAgICAgQVtpKm4ral0gKz0gTSAtIFJbaV0gLSBSW2pdO1xuICAgICAgQVtqKm4raV0gPSBBW2kqbitqXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gQTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIFNoYW5ub24gZW50cm9weSAobG9nIGJhc2UgMikgb2YgYW4gYXJyYXkgb2YgY291bnRzLlxuc3RhdHMuZW50cm9weSA9IGZ1bmN0aW9uKGNvdW50cywgZikge1xuICBmID0gdXRpbC4kKGYpO1xuICB2YXIgaSwgcCwgcyA9IDAsIEggPSAwLCBuID0gY291bnRzLmxlbmd0aDtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgcyArPSAoZiA/IGYoY291bnRzW2ldKSA6IGNvdW50c1tpXSk7XG4gIH1cbiAgaWYgKHMgPT09IDApIHJldHVybiAwO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBwID0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pIC8gcztcbiAgICBpZiAocCkgSCArPSBwICogTWF0aC5sb2cocCk7XG4gIH1cbiAgcmV0dXJuIC1IIC8gTWF0aC5MTjI7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgZm9ybSBbTUksIE1JX2Rpc3RhbmNlXSBcbi8vIE1JX2Rpc3RhbmNlIGlzIGRlZmluZWQgYXMgMSAtIEkoYSxiKSAvIEgoYSxiKS5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTXV0dWFsX2luZm9ybWF0aW9uXG5zdGF0cy5tdXR1YWwgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICB2YXIgeCA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGEpKSA6IHZhbHVlcyxcbiAgICAgIHkgPSBjb3VudHMgPyB2YWx1ZXMubWFwKHV0aWwuJChiKSkgOiBhLFxuICAgICAgeiA9IGNvdW50cyA/IHZhbHVlcy5tYXAodXRpbC4kKGNvdW50cykpIDogYjtcblxuICB2YXIgcHggPSB7fSxcbiAgICAgIHB5ID0ge30sXG4gICAgICBuID0gei5sZW5ndGgsXG4gICAgICBzID0gMCwgSSA9IDAsIEggPSAwLCBwLCB0LCBpO1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHB4W3hbaV1dID0gMDtcbiAgICBweVt5W2ldXSA9IDA7XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBweFt4W2ldXSArPSB6W2ldO1xuICAgIHB5W3lbaV1dICs9IHpbaV07XG4gICAgcyArPSB6W2ldO1xuICB9XG5cbiAgdCA9IDEgLyAocyAqIE1hdGguTE4yKTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYgKHpbaV0gPT09IDApIGNvbnRpbnVlO1xuICAgIHAgPSAocyAqIHpbaV0pIC8gKHB4W3hbaV1dICogcHlbeVtpXV0pO1xuICAgIEkgKz0geltpXSAqIHQgKiBNYXRoLmxvZyhwKTtcbiAgICBIICs9IHpbaV0gKiB0ICogTWF0aC5sb2coeltpXS9zKTtcbiAgfVxuXG4gIHJldHVybiBbSSwgMSArIEkvSF07XG59O1xuXG4vLyBDb21wdXRlIHRoZSBtdXR1YWwgaW5mb3JtYXRpb24gYmV0d2VlbiB0d28gZGlzY3JldGUgdmFyaWFibGVzLlxuc3RhdHMubXV0dWFsLmluZm8gPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICByZXR1cm4gc3RhdHMubXV0dWFsKHZhbHVlcywgYSwgYiwgY291bnRzKVswXTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBNSV9kaXN0YW5jZSBpcyBkZWZpbmVkIGFzIDEgLSBJKGEsYikgLyBIKGEsYikuXG5zdGF0cy5tdXR1YWwuZGlzdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYiwgY291bnRzKSB7XG4gIHJldHVybiBzdGF0cy5tdXR1YWwodmFsdWVzLCBhLCBiLCBjb3VudHMpWzFdO1xufTtcblxuLy8gQ29tcHV0ZSBhIHByb2ZpbGUgb2Ygc3VtbWFyeSBzdGF0aXN0aWNzIGZvciBhIHZhcmlhYmxlLlxuc3RhdHMucHJvZmlsZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgbWVhbiA9IDAsXG4gICAgICB2YWxpZCA9IDAsXG4gICAgICBtaXNzaW5nID0gMCxcbiAgICAgIGRpc3RpbmN0ID0gMCxcbiAgICAgIG1pbiA9IG51bGwsXG4gICAgICBtYXggPSBudWxsLFxuICAgICAgTTIgPSAwLFxuICAgICAgdmFscyA9IFtdLFxuICAgICAgdSA9IHt9LCBkZWx0YSwgc2QsIGksIHYsIHg7XG5cbiAgLy8gY29tcHV0ZSBzdW1tYXJ5IHN0YXRzXG4gIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuXG4gICAgLy8gdXBkYXRlIHVuaXF1ZSB2YWx1ZXNcbiAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcblxuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICsrbWlzc2luZztcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNWYWxpZCh2KSkge1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBpZiAobWluPT09bnVsbCB8fCB4IDwgbWluKSBtaW4gPSB4O1xuICAgICAgaWYgKG1heD09PW51bGwgfHwgeCA+IG1heCkgbWF4ID0geDtcbiAgICAgIGRlbHRhID0geCAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrdmFsaWQpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHggLSBtZWFuKTtcbiAgICAgIHZhbHMucHVzaCh4KTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvICh2YWxpZCAtIDEpO1xuICBzZCA9IE1hdGguc3FydChNMik7XG5cbiAgLy8gc29ydCB2YWx1ZXMgZm9yIG1lZGlhbiBhbmQgaXFyXG4gIHZhbHMuc29ydCh1dGlsLmNtcCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAgICAgdHlwZSh2YWx1ZXMsIGYpLFxuICAgIHVuaXF1ZTogICB1LFxuICAgIGNvdW50OiAgICB2YWx1ZXMubGVuZ3RoLFxuICAgIHZhbGlkOiAgICB2YWxpZCxcbiAgICBtaXNzaW5nOiAgbWlzc2luZyxcbiAgICBkaXN0aW5jdDogZGlzdGluY3QsXG4gICAgbWluOiAgICAgIG1pbixcbiAgICBtYXg6ICAgICAgbWF4LFxuICAgIG1lYW46ICAgICBtZWFuLFxuICAgIHN0ZGV2OiAgICBzZCxcbiAgICBtZWRpYW46ICAgKHYgPSBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjUpKSxcbiAgICBxMTogICAgICAgc3RhdHMucXVhbnRpbGUodmFscywgMC4yNSksXG4gICAgcTM6ICAgICAgIHN0YXRzLnF1YW50aWxlKHZhbHMsIDAuNzUpLFxuICAgIG1vZGVza2V3OiBzZCA9PT0gMCA/IDAgOiAobWVhbiAtIHYpIC8gc2RcbiAgfTtcbn07XG5cbi8vIENvbXB1dGUgcHJvZmlsZXMgZm9yIGFsbCB2YXJpYWJsZXMgaW4gYSBkYXRhIHNldC5cbnN0YXRzLnN1bW1hcnkgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgdmFyIHMgPSBmaWVsZHMubWFwKGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgcCA9IHN0YXRzLnByb2ZpbGUoZGF0YSwgdXRpbC4kKGYpKTtcbiAgICByZXR1cm4gKHAuZmllbGQgPSBmLCBwKTtcbiAgfSk7XG4gIHJldHVybiAocy5fX3N1bW1hcnlfXyA9IHRydWUsIHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGF0czsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCk7XG5cbnZhciBjb250ZXh0ID0ge1xuICBmb3JtYXRzOiAgICBbXSxcbiAgZm9ybWF0X21hcDoge30sXG4gIHRydW5jYXRlOiAgIHV0aWwudHJ1bmNhdGUsXG4gIHBhZDogICAgICAgIHV0aWwucGFkXG59O1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0KSB7XG4gIHZhciBzcmMgPSBzb3VyY2UodGV4dCwgJ2QnKTtcbiAgc3JjID0gJ3ZhciBfX3Q7IHJldHVybiAnICsgc3JjICsgJzsnO1xuXG4gIHRyeSB7XG4gICAgLyoganNoaW50IGV2aWw6IHRydWUgKi9cbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbignZCcsIHNyYykpLmJpbmQoY29udGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLnNvdXJjZSA9IHNyYztcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbnRlbXBsYXRlLnNvdXJjZSA9IHNvdXJjZTtcbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbi8vIGNsZWFyIGNhY2hlIG9mIGZvcm1hdCBvYmplY3RzXG4vLyBjYW4gKmJyZWFrKiBwcmlvciB0ZW1wbGF0ZSBmdW5jdGlvbnMsIHNvIGludm9rZSB3aXRoIGNhcmVcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuZnVuY3Rpb24gc291cmNlKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhcmlhYmxlID0gdmFyaWFibGUgfHwgJ29iaic7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBzcmMgPSAnXFwnJztcbiAgdmFyIHJlZ2V4ID0gdGVtcGxhdGVfcmU7XG5cbiAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cbiAgdGV4dC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihtYXRjaCwgaW50ZXJwb2xhdGUsIG9mZnNldCkge1xuICAgIHNyYyArPSB0ZXh0XG4gICAgICAuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICAgIC5yZXBsYWNlKHRlbXBsYXRlX2VzY2FwZXIsIHRlbXBsYXRlX2VzY2FwZUNoYXIpO1xuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgaWYgKGludGVycG9sYXRlKSB7XG4gICAgICBzcmMgKz0gJ1xcJ1xcbisoKF9fdD0oJyArXG4gICAgICAgIHRlbXBsYXRlX3ZhcihpbnRlcnBvbGF0ZSwgdmFyaWFibGUpICtcbiAgICAgICAgJykpPT1udWxsP1xcJ1xcJzpfX3QpK1xcblxcJyc7XG4gICAgfVxuXG4gICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG4gIHJldHVybiBzcmMgKyAnXFwnJztcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfdmFyKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhciBmaWx0ZXJzID0gdGV4dC5zcGxpdCgnfCcpO1xuICB2YXIgcHJvcCA9IGZpbHRlcnMuc2hpZnQoKS50cmltKCk7XG4gIHZhciBzdHJpbmdDYXN0ID0gdHJ1ZTtcbiAgXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8ICcnO1xuICAgIGlmIChzdHJpbmdDYXN0KSB7XG4gICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICBzcmMgPSAnU3RyaW5nKCcgKyBzcmMgKyAnKScgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIFxuICBmdW5jdGlvbiBkYXRlKCkge1xuICAgIHJldHVybiAnKHR5cGVvZiAnICsgc3JjICsgJz09PVwibnVtYmVyXCI/bmV3IERhdGUoJytzcmMrJyk6JytzcmMrJyknO1xuICB9XG4gIFxuICB2YXIgc3JjID0gdXRpbC5maWVsZChwcm9wKS5tYXAodXRpbC5zdHIpLmpvaW4oJ11bJyk7XG4gIHNyYyA9IHZhcmlhYmxlICsgJ1snICsgc3JjICsgJ10nO1xuICBcbiAgZm9yICh2YXIgaT0wOyBpPGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IGZpbHRlcnNbaV0sIGFyZ3MgPSBudWxsLCBwaWR4LCBhLCBiO1xuXG4gICAgaWYgKChwaWR4PWYuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgIGYgPSBmLnNsaWNlKDAsIHBpZHgpO1xuICAgICAgYXJncyA9IGZpbHRlcnNbaV0uc2xpY2UocGlkeCsxKS5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH0pO1xuICAgIH1cbiAgICBmID0gZi50cmltKCk7XG5cbiAgICBzd2l0Y2ggKGYpIHtcbiAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgIHN0cmNhbGwoJy5sZW5ndGgnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9VcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZUxvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cmltJzpcbiAgICAgICAgc3RyY2FsbCgnLnRyaW0oKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgwLCcgKyBhICsgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKC0nICsgYSArJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhICsgdXRpbC5udW1iZXIoYXJnc1sxXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgrJythKycsJytiKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2xpY2UnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgnKyBhICtcbiAgICAgICAgICAoYXJncy5sZW5ndGggPiAxID8gJywnICsgdXRpbC5udW1iZXIoYXJnc1sxXSkgOiAnJykgK1xuICAgICAgICAgICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT0nbGVmdCcgJiYgYiE9PSdtaWRkbGUnICYmIGIhPT0nY2VudGVyJykgPyAncmlnaHQnIDogYjtcbiAgICAgICAgc3JjID0gJ3RoaXMudHJ1bmNhdGUoJyArIHN0cmNhbGwoKSArICcsJyArIGEgKyAnLFxcJycgKyBiICsgJ1xcJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3BhZCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGFyZ3NbMV07XG4gICAgICAgIGIgPSAoYiE9PSdsZWZ0JyAmJiBiIT09J21pZGRsZScgJiYgYiE9PSdjZW50ZXInKSA/ICdyaWdodCcgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy5wYWQoJyArIHN0cmNhbGwoKSArICcsJyArIGEgKyAnLFxcJycgKyBiICsgJ1xcJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMuZm9ybWF0KTtcbiAgICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK3NyYysnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMudGltZS5mb3JtYXQpO1xuICAgICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrZGF0ZSgpKycpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcignVW5yZWNvZ25pemVkIHRlbXBsYXRlIGZpbHRlcjogJyArIGYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzcmM7XG59XG5cbnZhciB0ZW1wbGF0ZV9yZSA9IC9cXHtcXHsoLis/KVxcfVxcfXwkL2c7XG5cbi8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4vLyBzdHJpbmcgbGl0ZXJhbC5cbnZhciB0ZW1wbGF0ZV9lc2NhcGVzID0ge1xuICAnXFwnJzogICAgICdcXCcnLFxuICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICdcXHInOiAgICAgJ3InLFxuICAnXFxuJzogICAgICduJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbnZhciB0ZW1wbGF0ZV9lc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZV9lc2NhcGVDaGFyKG1hdGNoKSB7XG4gIHJldHVybiAnXFxcXCcgKyB0ZW1wbGF0ZV9lc2NhcGVzW21hdGNoXTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfZm9ybWF0KHBhdHRlcm4sIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcXCcnKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gPT09ICdcIicgICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09ICdcIicpKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKCdGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogJyArIHBhdHRlcm4pO1xuICB9XG4gIGlmICghY29udGV4dC5mb3JtYXRfbWFwW3BhdHRlcm5dKSB7XG4gICAgdmFyIGYgPSBmbXQocGF0dGVybik7XG4gICAgdmFyIGkgPSBjb250ZXh0LmZvcm1hdHMubGVuZ3RoO1xuICAgIGNvbnRleHQuZm9ybWF0cy5wdXNoKGYpO1xuICAgIGNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSA9IGk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXTtcbn1cbiIsInZhciBTVEVQUyA9IFtcbiAgWzMxNTM2ZTYsIDVdLCAgLy8gMS15ZWFyXG4gIFs3Nzc2ZTYsIDRdLCAgIC8vIDMtbW9udGhcbiAgWzI1OTJlNiwgNF0sICAgLy8gMS1tb250aFxuICBbMTIwOTZlNSwgM10sICAvLyAyLXdlZWtcbiAgWzYwNDhlNSwgM10sICAgLy8gMS13ZWVrXG4gIFsxNzI4ZTUsIDNdLCAgIC8vIDItZGF5XG4gIFs4NjRlNSwgM10sICAgIC8vIDEtZGF5XG4gIFs0MzJlNSwgMl0sICAgIC8vIDEyLWhvdXJcbiAgWzIxNmU1LCAyXSwgICAgLy8gNi1ob3VyXG4gIFsxMDhlNSwgMl0sICAgIC8vIDMtaG91clxuICBbMzZlNSwgMl0sICAgICAvLyAxLWhvdXJcbiAgWzE4ZTUsIDFdLCAgICAgLy8gMzAtbWludXRlXG4gIFs5ZTUsIDFdLCAgICAgIC8vIDE1LW1pbnV0ZVxuICBbM2U1LCAxXSwgICAgICAvLyA1LW1pbnV0ZVxuICBbNmU0LCAxXSwgICAgICAvLyAxLW1pbnV0ZVxuICBbM2U0LCAwXSwgICAgICAvLyAzMC1zZWNvbmRcbiAgWzE1ZTMsIDBdLCAgICAgLy8gMTUtc2Vjb25kXG4gIFs1ZTMsIDBdLCAgICAgIC8vIDUtc2Vjb25kXG4gIFsxZTMsIDBdICAgICAgIC8vIDEtc2Vjb25kXG5dO1xuXG5mdW5jdGlvbiBpc051bWJlcihkKSB7IHJldHVybiB0eXBlb2YgZCA9PT0gJ251bWJlcic7IH1cblxudmFyIGVudHJpZXMgPSBbXG4gIHtcbiAgICB0eXBlOiAnc2Vjb25kJyxcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogJyVZICViICUtZCAlSDolTTolUy4lTCcsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiAxZTMpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuICgrZCAvIDFlMyk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ21pbnV0ZScsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWSAlYiAlLWQgJUg6JU0nLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogNmU0KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDZlNCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ2hvdXInLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kICVIOjAwJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDM2ZTUpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gMzZlNSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogJ2RheScsXG4gICAgbWluc3RlcDogMSxcbiAgICBzdGVwOiBbMSwgN10sXG4gICAgZm9ybWF0OiAnJVkgJWIgJS1kJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDg2NGU1KTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiB+figrZCAvIDg2NGU1KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAnbW9udGgnLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgc3RlcDogWzEsIDMsIDZdLFxuICAgIGZvcm1hdDogJyViICVZJyxcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMofn4oZCAvIDEyKSwgZCAlIDEyLCAxKSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoaXNOdW1iZXIoZCkpIGQgPSBuZXcgRGF0ZShkKTtcbiAgICAgIHJldHVybiAxMiAqIGQuZ2V0VVRDRnVsbFllYXIoKSArIGQuZ2V0VVRDTW9udGgoKTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiAneWVhcicsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6ICclWScsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKGQsIDAsIDEpKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgfVxuICB9XG5dO1xuXG52YXIgbWludXRlT2ZIb3VyID0ge1xuICB0eXBlOiAnbWludXRlT2ZIb3VyJyxcbiAgbWluOiAwLFxuICBtYXg6IDU5LFxuICBtaW5zdGVwOiAxLFxuICBmb3JtYXQ6ICclTScsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgMCwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDTWludXRlcygpO1xuICB9XG59O1xuXG52YXIgaG91ck9mRGF5ID0ge1xuICB0eXBlOiAnaG91ck9mRGF5JyxcbiAgbWluOiAwLFxuICBtYXg6IDIzLFxuICBtaW5zdGVwOiAxLFxuICBmb3JtYXQ6ICclSCcsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgMSwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDSG91cnMoKTtcbiAgfVxufTtcblxudmFyIGRheU9mV2VlayA9IHtcbiAgdHlwZTogJ2RheU9mV2VlaycsXG4gIG1pbjogMCxcbiAgbWF4OiA2LFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogJyVhJyxcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCA0ICsgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDRGF5KCk7XG4gIH1cbn07XG5cbnZhciBkYXlPZk1vbnRoID0ge1xuICB0eXBlOiAnZGF5T2ZNb250aCcsXG4gIG1pbjogMSxcbiAgbWF4OiAzMSxcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6ICclLWQnLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIGQpKTtcbiAgfSxcbiAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiAoaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0RhdGUoKTtcbiAgfVxufTtcblxudmFyIG1vbnRoT2ZZZWFyID0ge1xuICB0eXBlOiAnbW9udGhPZlllYXInLFxuICBtaW46IDAsXG4gIG1heDogMTEsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiAnJWInLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIGQgJSAxMiwgMSkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIChpc051bWJlcihkKSA/IG5ldyBEYXRlKGQpIDogZCkuZ2V0VVRDTW9udGgoKTtcbiAgfVxufTtcblxudmFyIHVuaXRzID0ge1xuICAnc2Vjb25kJzogICAgICAgZW50cmllc1swXSxcbiAgJ21pbnV0ZSc6ICAgICAgIGVudHJpZXNbMV0sXG4gICdob3VyJzogICAgICAgICBlbnRyaWVzWzJdLFxuICAnZGF5JzogICAgICAgICAgZW50cmllc1szXSxcbiAgJ21vbnRoJzogICAgICAgIGVudHJpZXNbNF0sXG4gICd5ZWFyJzogICAgICAgICBlbnRyaWVzWzVdLFxuICAnbWludXRlT2ZIb3VyJzogbWludXRlT2ZIb3VyLFxuICAnaG91ck9mRGF5JzogICAgaG91ck9mRGF5LFxuICAnZGF5T2ZXZWVrJzogICAgZGF5T2ZXZWVrLFxuICAnZGF5T2ZNb250aCc6ICAgZGF5T2ZNb250aCxcbiAgJ21vbnRoT2ZZZWFyJzogIG1vbnRoT2ZZZWFyLFxuICAndGltZXN0ZXBzJzogICAgZW50cmllc1xufTtcblxudW5pdHMuZmluZCA9IGZ1bmN0aW9uKHNwYW4sIG1pbmIsIG1heGIpIHtcbiAgdmFyIGksIGxlbiwgYmlucywgc3RlcCA9IFNURVBTWzBdO1xuXG4gIGZvciAoaSA9IDEsIGxlbiA9IFNURVBTLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgc3RlcCA9IFNURVBTW2ldO1xuICAgIGlmIChzcGFuID4gc3RlcFswXSkge1xuICAgICAgYmlucyA9IHNwYW4gLyBzdGVwWzBdO1xuICAgICAgaWYgKGJpbnMgPiBtYXhiKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW1NURVBTW2kgLSAxXVsxXV07XG4gICAgICB9XG4gICAgICBpZiAoYmlucyA+PSBtaW5iKSB7XG4gICAgICAgIHJldHVybiBlbnRyaWVzW3N0ZXBbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZW50cmllc1tTVEVQU1tTVEVQUy5sZW5ndGggLSAxXVsxXV07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXRzO1xuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1bml0cyA9IHJlcXVpcmUoJy4vdGltZS11bml0cycpO1xudmFyIHUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyB3aGVyZSBhcmUgd2U/XG5cbnUuaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgIHR5cGVvZiBwcm9jZXNzLnN0ZGVyciAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnZhciBGTkFNRSA9ICdfX25hbWVfXyc7XG5cbnUubmFtZWRmdW5jID0gZnVuY3Rpb24obmFtZSwgZikgeyByZXR1cm4gKGZbRk5BTUVdID0gbmFtZSwgZik7IH07XG5cbnUubmFtZSA9IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGY9PW51bGwgPyBudWxsIDogZltGTkFNRV07IH07XG5cbnUuaWRlbnRpdHkgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9O1xuXG51LnRydWUgPSB1Lm5hbWVkZnVuYygndHJ1ZScsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cbnUuZmFsc2UgPSB1Lm5hbWVkZnVuYygnZmFsc2UnLCBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9KTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51Lmxlbmd0aCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiB4Lmxlbmd0aCAhPSBudWxsID8geC5sZW5ndGggOiBudWxsO1xufTtcblxudS5rZXlzID0gZnVuY3Rpb24oeCkge1xuICB2YXIga2V5cyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkga2V5cy5wdXNoKGspO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnUudmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHZhbHMgPSBbXSwgaztcbiAgZm9yIChrIGluIHgpIHZhbHMucHVzaCh4W2tdKTtcbiAgcmV0dXJuIHZhbHM7XG59O1xuXG51LnRvTWFwID0gZnVuY3Rpb24obGlzdCwgZikge1xuICByZXR1cm4gKGYgPSB1LiQoZikpID9cbiAgICBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHsgcmV0dXJuIChvYmpbZih4KV0gPSAxLCBvYmopOyB9LCB7fSkgOlxuICAgIGxpc3QucmVkdWNlKGZ1bmN0aW9uKG9iaiwgeCkgeyByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7IH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGg7XG4gIGlmICghbikgcmV0dXJuICcnO1xuICBmb3IgKHZhciBzPVN0cmluZyh2YWx1ZXNbMF0pLCBpPTE7IGk8bjsgKytpKSB7XG4gICAgcyArPSAnfCcgKyBTdHJpbmcodmFsdWVzW2ldKTtcbiAgfVxuICByZXR1cm4gcztcbn07XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG5cbnUuaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnUuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG51LmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xufTtcblxudS5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XG59O1xuXG51LmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzVmFsaWQgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmICFOdW1iZXIuaXNOYU4ob2JqKTtcbn07XG5cbnUuaXNCdWZmZXIgPSAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogK3M7XG59O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzID09IG51bGwgfHwgcyA9PT0gJycgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhcztcbn07XG5cbnUuZGF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbCB8fCBzID09PSAnJyA/IG51bGwgOiBEYXRlLnBhcnNlKHMpO1xufTtcblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudS5zdHIgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB1LmlzQXJyYXkoeCkgPyAnWycgKyB4Lm1hcCh1LnN0cikgKyAnXSdcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/ICgnXFwnJyt1dGlsX2VzY2FwZV9zdHIoeCkrJ1xcJycpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsICckMVxcXFxcXCcnKTtcbn1cblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBTdHJpbmcoZikuc3BsaXQoJ1xcXFwuJylcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoJy4nKTsgfSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCkgeyBhW2EubGVuZ3RoLTFdICs9ICcuJyArIGIuc2hpZnQoKTsgfVxuICAgICAgYS5wdXNoLmFwcGx5KGEsIGIpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSwgW10pO1xufTtcblxudS5hY2Nlc3NvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiBmPT1udWxsIHx8IHUuaXNGdW5jdGlvbihmKSA/IGYgOlxuICAgIHUubmFtZWRmdW5jKGYsIChzID0gdS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgICBmdW5jdGlvbih4KSB7IHJldHVybiBzLnJlZHVjZShmdW5jdGlvbih4LGYpIHsgcmV0dXJuIHhbZl07IH0sIHgpOyB9IDpcbiAgICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZl07IH1cbiAgICApO1xufTtcblxudS4kID0gdS5hY2Nlc3NvcjtcblxudS5tdXRhdG9yID0gZnVuY3Rpb24oZikge1xuICB2YXIgcztcbiAgcmV0dXJuIHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMSA/XG4gICAgZnVuY3Rpb24oeCwgdikge1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICB4W3NbaV1dID0gdjtcbiAgICB9IDpcbiAgICBmdW5jdGlvbih4LCB2KSB7IHhbZl0gPSB2OyB9O1xufTtcblxudS4kZnVuYyA9IGZ1bmN0aW9uKG5hbWUsIG9wKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgZiA9IHUuJChmKSB8fCB1LmlkZW50aXR5O1xuICAgIHZhciBuID0gbmFtZSArICh1Lm5hbWUoZikgPyAnXycrdS5uYW1lKGYpIDogJycpO1xuICAgIHJldHVybiB1Lm5hbWVkZnVuYyhuLCBmdW5jdGlvbihkKSB7IHJldHVybiBvcChmKGQpKTsgfSk7XG4gIH07XG59O1xuXG51LiR2YWxpZCAgPSB1LiRmdW5jKCd2YWxpZCcsIHUuaXNWYWxpZCk7XG51LiRsZW5ndGggPSB1LiRmdW5jKCdsZW5ndGgnLCB1Lmxlbmd0aCk7XG51LiR5ZWFyICAgPSB1LiRmdW5jKCd5ZWFyJywgdW5pdHMueWVhci51bml0KTtcbnUuJG1vbnRoICA9IHUuJGZ1bmMoJ21vbnRoJywgdW5pdHMubW9udGhPZlllYXIudW5pdCk7XG51LiRkYXRlICAgPSB1LiRmdW5jKCdkYXRlJywgdW5pdHMuZGF5T2ZNb250aC51bml0KTtcbnUuJGRheSAgICA9IHUuJGZ1bmMoJ2RheScsIHVuaXRzLmRheU9mV2Vlay51bml0KTtcbnUuJGhvdXIgICA9IHUuJGZ1bmMoJ2hvdXInLCB1bml0cy5ob3VyT2ZEYXkudW5pdCk7XG51LiRtaW51dGUgPSB1LiRmdW5jKCdtaW51dGUnLCB1bml0cy5taW51dGVPZkhvdXIudW5pdCk7XG5cbnUuJGluID0gZnVuY3Rpb24oZiwgdmFsdWVzKSB7XG4gIGYgPSB1LiQoZik7XG4gIHZhciBtYXAgPSB1LmlzQXJyYXkodmFsdWVzKSA/IHUudG9NYXAodmFsdWVzKSA6IHZhbHVlcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHsgcmV0dXJuICEhbWFwW2YoZCldOyB9O1xufTtcblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSAnLScpIHsgcyA9IC0xOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIGVsc2UgaWYgKGZbMF0gPT09ICcrJykgeyBzID0gKzE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgc2lnbi5wdXNoKHMpO1xuICAgIHJldHVybiB1LmFjY2Vzc29yKGYpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBpLCBuLCBmLCB4LCB5O1xuICAgIGZvciAoaT0wLCBuPXNvcnQubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgZiA9IHNvcnRbaV07IHggPSBmKGEpOyB5ID0gZihiKTtcbiAgICAgIGlmICh4IDwgeSkgcmV0dXJuIC0xICogc2lnbltpXTtcbiAgICAgIGlmICh4ID4geSkgcmV0dXJuIHNpZ25baV07XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufTtcblxudS5jbXAgPSBmdW5jdGlvbihhLCBiKSB7XG4gIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChhID4gYikge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGEgPj0gYikge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwgJiYgYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBOYU47XG59O1xuXG51Lm51bWNtcCA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuXG51LnN0YWJsZXNvcnQgPSBmdW5jdGlvbihhcnJheSwgc29ydEJ5LCBrZXlGbikge1xuICB2YXIgaW5kaWNlcyA9IGFycmF5LnJlZHVjZShmdW5jdGlvbihpZHgsIHYsIGkpIHtcbiAgICByZXR1cm4gKGlkeFtrZXlGbih2KV0gPSBpLCBpZHgpO1xuICB9LCB7fSk7XG5cbiAgYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHNhID0gc29ydEJ5KGEpLFxuICAgICAgICBzYiA9IHNvcnRCeShiKTtcbiAgICByZXR1cm4gc2EgPCBzYiA/IC0xIDogc2EgPiBzYiA/IDFcbiAgICAgICAgIDogKGluZGljZXNba2V5Rm4oYSldIC0gaW5kaWNlc1trZXlGbihiKV0pO1xuICB9KTtcblxuICByZXR1cm4gYXJyYXk7XG59O1xuXG5cbi8vIHN0cmluZyBmdW5jdGlvbnNcblxuLy8gRVM2IGNvbXBhdGliaWxpdHkgcGVyIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoI1BvbHlmaWxsXG4vLyBXZSBjb3VsZCBoYXZlIHVzZWQgdGhlIHBvbHlmaWxsIGNvZGUsIGJ1dCBsZXRzIHdhaXQgdW50aWwgRVM2IGJlY29tZXMgYSBzdGFuZGFyZCBmaXJzdFxudS5zdGFydHNXaXRoID0gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID9cbiAgZnVuY3Rpb24oc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcbiAgfSA6XG4gIGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sYXN0SW5kZXhPZihzZWFyY2hTdHJpbmcsIDApID09PSAwO1xuICB9O1xuXG51LnBhZCA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCBwYWRjaGFyKSB7XG4gIHBhZGNoYXIgPSBwYWRjaGFyIHx8IFwiIFwiO1xuICB2YXIgZCA9IGxlbmd0aCAtIHMubGVuZ3RoO1xuICBpZiAoZCA8PSAwKSByZXR1cm4gcztcbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHJldHVybiBzdHJyZXAoZCwgcGFkY2hhcikgKyBzO1xuICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIHJldHVybiBzdHJyZXAoTWF0aC5mbG9vcihkLzIpLCBwYWRjaGFyKSArXG4gICAgICAgICBzICsgc3RycmVwKE1hdGguY2VpbChkLzIpLCBwYWRjaGFyKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHMgKyBzdHJyZXAoZCwgcGFkY2hhcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHN0cnJlcChuLCBzdHIpIHtcbiAgdmFyIHMgPSBcIlwiLCBpO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHMgKz0gc3RyO1xuICByZXR1cm4gcztcbn1cblxudS50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVsbGlwc2lzKSA6ICdcXHUyMDI2JztcbiAgdmFyIGwgPSBNYXRoLm1heCgwLCBsZW5ndGggLSBlbGxpcHNpcy5sZW5ndGgpO1xuXG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICByZXR1cm4gZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCwxKSA6IHMuc2xpY2UobGVuLWwpKTtcbiAgICBjYXNlICdtaWRkbGUnOlxuICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICB2YXIgbDEgPSBNYXRoLmNlaWwobC8yKSwgbDIgPSBNYXRoLmZsb29yKGwvMik7XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwxKSA6IHMuc2xpY2UoMCxsMSkpICtcbiAgICAgICAgZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDIsMSkgOiBzLnNsaWNlKGxlbi1sMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwpIDogcy5zbGljZSgwLGwpKSArIGVsbGlwc2lzO1xuICB9XG59O1xuXG5mdW5jdGlvbiB0cnVuY2F0ZU9uV29yZChzLCBsZW4sIHJldikge1xuICB2YXIgY250ID0gMCwgdG9rID0gcy5zcGxpdCh0cnVuY2F0ZV93b3JkX3JlKTtcbiAgaWYgKHJldikge1xuICAgIHMgPSAodG9rID0gdG9rLnJldmVyc2UoKSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KVxuICAgICAgLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBzID0gdG9rLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pO1xuICB9XG4gIHJldHVybiBzLmxlbmd0aCA/IHMuam9pbignJykudHJpbSgpIDogdG9rWzBdLnNsaWNlKDAsIGxlbik7XG59XG5cbnZhciB0cnVuY2F0ZV93b3JkX3JlID0gLyhbXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTIwMjhcXHUyMDI5XFx1MzAwMFxcdUZFRkZdKS87XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIGJvdW5kcyA9IGZ1bmN0aW9uKGIpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBpZiAoYikgdGhpcy51bmlvbihiKTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSBib3VuZHMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnkxID0gK051bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueDIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbiAgdGhpcy54MiA9IHgyO1xuICB0aGlzLnkyID0geTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcbiAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgaWYgKHggPiB0aGlzLngyKSB0aGlzLngyID0geDtcbiAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24oZCkge1xuICB0aGlzLngxIC09IGQ7XG4gIHRoaXMueTEgLT0gZDtcbiAgdGhpcy54MiArPSBkO1xuICB0aGlzLnkyICs9IGQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSBNYXRoLmZsb29yKHRoaXMueDEpO1xuICB0aGlzLnkxID0gTWF0aC5mbG9vcih0aGlzLnkxKTtcbiAgdGhpcy54MiA9IE1hdGguY2VpbCh0aGlzLngyKTtcbiAgdGhpcy55MiA9IE1hdGguY2VpbCh0aGlzLnkyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gIHRoaXMueDEgKz0gZHg7XG4gIHRoaXMueDIgKz0gZHg7XG4gIHRoaXMueTEgKz0gZHk7XG4gIHRoaXMueTIgKz0gZHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCB4LCB5KSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICBjeCA9IHggLSB4KmNvcyArIHkqc2luLFxuICAgICAgY3kgPSB5IC0geCpzaW4gLSB5KmNvcyxcbiAgICAgIHgxID0gdGhpcy54MSwgeDIgPSB0aGlzLngyLFxuICAgICAgeTEgPSB0aGlzLnkxLCB5MiA9IHRoaXMueTI7XG5cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIC5hZGQoY29zKngxIC0gc2luKnkxICsgY3gsICBzaW4qeDEgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MiArIGN4LCAgc2luKngxICsgY29zKnkyICsgY3kpXG4gICAgLmFkZChjb3MqeDIgLSBzaW4qeTEgKyBjeCwgIHNpbip4MiArIGNvcyp5MSArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkyICsgY3gsICBzaW4qeDIgKyBjb3MqeTIgKyBjeSk7XG59XG5cbnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uKGIpIHtcbiAgaWYgKGIueDEgPCB0aGlzLngxKSB0aGlzLngxID0gYi54MTtcbiAgaWYgKGIueTEgPCB0aGlzLnkxKSB0aGlzLnkxID0gYi55MTtcbiAgaWYgKGIueDIgPiB0aGlzLngyKSB0aGlzLngyID0gYi54MjtcbiAgaWYgKGIueTIgPiB0aGlzLnkyKSB0aGlzLnkyID0gYi55MjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZW5jbG9zZXMgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiBiICYmIChcbiAgICB0aGlzLngxIDw9IGIueDEgJiZcbiAgICB0aGlzLngyID49IGIueDIgJiZcbiAgICB0aGlzLnkxIDw9IGIueTEgJiZcbiAgICB0aGlzLnkyID49IGIueTJcbiAgKTtcbn07XG5cbnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAhKFxuICAgIHRoaXMueDIgPCBiLngxIHx8XG4gICAgdGhpcy54MSA+IGIueDIgfHxcbiAgICB0aGlzLnkyIDwgYi55MSB8fFxuICAgIHRoaXMueTEgPiBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiAhKFxuICAgIHggPCB0aGlzLngxIHx8XG4gICAgeCA+IHRoaXMueDIgfHxcbiAgICB5IDwgdGhpcy55MSB8fFxuICAgIHkgPiB0aGlzLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xufTtcblxucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy55MiAtIHRoaXMueTE7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJvdW5kczsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2NhbnZhcy9pbmRleCcpLFxuICAgIHN2ZyA9IHJlcXVpcmUoJy4uL3JlbmRlci9zdmctaGVhZGxlc3MvaW5kZXgnKSxcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi9WaWV3JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbnZhciBIZWFkbGVzc1ZpZXcgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBtb2RlbCkge1xuICBWaWV3LmNhbGwobnVsbCwgd2lkdGgsIGhlaWdodCwgbW9kZWwpO1xuICB0aGlzLl9lbCA9IFwiYm9keVwiO1xuICB0aGlzLl90eXBlID0gXCJjYW52YXNcIjtcbiAgdGhpcy5fcmVuZGVyZXJzID0ge2NhbnZhczogY2FudmFzLCBzdmc6IHN2Z307XG4gIHRoaXMuX2NhbnZhcyA9IG51bGw7XG59XG5cbnZhciBwcm90b3R5cGUgPSAoSGVhZGxlc3NWaWV3LnByb3RvdHlwZSA9IG5ldyBWaWV3KCkpO1xuXG5wcm90b3R5cGUucmVuZGVyZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmKHR5cGUpIHRoaXMuX3R5cGUgPSB0eXBlO1xuICByZXR1cm4gVmlldy5wcm90b3R5cGUucmVuZGVyZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvdHlwZS5jYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbn07XG5cbnByb3RvdHlwZS5jYW52YXNBc3luYyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciByID0gdGhpcy5fcmVuZGVyZXIsIHZpZXcgPSB0aGlzO1xuICBcbiAgZnVuY3Rpb24gd2FpdCgpIHtcbiAgICBpZiAoci5wZW5kaW5nSW1hZ2VzKCkgPT09IDApIHtcbiAgICAgIHZpZXcucmVuZGVyKCk7IC8vIHJlLXJlbmRlciB3aXRoIGFsbCBpbWFnZXNcbiAgICAgIGNhbGxiYWNrKHZpZXcuX2NhbnZhcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQod2FpdCwgMTApO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIGltYWdlcyBsb2FkaW5nLCBwb2xsIHVudGlsIHJlYWR5XG4gIChyLnBlbmRpbmdJbWFnZXMoKSA+IDApID8gd2FpdCgpIDogY2FsbGJhY2sodGhpcy5fY2FudmFzKTtcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICh0aGlzLl90eXBlID09PSBcInN2Z1wiKVxuICAgID8gdGhpcy5fcmVuZGVyZXIuc3ZnKClcbiAgICA6IG51bGw7XG59O1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKCkgeyAgICBcbiAgdmFyIHcgPSB0aGlzLl93aWR0aCxcbiAgICAgIGggPSB0aGlzLl9oZWlnaHQsXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nO1xuXG4gIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgIHcgPSB0aGlzLl92aWV3cG9ydFswXSAtIChwYWQgPyBwYWQubGVmdCArIHBhZC5yaWdodCA6IDApO1xuICAgIGggPSB0aGlzLl92aWV3cG9ydFsxXSAtIChwYWQgPyBwYWQudG9wICsgcGFkLmJvdHRvbSA6IDApO1xuICB9XG5cbiAgdGhpcy5fcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlciB8fCBuZXcgdGhpcy5faW8uUmVuZGVyZXIoKTtcbiAgXG4gIGlmICh0aGlzLl90eXBlID09PSBcInN2Z1wiKSB7XG4gICAgdGhpcy5pbml0U1ZHKHcsIGgsIHBhZCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pbml0Q2FudmFzKHcsIGgsIHBhZCk7XG4gIH1cbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmluaXRDYW52YXMgPSBmdW5jdGlvbih3LCBoLCBwYWQpIHtcbiAgdmFyIENhbnZhcyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmNhbnZhcyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuY2FudmFzIDogbnVsbCksXG4gICAgICB0dyA9IHcgKyBwYWQubGVmdCArIHBhZC5yaWdodCxcbiAgICAgIHRoID0gaCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICAgICAgY2FudmFzID0gdGhpcy5fY2FudmFzID0gZGwuaXNOb2RlID8gbmV3IENhbnZhcyh0dywgdGgpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyksXG4gICAgICBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gIGlmKCFkbC5pc05vZGUpIHsgIC8vIE1hbnVhbGx5IHNldCB3aWR0aC9oZWlnaHQgb24gRE9NIGVsZW1lbnRzXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHR3KTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoKTtcbiAgfVxuICBcbiAgLy8gc2V0dXAgY2FudmFzIGNvbnRleHRcbiAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCBwYWQubGVmdCwgcGFkLnRvcCk7XG5cbiAgLy8gY29uZmlndXJlIHJlbmRlcmVyXG4gIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQoY3R4KTtcbiAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHcsIGgsIHBhZCk7XG59O1xuXG5wcm90b3R5cGUuaW5pdFNWRyA9IGZ1bmN0aW9uKHcsIGgsIHBhZCkge1xuICAvLyBjb25maWd1cmUgcmVuZGVyZXJcbiAgdGhpcy5fcmVuZGVyZXIuaW5pdGlhbGl6ZSh0aGlzLl9lbCwgdywgaCwgcGFkKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGVhZGxlc3NWaWV3O1xuIiwidmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvR3JhcGgnKSwgXG4gICAgTm9kZSAgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgR3JvdXBCdWlsZGVyID0gcmVxdWlyZSgnLi4vc2NlbmUvR3JvdXBCdWlsZGVyJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksIFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5mdW5jdGlvbiBNb2RlbCgpIHtcbiAgdGhpcy5fZGVmcyA9IHt9O1xuICB0aGlzLl9wcmVkaWNhdGVzID0ge307XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcblxuICB0aGlzLl9ub2RlID0gbnVsbDtcbiAgdGhpcy5fYnVpbGRlciA9IG51bGw7IC8vIFRvcC1sZXZlbCBzY2VuZWdyYXBoIGJ1aWxkZXJcblxuICBHcmFwaC5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMpO1xufTtcblxudmFyIHByb3RvID0gKE1vZGVsLnByb3RvdHlwZSA9IG5ldyBHcmFwaCgpKTtcblxucHJvdG8uZGVmcyA9IGZ1bmN0aW9uKGRlZnMpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fZGVmcztcbiAgdGhpcy5fZGVmcyA9IGRlZnM7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ubm9kZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZSB8fCAodGhpcy5fbm9kZSA9IG5ldyBOb2RlKHRoaXMpKTtcbn07XG5cbnByb3RvLmRhdGEgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRhdGEgPSBHcmFwaC5wcm90b3R5cGUuZGF0YS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID4gMSkgeyAgLy8gbmV3IERhdGFzb3VyY2VcbiAgICB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcihkYXRhLnBpcGVsaW5lKClbMF0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5mdW5jdGlvbiBwcmVkaWNhdGVzKG5hbWUpIHtcbiAgdmFyIG0gPSB0aGlzLCBwcmVkaWNhdGVzID0ge307XG4gIGlmKCFkbC5pc0FycmF5KG5hbWUpKSByZXR1cm4gdGhpcy5fcHJlZGljYXRlc1tuYW1lXTtcbiAgbmFtZS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHsgcHJlZGljYXRlc1tuXSA9IG0uX3ByZWRpY2F0ZXNbbl0gfSk7XG4gIHJldHVybiBwcmVkaWNhdGVzO1xufVxuXG5wcm90by5wcmVkaWNhdGUgPSBmdW5jdGlvbihuYW1lLCBwcmVkaWNhdGUpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHByZWRpY2F0ZXMuY2FsbCh0aGlzLCBuYW1lKTtcbiAgcmV0dXJuICh0aGlzLl9wcmVkaWNhdGVzW25hbWVdID0gcHJlZGljYXRlKTtcbn07XG5cbnByb3RvLnByZWRpY2F0ZXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZXM7IH07XG5cbnByb3RvLnNjZW5lID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgaWYodGhpcy5fYnVpbGRlcikgdGhpcy5ub2RlKCkucmVtb3ZlTGlzdGVuZXIodGhpcy5fYnVpbGRlci5kaXNjb25uZWN0KCkpO1xuICB0aGlzLl9idWlsZGVyID0gbmV3IEdyb3VwQnVpbGRlcih0aGlzLCB0aGlzLl9kZWZzLm1hcmtzLCB0aGlzLl9zY2VuZT17fSk7XG4gIHRoaXMubm9kZSgpLmFkZExpc3RlbmVyKHRoaXMuX2J1aWxkZXIuY29ubmVjdCgpKTtcbiAgdmFyIHAgPSB0aGlzLl9idWlsZGVyLnBpcGVsaW5lKCk7XG4gIHBbcC5sZW5ndGgtMV0uYWRkTGlzdGVuZXIocmVuZGVyZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obCkgeyB0aGlzLm5vZGUoKS5hZGRMaXN0ZW5lcihsKTsgfTtcbnByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obCkgeyB0aGlzLm5vZGUoKS5yZW1vdmVMaXN0ZW5lcihsKTsgfTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmKCFjcykgY3MgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gIHRoaXMucHJvcGFnYXRlKGNzLCB0aGlzLm5vZGUoKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vZGVsOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgcGFyc2VTdHJlYW1zID0gcmVxdWlyZSgnLi4vcGFyc2Uvc3RyZWFtcycpLFxuICAgIGNhbnZhcyA9IHJlcXVpcmUoJy4uL3JlbmRlci9jYW52YXMvaW5kZXgnKSxcbiAgICBzdmcgPSByZXF1aXJlKCcuLi9yZW5kZXIvc3ZnL2luZGV4JyksXG4gICAgRW5jb2RlciA9IHJlcXVpcmUoJy4uL3NjZW5lL0VuY29kZXInKSxcbiAgICBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vc2NlbmUvVHJhbnNpdGlvbicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbnZhciBWaWV3ID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIG1vZGVsKSB7XG4gIHRoaXMuX2VsICAgID0gbnVsbDtcbiAgdGhpcy5fbW9kZWwgPSBudWxsO1xuICB0aGlzLl93aWR0aCA9IHRoaXMuX193aWR0aCA9IHdpZHRoIHx8IDUwMDtcbiAgdGhpcy5faGVpZ2h0ICA9IHRoaXMuX19oZWlnaHQgPSBoZWlnaHQgfHwgMzAwO1xuICB0aGlzLl9hdXRvcGFkID0gMTtcbiAgdGhpcy5fcGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHRoaXMuX3ZpZXdwb3J0ID0gbnVsbDtcbiAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVyICA9IG51bGw7XG4gIHRoaXMuX3N0cmVhbWVyID0gbnVsbDsgLy8gVGFyZ2V0ZWQgdXBkYXRlIGZvciBzdHJlYW1pbmcgY2hhbmdlc1xuICB0aGlzLl9jaGFuZ2VzZXQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlcnMgPSB7Y2FudmFzOiBjYW52YXMsIHN2Zzogc3ZnfTtcbiAgdGhpcy5faW8gID0gY2FudmFzO1xuICB0aGlzLl9hcGkgPSB7fTsgLy8gU3Rhc2ggc3RyZWFtaW5nIGRhdGEgQVBJIHNhbmRib3hlcy5cbn07XG5cbnZhciBwcm90b3R5cGUgPSBWaWV3LnByb3RvdHlwZTtcblxucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIGlmICh0aGlzLl9tb2RlbCAhPT0gbW9kZWwpIHtcbiAgICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICAgIHRoaXMuX3N0cmVhbWVyID0gbmV3IE5vZGUobW9kZWwpO1xuICAgIHRoaXMuX2NoYW5nZXNldCA9IGNoYW5nZXNldC5jcmVhdGUoKTtcbiAgICBpZiAodGhpcy5faGFuZGxlcikgdGhpcy5faGFuZGxlci5tb2RlbChtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBTYW5kYm94ZWQgc3RyZWFtaW5nIGRhdGEgQVBJXG5mdW5jdGlvbiBzdHJlYW1pbmcoc3JjKSB7XG4gIHZhciB2aWV3ID0gdGhpcyxcbiAgICAgIGRzID0gdGhpcy5fbW9kZWwuZGF0YShzcmMpLFxuICAgICAgbGlzdGVuZXIgPSBkcy5waXBlbGluZSgpWzBdLFxuICAgICAgc3RyZWFtZXIgPSB0aGlzLl9zdHJlYW1lcixcbiAgICAgIGNzICA9IHRoaXMuX2NoYW5nZXNldCxcbiAgICAgIGFwaSA9IHt9O1xuXG4gIGlmKGRsLmtleXMoY3Muc2lnbmFscykubGVuZ3RoID4gMCkge1xuICAgIHRocm93IFwiTmV3IHNpZ25hbCB2YWx1ZXMgYXJlIG5vdCByZWZsZWN0ZWQgaW4gdGhlIHZpc3VhbGl6YXRpb24uXCIgK1xuICAgICAgXCIgUGxlYXNlIGNhbGwgdmlldy51cGRhdGUoKSBiZWZvcmUgdXBkYXRpbmcgZGF0YSB2YWx1ZXMuXCJcbiAgfVxuXG4gIC8vIElmIHdlIGhhdmUgaXQgc3Rhc2hlZCwgZG9uJ3QgY3JlYXRlIGEgbmV3IGNsb3N1cmUuIFxuICBpZih0aGlzLl9hcGlbc3JjXSkgcmV0dXJuIHRoaXMuX2FwaVtzcmNdO1xuXG4gIGFwaS5pbnNlcnQgPSBmdW5jdGlvbih2YWxzKSB7XG4gICAgZHMuaW5zZXJ0KGRsLmR1cGxpY2F0ZSh2YWxzKSk7ICAvLyBEb24ndCBwb2xsdXRlIHRoZSBlbnZpcm9ubWVudFxuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjcy5kYXRhW2RzLm5hbWUoKV0gPSAxO1xuICAgIHJldHVybiBhcGk7XG4gIH07XG5cbiAgYXBpLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjcy5kYXRhW2RzLm5hbWUoKV0gPSAxO1xuICAgIHJldHVybiAoZHMudXBkYXRlLmFwcGx5KGRzLCBhcmd1bWVudHMpLCBhcGkpO1xuICB9O1xuXG4gIGFwaS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICBzdHJlYW1lci5hZGRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY3MuZGF0YVtkcy5uYW1lKCldID0gMTtcbiAgICByZXR1cm4gKGRzLnJlbW92ZS5hcHBseShkcywgYXJndW1lbnRzKSwgYXBpKTtcbiAgfTtcblxuICBhcGkudmFsdWVzID0gZnVuY3Rpb24oKSB7IHJldHVybiBkcy52YWx1ZXMoKSB9OyAgICBcblxuICByZXR1cm4gKHRoaXMuX2FwaVtzcmNdID0gYXBpKTtcbn07XG5cbnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgdiA9IHRoaXM7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdi5fbW9kZWwuZGF0YVZhbHVlcygpO1xuICBlbHNlIGlmKGRsLmlzU3RyaW5nKGRhdGEpKSByZXR1cm4gc3RyZWFtaW5nLmNhbGwodiwgZGF0YSk7XG4gIGVsc2UgaWYoZGwuaXNPYmplY3QoZGF0YSkpIHtcbiAgICBkbC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGFwaSA9IHN0cmVhbWluZy5jYWxsKHYsIGspO1xuICAgICAgZGF0YVtrXShhcGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBtICA9IHRoaXMuX21vZGVsLFxuICAgICAgY3MgPSB0aGlzLl9jaGFuZ2VzZXQsXG4gICAgICBzdHJlYW1lciA9IHRoaXMuX3N0cmVhbWVyLFxuICAgICAgc2V0dGVyID0gbmFtZTsgXG5cbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtLnNpZ25hbFZhbHVlcygpO1xuICBlbHNlIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiBkbC5pc1N0cmluZyhuYW1lKSkgcmV0dXJuIG0uc2lnbmFsVmFsdWVzKG5hbWUpO1xuXG4gIGlmKGRsLmtleXMoY3MuZGF0YSkubGVuZ3RoID4gMCkge1xuICAgIHRocm93IFwiTmV3IGRhdGEgdmFsdWVzIGFyZSBub3QgcmVmbGVjdGVkIGluIHRoZSB2aXN1YWxpemF0aW9uLlwiICtcbiAgICAgIFwiIFBsZWFzZSBjYWxsIHZpZXcudXBkYXRlKCkgYmVmb3JlIHVwZGF0aW5nIHNpZ25hbCB2YWx1ZXMuXCJcbiAgfVxuXG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMikge1xuICAgIHNldHRlciA9IHt9O1xuICAgIHNldHRlcltuYW1lXSA9IHZhbHVlO1xuICB9XG5cbiAgZGwua2V5cyhzZXR0ZXIpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHN0cmVhbWVyLmFkZExpc3RlbmVyKG0uc2lnbmFsKGspLnZhbHVlKHNldHRlcltrXSkpO1xuICAgIGNzLnNpZ25hbHNba10gPSAxO1xuICAgIGNzLnJlZmxvdyA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24od2lkdGgpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fX3dpZHRoO1xuICBpZiAodGhpcy5fX3dpZHRoICE9PSB3aWR0aCkge1xuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuX3N0cmljdCkgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX19oZWlnaHQ7XG4gIGlmICh0aGlzLl9faGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLl9zdHJpY3QpIHRoaXMuX2F1dG9wYWQgPSAxO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnBhZGRpbmcgPSBmdW5jdGlvbihwYWQpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcGFkZGluZztcbiAgaWYgKHRoaXMuX3BhZGRpbmcgIT09IHBhZCkge1xuICAgIGlmIChkbC5pc1N0cmluZyhwYWQpKSB7XG4gICAgICB0aGlzLl9hdXRvcGFkID0gMTtcbiAgICAgIHRoaXMuX3BhZGRpbmcgPSB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICAgICAgdGhpcy5fc3RyaWN0ID0gKHBhZCA9PT0gXCJzdHJpY3RcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9wYWQgPSAwO1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgICAgIHRoaXMuX3N0cmljdCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZWwpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlc2l6ZSh0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBwYWQpO1xuICAgICAgaWYodGhpcy5faGFuZGxlcikgdGhpcy5faGFuZGxlci5wYWRkaW5nKHBhZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmF1dG9wYWQgPSBmdW5jdGlvbihvcHQpIHtcbiAgaWYgKHRoaXMuX2F1dG9wYWQgPCAxKSByZXR1cm4gdGhpcztcbiAgZWxzZSB0aGlzLl9hdXRvcGFkID0gMDtcblxuICB2YXIgcGFkID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIGIgPSB0aGlzLm1vZGVsKCkuc2NlbmUoKS5ib3VuZHMsXG4gICAgICBpbnNldCA9IGNvbmZpZy5hdXRvcGFkSW5zZXQsXG4gICAgICBsID0gYi54MSA8IDAgPyBNYXRoLmNlaWwoLWIueDEpICsgaW5zZXQgOiAwLFxuICAgICAgdCA9IGIueTEgPCAwID8gTWF0aC5jZWlsKC1iLnkxKSArIGluc2V0IDogMCxcbiAgICAgIHIgPSBiLngyID4gdGhpcy5fd2lkdGggID8gTWF0aC5jZWlsKCtiLngyIC0gdGhpcy5fd2lkdGgpICsgaW5zZXQgOiAwLFxuICAgICAgYiA9IGIueTIgPiB0aGlzLl9oZWlnaHQgPyBNYXRoLmNlaWwoK2IueTIgLSB0aGlzLl9oZWlnaHQpICsgaW5zZXQgOiAwO1xuICBwYWQgPSB7bGVmdDpsLCB0b3A6dCwgcmlnaHQ6ciwgYm90dG9tOmJ9O1xuXG4gIGlmICh0aGlzLl9zdHJpY3QpIHtcbiAgICB0aGlzLl9hdXRvcGFkID0gMDtcbiAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgIHRoaXMuX3dpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy5fX3dpZHRoIC0gKGwrcikpO1xuICAgIHRoaXMuX2hlaWdodCA9IE1hdGgubWF4KDAsIHRoaXMuX19oZWlnaHQgLSAodCtiKSk7XG4gICAgdGhpcy5fbW9kZWwud2lkdGgodGhpcy5fd2lkdGgpO1xuICAgIHRoaXMuX21vZGVsLmhlaWdodCh0aGlzLl9oZWlnaHQpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wYWRkaW5nKHBhZCkudXBkYXRlKG9wdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudmlld3BvcnQgPSBmdW5jdGlvbihzaXplKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xuICBpZiAodGhpcy5fdmlld3BvcnQgIT09IHNpemUpIHtcbiAgICB0aGlzLl92aWV3cG9ydCA9IHNpemU7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyZXIgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICBpZiAodGhpcy5fcmVuZGVyZXJzW3R5cGVdKSB0eXBlID0gdGhpcy5fcmVuZGVyZXJzW3R5cGVdO1xuICBlbHNlIGlmIChkbC5pc1N0cmluZyh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biByZW5kZXJlcjogXCIgKyB0eXBlKTtcbiAgZWxzZSBpZiAoIXR5cGUpIHRocm93IG5ldyBFcnJvcihcIk5vIHJlbmRlcmVyIHNwZWNpZmllZFwiKTtcblxuICBpZiAodGhpcy5faW8gIT09IHR5cGUpIHtcbiAgICB0aGlzLl9pbyA9IHR5cGU7XG4gICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIGlmICh0aGlzLl9idWlsZCkgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwpIHtcbiAgdmFyIHYgPSB0aGlzLCBwcmV2SGFuZGxlcixcbiAgICAgIHcgPSB2Ll93aWR0aCwgaCA9IHYuX2hlaWdodCwgcGFkID0gdi5fcGFkZGluZztcblxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgZWwgPT09IG51bGwpIHtcbiAgICBlbCA9IHRoaXMuX2VsID8gdGhpcy5fZWwucGFyZW50Tm9kZSA6IG51bGw7XG4gICAgaWYoIWVsKSByZXR1cm4gdGhpczsgIC8vIFRoaXMgVmlldyBjYW5ub3QgaW5pdCB3L28gYW5cbiAgfVxuICBcbiAgLy8gY2xlYXIgcHJlLWV4aXN0aW5nIGNvbnRhaW5lclxuICBkMy5zZWxlY3QoZWwpLnNlbGVjdChcImRpdi52ZWdhXCIpLnJlbW92ZSgpO1xuICBcbiAgLy8gYWRkIGRpdiBjb250YWluZXJcbiAgdGhpcy5fZWwgPSBlbCA9IGQzLnNlbGVjdChlbClcbiAgICAuYXBwZW5kKFwiZGl2XCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLCBcInZlZ2FcIilcbiAgICAuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXG4gICAgLm5vZGUoKTtcbiAgaWYgKHYuX3ZpZXdwb3J0KSB7XG4gICAgZDMuc2VsZWN0KGVsKVxuICAgICAgLnN0eWxlKFwid2lkdGhcIiwgICh2Ll92aWV3cG9ydFswXSB8fCB3KStcInB4XCIpXG4gICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgKHYuX3ZpZXdwb3J0WzFdIHx8IGgpK1wicHhcIilcbiAgICAgIC5zdHlsZShcIm92ZXJmbG93XCIsIFwiYXV0b1wiKTtcbiAgfVxuXG4gIC8vIHJlbmRlcmVyXG4gIHYuX3JlbmRlcmVyID0gKHYuX3JlbmRlcmVyIHx8IG5ldyB0aGlzLl9pby5SZW5kZXJlcigpKVxuICAgIC5pbml0aWFsaXplKGVsLCB3LCBoLCBwYWQpO1xuICBcbiAgLy8gaW5wdXQgaGFuZGxlclxuICBwcmV2SGFuZGxlciA9IHYuX2hhbmRsZXI7XG4gIHYuX2hhbmRsZXIgPSBuZXcgdGhpcy5faW8uSGFuZGxlcigpXG4gICAgLmluaXRpYWxpemUoZWwsIHBhZCwgdilcbiAgICAubW9kZWwodi5fbW9kZWwpO1xuXG4gIGlmIChwcmV2SGFuZGxlcikge1xuICAgIHByZXZIYW5kbGVyLmhhbmRsZXJzKCkuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICB2Ll9oYW5kbGVyLm9uKGgudHlwZSwgaC5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgZm9yIHNpZ25hbCBzdHJlYW0gZGVmaW5pdGlvbnMuXG4gICAgcGFyc2VTdHJlYW1zKHRoaXMpO1xuICB9XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGJ1aWxkKCkge1xuICB2YXIgdiA9IHRoaXM7XG4gIHYuX3JlbmRlck5vZGUgPSBuZXcgTm9kZSh2Ll9tb2RlbClcbiAgICAucm91dGVyKHRydWUpO1xuXG4gIHYuX3JlbmRlck5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGRlYnVnKGlucHV0LCBbXCJyZW5kZXJpbmdcIl0pO1xuXG4gICAgdmFyIHMgPSB2Ll9tb2RlbC5zY2VuZSgpO1xuICAgIGlmKGlucHV0LnRyYW5zKSB7XG4gICAgICBpbnB1dC50cmFucy5zdGFydChmdW5jdGlvbihpdGVtcykgeyB2Ll9yZW5kZXJlci5yZW5kZXIocywgaXRlbXMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdi5fcmVuZGVyZXIucmVuZGVyKHMpO1xuICAgIH1cblxuICAgIC8vIEZvciBhbGwgdXBkYXRlZCBkYXRhc291cmNlcywgZmluYWxpemUgdGhlaXIgY2hhbmdlc2V0cy5cbiAgICB2YXIgZCwgZHM7XG4gICAgZm9yKGQgaW4gaW5wdXQuZGF0YSkge1xuICAgICAgZHMgPSB2Ll9tb2RlbC5kYXRhKGQpO1xuICAgICAgaWYoIWRzLnJldmlzZXMoKSkgY29udGludWU7XG4gICAgICBjaGFuZ2VzZXQuZmluYWxpemUoZHMubGFzdCgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgcmV0dXJuICh2Ll9tb2RlbC5zY2VuZSh2Ll9yZW5kZXJOb2RlKSwgdHJ1ZSk7ICBcbn1cblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG9wdCkgeyAgICBcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgdiA9IHRoaXMsXG4gICAgICB0cmFucyA9IG9wdC5kdXJhdGlvblxuICAgICAgICA/IG5ldyBUcmFuc2l0aW9uKG9wdC5kdXJhdGlvbiwgb3B0LmVhc2UpXG4gICAgICAgIDogbnVsbDtcblxuICB2YXIgY3MgPSB2Ll9jaGFuZ2VzZXQ7XG4gIGlmKHRyYW5zKSBjcy50cmFucyA9IHRyYW5zO1xuICBpZihvcHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmKGRsLmtleXMoY3MuZGF0YSkubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgXCJOZXcgZGF0YSB2YWx1ZXMgYXJlIG5vdCByZWZsZWN0ZWQgaW4gdGhlIHZpc3VhbGl6YXRpb24uXCIgK1xuICAgICAgICBcIiBQbGVhc2UgY2FsbCB2aWV3LnVwZGF0ZSgpIGJlZm9yZSB1cGRhdGluZyBhIHNwZWNpZmllZCBwcm9wZXJ0eSBzZXQuXCJcbiAgICB9XG5cbiAgICBjcy5yZWZsb3cgID0gdHJ1ZTtcbiAgICBjcy5yZXF1ZXN0ID0gb3B0LnByb3BzO1xuICB9XG5cbiAgdi5fYnVpbGQgPSB2Ll9idWlsZCB8fCBidWlsZC5jYWxsKHRoaXMpO1xuXG4gIC8vIElmIHNwZWNpZmljIGl0ZW1zIGFyZSBzcGVjaWZpZWQsIHNob3J0LWNpcmN1aXQgZGF0YWZsb3cgZ3JhcGguXG4gIC8vIEVsc2UtSWYgdGhlcmUgYXJlIHN0cmVhbWluZyB1cGRhdGVzLCBwZXJmb3JtIGEgdGFyZ2V0ZWQgcHJvcGFnYXRpb24uXG4gIC8vIE90aGVyd2lzZSwgcmVldmFsdWF0ZSB0aGUgZW50aXJlIG1vZGVsIChkYXRhc291cmNlcyArIHNjZW5lKS5cbiAgaWYob3B0Lml0ZW1zKSB7IFxuICAgIEVuY29kZXIudXBkYXRlKHRoaXMuX21vZGVsLCBvcHQudHJhbnMsIG9wdC5wcm9wcywgb3B0Lml0ZW1zKTtcbiAgICB2Ll9yZW5kZXJOb2RlLmV2YWx1YXRlKGNzKTtcbiAgfSBlbHNlIGlmKHYuX3N0cmVhbWVyLmxpc3RlbmVycygpLmxlbmd0aCkge1xuICAgIHYuX21vZGVsLnByb3BhZ2F0ZShjcywgdi5fc3RyZWFtZXIpO1xuICAgIHYuX3N0cmVhbWVyLmRpc2Nvbm5lY3QoKTtcbiAgfSBlbHNlIHtcbiAgICB2Ll9tb2RlbC5maXJlKGNzKTtcbiAgfVxuXG4gIHYuX2NoYW5nZXNldCA9IGNoYW5nZXNldC5jcmVhdGUoKTtcblxuICByZXR1cm4gdi5hdXRvcGFkKG9wdCk7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdGhpcy5fcmVuZGVyZXIucmVuZGVyKHRoaXMuX21vZGVsLnNjZW5lKCksIGl0ZW1zKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vbi5hcHBseSh0aGlzLl9oYW5kbGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vblNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgdGhpcy5fbW9kZWwuc2lnbmFsKG5hbWUpLm9uKGhhbmRsZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vZmYuYXBwbHkodGhpcy5faGFuZGxlciwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUub2ZmU2lnbmFsID0gZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICB0aGlzLl9tb2RlbC5zaWduYWwobmFtZSkub2ZmKGhhbmRsZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblZpZXcuZmFjdG9yeSA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIHZhciBIZWFkbGVzc1ZpZXcgPSByZXF1aXJlKCcuL0hlYWRsZXNzVmlldycpO1xuICByZXR1cm4gZnVuY3Rpb24ob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHZhciBkZWZzID0gbW9kZWwuZGVmcygpO1xuICAgIHZhciB2ID0gKG9wdC5lbCA/IG5ldyBWaWV3KCkgOiBuZXcgSGVhZGxlc3NWaWV3KCkpXG4gICAgICAubW9kZWwobW9kZWwpXG4gICAgICAucmVuZGVyZXIob3B0LnJlbmRlcmVyIHx8IFwiY2FudmFzXCIpXG4gICAgICAud2lkdGgoZGVmcy53aWR0aClcbiAgICAgIC5oZWlnaHQoZGVmcy5oZWlnaHQpXG4gICAgICAucGFkZGluZyhkZWZzLnBhZGRpbmcpO1xuXG4gICAgaWYob3B0LmVsIHx8ICghb3B0LmVsICYmIHYgaW5zdGFuY2VvZiBIZWFkbGVzc1ZpZXcpKSB2LmluaXRpYWxpemUob3B0LmVsKTtcbiAgICBpZihvcHQuZGF0YSkgdi5kYXRhKG9wdC5kYXRhKTtcbiAgXG4gICAgcmV0dXJuIHY7XG4gIH07ICAgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuIiwidmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuL2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3IoZ3JhcGgpIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5fZGF0YSA9IFtdO1xuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQ29sbGVjdG9yLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImNvbGxlY3RpbmdcIl0pO1xuXG4gIGlmIChpbnB1dC5yZWZsb3cpIHtcbiAgICBpbnB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuICAgIGlucHV0Lm1vZCA9IHRoaXMuX2RhdGEuc2xpY2UoKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBpZiAoaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIHZhciBpZHMgPSBpbnB1dC5yZW0ucmVkdWNlKGZ1bmN0aW9uKG0seCkgeyByZXR1cm4gKG1beC5faWRdPTEsIG0pOyB9LCB7fSk7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGlkc1t4Ll9pZF0gIT09IDE7IH0pO1xuICB9XG5cbiAgaWYgKGlucHV0LmFkZC5sZW5ndGgpIHtcbiAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5sZW5ndGggPyB0aGlzLl9kYXRhLmNvbmNhdChpbnB1dC5hZGQpIDogaW5wdXQuYWRkO1xuICB9XG5cbiAgaWYgKGlucHV0LnNvcnQpIHtcbiAgICB0aGlzLl9kYXRhLnNvcnQoaW5wdXQuc29ydCk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3RvcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSwgXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuL3R1cGxlJyksIFxuICAgIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL0NvbGxlY3RvcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBEYXRhc291cmNlKGdyYXBoLCBuYW1lLCBmYWNldCkge1xuICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuICB0aGlzLl9mYWNldCA9IGZhY2V0O1xuICB0aGlzLl9pbnB1dCA9IGNoYW5nZXNldC5jcmVhdGUoKTtcbiAgdGhpcy5fb3V0cHV0ID0gbnVsbDsgICAgLy8gT3V0cHV0IGNoYW5nZXNldFxuXG4gIHRoaXMuX3BpcGVsaW5lICA9IG51bGw7IC8vIFBpcGVsaW5lIG9mIHRyYW5zZm9ybWF0aW9ucy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbnVsbDsgLy8gQ29sbGVjdG9yIHRvIG1hdGVyaWFsaXplIG91dHB1dCBvZiBwaXBlbGluZVxuICB0aGlzLl9yZXZpc2VzID0gZmFsc2U7IC8vIERvZXMgYW55IHBpcGVsaW5lIG9wZXJhdG9yIG5lZWQgdG8gdHJhY2sgcHJldj9cbn07XG5cbnZhciBwcm90byA9IERhdGFzb3VyY2UucHJvdG90eXBlO1xuXG5wcm90by5uYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX25hbWU7XG4gIHJldHVybiAodGhpcy5fbmFtZSA9IG5hbWUsIHRoaXMpO1xufTtcblxucHJvdG8uc291cmNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc291cmNlO1xuICByZXR1cm4gKHRoaXMuX3NvdXJjZSA9IHRoaXMuX2dyYXBoLmRhdGEoc3JjKSk7XG59O1xuXG5wcm90by5pbnNlcnQgPSBmdW5jdGlvbihkKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQ7XG5cbiAgdGhpcy5faW5wdXQuYWRkID0gdGhpcy5faW5wdXQuYWRkXG4gICAgLmNvbmNhdChkbC5hcnJheShkKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gdHVwbGUuaW5nZXN0KGQsIHByZXYpOyB9KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24od2hlcmUpIHtcbiAgdmFyIGQgPSB0aGlzLl9kYXRhLmZpbHRlcih3aGVyZSk7XG4gIHRoaXMuX2lucHV0LnJlbSA9IHRoaXMuX2lucHV0LnJlbS5jb25jYXQoZCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udXBkYXRlID0gZnVuY3Rpb24od2hlcmUsIGZpZWxkLCBmdW5jKSB7XG4gIHZhciBtb2QgPSB0aGlzLl9pbnB1dC5tb2QsXG4gICAgICBpZHMgPSB0dXBsZS5pZE1hcChtb2QpLFxuICAgICAgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkOyBcblxuICB0aGlzLl9pbnB1dC5maWVsZHNbZmllbGRdID0gMTtcbiAgdGhpcy5fZGF0YS5maWx0ZXIod2hlcmUpLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciBwcmV2ID0geFtmaWVsZF0sXG4gICAgICAgIG5leHQgPSBmdW5jKHgpO1xuICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICB0dXBsZS5zZXQoeCwgZmllbGQsIG5leHQpO1xuICAgICAgaWYoaWRzW3guX2lkXSAhPT0gMSkge1xuICAgICAgICBtb2QucHVzaCh4KTtcbiAgICAgICAgaWRzW3guX2lkXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by52YWx1ZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLl9jb2xsZWN0b3IgPyB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpIDogdGhpcy5fZGF0YTtcblxuICAvLyBSZXBsYWNlIGJhY2tpbmcgZGF0YVxuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gIGlmIChkYXRhKSB7IHRoaXMuaW5zZXJ0KGRhdGEpOyB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gc2V0X3ByZXYoZCkgeyBpZihkLl9wcmV2ID09PSB1bmRlZmluZWQpIGQuX3ByZXYgPSBDLlNFTlRJTkVMOyB9XG5cbnByb3RvLnJldmlzZXMgPSBmdW5jdGlvbihwKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmV2aXNlcztcblxuICAvLyBJZiB3ZSd2ZSBub3QgbmVlZGVkIHByZXYgaW4gdGhlIHBhc3QsIGJ1dCBhIG5ldyBkYXRhZmxvdyBub2RlIG5lZWRzIGl0IG5vd1xuICAvLyBlbnN1cmUgZXhpc3RpbmcgdHVwbGVzIGhhdmUgcHJldiBzZXQuXG4gIGlmKCF0aGlzLl9yZXZpc2VzICYmIHApIHtcbiAgICB0aGlzLl9kYXRhLmZvckVhY2goc2V0X3ByZXYpO1xuICAgIHRoaXMuX2lucHV0LmFkZC5mb3JFYWNoKHNldF9wcmV2KTsgLy8gTmV3IHR1cGxlcyB0aGF0IGhhdmVuJ3QgeWV0IGJlZW4gbWVyZ2VkIGludG8gX2RhdGFcbiAgfVxuXG4gIHRoaXMuX3JldmlzZXMgPSB0aGlzLl9yZXZpc2VzIHx8IHA7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ubGFzdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fb3V0cHV0OyB9O1xuXG5wcm90by5maXJlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYoaW5wdXQpIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZSh0aGlzLl9pbnB1dCwgdGhpcy5fcGlwZWxpbmVbMF0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24ocGlwZWxpbmUpIHtcbiAgdmFyIGRzID0gdGhpcywgbiwgYztcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9waXBlbGluZTtcblxuICBpZihwaXBlbGluZS5sZW5ndGgpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGlwZWxpbmUsIGFkZCBhIGNvbGxlY3RvciB0byB0aGUgZW5kIHRvIG1hdGVyaWFsaXplXG4gICAgLy8gdGhlIG91dHB1dC5cbiAgICBkcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3Rvcih0aGlzLl9ncmFwaCk7XG4gICAgcGlwZWxpbmUucHVzaChkcy5fY29sbGVjdG9yKTtcbiAgICBkcy5fcmV2aXNlcyA9IHBpcGVsaW5lLnNvbWUoZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5yZXZpc2VzKCk7IH0pO1xuICB9XG5cbiAgLy8gSW5wdXQgbm9kZSBhcHBsaWVzIHRoZSBkYXRhc291cmNlJ3MgZGVsdGEsIGFuZCBwcm9wYWdhdGVzIGl0IHRvIFxuICAvLyB0aGUgcmVzdCBvZiB0aGUgcGlwZWxpbmUuIEl0IHJlY2VpdmVzIHRvdWNoZXMgdG8gcmVmbG93IGRhdGEuXG4gIHZhciBpbnB1dCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIGlucHV0LmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZWJ1ZyhpbnB1dCwgW1wiaW5wdXRcIiwgZHMuX25hbWVdKTtcblxuICAgIHZhciBkZWx0YSA9IGRzLl9pbnB1dCwgXG4gICAgICAgIG91dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgICByZW07XG5cbiAgICAvLyBEZWx0YSBtaWdodCBjb250YWluIGZpZWxkcyB1cGRhdGVkIHRocm91Z2ggQVBJXG4gICAgZGwua2V5cyhkZWx0YS5maWVsZHMpLmZvckVhY2goZnVuY3Rpb24oZikgeyBvdXQuZmllbGRzW2ZdID0gMSB9KTtcblxuICAgIGlmKGlucHV0LnJlZmxvdykge1xuICAgICAgb3V0Lm1vZCA9IGRzLl9kYXRhLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSBkYXRhXG4gICAgICBpZihkZWx0YS5yZW0ubGVuZ3RoKSB7XG4gICAgICAgIHJlbSA9IHR1cGxlLmlkTWFwKGRlbHRhLnJlbSk7XG4gICAgICAgIGRzLl9kYXRhID0gZHMuX2RhdGFcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbVt4Ll9pZF0gIT09IDEgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGRlbHRhLmFkZC5sZW5ndGgpIGRzLl9kYXRhID0gZHMuX2RhdGEuY29uY2F0KGRlbHRhLmFkZCk7XG5cbiAgICAgIC8vIHJlc2V0IGNoYW5nZSBsaXN0XG4gICAgICBkcy5faW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG5cbiAgICAgIG91dC5hZGQgPSBkZWx0YS5hZGQ7IFxuICAgICAgb3V0Lm1vZCA9IGRlbHRhLm1vZDtcbiAgICAgIG91dC5yZW0gPSBkZWx0YS5yZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIChvdXQuZmFjZXQgPSBkcy5fZmFjZXQsIG91dCk7XG4gIH07XG5cbiAgcGlwZWxpbmUudW5zaGlmdChpbnB1dCk7XG5cbiAgLy8gT3V0cHV0IG5vZGUgY2FwdHVyZXMgdGhlIGxhc3QgY2hhbmdlc2V0IHNlZW4gYnkgdGhpcyBkYXRhc291cmNlXG4gIC8vIChuZWVkZWQgZm9yIGpvaW5zIGFuZCBidWlsZHMpIGFuZCBtYXRlcmlhbGl6ZXMgYW55IG5lc3RlZCBkYXRhLlxuICAvLyBJZiB0aGlzIGRhdGFzb3VyY2UgaXMgZmFjZXRlZCwgbWF0ZXJpYWxpemVzIHRoZSB2YWx1ZXMgaW4gdGhlIGZhY2V0LlxuICB2YXIgb3V0cHV0ID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKVxuICAgIC5jb2xsZWN0b3IodHJ1ZSk7XG5cbiAgb3V0cHV0LmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZWJ1ZyhpbnB1dCwgW1wib3V0cHV0XCIsIGRzLl9uYW1lXSk7XG4gICAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xuXG4gICAgaWYoZHMuX2ZhY2V0KSB7XG4gICAgICBkcy5fZmFjZXQudmFsdWVzID0gZHMudmFsdWVzKCk7XG4gICAgICBpbnB1dC5mYWNldCA9IG51bGw7XG4gICAgfVxuXG4gICAgZHMuX291dHB1dCA9IGlucHV0O1xuICAgIG91dHB1dC5kYXRhW2RzLl9uYW1lXSA9IDE7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICBwaXBlbGluZS5wdXNoKG91dHB1dCk7XG5cbiAgdGhpcy5fcGlwZWxpbmUgPSBwaXBlbGluZTtcbiAgdGhpcy5fZ3JhcGguY29ubmVjdChkcy5fcGlwZWxpbmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7IFxuICB2YXIgbCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKS5yb3V0ZXIodHJ1ZSksXG4gICAgICBkZXN0ID0gdGhpcyxcbiAgICAgIHByZXYgPSB0aGlzLl9yZXZpc2VzID8gbnVsbCA6IHVuZGVmaW5lZDtcblxuICBsLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZXN0Ll9zcmNNYXAgPSBkZXN0Ll9zcmNNYXAgfHwge307ICAvLyB0byBwcm9wYWdhdGUgdHVwbGVzIGNvcnJlY3RseVxuICAgIHZhciBtYXAgPSBkZXN0Ll9zcmNNYXAsXG4gICAgICAgIG91dHB1dCAgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICAgIG91dHB1dC5hZGQgPSBpbnB1dC5hZGQubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAobWFwW3QuX2lkXSA9IHR1cGxlLmRlcml2ZSh0LCB0Ll9wcmV2ICE9PSB1bmRlZmluZWQgPyB0Ll9wcmV2IDogcHJldikpO1xuICAgIH0pO1xuICAgIG91dHB1dC5tb2QgPSBpbnB1dC5tb2QubWFwKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIG1hcFt0Ll9pZF07IH0pO1xuICAgIG91dHB1dC5yZW0gPSBpbnB1dC5yZW0ubWFwKGZ1bmN0aW9uKHQpIHsgXG4gICAgICB2YXIgbyA9IG1hcFt0Ll9pZF07XG4gICAgICBtYXBbdC5faWRdID0gbnVsbDtcbiAgICAgIHJldHVybiBvO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIChkZXN0Ll9pbnB1dCA9IG91dHB1dCk7XG4gIH07XG5cbiAgbC5hZGRMaXN0ZW5lcih0aGlzLl9waXBlbGluZVswXSk7XG4gIHJldHVybiBsO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIGlmKGwgaW5zdGFuY2VvZiBEYXRhc291cmNlKSB7XG4gICAgaWYodGhpcy5fY29sbGVjdG9yKSB0aGlzLl9jb2xsZWN0b3IuYWRkTGlzdGVuZXIobC5saXN0ZW5lcigpKTtcbiAgICBlbHNlIHRoaXMuX3BpcGVsaW5lWzBdLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcGlwZWxpbmVbdGhpcy5fcGlwZWxpbmUubGVuZ3RoLTFdLmFkZExpc3RlbmVyKGwpOyAgICAgIFxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgdGhpcy5fcGlwZWxpbmVbdGhpcy5fcGlwZWxpbmUubGVuZ3RoLTFdLnJlbW92ZUxpc3RlbmVyKGwpO1xufTtcblxucHJvdG8ubGlzdGVuZXJzID0gZnVuY3Rpb24oZHMpIHtcbiAgcmV0dXJuIGRzIFxuICAgID8gdGhpcy5fY29sbGVjdG9yID8gdGhpcy5fY29sbGVjdG9yLmxpc3RlbmVycygpIDogdGhpcy5fcGlwZWxpbmVbMF0ubGlzdGVuZXJzKClcbiAgICA6IHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5saXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YXNvdXJjZTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgSGVhcCA9IHJlcXVpcmUoJ2hlYXAnKSxcbiAgICBEYXRhc291cmNlID0gcmVxdWlyZSgnLi9EYXRhc291cmNlJyksXG4gICAgU2lnbmFsID0gcmVxdWlyZSgnLi9TaWduYWwnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuL2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBHcmFwaCgpIHtcbn1cblxudmFyIHByb3RvID0gR3JhcGgucHJvdG90eXBlO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N0YW1wID0gMDtcbiAgdGhpcy5fcmFuayAgPSAwO1xuXG4gIHRoaXMuX2RhdGEgPSB7fTtcbiAgdGhpcy5fc2lnbmFscyA9IHt9O1xuXG4gIHRoaXMuZG9Ob3RQcm9wYWdhdGUgPSB7fTtcbn07XG5cbnByb3RvLmRhdGEgPSBmdW5jdGlvbihuYW1lLCBwaXBlbGluZSwgZmFjZXQpIHtcbiAgdmFyIGRiID0gdGhpcy5fZGF0YTtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBkbC5rZXlzKGRiKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZGJbZF07IH0pO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gZGJbbmFtZV07XG4gIHJldHVybiAoZGJbbmFtZV0gPSBuZXcgRGF0YXNvdXJjZSh0aGlzLCBuYW1lLCBmYWNldCkucGlwZWxpbmUocGlwZWxpbmUpKTtcbn07XG5cbnByb3RvLmRhdGFWYWx1ZXMgPSBmdW5jdGlvbihuYW1lcykge1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIG5hbWVzID0gZGwua2V5cyh0aGlzLl9kYXRhKTtcbiAgaWYgKCFkbC5pc0FycmF5KG5hbWVzKSkgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZXNdLnZhbHVlcygpO1xuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGRiLCBuKSB7XG4gICAgcmV0dXJuIChkYltuXSA9IGdyYXBoLl9kYXRhW25dLnZhbHVlcygpLCBkYik7XG4gIH0sIHt9KTtcbn07XG5cbmZ1bmN0aW9uIHNpZ25hbChuYW1lKSB7XG4gIHZhciBtID0gdGhpcywgaSwgbGVuO1xuICBpZighZGwuaXNBcnJheShuYW1lKSkgcmV0dXJuIHRoaXMuX3NpZ25hbHNbbmFtZV07XG4gIHJldHVybiBuYW1lLm1hcChmdW5jdGlvbihuKSB7IG0uX3NpZ25hbHNbbl07IH0pO1xufVxuXG5wcm90by5zaWduYWwgPSBmdW5jdGlvbihuYW1lLCBpbml0KSB7XG4gIHZhciBtID0gdGhpcztcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHNpZ25hbC5jYWxsKHRoaXMsIG5hbWUpO1xuICByZXR1cm4gKHRoaXMuX3NpZ25hbHNbbmFtZV0gPSBuZXcgU2lnbmFsKHRoaXMsIG5hbWUsIGluaXQpKTtcbn07XG5cbnByb3RvLnNpZ25hbFZhbHVlcyA9IGZ1bmN0aW9uKG5hbWVzKSB7XG4gIHZhciBncmFwaCA9IHRoaXM7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSBuYW1lcyA9IGRsLmtleXModGhpcy5fc2lnbmFscyk7XG4gIGlmKCFkbC5pc0FycmF5KG5hbWVzKSkgcmV0dXJuIHRoaXMuX3NpZ25hbHNbbmFtZXNdLnZhbHVlKCk7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oc2csIG4pIHtcbiAgICByZXR1cm4gKHNnW25dID0gZ3JhcGguX3NpZ25hbHNbbl0udmFsdWUoKSwgc2cpO1xuICB9LCB7fSk7XG59O1xuXG5wcm90by5zaWduYWxSZWYgPSBmdW5jdGlvbihyZWYpIHtcbiAgaWYoIWRsLmlzQXJyYXkocmVmKSkgcmVmID0gZGwuZmllbGQocmVmKTtcbiAgdmFyIHZhbHVlID0gdGhpcy5zaWduYWwocmVmLnNoaWZ0KCkpLnZhbHVlKCk7XG4gIGlmKHJlZi5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGZuID0gRnVuY3Rpb24oXCJzXCIsIFwicmV0dXJuIHNbXCIrcmVmLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIik7XG4gICAgdmFsdWUgPSBmbi5jYWxsKG51bGwsIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBzY2hlZHVsZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgLy8gSWYgdGhlIG5vZGVzIGFyZSBlcXVhbCwgcHJvcGFnYXRlIHRoZSBub24tcmVmbG93IHB1bHNlIGZpcnN0LFxuICAvLyBzbyB0aGF0IHdlIGNhbiBpZ25vcmUgc3Vic2VxdWVudCByZWZsb3cgcHVsc2VzLiBcbiAgaWYoYS5yYW5rID09IGIucmFuaykgcmV0dXJuIGEucHVsc2UucmVmbG93ID8gMSA6IC0xO1xuICBlbHNlIHJldHVybiBhLnJhbmsgLSBiLnJhbms7IFxufTtcblxucHJvdG8ucHJvcGFnYXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgdmFyIHYsIGwsIG4sIHAsIHIsIGksIGxlbiwgcmVmbG93ZWQ7XG5cbiAgLy8gbmV3IFBRIHdpdGggZWFjaCBwcm9wYWdhdGlvbiBjeWNsZSBzbyB0aGF0IHdlIGNhbiBwdWxzZSBicmFuY2hlc1xuICAvLyBvZiB0aGUgZGF0YWZsb3cgZ3JhcGggZHVyaW5nIGEgcHJvcGFnYXRpb24gKGUuZy4sIHdoZW4gY3JlYXRpbmdcbiAgLy8gYSBuZXcgaW5saW5lIGRhdGFzb3VyY2UpLlxuICB2YXIgcHEgPSBuZXcgSGVhcChzY2hlZHVsZSk7IFxuXG4gIGlmKHB1bHNlLnN0YW1wKSB0aHJvdyBcIlB1bHNlIGFscmVhZHkgaGFzIGEgbm9uLXplcm8gc3RhbXBcIlxuXG4gIHB1bHNlLnN0YW1wID0gKyt0aGlzLl9zdGFtcDtcbiAgcHEucHVzaCh7IG5vZGU6IG5vZGUsIHB1bHNlOiBwdWxzZSwgcmFuazogbm9kZS5yYW5rKCkgfSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucG9wKCksIG4gPSB2Lm5vZGUsIHAgPSB2LnB1bHNlLCByID0gdi5yYW5rLCBsID0gbi5fbGlzdGVuZXJzO1xuICAgIHJlZmxvd2VkID0gcC5yZWZsb3cgJiYgbi5sYXN0KCkgPj0gcC5zdGFtcDtcblxuICAgIGlmKHJlZmxvd2VkKSBjb250aW51ZTsgLy8gRG9uJ3QgbmVlZGxlc3NseSByZWZsb3cgb3BzLlxuXG4gICAgLy8gQSBub2RlJ3MgcmFuayBtaWdodCBjaGFuZ2UgZHVyaW5nIGEgcHJvcGFnYXRpb24gKGUuZy4gaW5zdGFudGlhdGluZ1xuICAgIC8vIGEgZ3JvdXAncyBkYXRhZmxvdyBicmFuY2gpLiBSZS1xdWV1ZSBpZiBpdCBoYXMuIFRcbiAgICAvLyBUT0RPOiB1c2UgcHEucmVwbGFjZSBvciBwcS5wb3BwdXNoP1xuICAgIGlmKHIgIT0gbi5yYW5rKCkpIHtcbiAgICAgIGRlYnVnKHAsIFsnUmFuayBtaXNtYXRjaCcsIHIsIG4ucmFuaygpXSk7XG4gICAgICBwcS5wdXNoKHsgbm9kZTogbiwgcHVsc2U6IHAsIHJhbms6IG4ucmFuaygpIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcCA9IHRoaXMuZXZhbHVhdGUocCwgbik7XG5cbiAgICAvLyBFdmVuIGlmIHdlIGRpZG4ndCBydW4gdGhlIG5vZGUsIHdlIHN0aWxsIHdhbnQgdG8gcHJvcGFnYXRlIFxuICAgIC8vIHRoZSBwdWxzZS4gXG4gICAgaWYgKHAgIT09IHRoaXMuZG9Ob3RQcm9wYWdhdGUpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcHEucHVzaCh7IG5vZGU6IGxbaV0sIHB1bHNlOiBwLCByYW5rOiBsW2ldLl9yYW5rIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gQ29ubmVjdCBhIGJyYW5jaCBvZiBkYXRhZmxvdyBub2Rlcy4gXG4vLyBEZXBlbmRlbmNpZXMgZ2V0IHdpcmVkIHRvIHRoZSBuZWFyZXN0IGNvbGxlY3Rvci4gXG5mdW5jdGlvbiBmb3JFYWNoTm9kZShicmFuY2gsIGZuKSB7XG4gIHZhciBub2RlLCBjb2xsZWN0b3IsIGksIGxlbjtcbiAgZm9yKGk9MCwgbGVuPWJyYW5jaC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBub2RlID0gYnJhbmNoW2ldO1xuICAgIGlmKG5vZGUuY29sbGVjdG9yKCkpIGNvbGxlY3RvciA9IG5vZGU7XG4gICAgZm4obm9kZSwgY29sbGVjdG9yLCBpKTtcbiAgfVxufVxuXG5wcm90by5jb25uZWN0ID0gZnVuY3Rpb24oYnJhbmNoKSB7XG4gIGRlYnVnKHt9LCBbJ2Nvbm5lY3RpbmcnXSk7XG4gIHZhciBncmFwaCA9IHRoaXM7XG4gIGZvckVhY2hOb2RlKGJyYW5jaCwgZnVuY3Rpb24obiwgYywgaSkge1xuICAgIHZhciBkYXRhID0gbi5kZXBlbmRlbmN5KEMuREFUQSksXG4gICAgICAgIHNpZ25hbHMgPSBuLmRlcGVuZGVuY3koQy5TSUdOQUxTKTtcblxuICAgIGlmKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgXG4gICAgICAgIGdyYXBoLmRhdGEoZClcbiAgICAgICAgICAucmV2aXNlcyhuLnJldmlzZXMoKSlcbiAgICAgICAgICAuYWRkTGlzdGVuZXIoYyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZihzaWduYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7IGdyYXBoLnNpZ25hbChzKS5hZGRMaXN0ZW5lcihjKTsgfSk7XG4gICAgfVxuXG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGJyYW5jaFtpLTFdLmFkZExpc3RlbmVyKGJyYW5jaFtpXSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gYnJhbmNoO1xufTtcblxucHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGJyYW5jaCkge1xuICBkZWJ1Zyh7fSwgWydkaXNjb25uZWN0aW5nJ10pO1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuXG4gIGZvckVhY2hOb2RlKGJyYW5jaCwgZnVuY3Rpb24obiwgYywgaSkge1xuICAgIHZhciBkYXRhID0gbi5kZXBlbmRlbmN5KEMuREFUQSksXG4gICAgICAgIHNpZ25hbHMgPSBuLmRlcGVuZGVuY3koQy5TSUdOQUxTKTtcblxuICAgIGlmKGRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZ3JhcGguZGF0YShkKS5yZW1vdmVMaXN0ZW5lcihjKTsgfSk7XG4gICAgfVxuXG4gICAgaWYoc2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBncmFwaC5zaWduYWwocykucmVtb3ZlTGlzdGVuZXIoYykgfSk7XG4gICAgfVxuXG4gICAgbi5kaXNjb25uZWN0KCk7ICBcbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvLnJlZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICB2YXIgcmVmbG93ZWQgPSAhcHVsc2UucmVmbG93IHx8IChwdWxzZS5yZWZsb3cgJiYgbm9kZS5sYXN0KCkgPj0gcHVsc2Uuc3RhbXApLFxuICAgICAgcnVuID0gISFwdWxzZS5hZGQubGVuZ3RoIHx8ICEhcHVsc2UucmVtLmxlbmd0aCB8fCBub2RlLnJvdXRlcigpO1xuICBydW4gPSBydW4gfHwgIXJlZmxvd2VkO1xuICByZXR1cm4gcnVuIHx8IG5vZGUucmVldmFsdWF0ZShwdWxzZSk7XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIGlmKCF0aGlzLnJlZXZhbHVhdGUocHVsc2UsIG5vZGUpKSByZXR1cm4gcHVsc2U7XG4gIHB1bHNlID0gbm9kZS5ldmFsdWF0ZShwdWxzZSk7XG4gIG5vZGUubGFzdChwdWxzZS5zdGFtcCk7XG4gIHJldHVybiBwdWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcmFwaDsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyksXG4gICAgUkVFVkFMID0gW0MuREFUQSwgQy5GSUVMRFMsIEMuU0NBTEVTLCBDLlNJR05BTFNdO1xuXG52YXIgbm9kZV9pZCA9IDE7XG5cbmZ1bmN0aW9uIE5vZGUoZ3JhcGgpIHtcbiAgaWYoZ3JhcGgpIHRoaXMuaW5pdChncmFwaCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSBOb2RlLnByb3RvdHlwZTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKGdyYXBoKSB7XG4gIHRoaXMuX2lkID0gbm9kZV9pZCsrO1xuICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB0aGlzLl9yYW5rID0gKytncmFwaC5fcmFuazsgLy8gRm9yIHRvcG9sb2dpYWwgc29ydFxuICB0aGlzLl9zdGFtcCA9IDA7ICAvLyBMYXN0IHN0YW1wIHNlZW5cblxuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5fcmVnaXN0ZXJlZCA9IHt9OyAvLyBUbyBwcmV2ZW50IGR1cGxpY2F0ZSBsaXN0ZW5lcnNcblxuICB0aGlzLl9kZXBzID0ge1xuICAgIGRhdGE6ICAgIFtdLFxuICAgIGZpZWxkczogIFtdLFxuICAgIHNjYWxlczogIFtdLFxuICAgIHNpZ25hbHM6IFtdLFxuICB9O1xuXG4gIHRoaXMuX2lzUm91dGVyID0gZmFsc2U7IC8vIFJlc3BvbnNpYmxlIGZvciBwcm9wYWdhdGluZyB0dXBsZXMsIGNhbm5vdCBldmVyIGJlIHNraXBwZWRcbiAgdGhpcy5faXNDb2xsZWN0b3IgPSBmYWxzZTsgIC8vIEhvbGRzIGEgbWF0ZXJpYWxpemVkIGRhdGFzZXQsIHB1bHNlIHRvIHJlZmxvd1xuICB0aGlzLl9yZXZpc2VzID0gZmFsc2U7IC8vIERvZXMgdGhlIG9wZXJhdG9yIHJlcXVpcmUgdHVwbGVzJyBwcmV2aW91cyB2YWx1ZXM/IFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpO1xuICBuLmV2YWx1YXRlID0gdGhpcy5ldmFsdWF0ZTtcbiAgbi5fZGVwcyA9IHRoaXMuX2RlcHM7XG4gIG4uX2lzUm91dGVyID0gdGhpcy5faXNSb3V0ZXI7XG4gIG4uX2lzQ29sbGVjdG9yID0gdGhpcy5faXNDb2xsZWN0b3I7XG4gIHJldHVybiBuO1xufTtcblxucHJvdG8ucmFuayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fcmFuazsgfTtcblxucHJvdG8ubGFzdCA9IGZ1bmN0aW9uKHN0YW1wKSB7IFxuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3N0YW1wO1xuICB0aGlzLl9zdGFtcCA9IHN0YW1wO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmRlcGVuZGVuY3kgPSBmdW5jdGlvbih0eXBlLCBkZXBzKSB7XG4gIHZhciBkID0gdGhpcy5fZGVwc1t0eXBlXTtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGQ7XG4gIGlmKGRlcHMgPT09IG51bGwpIHsgLy8gQ2xlYXIgZGVwZW5kZW5jaWVzIG9mIGEgY2VydGFpbiB0eXBlXG4gICAgd2hpbGUoZC5sZW5ndGggPiAwKSBkLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIGlmKCFkbC5pc0FycmF5KGRlcHMpICYmIGQuaW5kZXhPZihkZXBzKSA8IDApIGQucHVzaChkZXBzKTtcbiAgICBlbHNlIGQucHVzaC5hcHBseShkLCBkbC5hcnJheShkZXBzKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yb3V0ZXIgPSBmdW5jdGlvbihib29sKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5faXNSb3V0ZXI7XG4gIHRoaXMuX2lzUm91dGVyID0gISFib29sXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uY29sbGVjdG9yID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2lzQ29sbGVjdG9yO1xuICB0aGlzLl9pc0NvbGxlY3RvciA9ICEhYm9vbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZXZpc2VzID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JldmlzZXM7XG4gIHRoaXMuX3JldmlzZXMgPSAhIWJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ubGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9saXN0ZW5lcnM7XG59O1xuXG5wcm90by5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgaWYoIShsIGluc3RhbmNlb2YgTm9kZSkpIHRocm93IFwiTGlzdGVuZXIgaXMgbm90IGEgTm9kZVwiO1xuICBpZih0aGlzLl9yZWdpc3RlcmVkW2wuX2lkXSkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5fbGlzdGVuZXJzLnB1c2gobCk7XG4gIHRoaXMuX3JlZ2lzdGVyZWRbbC5faWRdID0gMTtcbiAgaWYodGhpcy5fcmFuayA+IGwuX3JhbmspIHtcbiAgICB2YXIgcSA9IFtsXTtcbiAgICB3aGlsZShxLmxlbmd0aCkge1xuICAgICAgdmFyIGN1ciA9IHEuc3BsaWNlKDAsMSlbMF07XG4gICAgICBjdXIuX3JhbmsgPSArK3RoaXMuX2dyYXBoLl9yYW5rO1xuICAgICAgcS5wdXNoLmFwcGx5KHEsIGN1ci5fbGlzdGVuZXJzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGwpIHtcbiAgdmFyIGZvdW5kU2VuZGluZyA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbiAmJiAhZm91bmRTZW5kaW5nOyBpKyspIHtcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzW2ldID09PSBsKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZFtsLl9pZF0gPSBudWxsO1xuICAgICAgZm91bmRTZW5kaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiBmb3VuZFNlbmRpbmc7XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICB0aGlzLl9yZWdpc3RlcmVkID0ge307XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7IHJldHVybiBwdWxzZTsgfVxuXG5wcm90by5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCByZWV2YWwgPSBmYWxzZTtcbiAgcmV0dXJuIFJFRVZBTC5zb21lKGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZWV2YWwgPSByZWV2YWwgfHwgbm9kZS5fZGVwc1twcm9wXS5zb21lKGZ1bmN0aW9uKGspIHsgcmV0dXJuICEhcHVsc2VbcHJvcF1ba10gfSk7XG4gICAgcmV0dXJuIHJlZXZhbDtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5vZGU7IiwidmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuL2NoYW5nZXNldCcpO1xuXG5mdW5jdGlvbiBTaWduYWwoZ3JhcGgsIG5hbWUsIGluaXQpIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5fbmFtZSAgPSBuYW1lO1xuICB0aGlzLl92YWx1ZSA9IGluaXQ7XG4gIHRoaXMuX2hhbmRsZXJzID0gW107XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIHByb3RvID0gKFNpZ25hbC5wcm90b3R5cGUgPSBuZXcgTm9kZSgpKTtcblxucHJvdG8ubmFtZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fbmFtZTsgfTtcblxucHJvdG8udmFsdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmKCFjcykgY3MgPSBjaGFuZ2VzZXQuY3JlYXRlKG51bGwsIHRydWUpO1xuICBjcy5zaWduYWxzW3RoaXMuX25hbWVdID0gMTtcbiAgdGhpcy5fZ3JhcGgucHJvcGFnYXRlKGNzLCB0aGlzKTtcbn07XG5cbnByb3RvLm9uID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICB2YXIgc2cgPSB0aGlzLFxuICAgICAgbm9kZSA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKTtcblxuICBub2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gKGhhbmRsZXIoc2cubmFtZSgpLCBzZy52YWx1ZSgpKSwgaW5wdXQpO1xuICB9O1xuXG4gIHRoaXMuX2hhbmRsZXJzLnB1c2goeyBoYW5kbGVyOiBoYW5kbGVyLCBub2RlOiBub2RlIH0pO1xuICByZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihub2RlKTtcbn07XG5cbnByb3RvLm9mZiA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIHNnID0gdGhpcywgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICBmb3IodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZighaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIHNnLnJlbW92ZUxpc3RlbmVyKGguc3BsaWNlKGksIDEpWzBdLm5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2lnbmFsOyIsInZhciBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcbnZhciBSRUVWQUwgPSBbQy5EQVRBLCBDLkZJRUxEUywgQy5TQ0FMRVMsIEMuU0lHTkFMU107XG5cbmZ1bmN0aW9uIGNyZWF0ZShjcywgcmVmbG93KSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgY29weShjcywgb3V0KTtcblxuICBvdXQuYWRkID0gW107XG4gIG91dC5tb2QgPSBbXTtcbiAgb3V0LnJlbSA9IFtdO1xuXG4gIG91dC5yZWZsb3cgPSByZWZsb3c7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcmVzZXRfcHJldih4KSB7XG4gIHguX3ByZXYgPSAoeC5fcHJldiA9PT0gdW5kZWZpbmVkKSA/IHVuZGVmaW5lZCA6IEMuU0VOVElORUw7XG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplKGNzKSB7XG4gIGZvcihpPTAsIGxlbj1jcy5hZGQubGVuZ3RoOyBpPGxlbjsgKytpKSByZXNldF9wcmV2KGNzLmFkZFtpXSk7XG4gIGZvcihpPTAsIGxlbj1jcy5tb2QubGVuZ3RoOyBpPGxlbjsgKytpKSByZXNldF9wcmV2KGNzLm1vZFtpXSk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoYSwgYikge1xuICBiLnN0YW1wID0gYSA/IGEuc3RhbXAgOiAwO1xuICBiLnNvcnQgID0gYSA/IGEuc29ydCAgOiBudWxsO1xuICBiLmZhY2V0ID0gYSA/IGEuZmFjZXQgOiBudWxsO1xuICBiLnRyYW5zID0gYSA/IGEudHJhbnMgOiBudWxsO1xuICBiLnJlcXVlc3QgPSBhID8gYS5yZXF1ZXN0IDogbnVsbDtcbiAgUkVFVkFMLmZvckVhY2goZnVuY3Rpb24oZCkgeyBiW2RdID0gYSA/IGFbZF0gOiB7fTsgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY29weTogY29weSxcbiAgZmluYWxpemU6IGZpbmFsaXplLFxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyksXG4gICAgdHVwbGVfaWQgPSAxO1xuXG4vLyBPYmplY3QuY3JlYXRlIGlzIGV4cGVuc2l2ZS4gU28sIHdoZW4gaW5nZXN0aW5nLCB0cnVzdCB0aGF0IHRoZVxuLy8gZGF0dW0gaXMgYW4gb2JqZWN0IHRoYXQgaGFzIGJlZW4gYXBwcm9wcmlhdGVseSBzYW5kYm94ZWQgZnJvbSBcbi8vIHRoZSBvdXRzaWRlIGVudmlyb25tZW50LiBcbmZ1bmN0aW9uIGluZ2VzdChkYXR1bSwgcHJldikge1xuICBkYXR1bSA9IGRsLmlzT2JqZWN0KGRhdHVtKSA/IGRhdHVtIDoge2RhdGE6IGRhdHVtfTtcbiAgZGF0dW0uX2lkID0gdHVwbGVfaWQrKztcbiAgZGF0dW0uX3ByZXYgPSAocHJldiAhPT0gdW5kZWZpbmVkKSA/IChwcmV2IHx8IEMuU0VOVElORUwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZGF0dW07XG59XG5cbmZ1bmN0aW9uIGRlcml2ZShkYXR1bSwgcHJldikge1xuICByZXR1cm4gaW5nZXN0KE9iamVjdC5jcmVhdGUoZGF0dW0pLCBwcmV2KTtcbn1cblxuLy8gV0FSTklORzogb3BlcmF0b3JzIHNob3VsZCBvbmx5IGNhbGwgdGhpcyBvbmNlIHBlciB0aW1lc3RhbXAhXG5mdW5jdGlvbiBzZXQodCwgaywgdikge1xuICB2YXIgcHJldiA9IHRba107XG4gIGlmKHByZXYgPT09IHYpIHJldHVybjtcbiAgc2V0X3ByZXYodCwgayk7XG4gIHRba10gPSB2O1xufVxuXG5mdW5jdGlvbiBzZXRfcHJldih0LCBrKSB7XG4gIGlmKHQuX3ByZXYgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICB0Ll9wcmV2ID0gKHQuX3ByZXYgPT09IEMuU0VOVElORUwpID8ge30gOiB0Ll9wcmV2O1xuICB0Ll9wcmV2W2tdID0gdFtrXTtcbn1cblxuZnVuY3Rpb24gaGFzX3ByZXYodCkge1xuICByZXR1cm4gdC5fcHJldiAmJiB0Ll9wcmV2ICE9PSBDLlNFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHsgdHVwbGVfaWQgPSAxOyB9XG5cbmZ1bmN0aW9uIGlkTWFwKGEpIHtcbiAgcmV0dXJuIGEucmVkdWNlKGZ1bmN0aW9uKG0seCkge1xuICAgIHJldHVybiAobVt4Ll9pZF0gPSAxLCBtKTtcbiAgfSwge30pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluZ2VzdDogaW5nZXN0LFxuICBkZXJpdmU6IGRlcml2ZSxcbiAgc2V0OiAgICBzZXQsXG4gIHNldF9wcmV2OiBzZXRfcHJldixcbiAgaGFzX3ByZXY6IGhhc19wcmV2LFxuICByZXNldDogIHJlc2V0LFxuICBpZE1hcDogIGlkTWFwXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgY29uc3RhbnRzID0gb3B0LmNvbnN0YW50cyB8fCByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuICB2YXIgZnVuY3Rpb25zID0gKG9wdC5mdW5jdGlvbnMgfHwgcmVxdWlyZSgnLi9mdW5jdGlvbnMnKSkoY29kZWdlbik7XG4gIHZhciBpZFdoaXRlTGlzdCA9IG9wdC5pZFdoaXRlTGlzdCA/IGRsLnRvTWFwKG9wdC5pZFdoaXRlTGlzdCkgOiBudWxsO1xuICB2YXIgaWRCbGFja0xpc3QgPSBvcHQuaWRCbGFja0xpc3QgPyBkbC50b01hcChvcHQuaWRCbGFja0xpc3QpIDogbnVsbDtcbiAgdmFyIG1lbWJlckRlcHRoID0gMDtcblxuICAvLyBUT0RPIGdlbmVyYWxpemU/XG4gIHZhciBEQVRVTSA9ICdkJztcbiAgdmFyIFNJR05BTF9QUkVGSVggPSAnc2cuJztcbiAgdmFyIHNpZ25hbHMgPSB7fTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNvZGVnZW5fd3JhcChhc3QpIHsgICAgXG4gICAgdmFyIHJldHZhbCA9IHtcbiAgICAgIGZuOiBjb2RlZ2VuKGFzdCksXG4gICAgICBzaWduYWxzOiBkbC5rZXlzKHNpZ25hbHMpLFxuICAgICAgZmllbGRzOiBkbC5rZXlzKGZpZWxkcylcbiAgICB9O1xuICAgIHNpZ25hbHMgPSB7fTtcbiAgICBmaWVsZHMgPSB7fTtcbiAgICByZXR1cm4gcmV0dmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gY29kZWdlbihhc3QpIHtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gYXN0O1xuICAgIHZhciBnZW5lcmF0b3IgPSBDT0RFR0VOX1RZUEVTW2FzdC50eXBlXTtcbiAgICBpZiAoZ2VuZXJhdG9yID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGU6IFwiICsgYXN0LnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdG9yKGFzdCk7XG4gIH1cblxuICB2YXIgQ09ERUdFTl9UWVBFUyA9IHtcbiAgICBcIkxpdGVyYWxcIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi5yYXc7XG4gICAgICB9LFxuICAgIFwiSWRlbnRpZmllclwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBpZCA9IG4ubmFtZTtcbiAgICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHJldHVybiBjb25zdGFudHNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZFdoaXRlTGlzdCkge1xuICAgICAgICAgIGlmIChpZFdoaXRlTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsc1tpZF0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIFNJR05BTF9QUkVGSVggKyBpZDsgLy8gSEFDS2lzaC4uLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRCbGFja0xpc3QgJiYgaWRCbGFja0xpc3QuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBpZGVudGlmaWVyOiBcIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9LFxuICAgIFwiUHJvZ3JhbVwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLmJvZHkubWFwKGNvZGVnZW4pLmpvaW4oXCJcXG5cIik7XG4gICAgICB9LFxuICAgIFwiTWVtYmVyRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBkID0gIW4uY29tcHV0ZWQ7XG4gICAgICAgIHZhciBvID0gY29kZWdlbihuLm9iamVjdCk7XG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgICB2YXIgcCA9IGNvZGVnZW4obi5wcm9wZXJ0eSk7XG4gICAgICAgIGlmIChvID09PSBEQVRVTSkgeyBmaWVsZHNbcF0gPSAxOyB9IC8vIEhBQ0tpc2guLi5cbiAgICAgICAgaWYgKGQpIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBvICsgKGQgPyBcIi5cIitwIDogXCJbXCIrcCtcIl1cIik7XG4gICAgICB9LFxuICAgIFwiQ2FsbEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICBpZiAobi5jYWxsZWUudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNhbGxlZSB0eXBlOiBcIiArIG4uY2FsbGVlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsZWUgPSBuLmNhbGxlZS5uYW1lO1xuICAgICAgICB2YXIgYXJncyA9IG4uYXJndW1lbnRzO1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoY2FsbGVlKSAmJiBmdW5jdGlvbnNbY2FsbGVlXTtcbiAgICAgICAgaWYgKCFmbikgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGZ1bmN0aW9uOiBcIiArIGNhbGxlZSk7XG4gICAgICAgIHJldHVybiBmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgPyBmbihhcmdzKVxuICAgICAgICAgIDogZm4gKyBcIihcIiArIGFyZ3MubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiQXJyYXlFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgbi5lbGVtZW50cy5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgIH0sXG4gICAgXCJCaW5hcnlFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgY29kZWdlbihuLmxlZnQpICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5yaWdodCkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJVbmFyeUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLmFyZ3VtZW50KSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIlVwZGF0ZUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyAocHJlZml4XG4gICAgICAgICAgPyBuLm9wZXJhdG9yICsgY29kZWdlbihuLmFyZ3VtZW50KVxuICAgICAgICAgIDogY29kZWdlbihuLmFyZ3VtZW50KSArIG4ub3BlcmF0b3JcbiAgICAgICAgKSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGNvZGVnZW4obi50ZXN0KVxuICAgICAgICAgICsgXCI/XCIgKyBjb2RlZ2VuKG4uY29uc2VxdWVudClcbiAgICAgICAgICArIFwiOlwiICsgY29kZWdlbihuLmFsdGVybmF0ZSlcbiAgICAgICAgICArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgY29kZWdlbihuLmxlZnQpICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5yaWdodCkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJPYmplY3RFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgbi5wcm9wZXJ0aWVzLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgICAgfSxcbiAgICBcIlByb3BlcnR5XCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgICAgdmFyIGsgPSBjb2RlZ2VuKG4ua2V5KTtcbiAgICAgICAgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgICAgcmV0dXJuIGsgKyBcIjpcIiArIGNvZGVnZW4obi52YWx1ZSk7XG4gICAgICB9LFxuICAgIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuKG4uZXhwcmVzc2lvbik7XG4gICAgICB9XG4gIH07XG4gIFxuICByZXR1cm4gY29kZWdlbl93cmFwO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJOYU5cIjogICAgIFwiTmFOXCIsXG4gIFwiRVwiOiAgICAgICBcIk1hdGguRVwiLFxuICBcIkxOMlwiOiAgICAgXCJNYXRoLkxOMlwiLFxuICBcIkxOMTBcIjogICAgXCJNYXRoLkxOMTBcIixcbiAgXCJMT0cyRVwiOiAgIFwiTWF0aC5MT0cyRVwiLFxuICBcIkxPRzEwRVwiOiAgXCJNYXRoLkxPRzEwRVwiLFxuICBcIlBJXCI6ICAgICAgXCJNYXRoLlBJXCIsXG4gIFwiU1FSVDFfMlwiOiBcIk1hdGguU1FSVDFfMlwiLFxuICBcIlNRUlQyXCI6ICAgXCJNYXRoLlNRUlQyXCJcbn07IiwidmFyIGRhdGFsaWIgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29kZWdlbikge1xuXG4gIGZ1bmN0aW9uIGZuY2FsbChuYW1lLCBhcmdzLCBjYXN0LCB0eXBlKSB7XG4gICAgdmFyIG9iaiA9IGNvZGVnZW4oYXJnc1swXSk7XG4gICAgaWYgKGNhc3QpIHtcbiAgICAgIG9iaiA9IGNhc3QgKyBcIihcIiArIG9iaiArIFwiKVwiO1xuICAgICAgaWYgKGRsLnN0YXJ0c1dpdGgoY2FzdCwgXCJuZXcgXCIpKSBvYmogPSBcIihcIiArIG9iaiArIFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gb2JqICsgXCIuXCIgKyBuYW1lICsgKHR5cGUgPCAwID8gXCJcIiA6IHR5cGUgPT09IDBcbiAgICAgID8gXCIoKVwiXG4gICAgICA6IFwiKFwiICsgYXJncy5zbGljZSgxKS5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIilcIik7XG4gIH1cbiAgXG4gIHZhciBEQVRFID0gXCJuZXcgRGF0ZVwiO1xuICB2YXIgU1RSSU5HID0gXCJTdHJpbmdcIjtcbiAgdmFyIFJFR0VYUCA9IFwiUmVnRXhwXCI7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBNQVRIIGZ1bmN0aW9uc1xuICAgIFwiaXNOYU5cIjogICAgXCJpc05hTlwiLFxuICAgIFwiaXNGaW5pdGVcIjogXCJpc0Zpbml0ZVwiLFxuICAgIFwiYWJzXCI6ICAgICAgXCJNYXRoLmFic1wiLFxuICAgIFwiYWNvc1wiOiAgICAgXCJNYXRoLmFjb3NcIixcbiAgICBcImFzaW5cIjogICAgIFwiTWF0aC5hc2luXCIsXG4gICAgXCJhdGFuXCI6ICAgICBcIk1hdGguYXRhblwiLFxuICAgIFwiYXRhbjJcIjogICAgXCJNYXRoLmF0YW4yXCIsXG4gICAgXCJjZWlsXCI6ICAgICBcIk1hdGguY2VpbFwiLFxuICAgIFwiY29zXCI6ICAgICAgXCJNYXRoLmNvc1wiLFxuICAgIFwiZXhwXCI6ICAgICAgXCJNYXRoLmV4cFwiLFxuICAgIFwiZmxvb3JcIjogICAgXCJNYXRoLmZsb29yXCIsXG4gICAgXCJsb2dcIjogICAgICBcIk1hdGgubG9nXCIsXG4gICAgXCJtYXhcIjogICAgICBcIk1hdGgubWF4XCIsXG4gICAgXCJtaW5cIjogICAgICBcIk1hdGgubWluXCIsXG4gICAgXCJwb3dcIjogICAgICBcIk1hdGgucG93XCIsXG4gICAgXCJyYW5kb21cIjogICBcIk1hdGgucmFuZG9tXCIsXG4gICAgXCJyb3VuZFwiOiAgICBcIk1hdGgucm91bmRcIixcbiAgICBcInNpblwiOiAgICAgIFwiTWF0aC5zaW5cIixcbiAgICBcInNxcnRcIjogICAgIFwiTWF0aC5zcXJ0XCIsXG4gICAgXCJ0YW5cIjogICAgICBcIk1hdGgudGFuXCIsXG5cbiAgICAvLyBEQVRFIGZ1bmN0aW9uc1xuICAgIFwibm93XCI6ICAgICAgXCJEYXRlLm5vd1wiLFxuICAgIFwiZGF0ZXRpbWVcIjogXCJuZXcgRGF0ZVwiLFxuICAgIFwiZGF0ZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXREYXRlXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcImRheVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXREYXlcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwieWVhclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRGdWxsWWVhclwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJtb250aFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRNb250aFwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJob3Vyc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRIb3Vyc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJtaW51dGVzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldE1pbnV0ZXNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwic2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRTZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcIm1pbGxpc2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRNaWxsaXNlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidGltZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRUaW1lXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInRpbWV6b25lb2Zmc2V0XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFRpbWV6b25lT2Zmc2V0XCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y2RhdGVcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDRGF0ZVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNkYXlcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDRGF5XCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y3llYXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDRnVsbFllYXJcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjbW9udGhcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDTW9udGhcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjaG91cnNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDSG91cnNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjbWludXRlc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENNaW51dGVzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y3NlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDU2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNtaWxsaXNlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDTWlsbGlzZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcblxuICAgIC8vIHNoYXJlZCBzZXF1ZW5jZSBmdW5jdGlvbnNcbiAgICBcImxlbmd0aFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJsZW5ndGhcIiwgYXJncywgbnVsbCwgLTEpO1xuICAgICAgfSxcbiAgICBcImluZGV4b2ZcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiaW5kZXhPZlwiLCBhcmdzLCBudWxsKTtcbiAgICAgIH0sXG4gICAgXCJsYXN0aW5kZXhvZlwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJsYXN0SW5kZXhPZlwiLCBhcmdzLCBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAvLyBTVFJJTkcgZnVuY3Rpb25zXG4gICAgXCJwYXJzZUZsb2F0XCI6IFwicGFyc2VGbG9hdFwiLFxuICAgIFwicGFyc2VJbnRcIjogXCJwYXJzZUludFwiLFxuICAgIFwidXBwZXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwidG9VcHBlckNhc2VcIiwgYXJncywgU1RSSU5HLCAwKTtcbiAgICAgIH0sXG4gICAgXCJsb3dlclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJ0b0xvd2VyQ2FzZVwiLCBhcmdzLCBTVFJJTkcsIDApO1xuICAgICAgfSxcbiAgICBcInNsaWNlXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInNsaWNlXCIsIGFyZ3MsIFNUUklORyk7XG4gICAgICB9LFxuICAgIFwic3Vic3RyaW5nXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInN1YnN0cmluZ1wiLCBhcmdzLCBTVFJJTkcpO1xuICAgICAgfSxcblxuICAgIC8vIFJFR0VYUCBmdW5jdGlvbnNcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwidGVzdFwiLCBhcmdzLCBSRUdFWFApO1xuICAgICAgfSxcbiAgICBcbiAgICAvLyBDb250cm9sIEZsb3cgZnVuY3Rpb25zXG4gICAgXCJpZlwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uXCIpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uXCIpO1xuICAgICAgICB2YXIgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgICByZXR1cm4gYVswXStcIj9cIithWzFdK1wiOlwiK2FbMl07XG4gICAgICB9XG4gIH07XG59OyIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpLFxuICAgIGNvZGVnZW4gPSByZXF1aXJlKCcuL2NvZGVnZW4nKTtcbiAgICBcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogZnVuY3Rpb24oaW5wdXQsIG9wdCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlKFwiKFwiK2lucHV0K1wiKVwiLCBvcHQpOyB9LFxuICBjb2RlOiBmdW5jdGlvbihvcHQpIHsgcmV0dXJuIGNvZGVnZW4ob3B0KTsgfVxufTtcbiIsIi8qXG4gIFRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiBwYXJzZXIgaXMgYmFzZWQgb24gRXNwcmltYSAoaHR0cDovL2VzcHJpbWEub3JnLykuXG4gIE9yaWdpbmFsIGhlYWRlciBjb21tZW50IGFuZCBsaWNlbnNlIGZvciBFc3ByaW1hIGlzIGluY2x1ZGVkIGhlcmU6XG5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVG9rZW4sXG4gICAgICBUb2tlbk5hbWUsXG4gICAgICBTeW50YXgsXG4gICAgICBQcm9wZXJ0eUtpbmQsXG4gICAgICBNZXNzYWdlcyxcbiAgICAgIFJlZ2V4LFxuICAgICAgc291cmNlLFxuICAgICAgc3RyaWN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsaW5lTnVtYmVyLFxuICAgICAgbGluZVN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgbG9va2FoZWFkLFxuICAgICAgc3RhdGUsXG4gICAgICBleHRyYTtcblxuICBUb2tlbiA9IHtcbiAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgRU9GOiAyLFxuICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgIEtleXdvcmQ6IDQsXG4gICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgIFN0cmluZ0xpdGVyYWw6IDgsXG4gICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOVxuICB9O1xuXG4gIFRva2VuTmFtZSA9IHt9O1xuICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcblxuICBTeW50YXggPSB7XG4gICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJ1xuICB9O1xuXG4gIFByb3BlcnR5S2luZCA9IHtcbiAgICAgIERhdGE6IDEsXG4gICAgICBHZXQ6IDIsXG4gICAgICBTZXQ6IDRcbiAgfTtcblxuICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICBNZXNzYWdlcyA9IHtcbiAgICAgIFVuZXhwZWN0ZWRUb2tlbjogICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgVW5leHBlY3RlZFN0cmluZzogICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAgJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICBVbmV4cGVjdGVkRU9TOiAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgIE5ld2xpbmVBZnRlclRocm93OiAgJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAgJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxuICAgICAgSW52YWxpZExIU0luRm9ySW46ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxuICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXG4gICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICBTdHJpY3RNb2RlV2l0aDogICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RWYXJOYW1lOiAgJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbU5hbWU6ICAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAgJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXG4gICAgICBTdHJpY3REZWxldGU6ICAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OiAgJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIEFjY2Vzc29yRGF0YVByb3BlcnR5OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBkYXRhIGFuZCBhY2Nlc3NvciBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgQWNjZXNzb3JHZXRTZXQ6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIG11bHRpcGxlIGdldC9zZXQgYWNjZXNzb3JzIHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAgJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUG9zdGZpeDogICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUHJlZml4OiAgJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFJlc2VydmVkV29yZDogICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gIH07XG5cbiAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgUmVnZXggPSB7XG4gICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSk7ICAgLy8gMC4uOVxuICB9XG5cbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICB9XG5cbiAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gIH1cblxuICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICB9XG5cbiAgLy8gNy42LjEuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgY2FzZSAnZW51bSc6XG4gICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICBjYXNlICd5aWVsZCc6XG4gICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICAvLyA3LjYuMS4xIEtleXdvcmRzXG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxuICAgICAgLy8gJ3lpZWxkJyBhbmQgJ2xldCcgYXJlIGZvciBjb21wYXRpYmxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXG4gICAgICAvLyBTb21lIG90aGVycyBhcmUgZnJvbSBmdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXG5cbiAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gICAgICB2YXIgY2gsIHN0YXJ0O1xuXG4gICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICAgICAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgY29kZSA9IDA7XG5cbiAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBVVEYtMTYgRW5jb2RpbmdcbiAgICAgIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgfVxuICAgICAgY3UxID0gKChjb2RlIC0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwO1xuICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIGNoLCBpZDtcblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZCA9IGNoO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICBzdGFydCA9IGluZGV4Kys7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVzY2FwZWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cbiAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXl3b3JkKGlkKSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLk51bGxMaXRlcmFsO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpLFxuICAgICAgICAgIGNvZGUyLFxuICAgICAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICAgICAgY2gyLFxuICAgICAgICAgIGNoMyxcbiAgICAgICAgICBjaDQ7XG5cbiAgICAgIHN3aXRjaCAoY29kZSkge1xuXG4gICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgIGNhc2UgMHgyRTogIC8vIC4gZG90XG4gICAgICBjYXNlIDB4Mjg6ICAvLyAoIG9wZW4gYnJhY2tldFxuICAgICAgY2FzZSAweDI5OiAgLy8gKSBjbG9zZSBicmFja2V0XG4gICAgICBjYXNlIDB4M0I6ICAvLyA7IHNlbWljb2xvblxuICAgICAgY2FzZSAweDJDOiAgLy8gLCBjb21tYVxuICAgICAgY2FzZSAweDdCOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4N0Q6ICAvLyB9IGNsb3NlIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4NUI6ICAvLyBbXG4gICAgICBjYXNlIDB4NUQ6ICAvLyBdXG4gICAgICBjYXNlIDB4M0E6ICAvLyA6XG4gICAgICBjYXNlIDB4M0Y6ICAvLyA/XG4gICAgICBjYXNlIDB4N0U6ICAvLyB+XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDdCKSB7XG4gICAgICAgICAgICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgIC8vICc9JyAoVSswMDNEKSBtYXJrcyBhbiBhc3NpZ25tZW50IG9yIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gICAgICAgICAgaWYgKGNvZGUyID09PSAweDNEKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDB4MkI6ICAvLyArXG4gICAgICAgICAgICAgIGNhc2UgMHgyRDogIC8vIC1cbiAgICAgICAgICAgICAgY2FzZSAweDJGOiAgLy8gL1xuICAgICAgICAgICAgICBjYXNlIDB4M0M6ICAvLyA8XG4gICAgICAgICAgICAgIGNhc2UgMHgzRTogIC8vID5cbiAgICAgICAgICAgICAgY2FzZSAweDVFOiAgLy8gXlxuICAgICAgICAgICAgICBjYXNlIDB4N0M6ICAvLyB8XG4gICAgICAgICAgICAgIGNhc2UgMHgyNTogIC8vICVcbiAgICAgICAgICAgICAgY2FzZSAweDI2OiAgLy8gJlxuICAgICAgICAgICAgICBjYXNlIDB4MkE6ICAvLyAqXG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjYXNlIDB4MjE6IC8vICFcbiAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuXG4gICAgICAgICAgICAgICAgICAvLyAhPT0gYW5kID09PVxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3I6ID4+Pj1cblxuICAgICAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgICAgIGlmIChjaDQgPT09ICc+Pj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoNCxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgIGNoMyA9IGNoNC5zdWJzdHIoMCwgMyk7XG5cbiAgICAgIGlmIChjaDMgPT09ICc+Pj4nIHx8IGNoMyA9PT0gJzw8PScgfHwgY2gzID09PSAnPj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMyxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxuICAgICAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcblxuICAgICAgaWYgKChjaDEgPT09IGNoMlsxXSAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB8fCBjaDIgPT09ICc9PicpIHtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDIsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPCA+ID0gISArIC0gKiAlICYgfCBeIC9cblxuICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICB9XG5cbiAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gIGZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICBvY3RhbDogdHJ1ZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgIG51bWJlciA9ICcnO1xuICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBkZWNpbWFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcgc3VjaCBhcyAnMDknIGlzIGlsbGVnYWwuXG4gICAgICAgICAgICAgIGlmIChjaCAmJiBpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIGNvZGUsIHVuZXNjYXBlZCwgcmVzdG9yZSwgb2N0YWwgPSBmYWxzZSwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydExpbmVTdGFydDtcbiAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICsraW5kZXg7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICBzdGFydExpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgIHZhciB0bXAgPSBwYXR0ZXJuLFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgICAgICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgICAgICAgLy8gYC91YCBmbGFnLlxuICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgICAgICAgIC8vIHBlcmZlY3RseSB2YWxpZCBwYXR0ZXJuIHRoYXQgaXMgZXF1aXZhbGVudCB0byBgW2EtYl1gLCBidXQgaXRcbiAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csICd4Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodG1wKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgIC8vIHVzZXMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEJvZHkoKSB7XG4gICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgLy8gRUNNQS0yNjIgNy44LjVcbiAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBib2R5LFxuICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgc3RyID0gJyc7XG4gICAgICBmbGFncyA9ICcnO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZmxhZ3MsXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuXG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlJlZ3VsYXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlZ2V4ID0gc2NhblJlZ0V4cCgpO1xuXG4gICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgfTtcblxuICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sIHdoaWNoIGlzIGxpa2VseSAnLycgb3IgJy89J1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmICh0b2tlbi5yYW5nZVswXSA9PT0gcG9zICYmIHRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICByZWdleDogcmVnZXgucmVnZXgsXG4gICAgICAgICAgICAgIHJhbmdlOiBbcG9zLCBpbmRleF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlU2xhc2goKSB7XG4gICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgIGNoZWNrVG9rZW47XG4gICAgICAvLyBVc2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICBwcmV2VG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFwcmV2VG9rZW4pIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICddJykge1xuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChjaGVja1Rva2VuLnZhbHVlID09PSAnaWYnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2ZvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3dpdGgnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnfScpIHtcbiAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdICYmXG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA1XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJiBwcmV2VG9rZW4udmFsdWUgIT09ICd0aGlzJykge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgIHZhciBjaDtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLkVPRixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cbiAgICAgIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjaCA9PT0gMHgyRikge1xuICAgICAgICAgIHJldHVybiBhZHZhbmNlU2xhc2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICB2YXIgbG9jLCB0b2tlbiwgdmFsdWUsIGVudHJ5O1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgbG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0b2tlbiA9IGFkdmFuY2UoKTtcbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxuICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4ucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgIHZhciB0b2tlbjtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG5cbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgaW5kZXggPSBwb3M7XG4gICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgdGhpcy5jb2x1bW4gPSBpbmRleCAtIGxpbmVTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKSB7XG4gICAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgbGluZTogc3RhcnRUb2tlbi5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4uc3RhcnRMaW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgICAvLyBTa2lwIGNvbW1lbnQuXG4gICAgICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5zdGFydExpbmVTdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5saW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5saW5lU3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlID0gW2luZGV4LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRUb2tlbi5zdGFydCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgdGhpcy5sb2MgPSBuZXcgV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIFdyYXBwaW5nTm9kZS5wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZSA9IHtcblxuICAgICAgZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFuZ2VbMV0gPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyYXlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JZGVudGlmaWVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5MaXRlcmFsO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmF3ID09ICcvLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9ICcvKD86KS8nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChhY2Nlc3Nvciwgb2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9ncmFtO1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSA/IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uIDogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICBmdW5jdGlvbiBwZWVrTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydCwgZm91bmQ7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBmb3VuZCA9IGxpbmVOdW1iZXIgIT09IGxpbmU7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IodG9rZW4sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIHRva2VuLmxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3JUb2xlcmFudCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3dFcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICBmdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICBmdW5jdGlvbiBleHBlY3QodmFsdWUpIHtcbiAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBleHBlY3RUb2xlcmFudFxuICAgKiBAZGVzY3JpcHRpb24gUXVpZXRseSBleHBlY3QgdGhlIGdpdmVuIHRva2VuIHZhbHVlIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlc1xuICAgKiB0byA8Y29kZT5leHBlY3QodmFsdWUpPC9jb2RlPlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHdlIGFyZSBleHBlY3RpbmcgdGhlIGxvb2thaGVhZCB0b2tlbiB0byBoYXZlXG4gICAqIEBzaW5jZSAyLjBcbiAgICovXG4gIGZ1bmN0aW9uIGV4cGVjdFRvbGVyYW50KHZhbHVlKSB7XG4gICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG4gIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCB8fCB0b2tlbi52YWx1ZSAhPT0ga2V5d29yZCkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuICBmdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxuXG4gIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgIHZhciBsaW5lO1xuXG4gICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNCIHx8IG1hdGNoKCc7JykpIHtcbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGlmIChsaW5lTnVtYmVyICE9PSBsaW5lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgcHJvdmlkZWQgZXhwcmVzc2lvbiBpcyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG5cbiAgZnVuY3Rpb24gaXNMZWZ0SGFuZFNpZGUoZXhwcikge1xuICAgICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHwgZXhwci50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIHdoaWxlICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcblxuICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXgoKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8vIDExLjEuNSBPYmplY3QgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICAgICAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZSwgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtdLCB0b2tlbiwgcHJvcGVydHksIG5hbWUsIGtleSwga2luZCwgbWFwID0ge30sIHRvU3RyaW5nID0gU3RyaW5nLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5LmtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICBuYW1lID0gcHJvcGVydHkua2V5Lm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHRvU3RyaW5nKHByb3BlcnR5LmtleS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtpbmQgPSAocHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSA/IFByb3BlcnR5S2luZC5EYXRhIDogKHByb3BlcnR5LmtpbmQgPT09ICdnZXQnKSA/IFByb3BlcnR5S2luZC5HZXQgOiBQcm9wZXJ0eUtpbmQuU2V0O1xuXG4gICAgICAgICAga2V5ID0gJyQnICsgbmFtZTtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgICAgICAgICBpZiAobWFwW2tleV0gPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgIT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwW2tleV0gJiBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckdldFNldCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWFwW2tleV0gfD0ga2luZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXBba2V5XSA9IGtpbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICBleHBlY3RUb2xlcmFudCgnLCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG4gIH1cblxuICAvLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXG5cbiAgZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICsrc3RhdGUucGFyZW50aGVzaXNDb3VudDtcblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICBleHBlY3QoJyknKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuXG4gIC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gIHZhciBsZWdhbEtleXdvcmRzID0ge1wiaWZcIjoxLCBcInRoaXNcIjoxfTtcblxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIHR5cGUsIHRva2VuLCBleHByLCBub2RlO1xuXG4gICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHwgbGVnYWxLZXl3b3Jkc1tsb29rYWhlYWQudmFsdWVdKSB7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoSWRlbnRpZmllcihsZXgoKS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQobG9va2FoZWFkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gKHRva2VuLnZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLycpIHx8IG1hdGNoKCcvPScpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwoY29sbGVjdFJlZ2V4KCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGVlaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cygpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBleHBlY3RUb2xlcmFudCgnLCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpIHtcbiAgICAgIGV4cGVjdCgnLicpO1xuXG4gICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgICAgIHZhciBleHByLCBhcmdzLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbiwgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgZXhwciA9IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHByb3BlcnR5LCBzdGFydFRva2VuO1xuICAgICAgYXNzZXJ0KHN0YXRlLmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMyBQb3N0Zml4IEV4cHJlc3Npb25zXG5cbiAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCB0b2tlbiwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICBpZiAoKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSAmJiAhcGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIHRva2VuLCBleHByLCBzdGFydFRva2VuO1xuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgYWxsb3dJbikge1xuICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc9PSc6XG4gICAgICBjYXNlICchPSc6XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICBjYXNlICc+JzpcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgIHByZWMgPSA3O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcHJlYyA9IGFsbG93SW4gPyA3IDogMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPDwnOlxuICAgICAgY2FzZSAnPj4nOlxuICAgICAgY2FzZSAnPj4+JzpcbiAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICctJzpcbiAgICAgICAgICBwcmVjID0gOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcvJzpcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZWM7XG4gIH1cblxuICAvLyAxMS41IE11bHRpcGxpY2F0aXZlIE9wZXJhdG9yc1xuICAvLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gIC8vIDExLjggUmVsYXRpb25hbCBPcGVyYXRvcnNcbiAgLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4gIC8vIDExLjExIEJpbmFyeSBMb2dpY2FsIE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuXG4gICAgICBtYXJrZXIgPSBsb29rYWhlYWQ7XG4gICAgICBsZWZ0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgc3RhdGUuYWxsb3dJbik7XG4gICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfVxuICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICBsZXgoKTtcblxuICAgICAgbWFya2VycyA9IFttYXJrZXIsIGxvb2thaGVhZF07XG4gICAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgICAgIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkLCBzdGF0ZS5hbGxvd0luKSkgPiAwKSB7XG5cbiAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xuICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNoaWZ0LlxuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cbiAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgZXhwciA9IHN0YWNrW2ldO1xuICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnMucG9wKCkpLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgICAgICAgIGkgLT0gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTMgQXNzaWdubWVudCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIG9sZFBhcmVudGhlc2lzQ291bnQsIHRva2VuLCBleHByLCByaWdodCwgbGlzdCwgc3RhcnRUb2tlbjtcblxuICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZCwgZXhwcmVzc2lvbnM7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBubyBzZXF1ZW5jZSBleHByZXNzaW9uc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDEyLjQgRXhwcmVzc2lvbiBTdGF0ZW1lbnRcblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gIH1cblxuICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgICB2YXIgdHlwZSA9IGxvb2thaGVhZC50eXBlLFxuICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgbGFiZWxlZEJvZHksXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5vZGU7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGJsb2NrIHN0YXRlbWVudFxuICAgICAgfVxuXG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGVtcHR5IHN0YXRlbWVudFxuICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8ga2V5d29yZFxuICAgICAgfVxuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICB9XG5cbiAgLy8gMTQgUHJvZ3JhbVxuXG4gIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudCgpIHtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIHNvdXJjZUVsZW1lbnQsIHNvdXJjZUVsZW1lbnRzID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZDtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2VFbGVtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSgpIHtcbiAgICAgIHZhciBib2R5LCBub2RlO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgcGVlaygpO1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICBzdHJpY3QgPSB0cnVlOyAvLyBhc3N1bWUgc3RyaWN0XG5cbiAgICAgIGJvZHkgPSBwYXJzZVNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9ncmFtKGJvZHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyVG9rZW5Mb2NhdGlvbigpIHtcbiAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZW50cnkgPSBleHRyYS50b2tlbnNbaV07XG4gICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4KSB7XG4gICAgICAgICAgICAgIHRva2VuLnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogZW50cnkucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiBlbnRyeS5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgdG9rZW4ucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0b2tlbi5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHRvU3RyaW5nLFxuICAgICAgICAgIHRva2VucztcblxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG5cbiAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gT2YgY291cnNlIHdlIGNvbGxlY3QgdG9rZW5zIGhlcmUuXG4gICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgIGV4dHJhLnRva2VuaXplID0gdHJ1ZTtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gLTE7XG4gICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IC0xO1xuXG4gICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHdoaWxlIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAobGV4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChsZXhFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBicmVhayBvbiB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgdG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9ncmFtLCB0b1N0cmluZztcblxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgcGFyZW50aGVzaXNDb3VudDogMCxcbiAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxuICAgICAgfTtcblxuICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgICAgICBpZiAoZXh0cmEubG9jICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsICYmIG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemUsXG4gICAgcGFyc2U6IHBhcnNlXG4gIH07XG5cbn0pKCk7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGF4cyA9IHJlcXVpcmUoJy4uL3NjZW5lL2F4aXMnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpO1xuXG52YXIgT1JJRU5UID0ge1xuICBcInhcIjogICAgICBcImJvdHRvbVwiLFxuICBcInlcIjogICAgICBcImxlZnRcIixcbiAgXCJ0b3BcIjogICAgXCJ0b3BcIixcbiAgXCJib3R0b21cIjogXCJib3R0b21cIixcbiAgXCJsZWZ0XCI6ICAgXCJsZWZ0XCIsXG4gIFwicmlnaHRcIjogIFwicmlnaHRcIlxufTtcblxuZnVuY3Rpb24gYXhlcyhtb2RlbCwgc3BlYywgYXhlcywgZ3JvdXApIHtcbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgIGF4ZXNbaW5kZXhdID0gYXhlc1tpbmRleF0gfHwgYXhzKG1vZGVsKTtcbiAgICBheGlzKGRlZiwgaW5kZXgsIGF4ZXNbaW5kZXhdLCBncm91cCk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gYXhpcyhkZWYsIGluZGV4LCBheGlzLCBncm91cCkge1xuICAvLyBheGlzIHNjYWxlXG4gIGlmIChkZWYuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGF4aXMuc2NhbGUoZ3JvdXAuc2NhbGUoZGVmLnNjYWxlKSk7XG4gIH1cblxuICAvLyBheGlzIG9yaWVudGF0aW9uXG4gIGF4aXMub3JpZW50KGRlZi5vcmllbnQgfHwgT1JJRU5UW2RlZi50eXBlXSk7XG4gIC8vIGF4aXMgb2Zmc2V0XG4gIGF4aXMub2Zmc2V0KGRlZi5vZmZzZXQgfHwgMCk7XG4gIC8vIGF4aXMgbGF5ZXJcbiAgYXhpcy5sYXllcihkZWYubGF5ZXIgfHwgXCJmcm9udFwiKTtcbiAgLy8gYXhpcyBncmlkIGxpbmVzXG4gIGF4aXMuZ3JpZChkZWYuZ3JpZCB8fCBmYWxzZSk7XG4gIC8vIGF4aXMgdGl0bGVcbiAgYXhpcy50aXRsZShkZWYudGl0bGUgfHwgbnVsbCk7XG4gIC8vIGF4aXMgdGl0bGUgb2Zmc2V0XG4gIGF4aXMudGl0bGVPZmZzZXQoZGVmLnRpdGxlT2Zmc2V0ICE9IG51bGxcbiAgICA/IGRlZi50aXRsZU9mZnNldCA6IGNvbmZpZy5heGlzLnRpdGxlT2Zmc2V0KTtcbiAgLy8gYXhpcyB2YWx1ZXNcbiAgYXhpcy50aWNrVmFsdWVzKGRlZi52YWx1ZXMgfHwgbnVsbCk7XG4gIC8vIGF4aXMgbGFiZWwgZm9ybWF0dGluZ1xuICBheGlzLnRpY2tGb3JtYXQoZGVmLmZvcm1hdCB8fCBudWxsKTtcbiAgLy8gYXhpcyB0aWNrIHN1YmRpdmlzaW9uXG4gIGF4aXMudGlja1N1YmRpdmlkZShkZWYuc3ViZGl2aWRlIHx8IDApO1xuICAvLyBheGlzIHRpY2sgcGFkZGluZ1xuICBheGlzLnRpY2tQYWRkaW5nKGRlZi50aWNrUGFkZGluZyB8fCBjb25maWcuYXhpcy5wYWRkaW5nKTtcblxuICAvLyBheGlzIHRpY2sgc2l6ZShzKVxuICB2YXIgc2l6ZSA9IFtdO1xuICBpZiAoZGVmLnRpY2tTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8MzsgKytpKSBzaXplLnB1c2goZGVmLnRpY2tTaXplKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHMgPSBjb25maWcuYXhpcy50aWNrU2l6ZTtcbiAgICBzaXplID0gW3RzLCB0cywgdHNdO1xuICB9XG4gIGlmIChkZWYudGlja1NpemVNYWpvciAhPSBudWxsKSBzaXplWzBdID0gZGVmLnRpY2tTaXplTWFqb3I7XG4gIGlmIChkZWYudGlja1NpemVNaW5vciAhPSBudWxsKSBzaXplWzFdID0gZGVmLnRpY2tTaXplTWlub3I7XG4gIGlmIChkZWYudGlja1NpemVFbmQgICAhPSBudWxsKSBzaXplWzJdID0gZGVmLnRpY2tTaXplRW5kO1xuICBpZiAoc2l6ZS5sZW5ndGgpIHtcbiAgICBheGlzLnRpY2tTaXplLmFwcGx5KGF4aXMsIHNpemUpO1xuICB9XG5cbiAgLy8gdGljayBhcmd1bWVudHNcbiAgaWYgKGRlZi50aWNrcyAhPSBudWxsKSB7XG4gICAgdmFyIHRpY2tzID0gZGwuaXNBcnJheShkZWYudGlja3MpID8gZGVmLnRpY2tzIDogW2RlZi50aWNrc107XG4gICAgYXhpcy50aWNrcy5hcHBseShheGlzLCB0aWNrcyk7XG4gIH0gZWxzZSB7XG4gICAgYXhpcy50aWNrcyhjb25maWcuYXhpcy50aWNrcyk7XG4gIH1cblxuICAvLyBzdHlsZSBwcm9wZXJ0aWVzXG4gIHZhciBwID0gZGVmLnByb3BlcnRpZXM7XG4gIGlmIChwICYmIHAudGlja3MpIHtcbiAgICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMocC5tYWpvclRpY2tzXG4gICAgICA/IGRsLmV4dGVuZCh7fSwgcC50aWNrcywgcC5tYWpvclRpY2tzKSA6IHAudGlja3MpO1xuICAgIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyhwLm1pbm9yVGlja3NcbiAgICAgID8gZGwuZXh0ZW5kKHt9LCBwLnRpY2tzLCBwLm1pbm9yVGlja3MpIDogcC50aWNrcyk7XG4gIH0gZWxzZSB7XG4gICAgYXhpcy5tYWpvclRpY2tQcm9wZXJ0aWVzKHAgJiYgcC5tYWpvclRpY2tzIHx8IHt9KTtcbiAgICBheGlzLm1pbm9yVGlja1Byb3BlcnRpZXMocCAmJiBwLm1pbm9yVGlja3MgfHwge30pO1xuICB9XG4gIGF4aXMudGlja0xhYmVsUHJvcGVydGllcyhwICYmIHAubGFiZWxzIHx8IHt9KTtcbiAgYXhpcy50aXRsZVByb3BlcnRpZXMocCAmJiBwLnRpdGxlIHx8IHt9KTtcbiAgYXhpcy5ncmlkTGluZVByb3BlcnRpZXMocCAmJiBwLmdyaWQgfHwge30pO1xuICBheGlzLmRvbWFpblByb3BlcnRpZXMocCAmJiBwLmF4aXMgfHwge30pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGF4ZXM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgcGFyc2VUcmFuc2Zvcm1zID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1zJyksXG4gICAgcGFyc2VNb2RpZnkgPSByZXF1aXJlKCcuL21vZGlmeScpO1xuXG52YXIgcGFyc2VEYXRhID0gZnVuY3Rpb24obW9kZWwsIHNwZWMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gbG9hZGVkKGQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBkbC5lcnJvcihcIkxPQURJTkcgRkFJTEVEOiBcIiArIGQudXJsICsgXCIgXCIgKyBlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC5kYXRhKGQubmFtZSkudmFsdWVzKGRsLnJlYWQoZGF0YSwgZC5mb3JtYXQpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtLWNvdW50ID09PSAwKSBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb2Nlc3MgZWFjaCBkYXRhIHNldCBkZWZpbml0aW9uXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICBpZiAoZC51cmwpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiBkLnVybH0sIGNvbmZpZy5sb2FkKSwgbG9hZGVkKGQpKTtcbiAgICB9XG4gICAgcGFyc2VEYXRhLmRhdGFzb3VyY2UobW9kZWwsIGQpO1xuICB9KTtcblxuICBpZiAoY291bnQgPT09IDApIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEpO1xuICByZXR1cm4gc3BlYztcbn07XG5cbnBhcnNlRGF0YS5kYXRhc291cmNlID0gZnVuY3Rpb24obW9kZWwsIGQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IChkLnRyYW5zZm9ybXx8W10pLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBwYXJzZVRyYW5zZm9ybXMobW9kZWwsIHQpIH0pLFxuICAgICAgbW9kID0gKGQubW9kaWZ5fHxbXSkubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTW9kaWZ5KG1vZGVsLCBtLCBkKSB9KSxcbiAgICAgIGRzID0gbW9kZWwuZGF0YShkLm5hbWUsIG1vZC5jb25jYXQodHJhbnNmb3JtKSk7XG5cbiAgaWYgKGQudmFsdWVzKSB7XG4gICAgZHMudmFsdWVzKGRsLnJlYWQoZC52YWx1ZXMsIGQuZm9ybWF0KSk7XG4gIH0gZWxzZSBpZiAoZC5zb3VyY2UpIHtcbiAgICBkcy5zb3VyY2UoZC5zb3VyY2UpXG4gICAgICAucmV2aXNlcyhkcy5yZXZpc2VzKCkpIC8vIElmIG5ldyBkcyByZXZpc2VzLCB0aGVuIGl0J3Mgb3JpZ2luIG11c3QgcmV2aXNlIHRvby5cbiAgICAgIC5hZGRMaXN0ZW5lcihkcyk7ICAvLyBEZXJpdmVkIGRzIHdpbGwgYmUgcHVsc2VkIGJ5IGl0cyBzcmMgcmF0aGVyIHRoYW4gdGhlIG1vZGVsLlxuICAgIG1vZGVsLnJlbW92ZUxpc3RlbmVyKGRzLnBpcGVsaW5lKClbMF0pOyBcbiAgfVxuXG4gIHJldHVybiBkczsgICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlRGF0YTtcbiIsIi8qXG4gKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICpcbiAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAqL1xuXG5mdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xufVxuXG5mdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlO1xuICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgdGhpcy5vZmZzZXQgICA9IG9mZnNldDtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgdGhpcy5uYW1lICAgICA9IFwiU3ludGF4RXJyb3JcIjtcbn1cblxucGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSxcblxuICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBzdGFydDogcGVnJHBhcnNlc3RhcnQgfSxcbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiAgPSBwZWckcGFyc2VzdGFydCxcblxuICAgICAgcGVnJGMwID0gcGVnJEZBSUxFRCxcbiAgICAgIHBlZyRjMSA9IFwiLFwiLFxuICAgICAgcGVnJGMyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLFxcXCJcIiB9LFxuICAgICAgcGVnJGMzID0gZnVuY3Rpb24obywgbSkgeyByZXR1cm4gW29dLmNvbmNhdChtKSB9LFxuICAgICAgcGVnJGM0ID0gZnVuY3Rpb24obykgeyByZXR1cm4gW29dIH0sXG4gICAgICBwZWckYzUgPSBcIltcIixcbiAgICAgIHBlZyRjNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgIHBlZyRjNyA9IFwiXVwiLFxuICAgICAgcGVnJGM4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXVxcXCJcIiB9LFxuICAgICAgcGVnJGM5ID0gXCI+XCIsXG4gICAgICBwZWckYzEwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPlxcXCJcIiB9LFxuICAgICAgcGVnJGMxMSA9IGZ1bmN0aW9uKGYxLCBmMiwgbykgeyByZXR1cm4ge3N0YXJ0OiBmMSwgZW5kOiBmMiwgbWlkZGxlOiBvfX0sXG4gICAgICBwZWckYzEyID0gW10sXG4gICAgICBwZWckYzEzID0gZnVuY3Rpb24ocywgZikgeyByZXR1cm4gKHMuZmlsdGVycyA9IGYpLCBzIH0sXG4gICAgICBwZWckYzE0ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyB9LFxuICAgICAgcGVnJGMxNSA9IG51bGwsXG4gICAgICBwZWckYzE2ID0gZnVuY3Rpb24odCwgZSkgeyByZXR1cm4geyBldmVudDogZSwgdGFyZ2V0OiB0IH0gfSxcbiAgICAgIHBlZyRjMTcgPSAvXls6YS16QS16MC05X1xcLV0vLFxuICAgICAgcGVnJGMxOCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbOmEtekEtejAtOV9cXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiWzphLXpBLXowLTlfXFxcXC1dXCIgfSxcbiAgICAgIHBlZyRjMTkgPSBmdW5jdGlvbihzKSB7IHJldHVybiB7IHNpZ25hbDogcy5qb2luKFwiXCIpIH19LFxuICAgICAgcGVnJGMyMCA9IFwiKFwiLFxuICAgICAgcGVnJGMyMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIihcIiwgZGVzY3JpcHRpb246IFwiXFxcIihcXFwiXCIgfSxcbiAgICAgIHBlZyRjMjIgPSBcIilcIixcbiAgICAgIHBlZyRjMjMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIpXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIpXFxcIlwiIH0sXG4gICAgICBwZWckYzI0ID0gZnVuY3Rpb24obSkgeyByZXR1cm4geyBzdHJlYW06IG0gfX0sXG4gICAgICBwZWckYzI1ID0gXCIuXCIsXG4gICAgICBwZWckYzI2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLlxcXCJcIiB9LFxuICAgICAgcGVnJGMyNyA9IFwiOlwiLFxuICAgICAgcGVnJGMyOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgIHBlZyRjMjkgPSBmdW5jdGlvbihjKSB7IHJldHVybiB7IHR5cGU6J2NsYXNzJywgdmFsdWU6IGMgfSB9LFxuICAgICAgcGVnJGMzMCA9IFwiI1wiLFxuICAgICAgcGVnJGMzMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiNcIiwgZGVzY3JpcHRpb246IFwiXFxcIiNcXFwiXCIgfSxcbiAgICAgIHBlZyRjMzIgPSBmdW5jdGlvbihpZCkgeyByZXR1cm4geyB0eXBlOidpZCcsIHZhbHVlOiBpZCB9IH0sXG4gICAgICBwZWckYzMzID0gXCJtb3VzZWRvd25cIixcbiAgICAgIHBlZyRjMzQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZWRvd25cIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlZG93blxcXCJcIiB9LFxuICAgICAgcGVnJGMzNSA9IFwibW91c2V1cFwiLFxuICAgICAgcGVnJGMzNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNldXBcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNldXBcXFwiXCIgfSxcbiAgICAgIHBlZyRjMzcgPSBcImNsaWNrXCIsXG4gICAgICBwZWckYzM4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiY2xpY2tcIiwgZGVzY3JpcHRpb246IFwiXFxcImNsaWNrXFxcIlwiIH0sXG4gICAgICBwZWckYzM5ID0gXCJkYmxjbGlja1wiLFxuICAgICAgcGVnJGM0MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRibGNsaWNrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkYmxjbGlja1xcXCJcIiB9LFxuICAgICAgcGVnJGM0MSA9IFwid2hlZWxcIixcbiAgICAgIHBlZyRjNDIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ3aGVlbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwid2hlZWxcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDMgPSBcImtleWRvd25cIixcbiAgICAgIHBlZyRjNDQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXlkb3duXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXlkb3duXFxcIlwiIH0sXG4gICAgICBwZWckYzQ1ID0gXCJrZXlwcmVzc1wiLFxuICAgICAgcGVnJGM0NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleXByZXNzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXlwcmVzc1xcXCJcIiB9LFxuICAgICAgcGVnJGM0NyA9IFwia2V5dXBcIixcbiAgICAgIHBlZyRjNDggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXl1cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5dXBcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDkgPSBcIm1vdXNld2hlZWxcIixcbiAgICAgIHBlZyRjNTAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZXdoZWVsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZXdoZWVsXFxcIlwiIH0sXG4gICAgICBwZWckYzUxID0gXCJtb3VzZW1vdmVcIixcbiAgICAgIHBlZyRjNTIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW1vdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlbW92ZVxcXCJcIiB9LFxuICAgICAgcGVnJGM1MyA9IFwibW91c2VvdXRcIixcbiAgICAgIHBlZyRjNTQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW91dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VvdXRcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTUgPSBcIm1vdXNlb3ZlclwiLFxuICAgICAgcGVnJGM1NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlb3ZlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VvdmVyXFxcIlwiIH0sXG4gICAgICBwZWckYzU3ID0gXCJtb3VzZWVudGVyXCIsXG4gICAgICBwZWckYzU4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VlbnRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VlbnRlclxcXCJcIiB9LFxuICAgICAgcGVnJGM1OSA9IFwidG91Y2hzdGFydFwiLFxuICAgICAgcGVnJGM2MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNoc3RhcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNoc3RhcnRcXFwiXCIgfSxcbiAgICAgIHBlZyRjNjEgPSBcInRvdWNobW92ZVwiLFxuICAgICAgcGVnJGM2MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNobW92ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidG91Y2htb3ZlXFxcIlwiIH0sXG4gICAgICBwZWckYzYzID0gXCJ0b3VjaGVuZFwiLFxuICAgICAgcGVnJGM2NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNoZW5kXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaGVuZFxcXCJcIiB9LFxuICAgICAgcGVnJGM2NSA9IGZ1bmN0aW9uKGZpZWxkKSB7IHJldHVybiBmaWVsZCAgfSxcbiAgICAgIHBlZyRjNjYgPSAvXlsnXCJhLXpBLVowLTlfLj48PSEgXFx0XFwtXS8sXG4gICAgICBwZWckYzY3ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsnXFxcImEtekEtWjAtOV8uPjw9ISBcXFxcdFxcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbJ1xcXCJhLXpBLVowLTlfLj48PSEgXFxcXHRcXFxcLV1cIiB9LFxuICAgICAgcGVnJGM2OCA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuam9pbihcIlwiKSB9LFxuICAgICAgcGVnJGM2OSA9IC9eWyBcXHRcXHJcXG5dLyxcbiAgICAgIHBlZyRjNzAgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyBcXFxcdFxcXFxyXFxcXG5dXCIsIGRlc2NyaXB0aW9uOiBcIlsgXFxcXHRcXFxcclxcXFxuXVwiIH0sXG5cbiAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgIHBlZyRjYWNoZWRQb3MgICAgICAgID0gMCxcbiAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfSxcbiAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICBwZWckc2lsZW50RmFpbHMgICAgICA9IDAsXG5cbiAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgfVxuXG4gICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHJlcG9ydGVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXBvcnRlZFBvcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmxpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2x1bW4oKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmNvbHVtbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKFxuICAgICAgbnVsbCxcbiAgICAgIFt7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxuICAgICAgcGVnJHJlcG9ydGVkUG9zXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgIHZhciBwLCBjaDtcblxuICAgICAgZm9yIChwID0gc3RhcnRQb3M7IHAgPCBlbmRQb3M7IHArKykge1xuICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfVxuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgIGlmIChwZWckY2FjaGVkUG9zID4gcG9zKSB7XG4gICAgICAgIHBlZyRjYWNoZWRQb3MgPSAwO1xuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBhZHZhbmNlKHBlZyRjYWNoZWRQb3NEZXRhaWxzLCBwZWckY2FjaGVkUG9zLCBwb3MpO1xuICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICB9XG5cbiAgICByZXR1cm4gcGVnJGNhY2hlZFBvc0RldGFpbHM7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgfVxuXG4gICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICB2YXIgaSA9IDE7XG5cbiAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBpZiAoYS5kZXNjcmlwdGlvbiA8IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChleHBlY3RlZFtpIC0gMV0gPT09IGV4cGVjdGVkW2ldKSB7XG4gICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAgICAnXFxcXFwiJylcbiAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJylcbiAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICAgJ1xcXFxuJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRVxceDBGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MTA4MC1cXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUnICArIGhleChjaCk7IH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgIGV4cGVjdGVkRGVzYywgZm91bmREZXNjLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuXG4gICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXG4gICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICArIGV4cGVjdGVkRGVzY3NbZXhwZWN0ZWQubGVuZ3RoIC0gMV1cbiAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFwiXFxcIlwiICsgc3RyaW5nRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcblxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZERlc2MgKyBcIiBidXQgXCIgKyBmb3VuZERlc2MgKyBcIiBmb3VuZC5cIjtcbiAgICB9XG5cbiAgICB2YXIgcG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpLFxuICAgICAgICBmb3VuZCAgICAgID0gcG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBvcykgOiBudWxsO1xuXG4gICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIHBvcyxcbiAgICAgIHBvc0RldGFpbHMubGluZSxcbiAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXN0YXJ0KCkge1xuICAgIHZhciBzMDtcblxuICAgIHMwID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VtZXJnZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczMgPSBwZWckYzE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMzKHMxLCBzNSk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VvcmRlcmVkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwLCBzMTEsIHMxMiwgczEzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICBzMSA9IHBlZyRjNTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRjMTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckYzc7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczEwID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckYzk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczExICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEzID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzExKHMzLCBzNywgczEzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZmlsdGVyZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZXN0cmVhbSgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyKCk7XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxMyhzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VzdHJlYW0oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE0KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyZWFtKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VjbGFzcygpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VpZCgpO1xuICAgIH1cbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJGMxNTtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZWV2ZW50VHlwZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTYoczEsIHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBpZiAocGVnJGMxNy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTkoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgICAgczEgPSBwZWckYzIwO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRjMjI7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzI0KHMyKTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VjbGFzcygpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgIHMxID0gcGVnJGMyNTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICAgIHMzID0gcGVnJGMyNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzI5KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlaWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM1KSB7XG4gICAgICBzMSA9IHBlZyRjMzA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzEpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMjc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMzMihzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWV2ZW50VHlwZSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGMzMykge1xuICAgICAgczAgPSBwZWckYzMzO1xuICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM0KTsgfVxuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzM1KSB7XG4gICAgICAgIHMwID0gcGVnJGMzNTtcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzM3KSB7XG4gICAgICAgICAgczAgPSBwZWckYzM3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGMzOSkge1xuICAgICAgICAgICAgczAgPSBwZWckYzM5O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQwKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQxKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGM0MTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQyKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzQzKSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzQzO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0NCk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM0NSkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ1O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ2KTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQ3KSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0NztcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ4KTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM0OSkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0OTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUwKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTIpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzUzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTQpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM1Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1OCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzYxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Mik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM2Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZpbHRlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNjUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V2YWx1ZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBpZiAocGVnJGM2Ni50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjcpOyB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBpZiAocGVnJGM2Ni50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Nyk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgIHMxID0gcGVnJGM2OChzMSk7XG4gICAgfVxuICAgIHMwID0gczE7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzZXAoKSB7XG4gICAgdmFyIHMwLCBzMTtcblxuICAgIHMwID0gW107XG4gICAgaWYgKHBlZyRjNjkudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcwKTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwLnB1c2goczEpO1xuICAgICAgaWYgKHBlZyRjNjkudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MCk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiBwZWckcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgIH1cblxuICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihudWxsLCBwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgcGFyc2U6ICAgICAgIHBhcnNlXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBleHByZXNzaW9uID0gcmVxdWlyZSgnLi4vZXhwcmVzc2lvbicpO1xuXG52YXIgZXhwciA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHBhcnNlID0gZXhwcmVzc2lvbi5wYXJzZTtcbiAgdmFyIGNvZGVnZW4gPSBleHByZXNzaW9uLmNvZGUoe1xuICAgIGlkV2hpdGVMaXN0OiBbJ2QnLCAnZScsICdpJywgJ3AnLCAnc2cnXVxuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24oZXhwcikgeyAgICBcbiAgICB2YXIgdmFsdWUgPSBjb2RlZ2VuKHBhcnNlKGV4cHIpKTtcbiAgICB2YWx1ZS5mbiA9IEZ1bmN0aW9uKCdkJywgJ2UnLCAnaScsICdwJywgJ3NnJyxcbiAgICAgICdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgdmFsdWUuZm4gKyAnKTsnKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59KSgpO1xuXG5leHByLmV2YWwgPSBmdW5jdGlvbihncmFwaCwgZm4sIGQsIGUsIGksIHAsIHNnKSB7XG4gIHNnID0gZ3JhcGguc2lnbmFsVmFsdWVzKGRsLmFycmF5KHNnKSk7XG4gIHJldHVybiBmbi5jYWxsKG51bGwsIGQsIGUsIGksIHAsIHNnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUludGVyYWN0b3JzKG1vZGVsLCBzcGVjLCBkZWZGYWN0b3J5KSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBzZyA9IHt9LCBwZCA9IHt9LCBtayA9IHt9LFxuICAgICAgc2lnbmFscyA9IFtdLCBwcmVkaWNhdGVzID0gW107XG5cbiAgZnVuY3Rpb24gbG9hZGVkKGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBkbC5lcnJvcihcIkxPQURJTkcgRkFJTEVEOiBcIiArIGkudXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWYgPSBkbC5pc09iamVjdChkYXRhKSA/IGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICBpbnRlcmFjdG9yKGkubmFtZSwgZGVmKTtcbiAgICAgIH1cbiAgICAgIGlmICgtLWNvdW50ID09IDApIGluamVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyYWN0b3IobmFtZSwgZGVmKSB7XG4gICAgc2cgPSB7fSwgcGQgPSB7fTtcbiAgICBpZiAoZGVmLnNpZ25hbHMpICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBuc1NpZ25hbHMobmFtZSwgZGVmLnNpZ25hbHMpKTtcbiAgICBpZiAoZGVmLnByZWRpY2F0ZXMpIHByZWRpY2F0ZXMucHVzaC5hcHBseShwcmVkaWNhdGVzLCBuc1ByZWRpY2F0ZXMobmFtZSwgZGVmLnByZWRpY2F0ZXMpKTtcbiAgICBuc01hcmtzKG5hbWUsIGRlZi5tYXJrcyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3QoKSB7XG4gICAgaWYgKGRsLmtleXMobWspLmxlbmd0aCA+IDApIGluamVjdE1hcmtzKHNwZWMubWFya3MpO1xuICAgIHNwZWMuc2lnbmFscyA9IGRsLmFycmF5KHNwZWMuc2lnbmFscyk7XG4gICAgc3BlYy5wcmVkaWNhdGVzID0gZGwuYXJyYXkoc3BlYy5wcmVkaWNhdGVzKTtcbiAgICBzcGVjLnNpZ25hbHMudW5zaGlmdC5hcHBseShzcGVjLnNpZ25hbHMsIHNpZ25hbHMpO1xuICAgIHNwZWMucHJlZGljYXRlcy51bnNoaWZ0LmFwcGx5KHNwZWMucHJlZGljYXRlcywgcHJlZGljYXRlcyk7XG4gICAgZGVmRmFjdG9yeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0TWFya3MobWFya3MpIHtcbiAgICB2YXIgbSwgciwgaSwgbGVuO1xuICAgIG1hcmtzID0gZGwuYXJyYXkobWFya3MpO1xuXG4gICAgZm9yKGkgPSAwLCBsZW4gPSBtYXJrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbSA9IG1hcmtzW2ldO1xuICAgICAgaWYgKHIgPSBta1ttLnR5cGVdKSB7XG4gICAgICAgIG1hcmtzW2ldID0gZGwuZHVwbGljYXRlKHIpO1xuICAgICAgICBpZiAobS5mcm9tKSBtYXJrc1tpXS5mcm9tID0gbS5mcm9tO1xuICAgICAgICBpZiAobS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgW0MuRU5URVIsIEMuVVBEQVRFLCBDLkVYSVRdLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgbWFya3NbaV0ucHJvcGVydGllc1twXSA9IGRsLmV4dGVuZChyLnByb3BlcnRpZXNbcF0sIG0ucHJvcGVydGllc1twXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobS5tYXJrcykgeyAgLy8gVE9ETyBob3cgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiBuZXN0ZWQgbWFya3M/XG4gICAgICAgIGluamVjdE1hcmtzKG0ubWFya3MpO1xuICAgICAgfVxuICAgIH0gICAgXG4gIH1cblxuICBmdW5jdGlvbiBucyhuLCBzKSB7IFxuICAgIGlmIChkbC5pc1N0cmluZyhzKSkge1xuICAgICAgcmV0dXJuIHMgKyBcIl9cIiArIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGRsLmtleXMocykuZm9yRWFjaChmdW5jdGlvbih4KSB7IFxuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdcXFxcYicreCsnXFxcXGInLCBcImdcIik7XG4gICAgICAgIG4gPSBuLnJlcGxhY2UocmVnZXgsIHNbeF0pIFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuc1NpZ25hbHMobmFtZSwgc2lnbmFscykge1xuICAgIHNpZ25hbHMgPSBkbC5hcnJheShzaWduYWxzKTtcbiAgICAvLyBUd28gcGFzc2VzIHRvIG5zIGFsbCBzaWduYWxzLCBhbmQgdGhlbiBvdmVyd3JpdGUgdGhlaXIgZGVmaW5pdGlvbnNcbiAgICAvLyBpbiBjYXNlIHNpZ25hbCBvcmRlciBpcyBpbXBvcnRhbnQuXG4gICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgcy5uYW1lID0gc2dbcy5uYW1lXSA9IG5zKHMubmFtZSwgbmFtZSk7IH0pO1xuICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAocy5zdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdC50eXBlID0gbnModC50eXBlLCBzZyk7XG4gICAgICAgIHQuZXhwciA9IG5zKHQuZXhwciwgc2cpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ25hbHM7XG4gIH1cblxuICBmdW5jdGlvbiBuc1ByZWRpY2F0ZXMobmFtZSwgcHJlZGljYXRlcykge1xuICAgIHByZWRpY2F0ZXMgPSBkbC5hcnJheShwcmVkaWNhdGVzKTtcbiAgICBwcmVkaWNhdGVzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgcC5uYW1lID0gcGRbcC5uYW1lXSA9IG5zKHAubmFtZSwgbmFtZSk7XG5cbiAgICAgIFtwLm9wZXJhbmRzLCBwLnJhbmdlXS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgKHggfHwgW10pLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgICAgIGlmIChvLnNpZ25hbCkgby5zaWduYWwgPSBucyhvLnNpZ25hbCwgc2cpO1xuICAgICAgICAgIGVsc2UgaWYgKG8ucHJlZGljYXRlKSBuc09wZXJhbmQobyk7XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgIH0pOyAgXG4gICAgcmV0dXJuIHByZWRpY2F0ZXM7IFxuICB9XG5cbiAgZnVuY3Rpb24gbnNPcGVyYW5kKG8pIHtcbiAgICBvLnByZWRpY2F0ZSA9IHBkW28ucHJlZGljYXRlXTtcbiAgICBkbC5rZXlzKG8uaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGkgPSBvLmlucHV0W2tdO1xuICAgICAgaWYgKGkuc2lnbmFsKSBpLnNpZ25hbCA9IG5zKGkuc2lnbmFsLCBzZyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuc01hcmtzKG5hbWUsIG1hcmtzKSB7XG4gICAgKG1hcmtzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKG0pIHsgXG4gICAgICBuc1Byb3BlcnRpZXMobS5wcm9wZXJ0aWVzLmVudGVyKTtcbiAgICAgIG5zUHJvcGVydGllcyhtLnByb3BlcnRpZXMudXBkYXRlKTtcbiAgICAgIG5zUHJvcGVydGllcyhtLnByb3BlcnRpZXMuZXhpdCk7XG4gICAgICBta1tucyhtLm5hbWUsIG5hbWUpXSA9IG07IFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbnNQcm9wZXJ0aWVzKHByb3BzZXQpIHtcbiAgICBkbC5rZXlzKHByb3BzZXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHAgPSBwcm9wc2V0W2tdO1xuICAgICAgaWYgKHAuc2lnbmFsKSBwLnNpZ25hbCA9IG5zKHAuc2lnbmFsLCBzZyk7XG4gICAgICBlbHNlIGlmIChwLnJ1bGUpIHtcbiAgICAgICAgcC5ydWxlLmZvckVhY2goZnVuY3Rpb24ocikgeyBcbiAgICAgICAgICBpZiAoci5zaWduYWwpIHIuc2lnbmFsID0gbnMoci5zaWduYWwsIHNnKTtcbiAgICAgICAgICBpZiAoci5wcmVkaWNhdGUpIG5zT3BlcmFuZChyKTsgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgKHNwZWMuaW50ZXJhY3RvcnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIGlmIChpLnVybCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IGkudXJsfSwgY29uZmlnLmxvYWQpLCBsb2FkZWQoaSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGNvdW50ID09PSAwKSBzZXRUaW1lb3V0KGluamVjdCwgMSk7XG4gIHJldHVybiBzcGVjO1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBwYXJzZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZU1hcmsobW9kZWwsIG1hcmspIHtcbiAgdmFyIHByb3BzID0gbWFyay5wcm9wZXJ0aWVzLFxuICAgICAgZ3JvdXAgPSBtYXJrLm1hcmtzO1xuXG4gIC8vIHBhcnNlIG1hcmsgcHJvcGVydHkgZGVmaW5pdGlvbnNcbiAgZGwua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcHJvcHNba10gPSBwYXJzZVByb3BlcnRpZXMobW9kZWwsIG1hcmsudHlwZSwgcHJvcHNba10pO1xuICB9KTtcblxuICAvLyBwYXJzZSBkZWxheSBmdW5jdGlvblxuICBpZiAobWFyay5kZWxheSkge1xuICAgIG1hcmsuZGVsYXkgPSBwYXJzZVByb3BlcnRpZXMobW9kZWwsIG1hcmsudHlwZSwge2RlbGF5OiBtYXJrLmRlbGF5fSk7XG4gIH1cblxuICAvLyByZWN1cnNlIGlmIGdyb3VwIHR5cGVcbiAgaWYgKGdyb3VwKSB7XG4gICAgbWFyay5tYXJrcyA9IGdyb3VwLm1hcChmdW5jdGlvbihnKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIGcpOyB9KTtcbiAgfVxuICAgIFxuICByZXR1cm4gbWFyaztcbn07IiwidmFyIHBhcnNlTWFyayA9IHJlcXVpcmUoJy4vbWFyaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZGVsLCBzcGVjLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cFwiLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBzY2FsZXM6IHNwZWMuc2NhbGVzIHx8IFtdLFxuICAgIGF4ZXM6IHNwZWMuYXhlcyB8fCBbXSxcbiAgICAvLyBsZWdlbmRzOiBzcGVjLmxlZ2VuZHMgfHwgW10sXG4gICAgbWFya3M6IChzcGVjLm1hcmtzIHx8IFtdKS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSlcbiAgfTtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBzcmMsIGRlc3QpIHtcbiAgZm9yKHZhciBpID0gc3JjLmxlbmd0aC0xOyBpID49IDA7IC0taSkge1xuICAgIGlmKHNyY1tpXVtmaWVsZF0gPT0gdmFsdWUpXG4gICAgICBkZXN0LnB1c2guYXBwbHkoZGVzdCwgc3JjLnNwbGljZShpLCAxKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VNb2RpZnkobW9kZWwsIGRlZiwgZHMpIHtcbiAgdmFyIHNpZ25hbCA9IGRlZi5zaWduYWwgPyBkbC5maWVsZChkZWYuc2lnbmFsKSA6IG51bGwsIFxuICAgICAgc2lnbmFsTmFtZSA9IHNpZ25hbCA/IHNpZ25hbFswXSA6IG51bGwsXG4gICAgICBwcmVkaWNhdGUgPSBkZWYucHJlZGljYXRlID8gbW9kZWwucHJlZGljYXRlKGRlZi5wcmVkaWNhdGUpIDogbnVsbCxcbiAgICAgIHJlZXZhbCA9IChwcmVkaWNhdGUgPT09IG51bGwpLFxuICAgICAgbm9kZSA9IG5ldyBOb2RlKG1vZGVsKTtcblxuICBub2RlLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBpZihwcmVkaWNhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkYiA9IHt9O1xuICAgICAgKHByZWRpY2F0ZS5kYXRhfHxbXSkuZm9yRWFjaChmdW5jdGlvbihkKSB7IGRiW2RdID0gbW9kZWwuZGF0YShkKS52YWx1ZXMoKTsgfSk7XG5cbiAgICAgIC8vIFRPRE86IGlucHV0XG4gICAgICByZWV2YWwgPSBwcmVkaWNhdGUuY2FsbChwcmVkaWNhdGUsIHt9LCBkYiwgbW9kZWwuc2lnbmFsVmFsdWVzKHByZWRpY2F0ZS5zaWduYWxzfHxbXSksIG1vZGVsLl9wcmVkaWNhdGVzKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhpbnB1dCwgW2RlZi50eXBlK1wiaW5nXCIsIHJlZXZhbF0pO1xuICAgIGlmKCFyZWV2YWwpIHJldHVybiBpbnB1dDtcblxuICAgIHZhciBkYXR1bSA9IHt9LCBcbiAgICAgICAgdmFsdWUgPSBzaWduYWwgPyBtb2RlbC5zaWduYWxSZWYoZGVmLnNpZ25hbCkgOiBudWxsLFxuICAgICAgICBkID0gbW9kZWwuZGF0YShkcy5uYW1lKSxcbiAgICAgICAgcHJldiA9IGQucmV2aXNlcygpID8gbnVsbCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdCA9IG51bGw7XG5cbiAgICBkYXR1bVtkZWYuZmllbGRdID0gdmFsdWU7XG5cbiAgICAvLyBXZSBoYXZlIHRvIG1vZGlmeSBkcy5fZGF0YSBzbyB0aGF0IHN1YnNlcXVlbnQgcHVsc2VzIGNvbnRhaW5cbiAgICAvLyBvdXIgZHluYW1pYyBkYXRhLiBXL28gbW9kaWZ5aW5nIGRzLl9kYXRhLCBvbmx5IHRoZSBvdXRwdXRcbiAgICAvLyBjb2xsZWN0b3Igd2lsbCBjb250YWluIGR5bmFtaWMgdHVwbGVzLiBcbiAgICBpZihkZWYudHlwZSA9PSBDLkFERCkge1xuICAgICAgdCA9IHR1cGxlLmluZ2VzdChkYXR1bSwgcHJldik7XG4gICAgICBpbnB1dC5hZGQucHVzaCh0KTtcbiAgICAgIGQuX2RhdGEucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYoZGVmLnR5cGUgPT0gQy5SRU1PVkUpIHtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5hZGQsIGlucHV0LnJlbSk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQubW9kLCBpbnB1dC5yZW0pO1xuICAgICAgZC5fZGF0YSA9IGQuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZGVmLmZpZWxkXSAhPT0gdmFsdWUgfSk7XG4gICAgfSBlbHNlIGlmKGRlZi50eXBlID09IEMuVE9HR0xFKSB7XG4gICAgICB2YXIgYWRkID0gW10sIHJlbSA9IFtdO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LnJlbSwgYWRkKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5hZGQsIHJlbSk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQubW9kLCByZW0pO1xuICAgICAgaWYoYWRkLmxlbmd0aCA9PSAwICYmIHJlbS5sZW5ndGggPT0gMCkgYWRkLnB1c2godHVwbGUuaW5nZXN0KGRhdHVtKSk7XG5cbiAgICAgIGlucHV0LmFkZC5wdXNoLmFwcGx5KGlucHV0LmFkZCwgYWRkKTtcbiAgICAgIGQuX2RhdGEucHVzaC5hcHBseShkLl9kYXRhLCBhZGQpO1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCByZW0pO1xuICAgICAgZC5fZGF0YSA9IGQuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbS5pbmRleE9mKHgpID09PSAtMSB9KTtcbiAgICB9IGVsc2UgaWYoZGVmLnR5cGUgPT0gQy5DTEVBUikge1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCBpbnB1dC5hZGQpO1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCBpbnB1dC5tb2QpO1xuICAgICAgaW5wdXQuYWRkID0gW107XG4gICAgICBpbnB1dC5tb2QgPSBbXTtcbiAgICAgIGQuX2RhdGEgID0gW107XG4gICAgfSBcblxuICAgIGlucHV0LmZpZWxkc1tkZWYuZmllbGRdID0gMTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgaWYoc2lnbmFsTmFtZSkgbm9kZS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgc2lnbmFsTmFtZSk7XG4gIGlmKHByZWRpY2F0ZSkgIG5vZGUuZGVwZW5kZW5jeShDLlNJR05BTFMsIHByZWRpY2F0ZS5zaWduYWxzKTtcbiAgXG4gIHJldHVybiBub2RlO1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVBhZGRpbmcocGFkKSB7XG4gIGlmIChwYWQgPT0gbnVsbCkgcmV0dXJuIFwiYXV0b1wiO1xuICBlbHNlIGlmIChkbC5pc1N0cmluZyhwYWQpKSByZXR1cm4gcGFkPT09XCJzdHJpY3RcIiA/IFwic3RyaWN0XCIgOiBcImF1dG9cIjtcbiAgZWxzZSBpZiAoZGwuaXNPYmplY3QocGFkKSkgcmV0dXJuIHBhZDtcbiAgdmFyIHAgPSBkbC5pc051bWJlcihwYWQpID8gcGFkIDogMjA7XG4gIHJldHVybiB7dG9wOnAsIGxlZnQ6cCwgcmlnaHQ6cCwgYm90dG9tOnB9O1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVByZWRpY2F0ZShtb2RlbCwgc3BlYykge1xuICB2YXIgdHlwZXMgPSB7XG4gICAgJz0nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAgICc9PSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnIT0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJz4nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAgICc+PSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPCc6ICBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJzw9JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICdhbmQnOiBwYXJzZUxvZ2ljYWwsXG4gICAgJyYmJzogIHBhcnNlTG9naWNhbCxcbiAgICAnb3InOiAgcGFyc2VMb2dpY2FsLFxuICAgICd8fCc6ICBwYXJzZUxvZ2ljYWwsXG4gICAgJ2luJzogcGFyc2VJblxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlU2lnbmFsKHNpZ25hbCwgc2lnbmFscykge1xuICAgIHZhciBzID0gZGwuZmllbGQoc2lnbmFsKSxcbiAgICAgICAgY29kZSA9IFwic2lnbmFsc1tcIitzLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIjtcbiAgICBzaWduYWxzW3Muc2hpZnQoKV0gPSAxO1xuICAgIHJldHVybiBjb2RlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3BlcmFuZHMob3BlcmFuZHMpIHtcbiAgICB2YXIgZGVjbCA9IFtdLCBkZWZzID0gW10sXG4gICAgICAgIHNpZ25hbHMgPSB7fSwgZGIgPSB7fTtcblxuICAgIGRsLmFycmF5KG9wZXJhbmRzKS5mb3JFYWNoKGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgIHZhciBzaWduYWwsIG5hbWUgPSBcIm9cIitpLCBkZWYgPSBcIlwiO1xuICAgICAgXG4gICAgICBpZihvLnZhbHVlICE9PSB1bmRlZmluZWQpIGRlZiA9IGRsLnN0cihvLnZhbHVlKTtcbiAgICAgIGVsc2UgaWYoby5hcmcpICAgIGRlZiA9IFwiYXJnc1tcIitkbC5zdHIoby5hcmcpK1wiXVwiO1xuICAgICAgZWxzZSBpZihvLnNpZ25hbCkgZGVmID0gcGFyc2VTaWduYWwoby5zaWduYWwsIHNpZ25hbHMpO1xuICAgICAgZWxzZSBpZihvLnByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcHJlZCA9IG1vZGVsLnByZWRpY2F0ZShvLnByZWRpY2F0ZSksXG4gICAgICAgICAgICBwID0gXCJwcmVkaWNhdGVzW1wiK2RsLnN0cihvLnByZWRpY2F0ZSkrXCJdXCI7XG5cbiAgICAgICAgcHJlZC5zaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBzaWduYWxzW3NdID0gMTsgfSk7XG4gICAgICAgIHByZWQuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZGJbZF0gPSAxIH0pO1xuXG4gICAgICAgIGRsLmtleXMoby5pbnB1dCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgICAgdmFyIGkgPSBvLmlucHV0W2tdLCBzaWduYWw7XG4gICAgICAgICAgZGVmICs9IFwiYXJnc1tcIitkbC5zdHIoaykrXCJdID0gXCI7XG4gICAgICAgICAgaWYoaS5zaWduYWwpICAgZGVmICs9IHBhcnNlU2lnbmFsKGkuc2lnbmFsLCBzaWduYWxzKTtcbiAgICAgICAgICBlbHNlIGlmKGkuYXJnKSBkZWYgKz0gXCJhcmdzW1wiK2RsLnN0cihpLmFyZykrXCJdXCI7XG4gICAgICAgICAgZGVmKz1cIiwgXCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRlZis9IHArXCIuY2FsbChcIitwK1wiLCBhcmdzLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcylcIjtcbiAgICAgIH1cblxuICAgICAgZGVjbC5wdXNoKG5hbWUpO1xuICAgICAgZGVmcy5wdXNoKG5hbWUrXCI9KFwiK2RlZitcIilcIik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogXCJ2YXIgXCIgKyBkZWNsLmpvaW4oXCIsIFwiKSArIFwiO1xcblwiICsgZGVmcy5qb2luKFwiO1xcblwiKSArIFwiO1xcblwiLFxuICAgICAgc2lnbmFsczogZGwua2V5cyhzaWduYWxzKSxcbiAgICAgIGRhdGE6IGRsLmtleXMoZGIpXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlQ29tcGFyYXRvcihzcGVjKSB7XG4gICAgdmFyIG9wcyA9IHBhcnNlT3BlcmFuZHMoc3BlYy5vcGVyYW5kcyk7XG4gICAgaWYoc3BlYy50eXBlID09ICc9Jykgc3BlYy50eXBlID0gJz09JztcblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBvcHMuY29kZSArIFwicmV0dXJuIFwiICsgW1wibzBcIiwgXCJvMVwiXS5qb2luKHNwZWMudHlwZSkgKyBcIjtcIixcbiAgICAgIHNpZ25hbHM6IG9wcy5zaWduYWxzLFxuICAgICAgZGF0YTogb3BzLmRhdGFcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlTG9naWNhbChzcGVjKSB7XG4gICAgdmFyIG9wcyA9IHBhcnNlT3BlcmFuZHMoc3BlYy5vcGVyYW5kcyksXG4gICAgICAgIG8gPSBbXSwgaSA9IDAsIGxlbiA9IHNwZWMub3BlcmFuZHMubGVuZ3RoO1xuXG4gICAgd2hpbGUoby5wdXNoKFwib1wiK2krKyk8bGVuKTtcbiAgICBpZihzcGVjLnR5cGUgPT0gJ2FuZCcpIHNwZWMudHlwZSA9ICcmJic7XG4gICAgZWxzZSBpZihzcGVjLnR5cGUgPT0gJ29yJykgc3BlYy50eXBlID0gJ3x8JztcblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBvcHMuY29kZSArIFwicmV0dXJuIFwiICsgby5qb2luKHNwZWMudHlwZSkgKyBcIjtcIixcbiAgICAgIHNpZ25hbHM6IG9wcy5zaWduYWxzLFxuICAgICAgZGF0YTogb3BzLmRhdGFcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlSW4oc3BlYykge1xuICAgIHZhciBvID0gW3NwZWMuaXRlbV0sIGNvZGUgPSBcIlwiO1xuICAgIGlmKHNwZWMucmFuZ2UpIG8ucHVzaC5hcHBseShvLCBzcGVjLnJhbmdlKTtcbiAgICBpZihzcGVjLnNjYWxlKSB7XG4gICAgICBjb2RlID0gcGFyc2VTY2FsZShzcGVjLnNjYWxlLCBvKTtcbiAgICB9XG5cbiAgICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhvKTtcbiAgICBjb2RlID0gb3BzLmNvZGUgKyBjb2RlO1xuXG4gICAgaWYoc3BlYy5kYXRhKSB7XG4gICAgICB2YXIgZmllbGQgPSBkbC5maWVsZChzcGVjLmZpZWxkKS5tYXAoZGwuc3RyKTtcbiAgICAgIGNvZGUgKz0gXCJ2YXIgd2hlcmUgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkW1wiK2ZpZWxkLmpvaW4oXCJdW1wiKStcIl0gPT0gbzAgfTtcXG5cIjtcbiAgICAgIGNvZGUgKz0gXCJyZXR1cm4gZGJbXCIrZGwuc3RyKHNwZWMuZGF0YSkrXCJdLmZpbHRlcih3aGVyZSkubGVuZ3RoID4gMDtcIjtcbiAgICB9IGVsc2UgaWYoc3BlYy5yYW5nZSkge1xuICAgICAgLy8gVE9ETzogaW5jbHVzaXZlL2V4Y2x1c2l2ZSByYW5nZT9cbiAgICAgIC8vIFRPRE86IGludmVydGluZyBvcmRpbmFsIHNjYWxlc1xuICAgICAgaWYoc3BlYy5zY2FsZSkgY29kZSArPSBcIm8xID0gc2NhbGUobzEpO1xcbm8yID0gc2NhbGUobzIpO1xcblwiO1xuICAgICAgY29kZSArPSBcInJldHVybiBvMSA8IG8yID8gbzEgPD0gbzAgJiYgbzAgPD0gbzIgOiBvMiA8PSBvMCAmJiBvMCA8PSBvMVwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBjb2RlLCBcbiAgICAgIHNpZ25hbHM6IG9wcy5zaWduYWxzLCBcbiAgICAgIGRhdGE6IG9wcy5kYXRhLmNvbmNhdChzcGVjLmRhdGEgPyBbc3BlYy5kYXRhXSA6IFtdKVxuICAgIH07XG4gIH07XG5cbiAgLy8gUG9wdWxhdGUgb3BzIHN1Y2ggdGhhdCB1bHRpbWF0ZSBzY2FsZS9pbnZlcnNpb24gZnVuY3Rpb24gd2lsbCBiZSBpbiBgc2NhbGVgIHZhci4gXG4gIGZ1bmN0aW9uIHBhcnNlU2NhbGUoc3BlYywgb3BzKSB7XG4gICAgdmFyIGNvZGUgPSBcInZhciBzY2FsZSA9IFwiLCBcbiAgICAgICAgaWR4ICA9IG9wcy5sZW5ndGg7XG5cbiAgICBpZihkbC5pc1N0cmluZyhzcGVjKSkge1xuICAgICAgb3BzLnB1c2goeyB2YWx1ZTogc3BlYyB9KTtcbiAgICAgIGNvZGUgKz0gXCJ0aGlzLnJvb3QoKS5zY2FsZShvXCIraWR4K1wiKVwiO1xuICAgIH0gZWxzZSBpZihzcGVjLmFyZykgeyAgLy8gU2NhbGUgZnVuY3Rpb24gaXMgYmVpbmcgcGFzc2VkIGFzIGFuIGFyZ1xuICAgICAgb3BzLnB1c2goc3BlYyk7XG4gICAgICBjb2RlICs9IFwib1wiK2lkeDtcbiAgICB9IGVsc2UgaWYoc3BlYy5uYW1lKSB7IC8vIEZ1bGwgc2NhbGUgcGFyYW1ldGVyIHtuYW1lOiAuLn1cbiAgICAgIG9wcy5wdXNoKGRsLmlzU3RyaW5nKHNwZWMubmFtZSkgPyB7dmFsdWU6IHNwZWMubmFtZX0gOiBzcGVjLm5hbWUpO1xuICAgICAgY29kZSArPSBcIih0aGlzLmlzRnVuY3Rpb24ob1wiK2lkeCtcIikgPyBvXCIraWR4K1wiIDogXCI7XG4gICAgICBpZihzcGVjLnNjb3BlKSB7XG4gICAgICAgIG9wcy5wdXNoKHNwZWMuc2NvcGUpO1xuICAgICAgICBjb2RlICs9IFwiKG9cIisoaWR4KzEpK1wiLnNjYWxlIHx8IHRoaXMucm9vdCgpLnNjYWxlKShvXCIraWR4K1wiKVwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZSArPSBcInRoaXMucm9vdCgpLnNjYWxlKG9cIitpZHgrXCIpXCI7XG4gICAgICB9XG4gICAgICBjb2RlICs9IFwiKVwiXG4gICAgfVxuXG4gICAgaWYoc3BlYy5pbnZlcnQgPT09IHRydWUpIHsgIC8vIEFsbG93IHNwZWMuaW52ZXJ0LmFyZz9cbiAgICAgIGNvZGUgKz0gXCIuaW52ZXJ0XCJcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZStcIjtcXG5cIjtcbiAgfVxuXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgcGFyc2UgPSB0eXBlc1tzLnR5cGVdKHMpLFxuICAgICAgICBwcmVkICA9IEZ1bmN0aW9uKFwiYXJnc1wiLCBcImRiXCIsIFwic2lnbmFsc1wiLCBcInByZWRpY2F0ZXNcIiwgcGFyc2UuY29kZSk7XG4gICAgcHJlZC5yb290ID0gZnVuY3Rpb24oKSB7IHJldHVybiBtb2RlbC5zY2VuZSgpLml0ZW1zWzBdIH07IC8vIEZvciBnbG9iYWwgc2NhbGVzXG4gICAgcHJlZC5pc0Z1bmN0aW9uID0gZGwuaXNGdW5jdGlvbjtcbiAgICBwcmVkLnNpZ25hbHMgPSBwYXJzZS5zaWduYWxzO1xuICAgIHByZWQuZGF0YSA9IHBhcnNlLmRhdGE7XG4gICAgbW9kZWwucHJlZGljYXRlKHMubmFtZSwgcHJlZCk7XG4gIH0pO1xuXG4gIHJldHVybiBzcGVjO1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpO1xuXG52YXIgREVQUyA9IFtcInNpZ25hbHNcIiwgXCJzY2FsZXNcIiwgXCJkYXRhXCIsIFwiZmllbGRzXCJdO1xuXG5mdW5jdGlvbiBjb21waWxlKG1vZGVsLCBtYXJrLCBzcGVjKSB7XG4gIHZhciBjb2RlID0gXCJcIixcbiAgICAgIG5hbWVzID0gZGwua2V5cyhzcGVjKSxcbiAgICAgIGksIGxlbiwgbmFtZSwgcmVmLCB2YXJzID0ge30sIFxuICAgICAgZGVwcyA9IHtcbiAgICAgICAgc2lnbmFsczoge30sXG4gICAgICAgIHNjYWxlczogIHt9LFxuICAgICAgICBkYXRhOiAgICB7fSxcbiAgICAgICAgZmllbGRzOiAge30sXG4gICAgICAgIHJlZmxvdzogIGZhbHNlXG4gICAgICB9O1xuICAgICAgXG4gIGNvZGUgKz0gXCJ2YXIgbyA9IHRyYW5zID8ge30gOiBpdGVtO1xcblwiXG4gIFxuICBmb3IgKGk9MCwgbGVuPW5hbWVzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHJlZiA9IHNwZWNbbmFtZSA9IG5hbWVzW2ldXTtcbiAgICBjb2RlICs9IChpID4gMCkgPyBcIlxcbiAgXCIgOiBcIiAgXCI7XG4gICAgaWYocmVmLnJ1bGUpIHtcbiAgICAgIHJlZiA9IHJ1bGUobW9kZWwsIG5hbWUsIHJlZi5ydWxlKTtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIFwiICsgcmVmLmNvZGVcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmID0gdmFsdWVSZWYobmFtZSwgcmVmKTtcbiAgICAgIGNvZGUgKz0gXCJ0aGlzLnRwbC5zZXQobywgXCIrZGwuc3RyKG5hbWUpK1wiLCBcIityZWYudmFsK1wiKTtcIjtcbiAgICB9XG5cbiAgICB2YXJzW25hbWVdID0gdHJ1ZTtcbiAgICBERVBTLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgaWYocmVmW3BdICE9IG51bGwpIGRsLmFycmF5KHJlZltwXSkuZm9yRWFjaChmdW5jdGlvbihrKSB7IGRlcHNbcF1ba10gPSAxIH0pO1xuICAgIH0pO1xuICAgIGRlcHMucmVmbG93ID0gZGVwcy5yZWZsb3cgfHwgcmVmLnJlZmxvdztcbiAgfVxuXG4gIGlmICh2YXJzLngyKSB7XG4gICAgaWYgKHZhcnMueCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgaWYgKG8ueCA+IG8ueDIpIHsgXCJcbiAgICAgICAgICAgICsgXCJ2YXIgdCA9IG8ueDtcIlxuICAgICAgICAgICAgKyBcInRoaXMudHBsLnNldChvLCAneCcsIG8ueDIpO1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd4MicsIHQpOyBcIlxuICAgICAgICAgICAgKyBcIn07XCI7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3dpZHRoJywgKG8ueDIgLSBvLngpKTtcIjtcbiAgICB9IGVsc2UgaWYgKHZhcnMud2lkdGgpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneCcsIChvLngyIC0gby53aWR0aCkpO1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3gnLCBvLngyKTtcIlxuICAgIH1cbiAgfVxuXG4gIGlmICh2YXJzLnkyKSB7XG4gICAgaWYgKHZhcnMueSkge1xuICAgICAgY29kZSArPSBcIlxcbiAgaWYgKG8ueSA+IG8ueTIpIHsgXCJcbiAgICAgICAgICAgICsgXCJ2YXIgdCA9IG8ueTtcIlxuICAgICAgICAgICAgKyBcInRoaXMudHBsLnNldChvLCAneScsIG8ueTIpO1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd5MicsIHQpO1wiXG4gICAgICAgICAgICArIFwifTtcIjtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAnaGVpZ2h0JywgKG8ueTIgLSBvLnkpKTtcIjtcbiAgICB9IGVsc2UgaWYgKHZhcnMuaGVpZ2h0KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICB0aGlzLnRwbC5zZXQobywgJ3knLCAoby55MiAtIG8uaGVpZ2h0KSk7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneScsIG8ueTIpO1wiXG4gICAgfVxuICB9XG4gIFxuICBpZiAoaGFzUGF0aChtYXJrLCB2YXJzKSkgY29kZSArPSBcIlxcbiAgaXRlbS50b3VjaCgpO1wiO1xuICBjb2RlICs9IFwiXFxuICBpZiAodHJhbnMpIHRyYW5zLmludGVycG9sYXRlKGl0ZW0sIG8pO1wiO1xuXG4gIHRyeSB7XG4gICAgdmFyIGVuY29kZXIgPSBGdW5jdGlvbihcIml0ZW1cIiwgXCJncm91cFwiLCBcInRyYW5zXCIsIFwiZGJcIiwgXG4gICAgICBcInNpZ25hbHNcIiwgXCJwcmVkaWNhdGVzXCIsIGNvZGUpO1xuICAgIGVuY29kZXIudHBsICA9IHR1cGxlO1xuICAgIGVuY29kZXIudXRpbCA9IGRsO1xuICAgIGVuY29kZXIuZDMgICA9IGQzOyAvLyBGb3IgY29sb3Igc3BhY2VzXG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY29kZTogIGVuY29kZXIsXG4gICAgICBzaWduYWxzOiBkbC5rZXlzKGRlcHMuc2lnbmFscyksXG4gICAgICBzY2FsZXM6ICBkbC5rZXlzKGRlcHMuc2NhbGVzKSxcbiAgICAgIGRhdGE6ICAgIGRsLmtleXMoZGVwcy5kYXRhKSxcbiAgICAgIGZpZWxkczogIGRsLmtleXMoZGVwcy5maWVsZHMpLFxuICAgICAgcmVmbG93OiAgZGVwcy5yZWZsb3dcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkbC5lcnJvcihlKTtcbiAgICBkbC5sb2coY29kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzUGF0aChtYXJrLCB2YXJzKSB7XG4gIHJldHVybiB2YXJzLnBhdGggfHxcbiAgICAoKG1hcms9PT1cImFyZWFcIiB8fCBtYXJrPT09XCJsaW5lXCIpICYmXG4gICAgICAodmFycy54IHx8IHZhcnMueDIgfHwgdmFycy53aWR0aCB8fFxuICAgICAgIHZhcnMueSB8fCB2YXJzLnkyIHx8IHZhcnMuaGVpZ2h0IHx8XG4gICAgICAgdmFycy50ZW5zaW9uIHx8IHZhcnMuaW50ZXJwb2xhdGUpKTtcbn1cblxuZnVuY3Rpb24gcnVsZShtb2RlbCwgbmFtZSwgcnVsZXMpIHtcbiAgdmFyIHNpZ25hbHMgPSBbXSwgc2NhbGVzID0gW10sIGRiID0gW10sXG4gICAgICBpbnB1dHMgPSBbXSwgY29kZSA9IFwiXCI7XG5cbiAgKHJ1bGVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihyLCBpKSB7XG4gICAgdmFyIHByZWROYW1lID0gci5wcmVkaWNhdGUsXG4gICAgICAgIHByZWQgPSBtb2RlbC5wcmVkaWNhdGUocHJlZE5hbWUpLFxuICAgICAgICBwID0gXCJwcmVkaWNhdGVzW1wiK2RsLnN0cihwcmVkTmFtZSkrXCJdXCIsXG4gICAgICAgIGlucHV0ID0gW10sIGFyZ3MgPSBuYW1lK1wiX2FyZ1wiK2ksXG4gICAgICAgIHJlZjtcblxuICAgIGRsLmtleXMoci5pbnB1dCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgcmVmID0gdmFsdWVSZWYoaSwgci5pbnB1dFtrXSk7XG4gICAgICBpbnB1dC5wdXNoKGRsLnN0cihrKStcIjogXCIrcmVmLnZhbCk7XG4gICAgICBpZihyZWYuc2lnbmFscykgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIGRsLmFycmF5KHJlZi5zaWduYWxzKSk7XG4gICAgICBpZihyZWYuc2NhbGVzKSAgc2NhbGVzLnB1c2guYXBwbHkoc2NhbGVzLCBkbC5hcnJheShyZWYuc2NhbGVzKSk7XG4gICAgfSk7XG5cbiAgICByZWYgPSB2YWx1ZVJlZihuYW1lLCByKTtcbiAgICBpZihyZWYuc2lnbmFscykgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIGRsLmFycmF5KHJlZi5zaWduYWxzKSk7XG4gICAgaWYocmVmLnNjYWxlcykgIHNjYWxlcy5wdXNoLmFwcGx5KHNjYWxlcywgZGwuYXJyYXkocmVmLnNjYWxlcykpO1xuXG4gICAgaWYocHJlZE5hbWUpIHtcbiAgICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBwcmVkLnNpZ25hbHMpO1xuICAgICAgZGIucHVzaC5hcHBseShkYiwgcHJlZC5kYXRhKTtcbiAgICAgIGlucHV0cy5wdXNoKGFyZ3MrXCIgPSB7XCIraW5wdXQuam9pbignLCAnKStcIn1cIik7XG4gICAgICBjb2RlICs9IFwiaWYoXCIrcCtcIi5jYWxsKFwiK3ArXCIsXCIrYXJncytcIiwgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpKSB7XFxuXCIgK1xuICAgICAgICBcIiAgICB0aGlzLnRwbC5zZXQobywgXCIrZGwuc3RyKG5hbWUpK1wiLCBcIityZWYudmFsK1wiKTtcXG5cIjtcbiAgICAgIGNvZGUgKz0gcnVsZXNbaSsxXSA/IFwiICB9IGVsc2UgXCIgOiBcIiAgfVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9IFwie1xcblwiICsgXG4gICAgICAgIFwiICAgIHRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1xcblwiK1xuICAgICAgICBcIiAgfVwiO1xuICAgIH1cbiAgfSk7XG5cbiAgY29kZSA9IFwidmFyIFwiICsgaW5wdXRzLmpvaW4oXCIsXFxuICAgICAgXCIpICsgXCI7XFxuICBcIiArIGNvZGU7XG4gIHJldHVybiB7Y29kZTogY29kZSwgc2lnbmFsczogc2lnbmFscywgc2NhbGVzOiBzY2FsZXMsIGRhdGE6IGRifTtcbn1cblxuZnVuY3Rpb24gdmFsdWVSZWYobmFtZSwgcmVmKSB7XG4gIGlmIChyZWYgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgaWYgKG5hbWU9PT1cImZpbGxcIiB8fCBuYW1lPT09XCJzdHJva2VcIikge1xuICAgIGlmIChyZWYuYykge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwiaGNsXCIsIHJlZi5oLCByZWYuYywgcmVmLmwpO1xuICAgIH0gZWxzZSBpZiAocmVmLmggfHwgcmVmLnMpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcImhzbFwiLCByZWYuaCwgcmVmLnMsIHJlZi5sKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5sIHx8IHJlZi5hKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJsYWJcIiwgcmVmLmwsIHJlZi5hLCByZWYuYik7XG4gICAgfSBlbHNlIGlmIChyZWYuciB8fCByZWYuZyB8fCByZWYuYikge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwicmdiXCIsIHJlZi5yLCByZWYuZywgcmVmLmIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluaXRpYWxpemUgdmFsdWVcbiAgdmFyIHZhbCA9IG51bGwsIHNjYWxlID0gbnVsbCwgXG4gICAgICBzZ1JlZiA9IHt9LCBmUmVmID0ge30sIHNSZWYgPSB7fSxcbiAgICAgIHNpZ25hbHMgPSBbXSwgZmllbGRzID0gW10sIHJlZmxvdyA9IGZhbHNlO1xuXG4gIGlmIChyZWYudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbCA9IGRsLnN0cihyZWYudmFsdWUpO1xuICB9XG5cbiAgaWYgKHJlZi5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHNnUmVmID0gZGwuZmllbGQocmVmLnNpZ25hbCk7XG4gICAgdmFsID0gXCJzaWduYWxzW1wiK3NnUmVmLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIjsgXG4gICAgc2lnbmFscy5wdXNoKHNnUmVmLnNoaWZ0KCkpO1xuICB9XG5cbiAgaWYocmVmLmZpZWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZWYuZmllbGQgPSBkbC5pc1N0cmluZyhyZWYuZmllbGQpID8ge2RhdHVtOiByZWYuZmllbGR9IDogcmVmLmZpZWxkO1xuICAgIGZSZWYgID0gZmllbGRSZWYocmVmLmZpZWxkKTtcbiAgICB2YWwgPSBmUmVmLnZhbDtcbiAgfVxuXG4gIGlmIChyZWYuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHNSZWYgPSBzY2FsZVJlZihyZWYuc2NhbGUpO1xuICAgIHNjYWxlID0gc1JlZi52YWw7XG5cbiAgICAvLyBydW4gdGhyb3VnaCBzY2FsZSBmdW5jdGlvbiBpZiB2YWwgc3BlY2lmaWVkLlxuICAgIC8vIGlmIG5vIHZhbCwgc2NhbGUgZnVuY3Rpb24gaXMgcHJlZGljYXRlIGFyZy5cbiAgICBpZih2YWwgIT09IG51bGwgfHwgcmVmLmJhbmQgfHwgcmVmLm11bHQgfHwgcmVmLm9mZnNldCkge1xuICAgICAgdmFsID0gc2NhbGUgKyAocmVmLmJhbmQgPyBcIi5yYW5nZUJhbmQoKVwiIDogXG4gICAgICAgIFwiKFwiKyh2YWwgIT09IG51bGwgPyB2YWwgOiBcIml0ZW0uZGF0dW0uZGF0YVwiKStcIilcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHNjYWxlO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gbXVsdGlwbHksIG9mZnNldCwgcmV0dXJuIHZhbHVlXG4gIHZhbCA9IFwiKFwiICsgKHJlZi5tdWx0PyhkbC5udW1iZXIocmVmLm11bHQpK1wiICogXCIpOlwiXCIpICsgdmFsICsgXCIpXCJcbiAgICArIChyZWYub2Zmc2V0ID8gXCIgKyBcIiArIGRsLm51bWJlcihyZWYub2Zmc2V0KSA6IFwiXCIpO1xuXG4gIC8vIENvbGxhdGUgZGVwZW5kZW5jaWVzXG4gIHJldHVybiB7XG4gICAgdmFsOiB2YWwsXG4gICAgc2lnbmFsczogc2lnbmFscy5jb25jYXQoZGwuYXJyYXkoZlJlZi5zaWduYWxzKSkuY29uY2F0KGRsLmFycmF5KHNSZWYuc2lnbmFscykpLFxuICAgIGZpZWxkczogIGZpZWxkcy5jb25jYXQoZGwuYXJyYXkoZlJlZi5maWVsZHMpKS5jb25jYXQoZGwuYXJyYXkoc1JlZi5maWVsZHMpKSxcbiAgICBzY2FsZXM6ICByZWYuc2NhbGUgPyAocmVmLnNjYWxlLm5hbWUgfHwgcmVmLnNjYWxlKSA6IG51bGwsIC8vIFRPRE86IGNvbm5lY3Qgc1JlZidkIHNjYWxlP1xuICAgIHJlZmxvdzogIHJlZmxvdyB8fCBmUmVmLnJlZmxvdyB8fCBzUmVmLnJlZmxvd1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb2xvclJlZih0eXBlLCB4LCB5LCB6KSB7XG4gIHZhciB4eCA9IHggPyB2YWx1ZVJlZihcIlwiLCB4KSA6IGNvbmZpZy5jb2xvclt0eXBlXVswXSxcbiAgICAgIHl5ID0geSA/IHZhbHVlUmVmKFwiXCIsIHkpIDogY29uZmlnLmNvbG9yW3R5cGVdWzFdLFxuICAgICAgenogPSB6ID8gdmFsdWVSZWYoXCJcIiwgeikgOiBjb25maWcuY29sb3JbdHlwZV1bMl1cbiAgICAgIHNpZ25hbHMgPSBbXSwgc2NhbGVzID0gW107XG5cbiAgW3h4LCB5eSwgenpdLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIGlmKHYuc2lnbmFscykgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIHYuc2lnbmFscyk7XG4gICAgaWYodi5zY2FsZXMpICBzY2FsZXMucHVzaCh2LnNjYWxlcyk7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdmFsOiBcIih0aGlzLmQzLlwiICsgdHlwZSArIFwiKFwiICsgW3h4LnZhbCwgeXkudmFsLCB6ei52YWxdLmpvaW4oXCIsXCIpICsgJykgKyBcIlwiKScsXG4gICAgc2lnbmFsczogc2lnbmFscyxcbiAgICBzY2FsZXM6IHNjYWxlc1xuICB9O1xufVxuXG4vLyB7ZmllbGQ6IHtkYXR1bTogXCJmb29cIn0gfSAgLT4gaXRlbS5kYXR1bS5mb29cbi8vIHtmaWVsZDoge2dyb3VwOiBcImZvb1wifSB9ICAtPiBncm91cC5mb29cbi8vIHtmaWVsZDoge3BhcmVudDogXCJmb29cIn0gfSAtPiBncm91cC5kYXR1bS5mb29cbmZ1bmN0aW9uIGZpZWxkUmVmKHJlZikge1xuICBpZihkbC5pc1N0cmluZyhyZWYpKSB7XG4gICAgcmV0dXJuIHt2YWw6IGRsLmZpZWxkKHJlZikubWFwKGRsLnN0cikuam9pbihcIl1bXCIpfTtcbiAgfSBcblxuICAvLyBSZXNvbHZlIG5lc3RpbmcvcGFyZW50IGxvb2t1cHNcbiAgdmFyIGwgPSByZWYubGV2ZWwsXG4gICAgICBuZXN0ZWQgPSAocmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQpICYmIGwsXG4gICAgICBzY29wZSA9IG5lc3RlZCA/IEFycmF5KGwpLmpvaW4oXCJncm91cC5tYXJrLlwiKSA6IFwiXCIsXG4gICAgICByID0gZmllbGRSZWYocmVmLmRhdHVtIHx8IHJlZi5ncm91cCB8fCByZWYucGFyZW50IHx8IHJlZi5zaWduYWwpLFxuICAgICAgdmFsID0gci52YWwsXG4gICAgICBmaWVsZHMgID0gci5maWVsZHMgIHx8IFtdLFxuICAgICAgc2lnbmFscyA9IHIuc2lnbmFscyB8fCBbXSxcbiAgICAgIHJlZmxvdyAgPSByLnJlZmxvdyAgfHwgZmFsc2U7IC8vIE5lc3RlZCBmaWVsZHJlZnMgdHJpZ2dlciBmdWxsIHJlZXZhbCBvZiBFbmNvZGVyLlxuXG4gIGlmKHJlZi5kYXR1bSkge1xuICAgIHZhbCA9IFwiaXRlbS5kYXR1bVtcIit2YWwrXCJdXCI7XG4gICAgZmllbGRzLnB1c2gocmVmLmRhdHVtKTtcbiAgfSBlbHNlIGlmKHJlZi5ncm91cCkge1xuICAgIHZhbCA9IHNjb3BlK1wiZ3JvdXBbXCIrdmFsK1wiXVwiO1xuICAgIHJlZmxvdyA9IHRydWU7XG4gIH0gZWxzZSBpZihyZWYucGFyZW50KSB7XG4gICAgdmFsID0gc2NvcGUrXCJncm91cC5kYXR1bVtcIit2YWwrXCJdXCI7XG4gICAgcmVmbG93ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmKHJlZi5zaWduYWwpIHtcbiAgICB2YWwgPSBcInNpZ25hbHNbXCIrdmFsK1wiXVwiO1xuICAgIHNpZ25hbHMucHVzaChkbC5maWVsZChyZWYuc2lnbmFsKVswXSk7XG4gICAgcmVmbG93ID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiB7dmFsOiB2YWwsIGZpZWxkczogZmllbGRzLCBzaWduYWxzOiBzaWduYWxzLCByZWZsb3c6IHJlZmxvd307XG59XG5cbi8vIHtzY2FsZTogXCJ4XCJ9XG4vLyB7c2NhbGU6IHtuYW1lOiBcInhcIn19LFxuLy8ge3NjYWxlOiBmaWVsZFJlZn1cbmZ1bmN0aW9uIHNjYWxlUmVmKHJlZikge1xuICB2YXIgc2NhbGUgPSBudWxsLFxuICAgICAgZnIgPSBudWxsO1xuXG4gIGlmKGRsLmlzU3RyaW5nKHJlZikpIHtcbiAgICBzY2FsZSA9IGRsLnN0cihyZWYpO1xuICB9IGVsc2UgaWYocmVmLm5hbWUpIHtcbiAgICBzY2FsZSA9IGRsLmlzU3RyaW5nKHJlZi5uYW1lKSA/IGRsLnN0cihyZWYubmFtZSkgOiAoZnIgPSBmaWVsZFJlZihyZWYubmFtZSkpLnZhbDtcbiAgfSBlbHNlIHtcbiAgICBzY2FsZSA9IChmciA9IGZpZWxkUmVmKHJlZikpLnZhbDtcbiAgfVxuXG4gIHNjYWxlID0gXCJncm91cC5zY2FsZShcIitzY2FsZStcIilcIjtcbiAgaWYocmVmLmludmVydCkgc2NhbGUgKz0gXCIuaW52ZXJ0XCI7ICAvLyBUT0RPOiBvcmRpbmFsIHNjYWxlc1xuXG4gIHJldHVybiBmciA/IChmci52YWwgPSBzY2FsZSwgZnIpIDoge3ZhbDogc2NhbGV9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGU7IiwidmFyIGV4cHIgPSByZXF1aXJlKCcuL2V4cHInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVNpZ25hbHMobW9kZWwsIHNwZWMpIHtcbiAgLy8gcHJvY2VzcyBlYWNoIHNpZ25hbCBkZWZpbml0aW9uXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgc2lnbmFsID0gbW9kZWwuc2lnbmFsKHMubmFtZSwgcy5pbml0KSxcbiAgICAgICAgZXhwO1xuXG4gICAgaWYocy5leHByKSB7XG4gICAgICBleHAgPSBleHByKHMuZXhwcik7XG4gICAgICBzaWduYWwuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBleHByLmV2YWwobW9kZWwsIGV4cC5mbiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgZXhwLnNpZ25hbHMpO1xuICAgICAgICBpZihzcGVjLnNjYWxlKSB2YWx1ZSA9IG1vZGVsLnNjYWxlKHNwZWMsIHZhbHVlKTtcbiAgICAgICAgc2lnbmFsLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgaW5wdXQuc2lnbmFsc1tzLm5hbWVdID0gMTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfTtcbiAgICAgIHNpZ25hbC5kZXBlbmRlbmN5KEMuU0lHTkFMUywgZXhwLnNpZ25hbHMpO1xuICAgICAgZXhwLnNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihkZXApIHsgbW9kZWwuc2lnbmFsKGRlcCkuYWRkTGlzdGVuZXIoc2lnbmFsKTsgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gc3BlYztcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE1vZGVsID0gcmVxdWlyZSgnLi4vY29yZS9Nb2RlbCcpLCBcbiAgICBWaWV3ID0gcmVxdWlyZSgnLi4vY29yZS9WaWV3JyksIFxuICAgIHBhcnNlUGFkZGluZyA9IHJlcXVpcmUoJy4uL3BhcnNlL3BhZGRpbmcnKSxcbiAgICBwYXJzZU1hcmtzID0gcmVxdWlyZSgnLi4vcGFyc2UvbWFya3MnKSxcbiAgICBwYXJzZVNpZ25hbHMgPSByZXF1aXJlKCcuLi9wYXJzZS9zaWduYWxzJyksXG4gICAgcGFyc2VQcmVkaWNhdGVzID0gcmVxdWlyZSgnLi4vcGFyc2UvcHJlZGljYXRlcycpLFxuICAgIHBhcnNlRGF0YSA9IHJlcXVpcmUoJy4uL3BhcnNlL2RhdGEnKSxcbiAgICBwYXJzZUludGVyYWN0b3JzID0gcmVxdWlyZSgnLi4vcGFyc2UvaW50ZXJhY3RvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVNwZWMoc3BlYywgY2FsbGJhY2ssIHZpZXdGYWN0b3J5KSB7XG4gIC8vIHByb3RlY3QgYWdhaW5zdCBzdWJzZXF1ZW50IHNwZWMgbW9kaWZpY2F0aW9uXG4gIHNwZWMgPSBkbC5kdXBsaWNhdGUoc3BlYyk7XG5cbiAgdmlld0ZhY3RvcnkgPSB2aWV3RmFjdG9yeSB8fCBWaWV3LmZhY3Rvcnk7XG5cbiAgdmFyIHdpZHRoID0gc3BlYy53aWR0aCB8fCA1MDAsXG4gICAgICBoZWlnaHQgPSBzcGVjLmhlaWdodCB8fCA1MDAsXG4gICAgICB2aWV3cG9ydCA9IHNwZWMudmlld3BvcnQgfHwgbnVsbCxcbiAgICAgIG1vZGVsID0gbmV3IE1vZGVsKCk7XG5cbiAgcGFyc2VJbnRlcmFjdG9ycyhtb2RlbCwgc3BlYywgZnVuY3Rpb24oKSB7XG4gICAgbW9kZWwuZGVmcyh7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgIHBhZGRpbmc6IHBhcnNlUGFkZGluZyhzcGVjLnBhZGRpbmcpLFxuICAgICAgc2lnbmFsczogcGFyc2VTaWduYWxzKG1vZGVsLCBzcGVjLnNpZ25hbHMpLFxuICAgICAgcHJlZGljYXRlczogcGFyc2VQcmVkaWNhdGVzKG1vZGVsLCBzcGVjLnByZWRpY2F0ZXMpLFxuICAgICAgbWFya3M6IHBhcnNlTWFya3MobW9kZWwsIHNwZWMsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgZGF0YTogcGFyc2VEYXRhKG1vZGVsLCBzcGVjLmRhdGEsIGZ1bmN0aW9uKCkgeyBjYWxsYmFjayh2aWV3RmFjdG9yeShtb2RlbCkpOyB9KVxuICAgIH0pO1xuICB9KTtcbn1cbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgY2hhbmdzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBzZWxlY3RvciA9IHJlcXVpcmUoJy4vZXZlbnRzJyksXG4gICAgZXhwciA9IHJlcXVpcmUoJy4vZXhwcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgU1RBUlQgPSBcInN0YXJ0XCIsIE1JRERMRSA9IFwibWlkZGxlXCIsIEVORCA9IFwiZW5kXCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmlldykge1xuICB2YXIgbW9kZWwgPSB2aWV3Lm1vZGVsKCksXG4gICAgICBzcGVjICA9IG1vZGVsLmRlZnMoKS5zaWduYWxzLFxuICAgICAgcmVnaXN0ZXIgPSB7fSwgbm9kZXMgPSB7fTtcblxuICBmdW5jdGlvbiBzY2FsZShzcGVjLCB2YWx1ZSkge1xuICAgIHZhciBkZWYgPSBzcGVjLnNjYWxlLFxuICAgICAgICBuYW1lICA9IGRlZi5uYW1lIHx8IGRlZi5zaWduYWwgfHwgZGVmLFxuICAgICAgICBzY29wZSA9IGRlZi5zY29wZSA/IG1vZGVsLnNpZ25hbFJlZihkZWYuc2NvcGUuc2lnbmFsKSA6IG51bGw7XG5cbiAgICBpZighc2NvcGUgfHwgIXNjb3BlLnNjYWxlKSB7XG4gICAgICBzY29wZSA9IChzY29wZSAmJiBzY29wZS5tYXJrKSA/IHNjb3BlLm1hcmsuZ3JvdXAgOiBtb2RlbC5zY2VuZSgpLml0ZW1zWzBdO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IHNjb3BlLnNjYWxlKG5hbWUpO1xuICAgIGlmKCFzY2FsZSkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBkZWYuaW52ZXJ0ID8gc2NhbGUuaW52ZXJ0KHZhbHVlKSA6IHNjYWxlKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbChzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgbiA9IG5ldyBOb2RlKG1vZGVsKTtcbiAgICBuLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGlmKCFpbnB1dC5zaWduYWxzW3NlbGVjdG9yLnNpZ25hbF0pIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTtcbiAgICAgIHZhciB2YWwgPSBleHByLmV2YWwobW9kZWwsIGV4cC5mbiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgZXhwLnNpZ25hbHMpO1xuICAgICAgaWYoc3BlYy5zY2FsZSkgdmFsID0gc2NhbGUoc3BlYywgdmFsKTtcbiAgICAgIHNpZy52YWx1ZSh2YWwpO1xuICAgICAgaW5wdXQuc2lnbmFsc1tzaWcubmFtZSgpXSA9IDE7XG4gICAgICBpbnB1dC5yZWZsb3cgPSB0cnVlO1xuICAgICAgcmV0dXJuIGlucHV0OyAgXG4gICAgfTtcbiAgICBuLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzZWxlY3Rvci5zaWduYWwpO1xuICAgIG4uYWRkTGlzdGVuZXIoc2lnKTtcbiAgICBtb2RlbC5zaWduYWwoc2VsZWN0b3Iuc2lnbmFsKS5hZGRMaXN0ZW5lcihuKTtcbiAgfTtcblxuICBmdW5jdGlvbiBldmVudChzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgZmlsdGVycyA9IHNlbGVjdG9yLmZpbHRlcnMgfHwgW10sXG4gICAgICAgIHRhcmdldCA9IHNlbGVjdG9yLnRhcmdldDtcblxuICAgIGlmKHRhcmdldCkgZmlsdGVycy5wdXNoKFwiaS5cIit0YXJnZXQudHlwZStcIj09XCIrZGwuc3RyKHRhcmdldC52YWx1ZSkpO1xuXG4gICAgcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdID0gcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdIHx8IFtdO1xuICAgIHJlZ2lzdGVyW3NlbGVjdG9yLmV2ZW50XS5wdXNoKHtcbiAgICAgIHNpZ25hbDogc2lnLFxuICAgICAgZXhwOiBleHAsXG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzLm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBleHByKGYpOyB9KSxcbiAgICAgIHNwZWM6IHNwZWNcbiAgICB9KTtcblxuICAgIG5vZGVzW3NlbGVjdG9yLmV2ZW50XSA9IG5vZGVzW3NlbGVjdG9yLmV2ZW50XSB8fCBuZXcgTm9kZShtb2RlbCk7XG4gICAgbm9kZXNbc2VsZWN0b3IuZXZlbnRdLmFkZExpc3RlbmVyKHNpZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gb3JkZXJlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgbmFtZSA9IHNpZy5uYW1lKCksIFxuICAgICAgICB0cnVlRm4gPSBleHByKFwidHJ1ZVwiKSxcbiAgICAgICAgcyA9IHt9O1xuXG4gICAgc1tTVEFSVF0gID0gbW9kZWwuc2lnbmFsKG5hbWUgKyBTVEFSVCwgIGZhbHNlKTtcbiAgICBzW01JRERMRV0gPSBtb2RlbC5zaWduYWwobmFtZSArIE1JRERMRSwgZmFsc2UpO1xuICAgIHNbRU5EXSAgICA9IG1vZGVsLnNpZ25hbChuYW1lICsgRU5ELCAgICBmYWxzZSk7XG5cbiAgICB2YXIgcm91dGVyID0gbmV3IE5vZGUobW9kZWwpO1xuICAgIHJvdXRlci5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZihzW1NUQVJUXS52YWx1ZSgpID09PSB0cnVlICYmIHNbRU5EXS52YWx1ZSgpID09PSBmYWxzZSkge1xuICAgICAgICAvLyBUT0RPOiBFeHBhbmQgc2VsZWN0b3Igc3ludGF4IHRvIGFsbG93IHN0YXJ0L2VuZCBzaWduYWxzIGludG8gc3RyZWFtLlxuICAgICAgICAvLyBVbnRpbCB0aGVuLCBwcmV2ZW50IG9sZCBtaWRkbGVzIGVudGVyaW5nIHN0cmVhbSBvbiBuZXcgc3RhcnQuXG4gICAgICAgIGlmKGlucHV0LnNpZ25hbHNbbmFtZStTVEFSVF0pIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTtcblxuICAgICAgICBzaWcudmFsdWUoc1tNSURETEVdLnZhbHVlKCkpO1xuICAgICAgICBpbnB1dC5zaWduYWxzW25hbWVdID0gMTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgfVxuXG4gICAgICBpZihzW0VORF0udmFsdWUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBzW1NUQVJUXS52YWx1ZShmYWxzZSk7XG4gICAgICAgIHNbRU5EXS52YWx1ZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtb2RlbC5kb05vdFByb3BhZ2F0ZTtcbiAgICB9O1xuICAgIHJvdXRlci5hZGRMaXN0ZW5lcihzaWcpO1xuXG4gICAgW1NUQVJULCBNSURETEUsIEVORF0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgdmFsID0gKHggPT0gTUlERExFKSA/IGV4cCA6IHRydWVGbixcbiAgICAgICAgICBzcCA9ICh4ID09IE1JRERMRSkgPyBzcGVjIDoge307XG5cbiAgICAgIGlmKHNlbGVjdG9yW3hdLmV2ZW50KSBldmVudChzW3hdLCBzZWxlY3Rvclt4XSwgdmFsLCBzcCk7XG4gICAgICBlbHNlIGlmKHNlbGVjdG9yW3hdLnNpZ25hbCkgc2lnbmFsKHNbeF0sIHNlbGVjdG9yW3hdLCB2YWwsIHNwKTtcbiAgICAgIGVsc2UgaWYoc2VsZWN0b3JbeF0uc3RyZWFtKSBtZXJnZWRTdHJlYW0oc1t4XSwgc2VsZWN0b3JbeF0uc3RyZWFtLCB2YWwsIHNwKTtcbiAgICAgIHNbeF0uYWRkTGlzdGVuZXIocm91dGVyKTtcbiAgICB9KTtcbiAgfTtcblxuICBmdW5jdGlvbiBtZXJnZWRTdHJlYW0oc2lnLCBzZWxlY3RvciwgZXhwLCBzcGVjKSB7XG4gICAgc2VsZWN0b3IuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICBpZihzLmV2ZW50KSAgICAgICBldmVudChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc2lnbmFsKSBzaWduYWwoc2lnLCBzLCBleHAsIHNwZWMpO1xuICAgICAgZWxzZSBpZihzLnN0YXJ0KSAgb3JkZXJlZFN0cmVhbShzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc3RyZWFtKSBtZXJnZWRTdHJlYW0oc2lnLCBzLnN0cmVhbSwgZXhwLCBzcGVjKTtcbiAgICB9KTtcbiAgfTtcblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzaWcpIHtcbiAgICB2YXIgc2lnbmFsID0gbW9kZWwuc2lnbmFsKHNpZy5uYW1lKTtcbiAgICBpZihzaWcuZXhwcikgcmV0dXJuOyAgLy8gQ2Fubm90IGhhdmUgYW4gZXhwciBhbmQgc3RyZWFtIGRlZmluaXRpb24uXG5cbiAgICAoc2lnLnN0cmVhbXMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgc2VsID0gc2VsZWN0b3IucGFyc2Uoc3RyZWFtLnR5cGUpLFxuICAgICAgICAgIGV4cCA9IGV4cHIoc3RyZWFtLmV4cHIpO1xuICAgICAgbWVyZ2VkU3RyZWFtKHNpZ25hbCwgc2VsLCBleHAsIHN0cmVhbSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFdlIHJlZ2lzdGVyIHRoZSBldmVudCBsaXN0ZW5lcnMgYWxsIHRvZ2V0aGVyIHNvIHRoYXQgaWYgbXVsdGlwbGVcbiAgLy8gc2lnbmFscyBhcmUgcmVnaXN0ZXJlZCBvbiB0aGUgc2FtZSBldmVudCwgdGhleSB3aWxsIHJlY2VpdmUgdGhlXG4gIC8vIG5ldyB2YWx1ZSBvbiB0aGUgc2FtZSBwdWxzZS4gXG5cbiAgLy8gVE9ETzogRmlsdGVycywgdGltZSBpbnRlcnZhbHMsIHRhcmdldCBzZWxlY3RvcnNcbiAgZGwua2V5cyhyZWdpc3RlcikuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gcmVnaXN0ZXJbcl0sIFxuICAgICAgICBub2RlID0gbm9kZXNbcl07XG5cbiAgICB2aWV3Lm9uKHIsIGZ1bmN0aW9uKGV2dCwgaXRlbSkge1xuICAgICAgdmFyIGNzID0gY2hhbmdzZXQuY3JlYXRlKG51bGwsIHRydWUpLFxuICAgICAgICAgIHBhZCA9IHZpZXcucGFkZGluZygpLFxuICAgICAgICAgIGZpbHRlcmVkID0gZmFsc2UsXG4gICAgICAgICAgdmFsLCBoLCBpLCBtLCBkO1xuXG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gU3RvcCB0ZXh0IHNlbGVjdGlvblxuICAgICAgbSA9IGQzLm1vdXNlKChkMy5ldmVudD1ldnQsIHZpZXcuX2VsKSk7IC8vIFJlbGF0aXZlIHBvc2l0aW9uIHdpdGhpbiBjb250YWluZXJcbiAgICAgIGl0ZW0gPSBpdGVtfHx7fTtcbiAgICAgIGQgPSBpdGVtLmRhdHVtfHx7fTtcbiAgICAgIHZhciBwID0ge3g6IG1bMF0gLSBwYWQubGVmdCwgeTogbVsxXSAtIHBhZC50b3B9O1xuXG4gICAgICBmb3IoaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoID0gaGFuZGxlcnNbaV07XG4gICAgICAgIGZpbHRlcmVkID0gaC5maWx0ZXJzLnNvbWUoZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiAhZXhwci5ldmFsKG1vZGVsLCBmLmZuLCBkLCBldnQsIGl0ZW0sIHAsIGYuc2lnbmFscyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZihmaWx0ZXJlZCkgY29udGludWU7XG4gICAgICAgIFxuICAgICAgICB2YWwgPSBleHByLmV2YWwobW9kZWwsIGguZXhwLmZuLCBkLCBldnQsIGl0ZW0sIHAsIGguZXhwLnNpZ25hbHMpOyBcbiAgICAgICAgaWYoaC5zcGVjLnNjYWxlKSB2YWwgPSBzY2FsZShoLnNwZWMsIHZhbCwgaXRlbSk7XG4gICAgICAgIGguc2lnbmFsLnZhbHVlKHZhbCk7XG4gICAgICAgIGNzLnNpZ25hbHNbaC5zaWduYWwubmFtZSgpXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsLnByb3BhZ2F0ZShjcywgbm9kZSk7XG4gICAgfSk7XG4gIH0pXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICB0cmFuc2Zvcm1zID0gcmVxdWlyZSgnLi4vdHJhbnNmb3Jtcy9pbmRleCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlVHJhbnNmb3Jtcyhtb2RlbCwgZGVmKSB7XG4gIHZhciB0eCA9IG5ldyB0cmFuc2Zvcm1zW2RlZi50eXBlXShtb2RlbCk7XG4gIFxuICAvLyBXZSB3YW50IHRvIHJlbmFtZSBvdXRwdXQgZmllbGRzIGJlZm9yZSBzZXR0aW5nIGFueSBvdGhlciBwcm9wZXJ0aWVzLFxuICAvLyBhcyBzdWJzZXF1ZW50IHByb3BlcnRpZXMgbWF5IHJlcXVpcmUgb3V0cHV0IHRvIGJlIHNldCAoZS5nLiBncm91cCBieSkuXG4gIGlmKGRlZi5vdXRwdXQpIHR4Lm91dHB1dChkZWYub3V0cHV0KTtcblxuICBkbC5rZXlzKGRlZikuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYoayA9PT0gJ3R5cGUnIHx8IGsgPT09ICdvdXRwdXQnKSByZXR1cm47XG4gICAgaWYoayA9PT0gJ3RyYW5zZm9ybScgJiYgZGVmLnR5cGUgPT09ICdmYWNldCcpIHJldHVybjtcbiAgICAodHhba10pLnNldCh0eCwgZGVmW2tdKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHR4O1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIGhhbmRsZXIgPSBmdW5jdGlvbihlbCwgbW9kZWwpIHtcbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgdGhpcy5faGFuZGxlcnMgPSB7fTtcbiAgaWYgKGVsKSB0aGlzLmluaXRpYWxpemUoZWwpO1xuICBpZiAobW9kZWwpIHRoaXMubW9kZWwobW9kZWwpO1xufTtcblxudmFyIHByb3RvdHlwZSA9IGhhbmRsZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCBwYWQsIG9iaikge1xuICB0aGlzLl9lbCA9IGQzLnNlbGVjdChlbCkubm9kZSgpO1xuICB0aGlzLl9jYW52YXMgPSBkMy5zZWxlY3QoZWwpLnNlbGVjdChcImNhbnZhcy5tYXJrc1wiKS5ub2RlKCk7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHRoaXMuX29iaiA9IG9iaiB8fCBudWxsO1xuICBcbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzLCB0aGF0ID0gdGhpcztcbiAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcHJvdG90eXBlW3R5cGVdLmNhbGwodGhhdCwgZXZ0KTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoID0gdGhpcy5faGFuZGxlcnM7XG4gIHJldHVybiBkbC5rZXlzKGgpLnJlZHVjZShmdW5jdGlvbihhLCBrKSB7XG4gICAgcmV0dXJuIGhba10ucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHsgcmV0dXJuIChhLnB1c2goeCksIGEpOyB9LCBhKTtcbiAgfSwgW10pO1xufTtcblxuLy8gc2V0dXAgZXZlbnRzXG52YXIgZXZlbnRzID0gW1xuICBcIm1vdXNlZG93blwiLFxuICBcIm1vdXNldXBcIixcbiAgXCJjbGlja1wiLFxuICBcImRibGNsaWNrXCIsXG4gIFwid2hlZWxcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5cHJlc3NcIixcbiAgXCJrZXl1cFwiLFxuICBcIm1vdXNld2hlZWxcIixcbiAgXCJ0b3VjaHN0YXJ0XCJcbl07XG5ldmVudHMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gIHByb3RvdHlwZVt0eXBlXSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIHRoaXMuZmlyZSh0eXBlLCBldnQpO1xuICB9O1xufSk7XG5ldmVudHMucHVzaChcIm1vdXNlbW92ZVwiKTtcbmV2ZW50cy5wdXNoKFwibW91c2VvdXRcIik7XG5ldmVudHMucHVzaChcInRvdWNobW92ZVwiKTtcbmV2ZW50cy5wdXNoKFwidG91Y2hlbmRcIik7XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZShuYW1lKSB7XG4gIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLlwiKTtcbiAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCxpKTtcbn1cblxucHJvdG90eXBlLnRvdWNobW92ZSA9IHByb3RvdHlwZS5tb3VzZW1vdmUgPSBmdW5jdGlvbihldnQpIHtcbiAgdmFyIHBhZCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICBiID0gZXZ0LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIHggPSBldnQuY2xpZW50WCAtIGIubGVmdCxcbiAgICAgIHkgPSBldnQuY2xpZW50WSAtIGIudG9wLFxuICAgICAgYSA9IHRoaXMuX2FjdGl2ZSxcbiAgICAgIHAgPSB0aGlzLnBpY2sodGhpcy5fbW9kZWwuc2NlbmUoKSwgeCwgeSwgeC1wYWQubGVmdCwgeS1wYWQudG9wKTtcblxuICBpZiAocCA9PT0gYSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlbW92ZVwiLCBldnQpO1xuICAgIGlmKGV2dC50eXBlID09IFwidG91Y2htb3ZlXCIpIHRoaXMuZmlyZShcInRvdWNobW92ZVwiLCBldnQpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChhKSB7XG4gICAgdGhpcy5maXJlKFwibW91c2VvdXRcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNoZW5kXCIpIHRoaXMuZmlyZShcInRvdWNoZW5kXCIsIGV2dCk7XG4gIH1cbiAgdGhpcy5fYWN0aXZlID0gcDtcbiAgaWYgKHApIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW92ZXJcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNoc3RhcnRcIikgdGhpcy5maXJlKFwidG91Y2hzdGFydFwiLCBldnQpO1xuICB9XG59O1xuXG5wcm90b3R5cGUudG91Y2hlbmQgPSBwcm90b3R5cGUubW91c2VvdXQgPSBmdW5jdGlvbihldnQpIHtcbiAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIGV2dCk7XG4gICAgdGhpcy5maXJlKFwidG91Y2hlbmRcIiwgZXZ0KTtcbiAgfVxuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xufTtcblxuLy8gdG8ga2VlcCBmaXJlZm94IGhhcHB5XG5wcm90b3R5cGUuRE9NTW91c2VTY3JvbGwgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKFwibW91c2V3aGVlbFwiLCBldnQpO1xufTtcblxuLy8gZmlyZSBhbiBldmVudFxucHJvdG90eXBlLmZpcmUgPSBmdW5jdGlvbih0eXBlLCBldnQpIHtcbiAgdmFyIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbdHlwZV07XG4gIGlmIChoKSB7XG4gICAgZm9yICh2YXIgaT0wLCBsZW49aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGhbaV0uaGFuZGxlci5jYWxsKHRoaXMuX29iaiwgZXZ0LCBhKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICBoID0gaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKTtcbiAgaC5wdXNoKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yICh2YXIgaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmIChoW2ldLnR5cGUgIT09IHR5cGUpIGNvbnRpbnVlO1xuICAgIGlmICghaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIGguc3BsaWNlKGksIDEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmV0cmlldmUgdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRleHRcbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xufTtcblxuLy8gZmluZCB0aGUgc2NlbmVncmFwaCBpdGVtIGF0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4vLyB4LCB5IC0tIHRoZSBhYnNvbHV0ZSB4LCB5IG1vdXNlIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMgZWxlbWVudFxuLy8gZ3gsIGd5IC0tIHRoZSByZWxhdGl2ZSBjb29yZGluYXRlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbnByb3RvdHlwZS5waWNrID0gZnVuY3Rpb24oc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgZyA9IHRoaXMuY29udGV4dCgpLFxuICAgICAgbWFya3R5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIHBpY2tlciA9IG1hcmtzLnBpY2tbbWFya3R5cGVdO1xuICByZXR1cm4gcGlja2VyLmNhbGwodGhpcywgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZXI7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Cb3VuZHMnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY3R4ID0gbnVsbDtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9pbWdsb2FkID0gMDtcbn07XG5cbnZhciBwcm90b3R5cGUgPSByZW5kZXJlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl9lbCA9IGVsO1xuICBcbiAgaWYgKCFlbCkgcmV0dXJuIHRoaXM7IC8vIGVhcmx5IGV4aXQgaWYgbm8gRE9NIGVsZW1lbnRcblxuICAvLyBzZWxlY3QgY2FudmFzIGVsZW1lbnRcbiAgdmFyIGNhbnZhcyA9IGQzLnNlbGVjdChlbClcbiAgICAuc2VsZWN0QWxsKFwiY2FudmFzLm1hcmtzXCIpXG4gICAgLmRhdGEoWzFdKTtcbiAgXG4gIC8vIGNyZWF0ZSBuZXcgY2FudmFzIGVsZW1lbnQgaWYgbmVlZGVkXG4gIGNhbnZhcy5lbnRlcigpXG4gICAgLmFwcGVuZChcImNhbnZhc1wiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrc1wiKTtcbiAgXG4gIC8vIHJlbW92ZSBleHRyYW5lb3VzIGNhbnZhcyBpZiBuZWVkZWRcbiAgY2FudmFzLmV4aXQoKS5yZW1vdmUoKTtcbiAgXG4gIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwYWQpO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIFxuICBpZiAodGhpcy5fZWwpIHtcbiAgICB2YXIgY2FudmFzID0gZDMuc2VsZWN0KHRoaXMuX2VsKS5zZWxlY3QoXCJjYW52YXMubWFya3NcIik7XG5cbiAgICAvLyBpbml0aWFsaXplIGNhbnZhcyBhdHRyaWJ1dGVzXG4gICAgY2FudmFzXG4gICAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgcGFkLmxlZnQgKyBwYWQucmlnaHQpXG4gICAgICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBwYWQudG9wICsgcGFkLmJvdHRvbSk7XG5cbiAgICAvLyBnZXQgdGhlIGNhbnZhcyBncmFwaGljcyBjb250ZXh0XG4gICAgdmFyIHM7XG4gICAgdGhpcy5fY3R4ID0gY2FudmFzLm5vZGUoKS5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgdGhpcy5fY3R4Ll9yYXRpbyA9IChzID0gc2NhbGVDYW52YXMoY2FudmFzLm5vZGUoKSwgdGhpcy5fY3R4KSB8fCAxKTtcbiAgICB0aGlzLl9jdHguc2V0VHJhbnNmb3JtKHMsIDAsIDAsIHMsIHMqcGFkLmxlZnQsIHMqcGFkLnRvcCk7XG4gIH1cbiAgXG4gIGluaXRpYWxpemVMaW5lRGFzaCh0aGlzLl9jdHgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHNjYWxlQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIC8vIGdldCBjYW52YXMgcGl4ZWwgZGF0YVxuICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IChcbiAgICAgICAgY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8pIHx8IDEsXG4gICAgICByYXRpbyA9IGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblxuICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyAhPT0gYmFja2luZ1N0b3JlUmF0aW8pIHtcbiAgICB2YXIgdyA9IGNhbnZhcy53aWR0aCwgaCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgLy8gc2V0IGFjdHVhbCBhbmQgdmlzaWJsZSBjYW52YXMgc2l6ZVxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3ICogcmF0aW8pO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaCAqIHJhdGlvKTtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gIH1cbiAgcmV0dXJuIHJhdGlvO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTGluZURhc2goY3R4KSB7XG4gIGlmIChjdHgudmdMaW5lRGFzaCkgcmV0dXJuOyAvLyBhbHJlYWR5IHNldFxuXG4gIHZhciBOT0RBU0ggPSBbXTtcbiAgaWYgKGN0eC5zZXRMaW5lRGFzaCkge1xuICAgIGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLnNldExpbmVEYXNoKGRhc2ggfHwgTk9EQVNIKTsgfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gb2ZmOyB9O1xuICB9IGVsc2UgaWYgKGN0eC53ZWJraXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gIFx0Y3R4LnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMud2Via2l0TGluZURhc2ggPSBkYXNoIHx8IE5PREFTSDsgfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyB0aGlzLndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gb2ZmOyB9O1xuICB9IGVsc2UgaWYgKGN0eC5tb3pEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5tb3pEYXNoID0gZGFzaDsgfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICB9IGVsc2Uge1xuICAgIGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICAgIGN0eC52Z0xpbmVEYXNoT2Zmc2V0ID0gZnVuY3Rpb24ob2ZmKSB7IC8qIHVuc3VwcG9ydGVkICovIH07XG4gIH1cbn1cblxucHJvdG90eXBlLmNvbnRleHQgPSBmdW5jdGlvbihjdHgpIHtcbiAgaWYgKGN0eCkgeyB0aGlzLl9jdHggPSBjdHg7IHJldHVybiB0aGlzOyB9XG4gIGVsc2UgcmV0dXJuIHRoaXMuX2N0eDtcbn07XG5cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbnByb3RvdHlwZS5wZW5kaW5nSW1hZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pbWdsb2FkO1xufTtcblxuZnVuY3Rpb24gdHJhbnNsYXRlZEJvdW5kcyhpdGVtLCBib3VuZHMpIHtcbiAgdmFyIGIgPSBuZXcgQm91bmRzKGJvdW5kcyk7XG4gIHdoaWxlICgoaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkgIT0gbnVsbCkge1xuICAgIGIudHJhbnNsYXRlKGl0ZW0ueCB8fCAwLCBpdGVtLnkgfHwgMCk7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG4gIFxuZnVuY3Rpb24gZ2V0Qm91bmRzKGl0ZW1zKSB7XG4gIHJldHVybiAhaXRlbXMgPyBudWxsIDpcbiAgICBkbC5hcnJheShpdGVtcykucmVkdWNlKGZ1bmN0aW9uKGIsIGl0ZW0pIHtcbiAgICAgIHJldHVybiBiLnVuaW9uKHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgaXRlbS5ib3VuZHMpKVxuICAgICAgICAgICAgICAudW5pb24odHJhbnNsYXRlZEJvdW5kcyhpdGVtLCBpdGVtWydib3VuZHM6cHJldiddKSk7XG4gICAgfSwgbmV3IEJvdW5kcygpKTsgIFxufVxuXG5mdW5jdGlvbiBzZXRCb3VuZHMoZywgYm91bmRzKSB7XG4gIHZhciBiYm94ID0gbnVsbDtcbiAgaWYgKGJvdW5kcykge1xuICAgIGJib3ggPSAobmV3IEJvdW5kcyhib3VuZHMpKS5yb3VuZCgpO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5yZWN0KGJib3gueDEsIGJib3gueTEsIGJib3gud2lkdGgoKSwgYmJveC5oZWlnaHQoKSk7XG4gICAgZy5jbGlwKCk7XG4gIH1cbiAgcmV0dXJuIGJib3g7XG59XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgdmFyIGcgPSB0aGlzLl9jdHgsXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgdyA9IHRoaXMuX3dpZHRoICsgcGFkLmxlZnQgKyBwYWQucmlnaHQsXG4gICAgICBoID0gdGhpcy5faGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20sXG4gICAgICBiYiA9IG51bGwsIGJiMjtcblxuICAvLyBzZXR1cFxuICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICBnLnNhdmUoKTtcbiAgYmIgPSBzZXRCb3VuZHMoZywgZ2V0Qm91bmRzKGl0ZW1zKSk7XG4gIGcuY2xlYXJSZWN0KC1wYWQubGVmdCwgLXBhZC50b3AsIHcsIGgpO1xuXG4gIC8vIHJlbmRlclxuICB0aGlzLmRyYXcoZywgc2NlbmUsIGJiKTtcblxuICAvLyByZW5kZXIgYWdhaW4gdG8gaGFuZGxlIHBvc3NpYmxlIGJvdW5kcyBjaGFuZ2VcbiAgaWYgKGl0ZW1zKSB7XG4gICAgZy5yZXN0b3JlKCk7XG4gICAgZy5zYXZlKCk7XG4gICAgYmIyID0gc2V0Qm91bmRzKGcsIGdldEJvdW5kcyhpdGVtcykpO1xuICAgIGlmICghYmIuZW5jbG9zZXMoYmIyKSkge1xuICAgICAgZy5jbGVhclJlY3QoLXBhZC5sZWZ0LCAtcGFkLnRvcCwgdywgaCk7XG4gICAgICB0aGlzLmRyYXcoZywgc2NlbmUsIGJiMik7XG4gICAgfVxuICB9XG4gIFxuICAvLyB0YWtlZG93blxuICBnLnJlc3RvcmUoKTtcbiAgdGhpcy5fc2NlbmUgPSBudWxsO1xufTtcblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmFyIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICByZW5kZXJlciA9IG1hcmtzLmRyYXdbbWFya3R5cGVdO1xuICByZW5kZXJlci5jYWxsKHRoaXMsIGN0eCwgc2NlbmUsIGJvdW5kcyk7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyQXN5bmMgPSBmdW5jdGlvbihzY2VuZSkge1xuICAvLyBUT0RPIG1ha2Ugc2FmZSBmb3IgbXVsdGlwbGUgc2NlbmUgcmVuZGVyaW5nP1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICBpZiAocmVuZGVyZXIuX2FzeW5jX2lkKSB7XG4gICAgY2xlYXJUaW1lb3V0KHJlbmRlcmVyLl9hc3luY19pZCk7XG4gIH1cbiAgcmVuZGVyZXIuX2FzeW5jX2lkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICByZW5kZXJlci5yZW5kZXIoc2NlbmUpO1xuICAgIGRlbGV0ZSByZW5kZXJlci5fYXN5bmNfaWQ7XG4gIH0sIDUwKTtcbn07XG5cbnByb3RvdHlwZS5sb2FkSW1hZ2UgPSBmdW5jdGlvbih1cmkpIHtcbiAgdmFyIHJlbmRlcmVyID0gdGhpcyxcbiAgICAgIHNjZW5lID0gcmVuZGVyZXIuX3NjZW5lLFxuICAgICAgaW1hZ2UgPSBudWxsLCB1cmw7XG5cbiAgcmVuZGVyZXIuX2ltZ2xvYWQgKz0gMTtcbiAgaWYgKGRsLmlzTm9kZSkge1xuICAgIGltYWdlID0gbmV3ICgodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5jYW52YXMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmNhbnZhcyA6IG51bGwpLkltYWdlKSgpO1xuICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IHVyaX0sIGNvbmZpZy5sb2FkKSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgICBpZiAoZXJyKSB7IGRsLmVycm9yKGVycik7IHJldHVybjsgfVxuICAgICAgaW1hZ2Uuc3JjID0gZGF0YTtcbiAgICAgIGltYWdlLmxvYWRlZCA9IHRydWU7XG4gICAgICByZW5kZXJlci5faW1nbG9hZCAtPSAxO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdXJsID0gY29uZmlnLmJhc2VVUkwgKyB1cmk7XG4gICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuX2ltZ2xvYWQgLT0gMTtcbiAgICAgIHJlbmRlcmVyLnJlbmRlckFzeW5jKHNjZW5lKTtcbiAgICB9O1xuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgfVxuXG4gIHJldHVybiBpbWFnZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhhbmRsZXI6ICByZXF1aXJlKCcuL0hhbmRsZXInKSxcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vUmVuZGVyZXInKVxufTsiLCJ2YXIgQm91bmRzID0gcmVxdWlyZSgnLi4vLi4vY29yZS9Cb3VuZHMnKSxcbiAgICBib3VuZHNDYWxjID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9ib3VuZHMnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpLFxuICAgIHBhdGggPSByZXF1aXJlKCcuL3BhdGgnKTtcblxudmFyIHBhcnNlUGF0aCA9IHBhdGgucGFyc2UsXG4gICAgcmVuZGVyUGF0aCA9IHBhdGgucmVuZGVyLFxuICAgIGhhbGZwaSA9IE1hdGguUEkgLyAyLFxuICAgIHNxcnQzID0gTWF0aC5zcXJ0KDMpLFxuICAgIHRhbjMwID0gTWF0aC50YW4oMzAgKiBNYXRoLlBJIC8gMTgwKSxcbiAgICB0bXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICByZXR1cm4gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbn1cblxuLy8gcGF0aCBnZW5lcmF0b3JzXG5cbmZ1bmN0aW9uIGFyY1BhdGgoZywgbykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgaXIgPSBvLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IG8ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIHNhID0gKG8uc3RhcnRBbmdsZSB8fCAwKSAtIE1hdGguUEkvMixcbiAgICAgIGVhID0gKG8uZW5kQW5nbGUgfHwgMCkgLSBNYXRoLlBJLzI7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIGlmIChpciA9PT0gMCkgZy5tb3ZlVG8oeCwgeSk7XG4gIGVsc2UgZy5hcmMoeCwgeSwgaXIsIHNhLCBlYSwgMCk7XG4gIGcuYXJjKHgsIHksIG9yLCBlYSwgc2EsIDEpO1xuICBnLmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBhcmVhUGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgbSA9IG8ubWFyayxcbiAgICAgIHAgPSBtLnBhdGhDYWNoZSB8fCAobS5wYXRoQ2FjaGUgPSBwYXJzZVBhdGgocGF0aC5hcmVhKGl0ZW1zKSkpO1xuICByZW5kZXJQYXRoKGcsIHApO1xufVxuXG5mdW5jdGlvbiBsaW5lUGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgbSA9IG8ubWFyayxcbiAgICAgIHAgPSBtLnBhdGhDYWNoZSB8fCAobS5wYXRoQ2FjaGUgPSBwYXJzZVBhdGgocGF0aC5saW5lKGl0ZW1zKSkpO1xuICByZW5kZXJQYXRoKGcsIHApO1xufVxuXG5mdW5jdGlvbiBwYXRoUGF0aChnLCBvKSB7XG4gIGlmIChvLnBhdGggPT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlUGF0aChvLnBhdGgpKTtcbiAgcmV0dXJuIHJlbmRlclBhdGgoZywgcCwgby54LCBvLnkpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2xQYXRoKGcsIG8pIHtcbiAgZy5iZWdpblBhdGgoKTtcbiAgdmFyIHNpemUgPSBvLnNpemUgIT0gbnVsbCA/IG8uc2l6ZSA6IDEwMCxcbiAgICAgIHggPSBvLngsIHkgPSBvLnksIHIsIHQsIHJ4LCByeTtcblxuICBpZiAoby5zaGFwZSA9PSBudWxsIHx8IG8uc2hhcGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICByID0gTWF0aC5zcXJ0KHNpemUvTWF0aC5QSSk7XG4gICAgZy5hcmMoeCwgeSwgciwgMCwgMipNYXRoLlBJLCAwKTtcbiAgICBnLmNsb3NlUGF0aCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoby5zaGFwZSkge1xuICAgIGNhc2UgXCJjcm9zc1wiOlxuICAgICAgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgICAgdCA9IDMqcjtcbiAgICAgIGcubW92ZVRvKHgtdCwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgtciwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgtciwgeS10KTtcbiAgICAgIGcubGluZVRvKHgrciwgeS10KTtcbiAgICAgIGcubGluZVRvKHgrciwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgrdCwgeS1yKTtcbiAgICAgIGcubGluZVRvKHgrdCwgeStyKTtcbiAgICAgIGcubGluZVRvKHgrciwgeStyKTtcbiAgICAgIGcubGluZVRvKHgrciwgeSt0KTtcbiAgICAgIGcubGluZVRvKHgtciwgeSt0KTtcbiAgICAgIGcubGluZVRvKHgtciwgeStyKTtcbiAgICAgIGcubGluZVRvKHgtdCwgeStyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgIHJ5ID0gTWF0aC5zcXJ0KHNpemUgLyAoMiAqIHRhbjMwKSk7XG4gICAgICByeCA9IHJ5ICogdGFuMzA7XG4gICAgICBnLm1vdmVUbyh4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHkpO1xuICAgICAgZy5saW5lVG8oeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInNxdWFyZVwiOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGcucmVjdCh4LXIsIHktciwgdCwgdCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS1kb3duXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGcubW92ZVRvKHgsIHkrcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5LXJ5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcInRyaWFuZ2xlLXVwXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeStyeSk7XG4gICAgICBnLmxpbmVUbyh4LXJ4LCB5K3J5KTtcbiAgfVxuICBnLmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBsaW5lU3Ryb2tlKGcsIGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBsdyA9IG8uc3Ryb2tlV2lkdGgsXG4gICAgICBsYyA9IG8uc3Ryb2tlQ2FwO1xuICBnLmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgbGluZVBhdGgoZywgaXRlbXMpO1xufVxuXG5mdW5jdGlvbiBydWxlU3Ryb2tlKGcsIG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwLFxuICAgICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MSxcbiAgICAgIGx3ID0gby5zdHJva2VXaWR0aCxcbiAgICAgIGxjID0gby5zdHJva2VDYXA7XG5cbiAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgZy5saW5lQ2FwICAgPSBsYyAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIGcubW92ZVRvKHgxLCB5MSk7XG4gIGcubGluZVRvKHgyLCB5Mik7XG59XG5cbi8vIGRyYXdpbmcgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIGRyYXdQYXRoT25lKHBhdGgsIGcsIG8sIGl0ZW1zKSB7XG4gIHZhciBmaWxsID0gby5maWxsLCBzdHJva2UgPSBvLnN0cm9rZSwgb3BhYywgbGMsIGx3O1xuXG4gIHBhdGgoZywgaXRlbXMpO1xuXG4gIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gIGlmIChvcGFjID09IDAgfHwgIWZpbGwgJiYgIXN0cm9rZSkgcmV0dXJuO1xuXG4gIGlmIChmaWxsKSB7XG4gICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5maWxsT3BhY2l0eT09bnVsbCA/IDEgOiBvLmZpbGxPcGFjaXR5KTtcbiAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIGZpbGwpO1xuICAgIGcuZmlsbCgpO1xuICB9XG5cbiAgaWYgKHN0cm9rZSkge1xuICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gICAgaWYgKGx3ID4gMCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgc3Ryb2tlKTtcbiAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICAgICAgZy52Z0xpbmVEYXNoKG8uc3Ryb2tlRGFzaCB8fCBudWxsKTtcbiAgICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UGF0aEFsbChwYXRoLCBnLCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBpLCBsZW4sIGl0ZW07XG4gIGZvciAoaT0wLCBsZW49c2NlbmUuaXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHNjZW5lLml0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcbiAgICBkcmF3UGF0aE9uZShwYXRoLCBnLCBpdGVtLCBpdGVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UmVjdChnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgZmlsbCwgc3Ryb2tlLCBvcGFjLCBsYywgbHcsIHgsIHksIHcsIGg7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIHggPSBvLnggfHwgMDtcbiAgICB5ID0gby55IHx8IDA7XG4gICAgdyA9IG8ud2lkdGggfHwgMDtcbiAgICBoID0gby5oZWlnaHQgfHwgMDtcblxuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT0gMCkgY29udGludWU7XG5cbiAgICBpZiAoZmlsbCA9IG8uZmlsbCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5maWxsT3BhY2l0eT09bnVsbCA/IDEgOiBvLmZpbGxPcGFjaXR5KTtcbiAgICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgZmlsbCk7XG4gICAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UgPSBvLnN0cm9rZSkge1xuICAgICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBzdHJva2UpO1xuICAgICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICAgICAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgICAgICBnLnZnTGluZURhc2hPZmZzZXQoby5zdHJva2VEYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgICBnLnN0cm9rZVJlY3QoeCwgeSwgdywgaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdSdWxlKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBzdHJva2UsIG9wYWMsIGxjLCBsdywgeDEsIHkxLCB4MiwgeTI7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbyA9IGl0ZW1zW2ldO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKG8uYm91bmRzKSlcbiAgICAgIGNvbnRpbnVlOyAvLyBib3VuZHMgY2hlY2tcblxuICAgIHgxID0gby54IHx8IDA7XG4gICAgeTEgPSBvLnkgfHwgMDtcbiAgICB4MiA9IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MTtcbiAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MTtcblxuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT0gMCkgY29udGludWU7XG4gICAgXG4gICAgaWYgKHN0cm9rZSA9IG8uc3Ryb2tlKSB7XG4gICAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICAgICAgaWYgKGx3ID4gMCkge1xuICAgICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKGcsIG8sIHN0cm9rZSk7XG4gICAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGcubGluZUNhcCA9IChsYyA9IG8uc3Ryb2tlQ2FwKSAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gICAgICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgICAgIGcudmdMaW5lRGFzaE9mZnNldChvLnN0cm9rZURhc2hPZmZzZXQgfHwgMCk7XG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGcubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGcubGluZVRvKHgyLCB5Mik7XG4gICAgICAgIGcuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdJbWFnZShnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLCBvO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBpZiAoIShvLmltYWdlICYmIG8uaW1hZ2UudXJsID09PSBvLnVybCkpIHtcbiAgICAgIG8uaW1hZ2UgPSByZW5kZXJlci5sb2FkSW1hZ2Uoby51cmwpO1xuICAgICAgby5pbWFnZS51cmwgPSBvLnVybDtcbiAgICB9XG5cbiAgICB2YXIgeCwgeSwgdywgaCwgb3BhYztcbiAgICB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwO1xuICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMDtcbiAgICB4ID0gKG8ueHx8MCkgLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKTtcbiAgICB5ID0gKG8ueXx8MCkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSk7XG5cbiAgICBpZiAoby5pbWFnZS5sb2FkZWQpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSAob3BhYyA9IG8ub3BhY2l0eSkgIT0gbnVsbCA/IG9wYWMgOiAxO1xuICAgICAgZy5kcmF3SW1hZ2Uoby5pbWFnZSwgeCwgeSwgdywgaCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBmaWxsLCBzdHJva2UsIG9wYWMsIGx3LCB4LCB5LCByLCB0O1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBnLmZvbnQgPSBmb250U3RyaW5nKG8pO1xuICAgIGcudGV4dEFsaWduID0gby5hbGlnbiB8fCBcImxlZnRcIjtcbiAgICBnLnRleHRCYXNlbGluZSA9IG8uYmFzZWxpbmUgfHwgXCJhbHBoYWJldGljXCI7XG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09IDApIGNvbnRpbnVlO1xuXG4gICAgeCA9IG8ueCB8fCAwO1xuICAgIHkgPSBvLnkgfHwgMDtcbiAgICBpZiAociA9IG8ucmFkaXVzKSB7XG4gICAgICB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICAgIH1cblxuICAgIGlmIChvLmFuZ2xlKSB7XG4gICAgICBnLnNhdmUoKTtcbiAgICAgIGcudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgZy5yb3RhdGUoby5hbmdsZSAqIE1hdGguUEkvMTgwKTtcbiAgICAgIHggPSBvLmR4IHx8IDA7XG4gICAgICB5ID0gby5keSB8fCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ICs9IChvLmR4IHx8IDApO1xuICAgICAgeSArPSAoby5keSB8fCAwKTtcbiAgICB9XG5cbiAgICBpZiAoZmlsbCA9IG8uZmlsbCkge1xuICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5maWxsT3BhY2l0eT09bnVsbCA/IDEgOiBvLmZpbGxPcGFjaXR5KTtcbiAgICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgZmlsbCk7XG4gICAgICBnLmZpbGxUZXh0KG8udGV4dCwgeCwgeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0cm9rZSA9IG8uc3Ryb2tlKSB7XG4gICAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IDE7XG4gICAgICBpZiAobHcgPiAwKSB7XG4gICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3Iobywgc3Ryb2tlKTtcbiAgICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgICAgZy5zdHJva2VUZXh0KG8udGV4dCwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG8uYW5nbGUpIGcucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdBbGwocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBkcmF3UGF0aEFsbChwYXRoRnVuYywgZywgc2NlbmUsIGJvdW5kcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd09uZShwYXRoRnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oZywgc2NlbmUsIGJvdW5kcykge1xuICAgIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoc2NlbmUuaXRlbXNbMF0uYm91bmRzKSlcbiAgICAgIHJldHVybjsgLy8gYm91bmRzIGNoZWNrXG4gICAgZHJhd1BhdGhPbmUocGF0aEZ1bmMsIGcsIHNjZW5lLml0ZW1zWzBdLCBzY2VuZS5pdGVtcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0dyb3VwKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsIGdyb3VwLCBheGVzLCBsZWdlbmRzLFxuICAgICAgcmVuZGVyZXIgPSB0aGlzLCBneCwgZ3ksIGdiLCBpLCBuLCBqLCBtO1xuXG4gIGRyYXdSZWN0KGcsIHNjZW5lLCBib3VuZHMpO1xuXG4gIGZvciAoaT0wLCBuPWl0ZW1zLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncm91cCA9IGl0ZW1zW2ldO1xuICAgIGF4ZXMgPSBncm91cC5heGlzSXRlbXMgfHwgW107XG4gICAgbGVnZW5kcyA9IGdyb3VwLmxlZ2VuZEl0ZW1zIHx8IFtdO1xuICAgIGd4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGd5ID0gZ3JvdXAueSB8fCAwO1xuXG4gICAgLy8gcmVuZGVyIGdyb3VwIGNvbnRlbnRzXG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBpZiAoZ3JvdXAuY2xpcCkge1xuICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgIGcucmVjdCgwLCAwLCBncm91cC53aWR0aCB8fCAwLCBncm91cC5oZWlnaHQgfHwgMCk7XG4gICAgICBnLmNsaXAoKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG4gICAgXG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIHJlbmRlcmVyLmRyYXcoZywgYXhlc1tqXSwgYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09Z3JvdXAuaXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgcmVuZGVyZXIuZHJhdyhnLCBncm91cC5pdGVtc1tqXSwgYm91bmRzKTtcbiAgICB9XG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgIT09IFwiYmFja1wiKSB7XG4gICAgICAgIHJlbmRlcmVyLmRyYXcoZywgYXhlc1tqXSwgYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICByZW5kZXJlci5kcmF3KGcsIGxlZ2VuZHNbal0sIGJvdW5kcyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBnLnJlc3RvcmUoKTtcbiAgfSAgICBcbn1cblxuZnVuY3Rpb24gY29sb3IoZywgbywgdmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZS5pZClcbiAgICA/IGdyYWRpZW50KGcsIHZhbHVlLCBvLmJvdW5kcylcbiAgICA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBncmFkaWVudChnLCBwLCBiKSB7XG4gIHZhciB3ID0gYi53aWR0aCgpLFxuICAgICAgaCA9IGIuaGVpZ2h0KCksXG4gICAgICB4MSA9IGIueDEgKyBwLngxICogdyxcbiAgICAgIHkxID0gYi55MSArIHAueTEgKiBoLFxuICAgICAgeDIgPSBiLngxICsgcC54MiAqIHcsXG4gICAgICB5MiA9IGIueTEgKyBwLnkyICogaCxcbiAgICAgIGdyYWQgPSBnLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSxcbiAgICAgIHN0b3AgPSBwLnN0b3BzLFxuICAgICAgaSwgbjtcblxuICBmb3IgKGk9MCwgbj1zdG9wLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncmFkLmFkZENvbG9yU3RvcChzdG9wW2ldLm9mZnNldCwgc3RvcFtpXS5jb2xvcik7XG4gIH1cbiAgcmV0dXJuIGdyYWQ7XG59XG5cbi8vIGhpdCB0ZXN0aW5nXG5cbmZ1bmN0aW9uIHBpY2tHcm91cChnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChzY2VuZS5pdGVtcy5sZW5ndGggPT09IDAgfHxcbiAgICAgIHNjZW5lLmJvdW5kcyAmJiAhc2NlbmUuYm91bmRzLmNvbnRhaW5zKGd4LCBneSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsIHN1YnNjZW5lLCBncm91cCwgaGl0LCBkeCwgZHksXG4gICAgICBoYW5kbGVyID0gdGhpcywgaSwgajtcblxuICBmb3IgKGk9aXRlbXMubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgZ3JvdXAgPSBpdGVtc1tpXTtcbiAgICBkeCA9IGdyb3VwLnggfHwgMDtcbiAgICBkeSA9IGdyb3VwLnkgfHwgMDtcblxuICAgIGcuc2F2ZSgpO1xuICAgIGcudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgZm9yIChqPWdyb3VwLml0ZW1zLmxlbmd0aDsgLS1qID49IDA7KSB7XG4gICAgICBzdWJzY2VuZSA9IGdyb3VwLml0ZW1zW2pdO1xuICAgICAgaWYgKHN1YnNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSkgY29udGludWU7XG4gICAgICBoaXQgPSBoYW5kbGVyLnBpY2soc3Vic2NlbmUsIHgsIHksIGd4LWR4LCBneS1keSk7XG4gICAgICBpZiAoaGl0KSB7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgfVxuICAgIH1cbiAgICBnLnJlc3RvcmUoKTtcbiAgfVxuXG4gIHJldHVybiBzY2VuZS5pbnRlcmFjdGl2ZVxuICAgID8gcGlja0FsbChoaXRUZXN0cy5ncm91cCwgZywgc2NlbmUsIHgsIHksIGd4LCBneSlcbiAgICA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwaWNrQWxsKHRlc3QsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIG8sIGIsIGk7XG5cbiAgaWYgKGcuX3JhdGlvICE9PSAxKSB7XG4gICAgeCAqPSBnLl9yYXRpbztcbiAgICB5ICo9IGcuX3JhdGlvO1xuICB9XG5cbiAgZm9yIChpPXNjZW5lLml0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgbyA9IHNjZW5lLml0ZW1zW2ldOyBiID0gby5ib3VuZHM7XG4gICAgLy8gZmlyc3QgaGl0IHRlc3QgYWdhaW5zdCBib3VuZGluZyBib3hcbiAgICBpZiAoKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgfHwgIWIpIGNvbnRpbnVlO1xuICAgIC8vIGlmIGluIGJvdW5kaW5nIGJveCwgcGVyZm9ybSBtb3JlIGNhcmVmdWwgdGVzdFxuICAgIGlmICh0ZXN0KGcsIG8sIHgsIHksIGd4LCBneSkpIHJldHVybiBvO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGlja0FyZWEoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGIsIGksIGRpLCBkZCwgb2QsIGR4LCBkeTtcblxuICBiID0gaXRlbXNbMF0uYm91bmRzO1xuICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChnLl9yYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5fcmF0aW87XG4gICAgeSAqPSBnLl9yYXRpbztcbiAgfVxuICBpZiAoIWhpdFRlc3RzLmFyZWEoZywgaXRlbXMsIHgsIHkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVtc1swXTtcbn1cblxuZnVuY3Rpb24gcGlja0xpbmUoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGIsIGksIGRpLCBkZCwgb2QsIGR4LCBkeTtcblxuICBiID0gaXRlbXNbMF0uYm91bmRzO1xuICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSByZXR1cm4gZmFsc2U7XG4gIGlmIChnLl9yYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5fcmF0aW87XG4gICAgeSAqPSBnLl9yYXRpbztcbiAgfVxuICBpZiAoIWhpdFRlc3RzLmxpbmUoZywgaXRlbXMsIHgsIHkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBpdGVtc1swXTtcbn1cblxuZnVuY3Rpb24gcGljayh0ZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICAgIHJldHVybiBwaWNrQWxsKHRlc3QsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0SGl0KGcsIG8sIHgsIHksIGd4LCBneSkge1xuICBpZiAoIW8uZm9udFNpemUpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFvLmFuZ2xlKSByZXR1cm4gdHJ1ZTsgLy8gYm91bmRzIHN1ZmZpY2llbnQgaWYgbm8gcm90YXRpb25cblxuICB2YXIgYiA9IGJvdW5kc0NhbGMudGV4dChvLCB0bXBCb3VuZHMsIHRydWUpLFxuICAgICAgYSA9IC1vLmFuZ2xlICogTWF0aC5QSSAvIDE4MCxcbiAgICAgIGNvcyA9IE1hdGguY29zKGEpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYSksXG4gICAgICB4ID0gby54LFxuICAgICAgeSA9IG8ueSxcbiAgICAgIHB4ID0gY29zKmd4IC0gc2luKmd5ICsgKHggLSB4KmNvcyArIHkqc2luKSxcbiAgICAgIHB5ID0gc2luKmd4ICsgY29zKmd5ICsgKHkgLSB4KnNpbiAtIHkqY29zKTtcblxuICByZXR1cm4gYi5jb250YWlucyhweCwgcHkpO1xufVxuXG52YXIgaGl0VGVzdHMgPSB7XG4gIHRleHQ6ICAgdGV4dEhpdCxcbiAgcmVjdDogICBmdW5jdGlvbihnLG8seCx5KSB7IHJldHVybiB0cnVlOyB9LCAvLyBib3VuZHMgdGVzdCBpcyBzdWZmaWNpZW50XG4gIGltYWdlOiAgZnVuY3Rpb24oZyxvLHgseSkgeyByZXR1cm4gdHJ1ZTsgfSwgLy8gYm91bmRzIHRlc3QgaXMgc3VmZmljaWVudFxuICBncm91cDogIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcmV0dXJuIG8uZmlsbCB8fCBvLnN0cm9rZTsgfSxcbiAgcnVsZTogICBmdW5jdGlvbihnLG8seCx5KSB7XG4gICAgICAgICAgICBpZiAoIWcuaXNQb2ludEluU3Ryb2tlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBydWxlU3Ryb2tlKGcsbyk7IHJldHVybiBnLmlzUG9pbnRJblN0cm9rZSh4LHkpO1xuICAgICAgICAgIH0sXG4gIGxpbmU6ICAgZnVuY3Rpb24oZyxzLHgseSkge1xuICAgICAgICAgICAgaWYgKCFnLmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGluZVN0cm9rZShnLHMpOyByZXR1cm4gZy5pc1BvaW50SW5TdHJva2UoeCx5KTtcbiAgICAgICAgICB9LFxuICBhcmM6ICAgIGZ1bmN0aW9uKGcsbyx4LHkpIHsgYXJjUGF0aChnLG8pOyAgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9LFxuICBhcmVhOiAgIGZ1bmN0aW9uKGcscyx4LHkpIHsgYXJlYVBhdGgoZyxzKTsgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9LFxuICBwYXRoOiAgIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcGF0aFBhdGgoZyxvKTsgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9LFxuICBzeW1ib2w6IGZ1bmN0aW9uKGcsbyx4LHkpIHsgc3ltYm9sUGF0aChnLG8pOyByZXR1cm4gZy5pc1BvaW50SW5QYXRoKHgseSk7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB7XG4gICAgZ3JvdXA6ICAgZHJhd0dyb3VwLFxuICAgIGFyZWE6ICAgIGRyYXdPbmUoYXJlYVBhdGgpLFxuICAgIGxpbmU6ICAgIGRyYXdPbmUobGluZVBhdGgpLFxuICAgIGFyYzogICAgIGRyYXdBbGwoYXJjUGF0aCksXG4gICAgcGF0aDogICAgZHJhd0FsbChwYXRoUGF0aCksXG4gICAgc3ltYm9sOiAgZHJhd0FsbChzeW1ib2xQYXRoKSxcbiAgICByZWN0OiAgICBkcmF3UmVjdCxcbiAgICBydWxlOiAgICBkcmF3UnVsZSxcbiAgICB0ZXh0OiAgICBkcmF3VGV4dCxcbiAgICBpbWFnZTogICBkcmF3SW1hZ2UsXG4gICAgZHJhd09uZTogZHJhd09uZSwgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gICAgZHJhd0FsbDogZHJhd0FsbCAgLy8gZXhwb3NlIGZvciBleHRlbnNpYmlsaXR5XG4gIH0sXG4gIHBpY2s6IHtcbiAgICBncm91cDogICBwaWNrR3JvdXAsXG4gICAgYXJlYTogICAgcGlja0FyZWEsXG4gICAgbGluZTogICAgcGlja0xpbmUsXG4gICAgYXJjOiAgICAgcGljayhoaXRUZXN0cy5hcmMpLFxuICAgIHBhdGg6ICAgIHBpY2soaGl0VGVzdHMucGF0aCksXG4gICAgc3ltYm9sOiAgcGljayhoaXRUZXN0cy5zeW1ib2wpLFxuICAgIHJlY3Q6ICAgIHBpY2soaGl0VGVzdHMucmVjdCksXG4gICAgcnVsZTogICAgcGljayhoaXRUZXN0cy5ydWxlKSxcbiAgICB0ZXh0OiAgICBwaWNrKGhpdFRlc3RzLnRleHQpLFxuICAgIGltYWdlOiAgIHBpY2soaGl0VGVzdHMuaW1hZ2UpLFxuICAgIHBpY2tBbGw6IHBpY2tBbGwgIC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICB9XG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRzJyk7XG5cbi8vIFBhdGggcGFyc2luZyBhbmQgcmVuZGVyaW5nIGNvZGUgdGFrZW4gZnJvbSBmYWJyaWMuanMgLS0gVGhhbmtzIVxudmFyIGNtZExlbmd0aCA9IHsgbToyLCBsOjIsIGg6MSwgdjoxLCBjOjYsIHM6NCwgcTo0LCB0OjIsIGE6NyB9LFxuICAgIHJlID0gWy8oW01MSFZDU1FUQVptbGh2Y3NxdGF6XSkvZywgLyMjIy8sIC8oXFxkKS0vZywgL1xcc3wsfCMjIy9dO1xuXG5mdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIGN1cnJlbnRQYXRoLFxuICAgICAgY2h1bmtzLFxuICAgICAgcGFyc2VkO1xuXG4gIC8vIEZpcnN0LCBicmVhayBwYXRoIGludG8gY29tbWFuZCBzZXF1ZW5jZVxuICBwYXRoID0gcGF0aC5zbGljZSgpLnJlcGxhY2UocmVbMF0sICcjIyMkMScpLnNwbGl0KHJlWzFdKS5zbGljZSgxKTtcblxuICAvLyBOZXh0LCBwYXJzZSBlYWNoIGNvbW1hbmQgaW4gdHVyblxuICBmb3IgKHZhciBpPTAsIGosIGNodW5rc1BhcnNlZCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgaSsrKSB7XG4gICAgY3VycmVudFBhdGggPSBwYXRoW2ldO1xuICAgIGNodW5rcyA9IGN1cnJlbnRQYXRoLnNsaWNlKDEpLnRyaW0oKS5yZXBsYWNlKHJlWzJdLCckMSMjIy0nKS5zcGxpdChyZVszXSk7XG4gICAgY2h1bmtzUGFyc2VkID0gW2N1cnJlbnRQYXRoLmNoYXJBdCgwKV07XG5cbiAgICBmb3IgKHZhciBqID0gMCwgamxlbiA9IGNodW5rcy5sZW5ndGg7IGogPCBqbGVuOyBqKyspIHtcbiAgICAgIHBhcnNlZCA9IHBhcnNlRmxvYXQoY2h1bmtzW2pdKTtcbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSkge1xuICAgICAgICBjaHVua3NQYXJzZWQucHVzaChwYXJzZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb21tYW5kID0gY2h1bmtzUGFyc2VkWzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGNvbW1hbmRMZW5ndGggPSBjbWRMZW5ndGhbY29tbWFuZF07XG5cbiAgICBpZiAoY2h1bmtzUGFyc2VkLmxlbmd0aCAtIDEgPiBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMSwga2xlbiA9IGNodW5rc1BhcnNlZC5sZW5ndGg7IGsgPCBrbGVuOyBrICs9IGNvbW1hbmRMZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goWyBjaHVua3NQYXJzZWRbMF0gXS5jb25jYXQoY2h1bmtzUGFyc2VkLnNsaWNlKGssIGsgKyBjb21tYW5kTGVuZ3RoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNodW5rc1BhcnNlZCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZHJhd0FyYyhnLCB4LCB5LCBjb29yZHMsIGJvdW5kcywgbCwgdCkge1xuICB2YXIgcnggPSBjb29yZHNbMF07XG4gIHZhciByeSA9IGNvb3Jkc1sxXTtcbiAgdmFyIHJvdCA9IGNvb3Jkc1syXTtcbiAgdmFyIGxhcmdlID0gY29vcmRzWzNdO1xuICB2YXIgc3dlZXAgPSBjb29yZHNbNF07XG4gIHZhciBleCA9IGNvb3Jkc1s1XTtcbiAgdmFyIGV5ID0gY29vcmRzWzZdO1xuICB2YXIgc2VncyA9IGFyY1RvU2VnbWVudHMoZXgsIGV5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90LCB4LCB5KTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmV6ID0gc2VnbWVudFRvQmV6aWVyLmFwcGx5KG51bGwsIHNlZ3NbaV0pO1xuICAgIGcuYmV6aWVyQ3VydmVUby5hcHBseShnLCBiZXopO1xuICAgIGJvdW5kcy5hZGQoYmV6WzBdLWwsIGJlelsxXS10KTtcbiAgICBib3VuZHMuYWRkKGJlelsyXS1sLCBiZXpbM10tdCk7XG4gICAgYm91bmRzLmFkZChiZXpbNF0tbCwgYmV6WzVdLXQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kQXJjKHgsIHksIGNvb3JkcywgYm91bmRzKSB7XG4gIHZhciByeCA9IGNvb3Jkc1swXTtcbiAgdmFyIHJ5ID0gY29vcmRzWzFdO1xuICB2YXIgcm90ID0gY29vcmRzWzJdO1xuICB2YXIgbGFyZ2UgPSBjb29yZHNbM107XG4gIHZhciBzd2VlcCA9IGNvb3Jkc1s0XTtcbiAgdmFyIGV4ID0gY29vcmRzWzVdO1xuICB2YXIgZXkgPSBjb29yZHNbNl07XG4gIHZhciBzZWdzID0gYXJjVG9TZWdtZW50cyhleCwgZXksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3QsIHgsIHkpO1xuICBmb3IgKHZhciBpPTA7IGk8c2Vncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiZXogPSBzZWdtZW50VG9CZXppZXIuYXBwbHkobnVsbCwgc2Vnc1tpXSk7XG4gICAgYm91bmRzLmFkZChiZXpbMF0sIGJlelsxXSk7XG4gICAgYm91bmRzLmFkZChiZXpbMl0sIGJlelszXSk7XG4gICAgYm91bmRzLmFkZChiZXpbNF0sIGJlels1XSk7XG4gIH1cbn1cblxudmFyIGFyY1RvU2VnbWVudHNDYWNoZSA9IHsgfSxcbiAgICBzZWdtZW50VG9CZXppZXJDYWNoZSA9IHsgfSxcbiAgICBqb2luID0gQXJyYXkucHJvdG90eXBlLmpvaW4sXG4gICAgYXJnc1N0cjtcblxuLy8gQ29waWVkIGZyb20gSW5rc2NhcGUgc3ZndG9wZGYsIHRoYW5rcyFcbmZ1bmN0aW9uIGFyY1RvU2VnbWVudHMoeCwgeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgsIG94LCBveSkge1xuICBhcmdzU3RyID0gam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cl0pIHtcbiAgICByZXR1cm4gYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJdO1xuICB9XG5cbiAgdmFyIHRoID0gcm90YXRlWCAqIChNYXRoLlBJLzE4MCk7XG4gIHZhciBzaW5fdGggPSBNYXRoLnNpbih0aCk7XG4gIHZhciBjb3NfdGggPSBNYXRoLmNvcyh0aCk7XG4gIHJ4ID0gTWF0aC5hYnMocngpO1xuICByeSA9IE1hdGguYWJzKHJ5KTtcbiAgdmFyIHB4ID0gY29zX3RoICogKG94IC0geCkgKiAwLjUgKyBzaW5fdGggKiAob3kgLSB5KSAqIDAuNTtcbiAgdmFyIHB5ID0gY29zX3RoICogKG95IC0geSkgKiAwLjUgLSBzaW5fdGggKiAob3ggLSB4KSAqIDAuNTtcbiAgdmFyIHBsID0gKHB4KnB4KSAvIChyeCpyeCkgKyAocHkqcHkpIC8gKHJ5KnJ5KTtcbiAgaWYgKHBsID4gMSkge1xuICAgIHBsID0gTWF0aC5zcXJ0KHBsKTtcbiAgICByeCAqPSBwbDtcbiAgICByeSAqPSBwbDtcbiAgfVxuXG4gIHZhciBhMDAgPSBjb3NfdGggLyByeDtcbiAgdmFyIGEwMSA9IHNpbl90aCAvIHJ4O1xuICB2YXIgYTEwID0gKC1zaW5fdGgpIC8gcnk7XG4gIHZhciBhMTEgPSAoY29zX3RoKSAvIHJ5O1xuICB2YXIgeDAgPSBhMDAgKiBveCArIGEwMSAqIG95O1xuICB2YXIgeTAgPSBhMTAgKiBveCArIGExMSAqIG95O1xuICB2YXIgeDEgPSBhMDAgKiB4ICsgYTAxICogeTtcbiAgdmFyIHkxID0gYTEwICogeCArIGExMSAqIHk7XG5cbiAgdmFyIGQgPSAoeDEteDApICogKHgxLXgwKSArICh5MS15MCkgKiAoeTEteTApO1xuICB2YXIgc2ZhY3Rvcl9zcSA9IDEgLyBkIC0gMC4yNTtcbiAgaWYgKHNmYWN0b3Jfc3EgPCAwKSBzZmFjdG9yX3NxID0gMDtcbiAgdmFyIHNmYWN0b3IgPSBNYXRoLnNxcnQoc2ZhY3Rvcl9zcSk7XG4gIGlmIChzd2VlcCA9PSBsYXJnZSkgc2ZhY3RvciA9IC1zZmFjdG9yO1xuICB2YXIgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxLXkwKTtcbiAgdmFyIHljID0gMC41ICogKHkwICsgeTEpICsgc2ZhY3RvciAqICh4MS14MCk7XG5cbiAgdmFyIHRoMCA9IE1hdGguYXRhbjIoeTAteWMsIHgwLXhjKTtcbiAgdmFyIHRoMSA9IE1hdGguYXRhbjIoeTEteWMsIHgxLXhjKTtcblxuICB2YXIgdGhfYXJjID0gdGgxLXRoMDtcbiAgaWYgKHRoX2FyYyA8IDAgJiYgc3dlZXAgPT0gMSl7XG4gICAgdGhfYXJjICs9IDIqTWF0aC5QSTtcbiAgfSBlbHNlIGlmICh0aF9hcmMgPiAwICYmIHN3ZWVwID09IDApIHtcbiAgICB0aF9hcmMgLT0gMiAqIE1hdGguUEk7XG4gIH1cblxuICB2YXIgc2VnbWVudHMgPSBNYXRoLmNlaWwoTWF0aC5hYnModGhfYXJjIC8gKE1hdGguUEkgKiAwLjUgKyAwLjAwMSkpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBpPTA7IGk8c2VnbWVudHM7IGkrKykge1xuICAgIHZhciB0aDIgPSB0aDAgKyBpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgdmFyIHRoMyA9IHRoMCArIChpKzEpICogdGhfYXJjIC8gc2VnbWVudHM7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG5cbiAgcmV0dXJuIChhcmNUb1NlZ21lbnRzQ2FjaGVbYXJnc1N0cl0gPSByZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBzZWdtZW50VG9CZXppZXIoY3gsIGN5LCB0aDAsIHRoMSwgcngsIHJ5LCBzaW5fdGgsIGNvc190aCkge1xuICBhcmdzU3RyID0gam9pbi5jYWxsKGFyZ3VtZW50cyk7XG4gIGlmIChzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyXSkge1xuICAgIHJldHVybiBzZWdtZW50VG9CZXppZXJDYWNoZVthcmdzU3RyXTtcbiAgfVxuXG4gIHZhciBhMDAgPSBjb3NfdGggKiByeDtcbiAgdmFyIGEwMSA9IC1zaW5fdGggKiByeTtcbiAgdmFyIGExMCA9IHNpbl90aCAqIHJ4O1xuICB2YXIgYTExID0gY29zX3RoICogcnk7XG5cbiAgdmFyIGNvc190aDAgPSBNYXRoLmNvcyh0aDApO1xuICB2YXIgc2luX3RoMCA9IE1hdGguc2luKHRoMCk7XG4gIHZhciBjb3NfdGgxID0gTWF0aC5jb3ModGgxKTtcbiAgdmFyIHNpbl90aDEgPSBNYXRoLnNpbih0aDEpO1xuXG4gIHZhciB0aF9oYWxmID0gMC41ICogKHRoMSAtIHRoMCk7XG4gIHZhciBzaW5fdGhfaDIgPSBNYXRoLnNpbih0aF9oYWxmICogMC41KTtcbiAgdmFyIHQgPSAoOC8zKSAqIHNpbl90aF9oMiAqIHNpbl90aF9oMiAvIE1hdGguc2luKHRoX2hhbGYpO1xuICB2YXIgeDEgPSBjeCArIGNvc190aDAgLSB0ICogc2luX3RoMDtcbiAgdmFyIHkxID0gY3kgKyBzaW5fdGgwICsgdCAqIGNvc190aDA7XG4gIHZhciB4MyA9IGN4ICsgY29zX3RoMTtcbiAgdmFyIHkzID0gY3kgKyBzaW5fdGgxO1xuICB2YXIgeDIgPSB4MyArIHQgKiBzaW5fdGgxO1xuICB2YXIgeTIgPSB5MyAtIHQgKiBjb3NfdGgxO1xuXG4gIHJldHVybiAoc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cl0gPSBbXG4gICAgYTAwICogeDEgKyBhMDEgKiB5MSwgIGExMCAqIHgxICsgYTExICogeTEsXG4gICAgYTAwICogeDIgKyBhMDEgKiB5MiwgIGExMCAqIHgyICsgYTExICogeTIsXG4gICAgYTAwICogeDMgKyBhMDEgKiB5MywgIGExMCAqIHgzICsgYTExICogeTNcbiAgXSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcihnLCBwYXRoLCBsLCB0KSB7XG4gIHZhciBjdXJyZW50LCAvLyBjdXJyZW50IGluc3RydWN0aW9uXG4gICAgICBwcmV2aW91cyA9IG51bGwsXG4gICAgICB4ID0gMCwgLy8gY3VycmVudCB4XG4gICAgICB5ID0gMCwgLy8gY3VycmVudCB5XG4gICAgICBjb250cm9sWCA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgICBjb250cm9sWSA9IDAsIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgICB0ZW1wWCxcbiAgICAgIHRlbXBZLFxuICAgICAgdGVtcENvbnRyb2xYLFxuICAgICAgdGVtcENvbnRyb2xZLFxuICAgICAgYm91bmRzID0gbmV3IEJvdW5kcygpO1xuICBpZiAobCA9PSB1bmRlZmluZWQpIGwgPSAwO1xuICBpZiAodCA9PSB1bmRlZmluZWQpIHQgPSAwO1xuXG4gIGcuYmVnaW5QYXRoKCk7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsIC8vIHkxXG4gICAgICAgICAgY29udHJvbFggKyBsLCAvLyB4MlxuICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBsLFxuICAgICAgICAgIHkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgeCArIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIHkgKyBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMip4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMip5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIGN1cnJlbnRbMV0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY3VycmVudFsxXSwgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICAvLyBzZXQgY29udHJvbCBwb2ludCB0byAybmQgb25lIG9mIHRoaXMgY29tbWFuZFxuICAgICAgICAvLyBcIi4uLiB0aGUgZmlyc3QgY29udHJvbCBwb2ludCBpcyBhc3N1bWVkIHRvIGJlIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludCBvbiB0aGUgcHJldmlvdXMgY29tbWFuZCByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb2ludC5cIlxuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcblxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGRyYXdBcmMoZywgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0gKyB4ICsgbCxcbiAgICAgICAgICBjdXJyZW50WzddICsgeSArIHRcbiAgICAgICAgXSwgYm91bmRzLCBsLCB0KTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgZHJhd0FyYyhnLCB4ICsgbCwgeSArIHQsIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHRcbiAgICAgICAgXSwgYm91bmRzLCBsLCB0KTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuICByZXR1cm4gYm91bmRzLnRyYW5zbGF0ZShsLCB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmRzKHBhdGgsIGJvdW5kcykge1xuICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgY29udHJvbFkgPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICAgICAgdGVtcFgsXG4gICAgICB0ZW1wWSxcbiAgICAgIHRlbXBDb250cm9sWCxcbiAgICAgIHRlbXBDb250cm9sWTtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuXG4gICAgc3dpdGNoIChjdXJyZW50WzBdKSB7IC8vIGZpcnN0IGxldHRlclxuXG4gICAgICBjYXNlICdsJzogLy8gbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0wnOiAvLyBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnSCc6IC8vIGhvcml6b250YWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3YnOiAvLyB2ZXJ0aWNhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHkgKz0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1YnOiAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtJzogLy8gbW92ZVRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgKz0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ00nOiAvLyBtb3ZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICB5ID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2MnOiAvLyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzVdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzRdO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1MnOiAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMip4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMip5IC0gY29udHJvbFk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdRJzogLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3QnOiAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgaWYgKHByZXZpb3VzWzBdLm1hdGNoKC9bUXFUdF0vKSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHByZXZpb3VzIGNvbW1hbmQgb3IgaWYgdGhlIHByZXZpb3VzIGNvbW1hbmQgd2FzIG5vdCBhIFEsIHEsIFQgb3IgdCxcbiAgICAgICAgICAvLyBhc3N1bWUgdGhlIGNvbnRyb2wgcG9pbnQgaXMgY29pbmNpZGVudCB3aXRoIHRoZSBjdXJyZW50IHBvaW50XG4gICAgICAgICAgY29udHJvbFggPSB4O1xuICAgICAgICAgIGNvbnRyb2xZID0geTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3QnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHRcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gdGVtcENvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSB0ZW1wQ29udHJvbFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICdxJykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciBxXG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlbXBDb250cm9sWCA9IGNvbnRyb2xYO1xuICAgICAgICB0ZW1wQ29udHJvbFkgPSBjb250cm9sWTtcblxuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdUJzpcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGJvdW5kQXJjKHgsIHksIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSArIHgsXG4gICAgICAgICAgY3VycmVudFs3XSArIHlcbiAgICAgICAgXSwgYm91bmRzKTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgYm91bmRBcmMoeCwgeSwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdLFxuICAgICAgICAgIGN1cnJlbnRbN11cbiAgICAgICAgXSwgYm91bmRzKTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBhcmVhKGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIHZhciBhcmVhID0gZDMuc3ZnLmFyZWEoKVxuICAgIC54KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueDsgfSlcbiAgICAueTEoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55OyB9KVxuICAgIC55MChmdW5jdGlvbihkKSB7IHJldHVybiBkLnkgKyBkLmhlaWdodDsgfSk7XG4gIGlmIChvLmludGVycG9sYXRlKSBhcmVhLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUpO1xuICBpZiAoby50ZW5zaW9uICE9IG51bGwpIGFyZWEudGVuc2lvbihvLnRlbnNpb24pO1xuICByZXR1cm4gYXJlYShpdGVtcyk7XG59XG5cbmZ1bmN0aW9uIGxpbmUoaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgdmFyIGxpbmUgPSBkMy5zdmcubGluZSgpXG4gICAueChmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pXG4gICAueShmdW5jdGlvbihkKSB7IHJldHVybiBkLnk7IH0pO1xuICBpZiAoby5pbnRlcnBvbGF0ZSkgbGluZS5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlKTtcbiAgaWYgKG8udGVuc2lvbiAhPSBudWxsKSBsaW5lLnRlbnNpb24oby50ZW5zaW9uKTtcbiAgcmV0dXJuIGxpbmUoaXRlbXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2U6ICBwYXJzZSxcbiAgcmVuZGVyOiByZW5kZXIsXG4gIGJvdW5kczogYm91bmRzLFxuICBhcmVhOiAgIGFyZWEsXG4gIGxpbmU6ICAgbGluZVxufTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpLFxuICAgIFNWR0J1aWxkZXIgPSByZXF1aXJlKCcuL3N2ZycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fYnVpbGRlciA9IG51bGw7XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fYnVpbGRlciA9IG5ldyBTVkdCdWlsZGVyKCk7XG4gIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwYWQpO1xufVxuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZCB8fCB7dG9wOjAsIGxlZnQ6MCwgYm90dG9tOjAsIHJpZ2h0OjB9O1xuICB0aGlzLl9hdXRvcGFkID0gZGwuaXNTdHJpbmcodGhpcy5fcGFkZGluZykgPyAxIDogMDtcblxuICB2YXIgdyA9IHRoaXMuX3dpZHRoLCBoID0gdGhpcy5faGVpZ2h0LCBwYWQgPSB0aGlzLl9wYWRkaW5nO1xuICBcbiAgLy8gKHJlLSljb25maWd1cmUgYnVpbGRlciBzaXplXG4gIHRoaXMuX2J1aWxkZXIuaW5pdGlhbGl6ZShudWxsLCB3LCBoLCBwYWQpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lLCBpdGVtcykge1xuICAvLyBoZWFkbGVzcyBhbHdheXMgZHJhd3MgdGhlIGVudGlyZSBzY2VuZSwgaWdub3JpbmcgaXRlbXNcbiAgdGhpcy5fYnVpbGRlci5yZW5kZXIoc2NlbmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2J1aWxkZXIuc3ZnKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1JlbmRlcmVyJylcbn07XG4iLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpO1xuXG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZ2lkID0gMDsgLy8gZ3JvdXAgaWQgY291bnRlciBmb3IgZDMgZG9tIGNvbXBhdFxuICB0aGlzLl90ZXh0ID0ge1xuICAgIGhlYWQ6IFwiXCIsXG4gICAgcm9vdDogXCJcIixcbiAgICBmb290OiBcIlwiLFxuICAgIGRlZnM6IFwiXCIsXG4gICAgYm9keTogXCJcIlxuICB9O1xuICB0aGlzLl9kZWZzID0ge1xuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIG9wZW4odGFnLCBhdHRyLCByYXcpIHtcbiAgdmFyIHMgPSBcIjxcIiArIHRhZztcbiAgaWYgKGF0dHIpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gYXR0cikge1xuICAgICAgdmFyIHZhbCA9IGF0dHJba2V5XTtcbiAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xuICAgICAgICBzICs9IFwiIFwiICsga2V5ICsgJz1cIicgKyB2YWwgKyAnXCInO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocmF3KSBzICs9IFwiIFwiICsgcmF3O1xuICByZXR1cm4gcyArIFwiPlwiO1xufVxuXG5mdW5jdGlvbiBjbG9zZSh0YWcpIHtcbiAgcmV0dXJuIFwiPC9cIiArIHRhZyArIFwiPlwiO1xufVxuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3LCBoLCBwYWQpIHtcbiAgdmFyIHQgPSB0aGlzLl90ZXh0O1xuXG4gIHQuaGVhZCA9IG9wZW4oJ3N2ZycsIHtcbiAgICBcImNsYXNzXCI6ICdtYXJrcycsXG4gICAgd2lkdGg6IHcgKyBwYWQubGVmdCArIHBhZC5yaWdodCxcbiAgICBoZWlnaHQ6IGggKyBwYWQudG9wICsgcGFkLmJvdHRvbSxcbiAgfSwgY29uZmlnLnN2Z05hbWVzcGFjZSk7XG5cbiAgdC5yb290ID0gb3BlbignZycsIHtcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHBhZC5sZWZ0ICsgJywnICsgcGFkLnRvcCArICcpJ1xuICB9KTtcblxuICB0LmZvb3QgPSBjbG9zZSgnZycpICsgY2xvc2UoJ3N2ZycpO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuX3RleHQ7XG4gIHJldHVybiB0LmhlYWQgKyB0LmRlZnMgKyB0LnJvb3QgKyB0LmJvZHkgKyB0LmZvb3Q7XG59O1xuXG5wcm90b3R5cGUuYnVpbGREZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbGwgPSB0aGlzLl9kZWZzLFxuICAgICAgZGdyYWQgPSBkbC5rZXlzKGFsbC5ncmFkaWVudCksXG4gICAgICBkY2xpcCA9IGRsLmtleXMoYWxsLmNsaXBwaW5nKSxcbiAgICAgIGRlZnMgPSBcIlwiLCBncmFkLCBjbGlwLCBpLCBqO1xuXG4gIGZvciAoaT0wOyBpPGRncmFkLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGlkID0gZGdyYWRbaV0sXG4gICAgICAgIGRlZiA9IGFsbC5ncmFkaWVudFtpZF0sXG4gICAgICAgIHN0b3BzID0gZGVmLnN0b3BzO1xuXG4gICAgZGVmcyArPSBvcGVuKFwibGluZWFyR3JhZGllbnRcIiwge1xuICAgICAgaWQ6IGlkLFxuICAgICAgeDE6IGRlZi54MSxcbiAgICAgIHgyOiBkZWYueDIsXG4gICAgICB5MTogZGVmLnkxLFxuICAgICAgeTI6IGRlZi55MlxuICAgIH0pO1xuICAgIFxuICAgIGZvciAoaj0wOyBqPHN0b3BzLmxlbmd0aDsgKytqKSB7XG4gICAgICBkZWZzICs9IG9wZW4oXCJzdG9wXCIsIHtcbiAgICAgICAgb2Zmc2V0OiBzdG9wc1tqXS5vZmZzZXQsXG4gICAgICAgIFwic3RvcC1jb2xvclwiOiBzdG9wc1tqXS5jb2xvclxuICAgICAgfSkgKyBjbG9zZShcInN0b3BcIik7XG4gICAgfVxuICAgIFxuICAgIGRlZnMgKz0gY2xvc2UoXCJsaW5lYXJHcmFkaWVudFwiKTtcbiAgfVxuICBcbiAgZm9yIChpPTA7IGk8ZGNsaXAubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaWQgPSBkY2xpcFtpXSxcbiAgICAgICAgZGVmID0gYWxsLmNsaXBwaW5nW2lkXTtcblxuICAgIGRlZnMgKz0gb3BlbihcImNsaXBQYXRoXCIsIHtpZDogaWR9KTtcblxuICAgIGRlZnMgKz0gb3BlbihcInJlY3RcIiwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZGVmLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkZWYuaGVpZ2h0XG4gICAgfSkgKyBjbG9zZShcInJlY3RcIik7XG5cbiAgICBkZWZzICs9IGNsb3NlKFwiY2xpcFBhdGhcIik7XG4gIH1cbiAgXG4gIGlmIChkZWZzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gb3BlbihcImRlZnNcIikgKyBkZWZzICsgY2xvc2UoXCJkZWZzXCIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiXG4gIH1cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdGhpcy5fZ2lkID0gMDsgLy8gcmVzZXQgdGhlIGdyb3VwIGNvdW50ZXJcbiAgdGhpcy5fdGV4dC5ib2R5ID0gdGhpcy5kcmF3KHNjZW5lKTtcbiAgdGhpcy5fdGV4dC5kZWZzID0gdGhpcy5idWlsZERlZnMoKTtcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIG1ldGEgPSBNQVJLU1tzY2VuZS5tYXJrdHlwZV07XG4gIGlmICghbWV0YSkge1xuICAgIHJldHVybjsgLy8gbm8ga25vd24gbWFya3R5cGUgKGUuZy4sIGFuIGludGVyYWN0b3IpXG4gIH1cbiAgdmFyIHRhZyAgPSBtZXRhWzBdLFxuICAgICAgYXR0ciA9IG1ldGFbMV0sXG4gICAgICBuZXN0ID0gbWV0YVsyXSB8fCBmYWxzZSxcbiAgICAgIGRhdGEgPSBuZXN0ID8gW3NjZW5lLml0ZW1zXSA6IHNjZW5lLml0ZW1zLFxuICAgICAgZGVmcyA9IHRoaXMuX2RlZnMsXG4gICAgICBzdmcgPSBcIlwiLCBpLCBzdHk7XG5cbiAgdmFyIGNscyA9IGNzc0NsYXNzKHNjZW5lLmRlZik7XG5cbiAgLy8gc3R5bGUgbGl0ZXJhbHMgdG8gZXhhY3RseSBtYXRjaCB0aGUgZDMgZG9tXG4gIHZhciBzdHlsID0gbnVsbDtcbiAgaWYgKGNscyA9PT0gJ3R5cGUtcnVsZScgfHwgY2xzID09PSAndHlwZS1wYXRoJylcbiAgICBzdHlsID0gJ3N0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCInO1xuICBlbHNlIGlmIChjbHMgIT09ICd0eXBlLWdyb3VwJylcbiAgICBzdHlsID0gJ3N0eWxlPVwiXCInO1xuXG4gIHN2ZyArPSBvcGVuKCdnJywge1xuICAgICdpZCc6ICdnJyArICsrdGhpcy5fZ2lkLCAvLyBkMyBkb20gY29tcGF0XG4gICAgJ2NsYXNzJzogY3NzQ2xhc3Moc2NlbmUuZGVmKVxuICB9LCBzdHlsKTtcblxuICBmb3IgKGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHN0eSA9IHRhZyA9PT0gJ2cnID8gbnVsbCA6IHN0eWxlKGRhdGFbaV0sIHRhZywgZGVmcyk7XG4gICAgc3ZnICs9IG9wZW4odGFnLCBhdHRyKGRhdGFbaV0sIGRlZnMpLCBzdHkpO1xuICAgIGlmICh0YWcgPT09ICd0ZXh0Jykgc3ZnICs9IGVzY2FwZV90ZXh0KGRhdGFbaV0udGV4dCk7XG4gICAgaWYgKHRhZyA9PT0gJ2cnKSBzdmcgKz0gdGhpcy5kcmF3R3JvdXAoZGF0YVtpXSk7XG4gICAgc3ZnICs9IGNsb3NlKHRhZyk7XG4gIH1cblxuICByZXR1cm4gc3ZnICsgY2xvc2UoJ2cnKTtcbn07XG5cbmZ1bmN0aW9uIGVzY2FwZV90ZXh0KHMpIHtcbiAgcyA9IChzID09IG51bGwgPyBcIlwiIDogU3RyaW5nKHMpKTtcbiAgcmV0dXJuIHMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcbiAgICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVfZm9udChzKSB7XG4gIHJldHVybiBTdHJpbmcocykucmVwbGFjZSgvXFxcIi9nLCBcIidcIik7XG59XG5cbnZhciBNQVJLUyA9IHtcbiAgZ3JvdXA6ICBbJ2cnLCBncm91cF0sXG4gIGFyZWE6ICAgWydwYXRoJywgYXJlYSwgdHJ1ZV0sXG4gIGxpbmU6ICAgWydwYXRoJywgbGluZSwgdHJ1ZV0sXG4gIGFyYzogICAgWydwYXRoJywgYXJjXSxcbiAgcGF0aDogICBbJ3BhdGgnLCBwYXRoXSxcbiAgc3ltYm9sOiBbJ3BhdGgnLCBzeW1ib2xdLFxuICByZWN0OiAgIFsncmVjdCcsIHJlY3RdLFxuICBydWxlOiAgIFsnbGluZScsIHJ1bGVdLFxuICB0ZXh0OiAgIFsndGV4dCcsIHRleHRdLFxuICBpbWFnZTogIFsnaW1hZ2UnLCBpbWFnZV1cbn07XG5cbnByb3RvdHlwZS5kcmF3R3JvdXAgPSBmdW5jdGlvbihzY2VuZSkge1xuICB2YXIgc3ZnID0gXCJcIixcbiAgICAgIGF4ZXMgPSBzY2VuZS5heGlzSXRlbXMgfHwgW10sXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbGVnZW5kcyA9IHNjZW5lLmxlZ2VuZEl0ZW1zIHx8IFtdLFxuICAgICAgaSwgaiwgbTtcblxuICBzdmcgKz0gZ3JvdXBfYmcoc2NlbmUpO1xuXG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmRlZi5sYXllciA9PT0gXCJiYWNrXCIpIHtcbiAgICAgIHN2ZyArPSB0aGlzLmRyYXcoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdmcgKz0gdGhpcy5kcmF3KGl0ZW1zW2pdKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgIT09IFwiYmFja1wiKSB7XG4gICAgICBzdmcgKz0gdGhpcy5kcmF3KGF4ZXNbal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdmcgKz0gdGhpcy5kcmF3KGxlZ2VuZHNbal0pO1xuICB9XG5cbiAgcmV0dXJuIHN2Zztcbn07XG5cbi8vL1xuXG5mdW5jdGlvbiBncm91cF9iZyhvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG5cbiAgdmFyIHN0eWwgPSBvLm1hcmsuaW50ZXJhY3RpdmUgPT09IGZhbHNlID9cbiAgICAnc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIicgOiBcbiAgICAnc3R5bGU9XCJcIic7XG5cbiAgcmV0dXJuIG9wZW4oJ3JlY3QnLCB7XG4gICAgJ2NsYXNzJzogJ2JhY2tncm91bmQnXG4gIH0sIHN0eWwpICsgY2xvc2UoJ3JlY3QnKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAobywgZGVmcykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgYXR0ciA9IHt0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIn07XG5cbiAgaWYgKG8uY2xpcCkge1xuICAgIHZhciBjID0ge3dpZHRoOiBvLndpZHRoIHx8IDAsIGhlaWdodDogby5oZWlnaHQgfHwgMH0sXG4gICAgICAgIGlkID0gby5jbGlwX2lkIHx8IChvLmNsaXBfaWQgPSBcImNsaXBcIiArIGNsaXBfaWQrKyk7XG4gICAgZGVmcy5jbGlwcGluZ1tpZF0gPSBjO1xuICAgIGF0dHJbXCJjbGlwLXBhdGhcIl0gPSBcInVybCgjXCIraWQrXCIpXCI7XG4gIH1cblxuICByZXR1cm4gYXR0cjtcbn1cblxuZnVuY3Rpb24gYXJjKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIixcbiAgICBkOiBhcmNfcGF0aChvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBhcmVhKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF0sXG4gICAgICBwYXRoID0gby5vcmllbnQgPT09IFwiaG9yaXpvbnRhbFwiID8gYXJlYV9wYXRoX2ggOiBhcmVhX3BhdGhfdjtcbiAgcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICByZXR1cm4ge2Q6IHBhdGgoaXRlbXMpfTtcbn1cblxuZnVuY3Rpb24gbGluZShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICBsaW5lX3BhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgcmV0dXJuIHtkOiBsaW5lX3BhdGgoaXRlbXMpfTtcbn1cblxuZnVuY3Rpb24gcGF0aChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIsXG4gICAgZDogby5wYXRoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY3Qobykge1xuICByZXR1cm4ge1xuICAgIHg6IG8ueCB8fCAwLFxuICAgIHk6IG8ueSB8fCAwLFxuICAgIHdpZHRoOiBvLndpZHRoIHx8IDAsXG4gICAgaGVpZ2h0OiBvLmhlaWdodCB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJ1bGUobykge1xuICB2YXIgeDEgPSBvLnggfHwgMCxcbiAgICAgIHkxID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgeDE6IHgxLFxuICAgIHkxOiB5MSxcbiAgICB4Mjogby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgIHkyOiBvLnkyICE9IG51bGwgPyBvLnkyIDogeTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIixcbiAgICBkOiBzeW1ib2xfcGF0aChvKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbWFnZShvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IChvLmltYWdlICYmIG8uaW1hZ2UuaGVpZ2h0KSB8fCAwLFxuICAgICAgeCA9IG8ueCAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSksXG4gICAgICB5ID0gby55IC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSksXG4gICAgICB1cmwgPSBjb25maWcuYmFzZVVSTCArIG8udXJsO1xuICBcbiAgcmV0dXJuIHtcbiAgICBcInhsaW5rOmhyZWZcIjogdXJsLFxuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogdyxcbiAgICBoZWlnaHQ6IGhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBkeCA9IG8uZHggfHwgMCxcbiAgICAgIGR5ID0gby5keSB8fCAwLFxuICAgICAgYSA9IG8uYW5nbGUgfHwgMCxcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgYWxpZ24gPSB0ZXh0QWxpZ25bby5hbGlnbiB8fCBcImxlZnRcIl0sXG4gICAgICBiYXNlID0gby5iYXNlbGluZT09PVwidG9wXCIgPyBcIi45ZW1cIlxuICAgICAgICAgICA6IG8uYmFzZWxpbmU9PT1cIm1pZGRsZVwiID8gXCIuMzVlbVwiIDogMDtcblxuICBpZiAocikge1xuICAgIHZhciB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHggKyBkeCxcbiAgICB5OiB5ICsgZHksXG4gICAgJ3RleHQtYW5jaG9yJzogYWxpZ24sXG4gICAgdHJhbnNmb3JtOiBhID8gXCJyb3RhdGUoXCIrYStcIiBcIit4K1wiLFwiK3krXCIpXCIgOiBudWxsLFxuICAgIGR5OiBiYXNlID8gYmFzZSA6IG51bGxcbiAgfTtcbn1cblxuLy8vXG5cbmZ1bmN0aW9uIGNzc0NsYXNzKGRlZikge1xuICB2YXIgY2xzID0gXCJ0eXBlLVwiICsgZGVmLnR5cGU7XG4gIGlmIChkZWYubmFtZSkgY2xzICs9IFwiIFwiICsgZGVmLm5hbWU7XG4gIHJldHVybiBjbHM7XG59XG5cbmZ1bmN0aW9uIHgobykgICAgIHsgcmV0dXJuIG8ueCB8fCAwOyB9XG5mdW5jdGlvbiB5KG8pICAgICB7IHJldHVybiBvLnkgfHwgMDsgfVxuZnVuY3Rpb24geHcobykgICAgeyByZXR1cm4gby54ICsgby53aWR0aCB8fCAwOyB9XG5mdW5jdGlvbiB5aChvKSAgICB7IHJldHVybiBvLnkgKyBvLmhlaWdodCB8fCAwOyB9XG5mdW5jdGlvbiBrZXkobykgICB7IHJldHVybiBvLmtleTsgfVxuZnVuY3Rpb24gc2l6ZShvKSAgeyByZXR1cm4gby5zaXplPT1udWxsID8gMTAwIDogby5zaXplOyB9XG5mdW5jdGlvbiBzaGFwZShvKSB7IHJldHVybiBvLnNoYXBlIHx8IFwiY2lyY2xlXCI7IH1cblxudmFyIGFyY19wYXRoICAgID0gZDMuc3ZnLmFyYygpLFxuICAgIGFyZWFfcGF0aF92ID0gZDMuc3ZnLmFyZWEoKS54KHgpLnkxKHkpLnkwKHloKSxcbiAgICBhcmVhX3BhdGhfaCA9IGQzLnN2Zy5hcmVhKCkueSh5KS54MCh4dykueDEoeCksXG4gICAgbGluZV9wYXRoICAgPSBkMy5zdmcubGluZSgpLngoeCkueSh5KSxcbiAgICBzeW1ib2xfcGF0aCA9IGQzLnN2Zy5zeW1ib2woKS50eXBlKHNoYXBlKS5zaXplKHNpemUpO1xuXG52YXIgbWFya19pZCA9IDAsXG4gICAgY2xpcF9pZCA9IDA7XG5cbnZhciB0ZXh0QWxpZ24gPSB7XG4gIFwibGVmdFwiOiAgIFwic3RhcnRcIixcbiAgXCJjZW50ZXJcIjogXCJtaWRkbGVcIixcbiAgXCJyaWdodFwiOiAgXCJlbmRcIlxufTtcblxudmFyIHN0eWxlcyA9IHtcbiAgXCJmaWxsXCI6ICAgICAgICAgICAgIFwiZmlsbFwiLFxuICBcImZpbGxPcGFjaXR5XCI6ICAgICAgXCJmaWxsLW9wYWNpdHlcIixcbiAgXCJzdHJva2VcIjogICAgICAgICAgIFwic3Ryb2tlXCIsXG4gIFwic3Ryb2tlV2lkdGhcIjogICAgICBcInN0cm9rZS13aWR0aFwiLFxuICBcInN0cm9rZU9wYWNpdHlcIjogICAgXCJzdHJva2Utb3BhY2l0eVwiLFxuICBcInN0cm9rZUNhcFwiOiAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiLFxuICBcInN0cm9rZURhc2hcIjogICAgICAgXCJzdHJva2UtZGFzaGFycmF5XCIsXG4gIFwic3Ryb2tlRGFzaE9mZnNldFwiOiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gIFwib3BhY2l0eVwiOiAgICAgICAgICBcIm9wYWNpdHlcIlxufTtcblxudmFyIHN0eWxlUHJvcHMgPSBkbC5rZXlzKHN0eWxlcyk7XG5cbmZ1bmN0aW9uIHN0eWxlKGQsIHRhZywgZGVmcykge1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWUsXG4gICAgICBvID0gZC5tYXJrID8gZCA6IGQubGVuZ3RoID8gZFswXSA6IG51bGw7XG4gIGlmIChvID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcyA9IFwiXCI7XG5cbiAgaWYgKHRhZyA9PT0gJ3RleHQnKSB7XG4gICAgcyArPSAnZm9udDogJyArIGZvbnRTdHJpbmcobykgKyAnOyc7XG4gIH1cbiAgXG4gIGZvciAoaT0wLCBuPXN0eWxlUHJvcHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHByb3AgPSBzdHlsZVByb3BzW2ldO1xuICAgIG5hbWUgPSBzdHlsZXNbcHJvcF07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSBcImZpbGxcIikgcyArPSAnZmlsbDogbm9uZTsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBcInVybChcIiArIHdpbmRvdy5sb2NhdGlvbi5ocmVmICsgXCIjXCIgKyB2YWx1ZS5pZCArIFwiKVwiO1xuICAgICAgfVxuICAgICAgcyArPSAocy5sZW5ndGggPyAnICcgOiAnJykgKyBuYW1lICsgJzogJyArIHZhbHVlICsgJzsnXG4gICAgfVxuICB9XG4gIFxuICAvLyBub3QgdGhhdCB3ZSBkb24ndCBleGNsdWRlIGJsYW5rIHN0eWxlcyBmb3IgZDMgZG9tIGNvbXBhdFxuICByZXR1cm4gJ3N0eWxlPVwiJytzKydcIic7XG59XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICB2YXIgZiA9IChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250ICYmIGVzY2FwZV9mb250KG8uZm9udCkgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbiAgcmV0dXJuIGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbnZhciBoYW5kbGVyID0gZnVuY3Rpb24oZWwsIG1vZGVsKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGlmIChlbCkgdGhpcy5pbml0aWFsaXplKGVsKTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsKG1vZGVsKTtcbn07XG5cbmZ1bmN0aW9uIHN2Z0hhbmRsZXIoaGFuZGxlcikge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZ0LnRhcmdldCxcbiAgICAgICAgaXRlbSA9IHRhcmdldC5fX2RhdGFfXztcblxuICAgIGlmIChpdGVtKSBpdGVtID0gaXRlbS5tYXJrID8gaXRlbSA6IGl0ZW1bMF07XG4gICAgaGFuZGxlci5jYWxsKHRoYXQuX29iaiwgZXZ0LCBpdGVtKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZlbnROYW1lKG5hbWUpIHtcbiAgdmFyIGkgPSBuYW1lLmluZGV4T2YoXCIuXCIpO1xuICByZXR1cm4gaSA8IDAgPyBuYW1lIDogbmFtZS5zbGljZSgwLGkpO1xufVxuXG52YXIgcHJvdG90eXBlID0gaGFuZGxlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHBhZCwgb2JqKSB7XG4gIHRoaXMuX2VsID0gZDMuc2VsZWN0KGVsKS5ub2RlKCk7XG4gIHRoaXMuX3N2ZyA9IGQzLnNlbGVjdChlbCkuc2VsZWN0KFwic3ZnLm1hcmtzXCIpLm5vZGUoKTtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgdGhpcy5fb2JqID0gb2JqIHx8IG51bGw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnBhZGRpbmcgPSBmdW5jdGlvbihwYWQpIHtcbiAgdGhpcy5fcGFkZGluZyA9IHBhZDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihtb2RlbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgdGhpcy5fbW9kZWwgPSBtb2RlbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuaGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGggPSB0aGlzLl9oYW5kbGVycztcbiAgcmV0dXJuIGRsLmtleXMoaCkucmVkdWNlKGZ1bmN0aW9uKGEsIGspIHtcbiAgICByZXR1cm4gaFtrXS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkgeyByZXR1cm4gKGEucHVzaCh4KSwgYSk7IH0sIGEpO1xuICB9LCBbXSk7XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgIGRvbSA9IGQzLnNlbGVjdCh0aGlzLl9zdmcpLm5vZGUoKTtcbiAgICAgIFxuICB2YXIgeCA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgc3ZnOiBzdmdIYW5kbGVyLmNhbGwodGhpcywgaGFuZGxlcilcbiAgfTtcbiAgaCA9IGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSk7XG4gIGgucHVzaCh4KTtcblxuICBkb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCB4LnN2Zyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gZXZlbnROYW1lKHR5cGUpLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLFxuICAgICAgZG9tID0gZDMuc2VsZWN0KHRoaXMuX3N2Zykubm9kZSgpO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yICh2YXIgaT1oLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGlmIChoW2ldLnR5cGUgIT09IHR5cGUpIGNvbnRpbnVlO1xuICAgIGlmICghaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhbaV0uc3ZnKTtcbiAgICAgIGguc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFuZGxlcjsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3N2ZyA9IG51bGw7XG4gIHRoaXMuX2N0eCA9IG51bGw7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fZWwgPSBlbDtcblxuICAvLyByZW1vdmUgYW55IGV4aXN0aW5nIHN2ZyBlbGVtZW50XG4gIGQzLnNlbGVjdChlbCkuc2VsZWN0KFwic3ZnLm1hcmtzXCIpLnJlbW92ZSgpO1xuXG4gIC8vIGNyZWF0ZSBzdmcgZWxlbWVudCBhbmQgaW5pdGlhbGl6ZSBhdHRyaWJ1dGVzXG4gIHRoaXMuX3N2ZyA9IGQzLnNlbGVjdChlbClcbiAgICAuYXBwZW5kKFwic3ZnXCIpXG4gICAgLmF0dHIoXCJjbGFzc1wiLCBcIm1hcmtzXCIpO1xuICBcbiAgLy8gc2V0IHRoZSBzdmcgcm9vdCBncm91cFxuICB0aGlzLl9jdHggPSB0aGlzLl9zdmcuYXBwZW5kKFwiZ1wiKTtcbiAgXG4gIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwYWQpO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIFxuICB0aGlzLl9zdmdcbiAgICAuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgcGFkLmxlZnQgKyBwYWQucmlnaHQpXG4gICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20pO1xuICAgIFxuICB0aGlzLl9jdHhcbiAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIitwYWQubGVmdCtcIixcIitwYWQudG9wK1wiKVwiKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jdHg7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUudXBkYXRlRGVmcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgYWxsID0gdGhpcy5fZGVmcyxcbiAgICAgIGRncmFkID0gZGwua2V5cyhhbGwuZ3JhZGllbnQpLFxuICAgICAgZGNsaXAgPSBkbC5rZXlzKGFsbC5jbGlwcGluZyksXG4gICAgICBkZWZzID0gc3ZnLnNlbGVjdChcImRlZnNcIiksIGdyYWQsIGNsaXA7XG5cbiAgLy8gZ2V0IG9yIGNyZWF0ZSBzdmcgZGVmcyBibG9ja1xuICBpZiAoZGdyYWQubGVuZ3RoPT09MCAmJiBkY2xpcC5sZW5ndGg9PTApIHsgZGVmcy5yZW1vdmUoKTsgcmV0dXJuOyB9XG4gIGlmIChkZWZzLmVtcHR5KCkpIGRlZnMgPSBzdmcuaW5zZXJ0KFwiZGVmc1wiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgXG4gIGdyYWQgPSBkZWZzLnNlbGVjdEFsbChcImxpbmVhckdyYWRpZW50XCIpLmRhdGEoZGdyYWQsIGRsLmlkZW50aXR5KTtcbiAgZ3JhZC5lbnRlcigpLmFwcGVuZChcImxpbmVhckdyYWRpZW50XCIpLmF0dHIoXCJpZFwiLCBkbC5pZGVudGl0eSk7XG4gIGdyYWQuZXhpdCgpLnJlbW92ZSgpO1xuICBncmFkLmVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZGVmID0gYWxsLmdyYWRpZW50W2lkXSxcbiAgICAgICAgZ3JkID0gZDMuc2VsZWN0KHRoaXMpO1xuXG4gICAgLy8gc2V0IGdyYWRpZW50IGNvb3JkaW5hdGVzXG4gICAgZ3JkLmF0dHIoe3gxOiBkZWYueDEsIHgyOiBkZWYueDIsIHkxOiBkZWYueTEsIHkyOiBkZWYueTJ9KTtcblxuICAgIC8vIHNldCBncmFkaWVudCBzdG9wc1xuICAgIHN0b3AgPSBncmQuc2VsZWN0QWxsKFwic3RvcFwiKS5kYXRhKGRlZi5zdG9wcyk7XG4gICAgc3RvcC5lbnRlcigpLmFwcGVuZChcInN0b3BcIik7XG4gICAgc3RvcC5leGl0KCkucmVtb3ZlKCk7XG4gICAgc3RvcC5hdHRyKFwib2Zmc2V0XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQub2Zmc2V0OyB9KVxuICAgICAgICAuYXR0cihcInN0b3AtY29sb3JcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC5jb2xvcjsgfSk7XG4gIH0pO1xuICBcbiAgY2xpcCA9IGRlZnMuc2VsZWN0QWxsKFwiY2xpcFBhdGhcIikuZGF0YShkY2xpcCwgZGwuaWRlbnRpdHkpO1xuICBjbGlwLmVudGVyKCkuYXBwZW5kKFwiY2xpcFBhdGhcIikuYXR0cihcImlkXCIsIGRsLmlkZW50aXR5KTtcbiAgY2xpcC5leGl0KCkucmVtb3ZlKCk7XG4gIGNsaXAuZWFjaChmdW5jdGlvbihpZCkge1xuICAgIHZhciBkZWYgPSBhbGwuY2xpcHBpbmdbaWRdLFxuICAgICAgICBjciA9IGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJyZWN0XCIpLmRhdGEoWzFdKTtcbiAgICBjci5lbnRlcigpLmFwcGVuZChcInJlY3RcIik7XG4gICAgY3IuYXR0cihcInhcIiwgMClcbiAgICAgIC5hdHRyKFwieVwiLCAwKVxuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBkZWYud2lkdGgpXG4gICAgICAuYXR0cihcImhlaWdodFwiLCBkZWYuaGVpZ2h0KTtcbiAgfSk7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIG1hcmtzLmN1cnJlbnQgPSB0aGlzO1xuXG4gIGlmIChpdGVtcykge1xuICAgIHRoaXMucmVuZGVySXRlbXMoZGwuYXJyYXkoaXRlbXMpKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmRyYXcodGhpcy5fY3R4LCBzY2VuZSwgLTEpO1xuICB9XG4gIHRoaXMudXBkYXRlRGVmcygpO1xuXG4gZGVsZXRlIG1hcmtzLmN1cnJlbnQ7XG59O1xuXG5wcm90b3R5cGUucmVuZGVySXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xuICB2YXIgaXRlbSwgbm9kZSwgdHlwZSwgbmVzdCwgaSwgbjtcblxuICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIG5vZGUgPSBpdGVtLl9zdmc7XG4gICAgdHlwZSA9IGl0ZW0ubWFyay5tYXJrdHlwZTtcblxuICAgIGl0ZW0gPSBtYXJrcy5uZXN0ZWRbdHlwZV0gPyBpdGVtLm1hcmsuaXRlbXMgOiBpdGVtO1xuICAgIG1hcmtzLnVwZGF0ZVt0eXBlXS5jYWxsKG5vZGUsIGl0ZW0pO1xuICAgIG1hcmtzLnN0eWxlLmNhbGwobm9kZSwgaXRlbSk7XG4gIH1cbn1cblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHNjZW5lLCBpbmRleCkge1xuICB2YXIgbWFya3R5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIHJlbmRlcmVyID0gbWFya3MuZHJhd1ttYXJrdHlwZV07XG4gIHJlbmRlcmVyLmNhbGwodGhpcywgY3R4LCBzY2VuZSwgaW5kZXgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJlcjtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJyk7XG5cbmZ1bmN0aW9uIHgobykgICAgIHsgcmV0dXJuIG8ueCB8fCAwOyB9XG5mdW5jdGlvbiB5KG8pICAgICB7IHJldHVybiBvLnkgfHwgMDsgfVxuZnVuY3Rpb24geWgobykgICAgeyByZXR1cm4gby55ICsgby5oZWlnaHQgfHwgMDsgfVxuZnVuY3Rpb24ga2V5KG8pICAgeyByZXR1cm4gby5rZXk7IH1cbmZ1bmN0aW9uIHNpemUobykgIHsgcmV0dXJuIG8uc2l6ZT09bnVsbCA/IDEwMCA6IG8uc2l6ZTsgfVxuZnVuY3Rpb24gc2hhcGUobykgeyByZXR1cm4gby5zaGFwZSB8fCBcImNpcmNsZVwiOyB9XG4gICAgXG52YXIgYXJjX3BhdGggICAgPSBkMy5zdmcuYXJjKCksXG4gICAgYXJlYV9wYXRoICAgPSBkMy5zdmcuYXJlYSgpLngoeCkueTEoeSkueTAoeWgpLFxuICAgIGxpbmVfcGF0aCAgID0gZDMuc3ZnLmxpbmUoKS54KHgpLnkoeSksXG4gICAgc3ltYm9sX3BhdGggPSBkMy5zdmcuc3ltYm9sKCkudHlwZShzaGFwZSkuc2l6ZShzaXplKTtcblxudmFyIG1hcmtfaWQgPSAwLFxuICAgIGNsaXBfaWQgPSAwO1xuXG52YXIgdGV4dEFsaWduID0ge1xuICBcImxlZnRcIjogICBcInN0YXJ0XCIsXG4gIFwiY2VudGVyXCI6IFwibWlkZGxlXCIsXG4gIFwicmlnaHRcIjogIFwiZW5kXCJcbn07XG5cbnZhciBzdHlsZXMgPSB7XG4gIFwiZmlsbFwiOiAgICAgICAgICAgICBcImZpbGxcIixcbiAgXCJmaWxsT3BhY2l0eVwiOiAgICAgIFwiZmlsbC1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlXCI6ICAgICAgICAgICBcInN0cm9rZVwiLFxuICBcInN0cm9rZVdpZHRoXCI6ICAgICAgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJzdHJva2VPcGFjaXR5XCI6ICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgXCJzdHJva2VDYXBcIjogICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIixcbiAgXCJzdHJva2VEYXNoXCI6ICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiLFxuICBcInN0cm9rZURhc2hPZmZzZXRcIjogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICBcIm9wYWNpdHlcIjogICAgICAgICAgXCJvcGFjaXR5XCJcbn07XG52YXIgc3R5bGVQcm9wcyA9IGRsLmtleXMoc3R5bGVzKTtcblxuZnVuY3Rpb24gc3R5bGUoZCkge1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWUsXG4gICAgICBvID0gZC5tYXJrID8gZCA6IGQubGVuZ3RoID8gZFswXSA6IG51bGw7XG4gIGlmIChvID09PSBudWxsKSByZXR1cm47XG5cbiAgZm9yIChpPTAsIG49c3R5bGVQcm9wcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IHN0eWxlUHJvcHNbaV07XG4gICAgbmFtZSA9IHN0eWxlc1twcm9wXTtcbiAgICB2YWx1ZSA9IG9bcHJvcF07XG5cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5hbWUgPT09IFwiZmlsbFwiKSB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIFwibm9uZVwiLCBudWxsKTtcbiAgICAgIGVsc2UgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgIC8vIGVuc3VyZSBkZWZpbml0aW9uIGlzIGluY2x1ZGVkXG4gICAgICAgIG1hcmtzLmN1cnJlbnQuX2RlZnMuZ3JhZGllbnRbdmFsdWUuaWRdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gXCJ1cmwoI1wiICsgdmFsdWUuaWQgKyBcIilcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUrXCJcIiwgbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFyYyhvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBhcmNfcGF0aChvKSk7XG59XG5cbmZ1bmN0aW9uIGFyZWEoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgYXJlYV9wYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBhcmVhX3BhdGgoaXRlbXMpKTtcbn1cblxuZnVuY3Rpb24gbGluZShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICBsaW5lX3BhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIGxpbmVfcGF0aChpdGVtcykpO1xufVxuXG5mdW5jdGlvbiBwYXRoKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcbiAgaWYgKG8ucGF0aCAhPSBudWxsKSB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgby5wYXRoKTtcbn1cblxuZnVuY3Rpb24gcmVjdChvKSB7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCBvLnggfHwgMCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCBvLnkgfHwgMCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgby53aWR0aCB8fCAwKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgby5oZWlnaHQgfHwgMCk7XG59XG5cbmZ1bmN0aW9uIHJ1bGUobykge1xuICB2YXIgeDEgPSBvLnggfHwgMCxcbiAgICAgIHkxID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieDFcIiwgeDEpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInkxXCIsIHkxKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4MlwiLCBvLngyICE9IG51bGwgPyBvLngyIDogeDEpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInkyXCIsIG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MSk7XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBzeW1ib2xfcGF0aChvKSk7XG59XG5cbmZ1bmN0aW9uIGltYWdlKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDAsXG4gICAgICB4ID0gby54IC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKSxcbiAgICAgIHkgPSBvLnkgLSAoby5iYXNlbGluZSA9PT0gXCJtaWRkbGVcIlxuICAgICAgICA/IGgvMiA6IChvLmJhc2VsaW5lID09PSBcImJvdHRvbVwiID8gaCA6IDApKSxcbiAgICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgby51cmw7XG4gIFxuICB0aGlzLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLCBcImhyZWZcIiwgdXJsKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgeSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGgpO1xufVxuICBcbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICByZXR1cm4gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbn1cblxuZnVuY3Rpb24gdGV4dChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICBkeCA9IG8uZHggfHwgMCxcbiAgICAgIGR5ID0gby5keSB8fCAwLFxuICAgICAgYSA9IG8uYW5nbGUgfHwgMCxcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgYWxpZ24gPSB0ZXh0QWxpZ25bby5hbGlnbiB8fCBcImxlZnRcIl0sXG4gICAgICBiYXNlID0gby5iYXNlbGluZT09PVwidG9wXCIgPyBcIi45ZW1cIlxuICAgICAgICAgICA6IG8uYmFzZWxpbmU9PT1cIm1pZGRsZVwiID8gXCIuMzVlbVwiIDogMDtcblxuICBpZiAocikge1xuICAgIHZhciB0ID0gKG8udGhldGEgfHwgMCkgLSBNYXRoLlBJLzI7XG4gICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gIH1cblxuICB0aGlzLnNldEF0dHJpYnV0ZShcInhcIiwgeCArIGR4KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkgKyBkeSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidGV4dC1hbmNob3JcIiwgYWxpZ24pO1xuICBcbiAgaWYgKGEpIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKFwiK2ErXCIgXCIreCtcIixcIit5K1wiKVwiKTtcbiAgZWxzZSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgXG4gIGlmIChiYXNlKSB0aGlzLnNldEF0dHJpYnV0ZShcImR5XCIsIGJhc2UpO1xuICBlbHNlIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwiZHlcIik7XG4gIFxuICB0aGlzLnRleHRDb250ZW50ID0gby50ZXh0O1xuICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KFwiZm9udFwiLCBmb250U3RyaW5nKG8pLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuXG4gIGlmIChvLmNsaXApIHtcbiAgICB2YXIgYyA9IHt3aWR0aDogby53aWR0aCB8fCAwLCBoZWlnaHQ6IG8uaGVpZ2h0IHx8IDB9LFxuICAgICAgICBpZCA9IG8uY2xpcF9pZCB8fCAoby5jbGlwX2lkID0gXCJjbGlwXCIgKyBjbGlwX2lkKyspO1xuICAgIG1hcmtzLmN1cnJlbnQuX2RlZnMuY2xpcHBpbmdbaWRdID0gYztcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShcImNsaXAtcGF0aFwiLCBcInVybCgjXCIraWQrXCIpXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdyb3VwX2JnKG8pIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB3KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaCk7XG59XG5cbmZ1bmN0aW9uIGNzc0NsYXNzKGRlZikge1xuICB2YXIgY2xzID0gXCJ0eXBlLVwiICsgZGVmLnR5cGU7XG4gIGlmIChkZWYubmFtZSkgY2xzICs9IFwiIFwiICsgZGVmLm5hbWU7XG4gIHJldHVybiBjbHM7XG59XG5cbmZ1bmN0aW9uIGRyYXcodGFnLCBhdHRyLCBuZXN0KSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgaW5kZXgpIHtcbiAgICBkcmF3TWFyayhnLCBzY2VuZSwgaW5kZXgsIFwibWFya19cIiwgdGFnLCBhdHRyLCBuZXN0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHJhd01hcmsoZywgc2NlbmUsIGluZGV4LCBwcmVmaXgsIHRhZywgYXR0ciwgbmVzdCkge1xuICB2YXIgZGF0YSA9IG5lc3QgPyBbc2NlbmUuaXRlbXNdIDogc2NlbmUuaXRlbXMsXG4gICAgICBldnRzID0gc2NlbmUuaW50ZXJhY3RpdmU9PT1mYWxzZSA/IFwibm9uZVwiIDogbnVsbCxcbiAgICAgIGdycHMgPSBnLm5vZGUoKS5jaGlsZE5vZGVzLFxuICAgICAgbm90RyA9ICh0YWcgIT09IFwiZ1wiKSxcbiAgICAgIHAgPSAocCA9IGdycHNbaW5kZXgrMV0pIC8vICsxIHRvIHNraXAgZ3JvdXAgYmFja2dyb3VuZCByZWN0XG4gICAgICAgID8gZDMuc2VsZWN0KHApXG4gICAgICAgIDogZy5hcHBlbmQoXCJnXCIpXG4gICAgICAgICAgIC5hdHRyKFwiaWRcIiwgXCJnXCIrKCsrbWFya19pZCkpXG4gICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgY3NzQ2xhc3Moc2NlbmUuZGVmKSk7XG5cbiAgdmFyIGlkID0gcC5hdHRyKFwiaWRcIiksXG4gICAgICBzID0gXCIjXCIgKyBpZCArIFwiID4gXCIgKyB0YWcsXG4gICAgICBtID0gcC5zZWxlY3RBbGwocykuZGF0YShkYXRhKSxcbiAgICAgIGUgPSBtLmVudGVyKCkuYXBwZW5kKHRhZyk7XG5cbiAgaWYgKG5vdEcpIHtcbiAgICBwLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgZXZ0cyk7XG4gICAgZS5lYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmIChkLm1hcmspIGQuX3N2ZyA9IHRoaXM7XG4gICAgICBlbHNlIGlmIChkLmxlbmd0aCkgZFswXS5fc3ZnID0gdGhpcztcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBlLmFwcGVuZChcInJlY3RcIikuYXR0cihcImNsYXNzXCIsXCJiYWNrZ3JvdW5kXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIixldnRzKTtcbiAgfVxuICBcbiAgbS5leGl0KCkucmVtb3ZlKCk7XG4gIG0uZWFjaChhdHRyKTtcbiAgaWYgKG5vdEcpIG0uZWFjaChzdHlsZSk7XG4gIGVsc2UgcC5zZWxlY3RBbGwocytcIiA+IHJlY3QuYmFja2dyb3VuZFwiKS5lYWNoKGdyb3VwX2JnKS5lYWNoKHN0eWxlKTtcbiAgXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBkcmF3R3JvdXAoZywgc2NlbmUsIGluZGV4LCBwcmVmaXgpIHsgICAgXG4gIHZhciBwID0gZHJhd01hcmsoZywgc2NlbmUsIGluZGV4LCBwcmVmaXggfHwgXCJncm91cF9cIiwgXCJnXCIsIGdyb3VwKSxcbiAgICAgIGMgPSBwLm5vZGUoKS5jaGlsZE5vZGVzLCBuID0gYy5sZW5ndGgsIGksIGosIG07XG4gIFxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2YXIgaXRlbXMgPSBjW2ldLl9fZGF0YV9fLml0ZW1zLFxuICAgICAgICBsZWdlbmRzID0gY1tpXS5fX2RhdGFfXy5sZWdlbmRJdGVtcyB8fCBbXSxcbiAgICAgICAgYXhlcyA9IGNbaV0uX19kYXRhX18uYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgICBzZWwgPSBkMy5zZWxlY3QoY1tpXSksXG4gICAgICAgIGlkeCA9IDA7XG5cbiAgICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGlmIChheGVzW2pdLmRlZi5sYXllciA9PT0gXCJiYWNrXCIpIHtcbiAgICAgICAgZHJhd0dyb3VwLmNhbGwodGhpcywgc2VsLCBheGVzW2pdLCBpZHgrKywgXCJheGlzX1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPTAsIG09aXRlbXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgdGhpcy5kcmF3KHNlbCwgaXRlbXNbal0sIGlkeCsrKTtcbiAgICB9XG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgIT09IFwiYmFja1wiKSB7XG4gICAgICAgIGRyYXdHcm91cC5jYWxsKHRoaXMsIHNlbCwgYXhlc1tqXSwgaWR4KyssIFwiYXhpc19cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgZHJhd0dyb3VwLmNhbGwodGhpcywgc2VsLCBsZWdlbmRzW2pdLCBpZHgrKywgXCJsZWdlbmRfXCIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgdXBkYXRlOiB7XG4gICAgZ3JvdXA6ICAgcmVjdCxcbiAgICBhcmVhOiAgICBhcmVhLFxuICAgIGxpbmU6ICAgIGxpbmUsXG4gICAgYXJjOiAgICAgYXJjLFxuICAgIHBhdGg6ICAgIHBhdGgsXG4gICAgc3ltYm9sOiAgc3ltYm9sLFxuICAgIHJlY3Q6ICAgIHJlY3QsXG4gICAgcnVsZTogICAgcnVsZSxcbiAgICB0ZXh0OiAgICB0ZXh0LFxuICAgIGltYWdlOiAgIGltYWdlXG4gIH0sXG4gIG5lc3RlZDoge1xuICAgIFwiYXJlYVwiOiB0cnVlLFxuICAgIFwibGluZVwiOiB0cnVlXG4gIH0sXG4gIHN0eWxlOiBzdHlsZSxcbiAgZHJhdzoge1xuICAgIGdyb3VwOiAgIGRyYXdHcm91cCxcbiAgICBhcmVhOiAgICBkcmF3KFwicGF0aFwiLCBhcmVhLCB0cnVlKSxcbiAgICBsaW5lOiAgICBkcmF3KFwicGF0aFwiLCBsaW5lLCB0cnVlKSxcbiAgICBhcmM6ICAgICBkcmF3KFwicGF0aFwiLCBhcmMpLFxuICAgIHBhdGg6ICAgIGRyYXcoXCJwYXRoXCIsIHBhdGgpLFxuICAgIHN5bWJvbDogIGRyYXcoXCJwYXRoXCIsIHN5bWJvbCksXG4gICAgcmVjdDogICAgZHJhdyhcInJlY3RcIiwgcmVjdCksXG4gICAgcnVsZTogICAgZHJhdyhcImxpbmVcIiwgcnVsZSksXG4gICAgdGV4dDogICAgZHJhdyhcInRleHRcIiwgdGV4dCksXG4gICAgaW1hZ2U6ICAgZHJhdyhcImltYWdlXCIsIGltYWdlKSxcbiAgICBkcmF3OiAgICBkcmF3IC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICB9LFxuICBjdXJyZW50OiBudWxsXG59OyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbmZ1bmN0aW9uIEJvdW5kZXIoZ3JhcGgsIG1hcmspIHtcbiAgdGhpcy5fbWFyayA9IG1hcms7XG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKEJvdW5kZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImJvdW5kc1wiLCB0aGlzLl9tYXJrLm1hcmt0eXBlXSk7XG5cbiAgYm91bmRzLm1hcmsodGhpcy5fbWFyayk7XG4gIGlmICh0aGlzLl9tYXJrLm1hcmt0eXBlID09PSBDLkdST1VQKSBcbiAgICBib3VuZHMubWFyayh0aGlzLl9tYXJrLCBudWxsLCBmYWxzZSk7XG5cbiAgaW5wdXQucmVmbG93ID0gdHJ1ZTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCb3VuZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEVuY29kZXIgID0gcmVxdWlyZSgnLi9FbmNvZGVyJyksXG4gICAgQm91bmRlciAgPSByZXF1aXJlKCcuL0JvdW5kZXInKSxcbiAgICBJdGVtICA9IHJlcXVpcmUoJy4vSXRlbScpLFxuICAgIHBhcnNlRGF0YSA9IHJlcXVpcmUoJy4uL3BhcnNlL2RhdGEnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEJ1aWxkZXIoKSB7ICAgIFxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbn1cblxudmFyIHByb3RvID0gKEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIHRoaXMuX2RlZiAgID0gZGVmO1xuICB0aGlzLl9tYXJrICA9IG1hcms7XG4gIHRoaXMuX2Zyb20gID0gKGRlZi5mcm9tID8gZGVmLmZyb20uZGF0YSA6IG51bGwpIHx8IGluaGVyaXRGcm9tO1xuICB0aGlzLl9kcyAgICA9IGRsLmlzU3RyaW5nKHRoaXMuX2Zyb20pID8gZ3JhcGguZGF0YSh0aGlzLl9mcm9tKSA6IG51bGw7XG4gIHRoaXMuX21hcCAgID0ge307XG5cbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAgLy8gU2hvdWxkIHNjZW5lZ3JhcGggaXRlbXMgdHJhY2sgX3ByZXY/XG5cbiAgbWFyay5kZWYgPSBkZWY7XG4gIG1hcmsubWFya3R5cGUgPSBkZWYudHlwZTtcbiAgbWFyay5pbnRlcmFjdGl2ZSA9ICEoZGVmLmludGVyYWN0aXZlID09PSBmYWxzZSk7XG4gIG1hcmsuaXRlbXMgPSBbXTtcblxuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX3BhcmVudF9pZCA9IHBhcmVudF9pZDtcblxuICBpZihkZWYuZnJvbSAmJiAoZGVmLmZyb20ubWFyayB8fCBkZWYuZnJvbS50cmFuc2Zvcm0gfHwgZGVmLmZyb20ubW9kaWZ5KSkge1xuICAgIGlubGluZURzLmNhbGwodGhpcyk7XG4gIH1cblxuICAvLyBOb24tZ3JvdXAgbWFyayBidWlsZGVycyBhcmUgc3VwZXIgbm9kZXMuIEVuY29kZXIgYW5kIEJvdW5kZXIgcmVtYWluIFxuICAvLyBzZXBhcmF0ZSBvcGVyYXRvcnMgYnV0IGFyZSBlbWJlZGRlZCBhbmQgY2FsbGVkIGJ5IEJ1aWxkZXIuZXZhbHVhdGUuXG4gIHRoaXMuX2lzU3VwZXIgPSAodGhpcy5fZGVmLnR5cGUgIT09IEMuR1JPVVApOyBcbiAgdGhpcy5fZW5jb2RlciA9IG5ldyBFbmNvZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcbiAgdGhpcy5fYm91bmRlciA9IG5ldyBCb3VuZGVyKHRoaXMuX2dyYXBoLCB0aGlzLl9tYXJrKTtcblxuICBpZih0aGlzLl9kcykgeyB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5EQVRBLCB0aGlzLl9mcm9tKTsgfVxuXG4gIC8vIFNpbmNlIEJ1aWxkZXJzIGFyZSBzdXBlciBub2RlcywgY29weSBvdmVyIGVuY29kZXIgZGVwZW5kZW5jaWVzXG4gIC8vIChib3VuZGVyIGhhcyBubyByZWdpc3RlcmVkIGRlcGVuZGVuY2llcykuXG4gIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLkRBVEEpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0NBTEVTLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5TQ0FMRVMpKTtcbiAgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0lHTkFMUykpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKHApIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuXG4gIC8vIElmIHdlJ3ZlIG5vdCBuZWVkZWQgcHJldiBpbiB0aGUgcGFzdCwgYnV0IGEgbmV3IGlubGluZSBkcyBuZWVkcyBpdCBub3dcbiAgLy8gZW5zdXJlIGV4aXN0aW5nIGl0ZW1zIGhhdmUgcHJldiBzZXQuXG4gIGlmKCF0aGlzLl9yZXZpc2VzICYmIHApIHtcbiAgICB0aGlzLl9pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgaWYoZC5fcHJldiA9PT0gdW5kZWZpbmVkKSBkLl9wcmV2ID0gQy5TRU5USU5FTDsgfSk7XG4gIH1cblxuICB0aGlzLl9yZXZpc2VzID0gdGhpcy5fcmV2aXNlcyB8fCBwO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIFJlYWN0aXZlIGdlb21ldHJ5IGFuZCBtYXJrLWxldmVsIHRyYW5zZm9ybWF0aW9ucyBhcmUgaGFuZGxlZCBoZXJlIFxuLy8gYmVjYXVzZSB0aGV5IG5lZWQgdGhlaXIgZ3JvdXAncyBkYXRhLWpvaW5lZCBjb250ZXh0LiBcbmZ1bmN0aW9uIGlubGluZURzKCkge1xuICB2YXIgZnJvbSA9IHRoaXMuX2RlZi5mcm9tLFxuICAgICAgZ2VvbSA9IGZyb20ubWFyayxcbiAgICAgIHNyYywgbmFtZSwgc3BlYywgc2libGluZywgb3V0cHV0O1xuXG4gIGlmKGdlb20pIHtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fcGFyZW50X2lkLCBnZW9tXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sIFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc3JjID0gdGhpcy5fZ3JhcGguZGF0YSh0aGlzLl9mcm9tKTtcbiAgICBuYW1lID0gW1widmdcIiwgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGUsIHNyYy5saXN0ZW5lcnModHJ1ZSkubGVuZ3RoXS5qb2luKFwiX1wiKTtcbiAgICBzcGVjID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHNvdXJjZTogdGhpcy5fZnJvbSxcbiAgICAgIHRyYW5zZm9ybTogZnJvbS50cmFuc2Zvcm0sXG4gICAgICBtb2RpZnk6IGZyb20ubW9kaWZ5XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuX2Zyb20gPSBuYW1lO1xuICB0aGlzLl9kcyA9IHBhcnNlRGF0YS5kYXRhc291cmNlKHRoaXMuX2dyYXBoLCBzcGVjKTtcbiAgdmFyIHJldmlzZXMgPSB0aGlzLl9kcy5yZXZpc2VzKCk7XG5cbiAgaWYoZ2VvbSkge1xuICAgIHNpYmxpbmcgPSB0aGlzLnNpYmxpbmcoZ2VvbSkucmV2aXNlcyhyZXZpc2VzKTtcbiAgICBpZihzaWJsaW5nLl9pc1N1cGVyKSBzaWJsaW5nLmFkZExpc3RlbmVyKHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICAgIGVsc2Ugc2libGluZy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9kcy5saXN0ZW5lcigpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIGEgbmV3IGRhdGFzb3VyY2UgYnV0IGl0IGlzIGVtcHR5IGFzXG4gICAgLy8gdGhlIHByb3BhZ2F0aW9uIGN5Y2xlIGhhcyBhbHJlYWR5IGNyb3NzZWQgdGhlIGRhdGFzb3VyY2VzLiBcbiAgICAvLyBTbywgd2UgcmVwdWxzZSBqdXN0IHRoaXMgZGF0YXNvdXJjZS4gVGhpcyBzaG91bGQgYmUgc2FmZVxuICAgIC8vIGFzIHRoZSBkcyBpc24ndCBjb25uZWN0ZWQgdG8gdGhlIHNjZW5lZ3JhcGggeWV0LlxuICAgIFxuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9kcy5zb3VyY2UoKS5yZXZpc2VzKHJldmlzZXMpLmxhc3QoKTtcbiAgICAgICAgaW5wdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShvdXRwdXQpO1xuXG4gICAgaW5wdXQuYWRkID0gb3V0cHV0LmFkZDtcbiAgICBpbnB1dC5tb2QgPSBvdXRwdXQubW9kO1xuICAgIGlucHV0LnJlbSA9IG91dHB1dC5yZW07XG4gICAgaW5wdXQuc3RhbXAgPSBudWxsO1xuICAgIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShpbnB1dCwgdGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gIH1cbn1cblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0aGlzXTtcbn07XG5cbnByb3RvLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX2dyYXBoLmNvbm5lY3QodGhpcy5waXBlbGluZSgpKTtcbiAgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0NBTEVTKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICBidWlsZGVyLl9wYXJlbnQuc2NhbGUocykuYWRkTGlzdGVuZXIoYnVpbGRlcik7XG4gIH0pO1xuXG4gIGlmKHRoaXMuX3BhcmVudCkge1xuICAgIGlmKHRoaXMuX2lzU3VwZXIpIHRoaXMuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICAgIGVsc2UgdGhpcy5fYm91bmRlci5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQuX2NvbGxlY3Rvcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBpZighdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCkgcmV0dXJuIHRoaXM7XG5cbiAgTm9kZS5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xuICB0aGlzLl9ncmFwaC5kaXNjb25uZWN0KHRoaXMucGlwZWxpbmUoKSk7XG4gIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNDQUxFUykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgYnVpbGRlci5fcGFyZW50LnNjYWxlKHMpLnJlbW92ZUxpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5zaWJsaW5nID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy5fcGFyZW50LmNoaWxkKG5hbWUsIHRoaXMuX3BhcmVudF9pZCk7XG59O1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJidWlsZGluZ1wiLCB0aGlzLl9mcm9tLCB0aGlzLl9kZWYudHlwZV0pO1xuXG4gIHZhciBvdXRwdXQsIGZ1bGxVcGRhdGUsIGZjcywgZGF0YTtcblxuICBpZih0aGlzLl9kcykge1xuICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBkZXRlcm1pbmUgaWYgYW55IGVuY29kZXIgZGVwZW5kZW5jaWVzIGhhdmUgYmVlbiB1cGRhdGVkLlxuICAgIC8vIEhvd2V2ZXIsIHRoZSBlbmNvZGVyJ3MgZGF0YSBzb3VyY2Ugd2lsbCBsaWtlbHkgYmUgdXBkYXRlZCwgYW5kIHNob3VsZG4ndFxuICAgIC8vIHRyaWdnZXIgYWxsIGl0ZW1zIHRvIG1vZC5cbiAgICBkYXRhID0gZGwuZHVwbGljYXRlKG91dHB1dC5kYXRhKTtcbiAgICBkZWxldGUgb3V0cHV0LmRhdGFbdGhpcy5fZHMubmFtZSgpXTtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKG91dHB1dCk7XG4gICAgb3V0cHV0LmRhdGEgPSBkYXRhO1xuXG4gICAgLy8gSWYgYSBzY2FsZSBvciBzaWduYWwgaW4gdGhlIHVwZGF0ZSBwcm9wc2V0IGhhcyBiZWVuIHVwZGF0ZWQsIFxuICAgIC8vIHNlbmQgZm9yd2FyZCBhbGwgaXRlbXMgZm9yIHJlZW5jb2RpbmcgaWYgd2UgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgIGlmKGZ1bGxVcGRhdGUpIG91dHB1dC5tb2QgPSB0aGlzLl9tYXJrLml0ZW1zLnNsaWNlKCk7XG5cbiAgICBmY3MgPSB0aGlzLl9kcy5sYXN0KCk7XG4gICAgaWYoIWZjcykge1xuICAgICAgb3V0cHV0LnJlZmxvdyA9IHRydWVcbiAgICB9IGVsc2UgaWYoZmNzLnN0YW1wID4gdGhpcy5fc3RhbXApIHtcbiAgICAgIG91dHB1dCA9IGpvaW5EYXRhc291cmNlLmNhbGwodGhpcywgZmNzLCB0aGlzLl9kcy52YWx1ZXMoKSwgZnVsbFVwZGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZ1bGxVcGRhdGUgPSB0aGlzLl9lbmNvZGVyLnJlZXZhbHVhdGUoaW5wdXQpO1xuICAgIGRhdGEgPSBkbC5pc0Z1bmN0aW9uKHRoaXMuX2RlZi5mcm9tKSA/IHRoaXMuX2RlZi5mcm9tKCkgOiBbQy5TRU5USU5FTF07XG4gICAgb3V0cHV0ID0gam9pblZhbHVlcy5jYWxsKHRoaXMsIGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKTtcbiAgfVxuXG4gIG91dHB1dCA9IHRoaXMuX2dyYXBoLmV2YWx1YXRlKG91dHB1dCwgdGhpcy5fZW5jb2Rlcik7XG4gIHJldHVybiB0aGlzLl9pc1N1cGVyID8gdGhpcy5fZ3JhcGguZXZhbHVhdGUob3V0cHV0LCB0aGlzLl9ib3VuZGVyKSA6IG91dHB1dDtcbn07XG5cbmZ1bmN0aW9uIG5ld0l0ZW0oKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQsXG4gICAgICBpdGVtID0gdHVwbGUuaW5nZXN0KG5ldyBJdGVtKHRoaXMuX21hcmspLCBwcmV2KTtcblxuICAvLyBGb3IgdGhlIHJvb3Qgbm9kZSdzIGl0ZW1cbiAgaWYodGhpcy5fZGVmLndpZHRoKSAgdHVwbGUuc2V0KGl0ZW0sIFwid2lkdGhcIiwgIHRoaXMuX2RlZi53aWR0aCk7XG4gIGlmKHRoaXMuX2RlZi5oZWlnaHQpIHR1cGxlLnNldChpdGVtLCBcImhlaWdodFwiLCB0aGlzLl9kZWYuaGVpZ2h0KTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5mdW5jdGlvbiBqb2luKGRhdGEsIGtleWYsIG5leHQsIG91dHB1dCwgcHJldiwgbW9kKSB7XG4gIHZhciBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvcihpPTAsIGxlbj1kYXRhLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGRhdHVtID0gZGF0YVtpXTtcbiAgICBpdGVtICA9IGtleWYgPyB0aGlzLl9tYXBba2V5ID0ga2V5ZihkYXR1bSldIDogcHJldltpXTtcbiAgICBlbnRlciA9IGl0ZW0gPyBmYWxzZSA6IChpdGVtID0gbmV3SXRlbS5jYWxsKHRoaXMpLCB0cnVlKTtcbiAgICBpdGVtLnN0YXR1cyA9IGVudGVyID8gQy5FTlRFUiA6IEMuVVBEQVRFO1xuICAgIGl0ZW0uZGF0dW0gPSBkYXR1bTtcbiAgICB0dXBsZS5zZXQoaXRlbSwgXCJrZXlcIiwga2V5KTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IGl0ZW07XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIGlmKGVudGVyKSBvdXRwdXQuYWRkLnB1c2goaXRlbSk7XG4gICAgZWxzZSBpZighbW9kIHx8IChtb2QgJiYgbW9kW2RhdHVtLl9pZF0pKSBvdXRwdXQubW9kLnB1c2goaXRlbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gam9pbkRhdGFzb3VyY2UoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkgfHwgXCJfaWRcIiksXG4gICAgICBhZGQgPSBpbnB1dC5hZGQsIFxuICAgICAgbW9kID0gaW5wdXQubW9kLCBcbiAgICAgIHJlbSA9IGlucHV0LnJlbSxcbiAgICAgIG5leHQgPSBbXSxcbiAgICAgIGksIGtleSwgbGVuLCBpdGVtLCBkYXR1bSwgZW50ZXI7XG5cbiAgLy8gQnVpbGQgcmVtcyBmaXJzdCwgYW5kIHB1dCB0aGVtIGF0IHRoZSBoZWFkIG9mIHRoZSBuZXh0IGl0ZW1zXG4gIC8vIFRoZW4gYnVpbGQgdGhlIHJlc3Qgb2YgdGhlIGRhdGEgdmFsdWVzICh3aGljaCB3b24ndCBjb250YWluIHJlbSkuXG4gIC8vIFRoaXMgd2lsbCBwcmVzZXJ2ZSB0aGUgc29ydCBvcmRlciB3aXRob3V0IG5lZWRpbmcgYW55dGhpbmcgZXh0cmEuXG5cbiAgZm9yKGk9MCwgbGVuPXJlbS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gdGhpcy5fbWFwW2tleSA9IGtleWYocmVtW2ldKV07XG4gICAgaXRlbS5zdGF0dXMgPSBDLkVYSVQ7XG4gICAgbmV4dC5wdXNoKGl0ZW0pO1xuICAgIG91dHB1dC5yZW0ucHVzaChpdGVtKTtcbiAgICB0aGlzLl9tYXBba2V5XSA9IG51bGw7XG4gIH1cblxuICBqb2luLmNhbGwodGhpcywgZGF0YSwga2V5ZiwgbmV4dCwgb3V0cHV0LCBudWxsLCB0dXBsZS5pZE1hcChmdWxsVXBkYXRlID8gZGF0YSA6IG1vZCkpO1xuXG4gIHJldHVybiAodGhpcy5fbWFyay5pdGVtcyA9IG5leHQsIG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIGpvaW5WYWx1ZXMoaW5wdXQsIGRhdGEsIGZ1bGxVcGRhdGUpIHtcbiAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAga2V5ZiA9IGtleUZ1bmN0aW9uKHRoaXMuX2RlZi5rZXkpLFxuICAgICAgcHJldiA9IHRoaXMuX21hcmsuaXRlbXMgfHwgW10sXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpdGVtLnN0YXR1cyA9IEMuRVhJVDtcbiAgICBpZiAoa2V5ZikgdGhpcy5fbWFwW2l0ZW0ua2V5XSA9IGl0ZW07XG4gIH1cbiAgXG4gIGpvaW4uY2FsbCh0aGlzLCBkYXRhLCBrZXlmLCBuZXh0LCBvdXRwdXQsIHByZXYsIGZ1bGxVcGRhdGUgPyB0dXBsZS5pZE1hcChkYXRhKSA6IG51bGwpO1xuXG4gIGZvciAoaT0wLCBsZW49cHJldi5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBpdGVtID0gcHJldltpXTtcbiAgICBpZiAoaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkge1xuICAgICAgdHVwbGUuc2V0KGl0ZW0sIFwia2V5XCIsIGtleWYgPyBpdGVtLmtleSA6IHRoaXMuX2l0ZW1zLmxlbmd0aCk7XG4gICAgICBuZXh0LnNwbGljZSgwLCAwLCBpdGVtKTsgIC8vIEtlZXAgaXRlbSBhcm91bmQgZm9yIFwiZXhpdFwiIHRyYW5zaXRpb24uXG4gICAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gKHRoaXMuX21hcmsuaXRlbXMgPSBuZXh0LCBvdXRwdXQpO1xufTtcblxuZnVuY3Rpb24ga2V5RnVuY3Rpb24oa2V5KSB7XG4gIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG4gIHZhciBmID0gZGwuYXJyYXkoa2V5KS5tYXAoZGwuYWNjZXNzb3IpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIGZvciAodmFyIHM9XCJcIiwgaT0wLCBuPWYubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaWYgKGk+MCkgcyArPSBcInxcIjtcbiAgICAgIHMgKz0gU3RyaW5nKGZbaV0oZCkpO1xuICAgIH1cbiAgICByZXR1cm4gcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWlsZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGJvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgRU1QVFkgPSB7fTtcblxuZnVuY3Rpb24gRW5jb2RlcihncmFwaCwgbWFyaykge1xuICB2YXIgcHJvcHMgPSBtYXJrLmRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlO1xuXG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcblxuICB0aGlzLl9tYXJrICA9IG1hcms7XG5cbiAgaWYodXBkYXRlKSB7XG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuREFUQSwgdXBkYXRlLmRhdGEpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLlNDQUxFUywgdXBkYXRlLnNjYWxlcyk7XG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUywgdXBkYXRlLnNpZ25hbHMpO1xuICAgIHRoaXMuZGVwZW5kZW5jeShDLkZJRUxEUywgdXBkYXRlLmZpZWxkcyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEVuY29kZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImVuY29kaW5nXCIsIHRoaXMuX21hcmsuZGVmLnR5cGVdKTtcbiAgdmFyIGdyYXBoID0gdGhpcy5fZ3JhcGgsXG4gICAgICBpdGVtcyA9IHRoaXMuX21hcmsuaXRlbXMsXG4gICAgICBwcm9wcyA9IHRoaXMuX21hcmsuZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBlbnRlciAgPSBwcm9wcy5lbnRlcixcbiAgICAgIHVwZGF0ZSA9IHByb3BzLnVwZGF0ZSxcbiAgICAgIGV4aXQgICA9IHByb3BzLmV4aXQsXG4gICAgICBwcmVkcyAgPSB0aGlzLl9ncmFwaC5wcmVkaWNhdGVzKCksXG4gICAgICBzZyA9IGdyYXBoLnNpZ25hbFZhbHVlcygpLCAgLy8gRm9yIGV4cGVkaWVuY3ksIGdldCBhbGwgc2lnbmFsIHZhbHVlc1xuICAgICAgZGIgPSBncmFwaC5kYXRhVmFsdWVzKCksIFxuICAgICAgcmVxID0gaW5wdXQucmVxdWVzdCxcbiAgICAgIGksIGxlbiwgaXRlbSwgcHJvcDtcblxuICBpZihyZXEpIHtcbiAgICBpZihwcm9wID0gcHJvcHNbcmVxXSkge1xuICAgICAgZm9yKGk9MCwgbGVuPWlucHV0Lm1vZC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgICAgaXRlbSA9IGlucHV0Lm1vZFtpXTtcbiAgICAgICAgZW5jb2RlLmNhbGwodGhpcywgcHJvcCwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbnB1dDsgLy8gZXhpdCBlYXJseSBpZiBnaXZlbiByZXF1ZXN0XG4gIH1cblxuICAvLyBJdGVtcyBtYXJrZWQgZm9yIHJlbW92YWwgYXJlIGF0IHRoZSBoZWFkIG9mIGl0ZW1zLiBQcm9jZXNzIHRoZW0gZmlyc3QuXG4gIGZvcihpPTAsIGxlbj1pbnB1dC5yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IGlucHV0LnJlbVtpXTtcbiAgICBpZih1cGRhdGUpIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpO1xuICAgIGlmKGV4aXQpICAgZW5jb2RlLmNhbGwodGhpcywgZXhpdCwgICBpdGVtLCBpbnB1dC50cmFucywgZGIsIHNnLCBwcmVkcyk7IFxuICAgIGlmKGlucHV0LnRyYW5zICYmICFleGl0KSBpbnB1dC50cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBFTVBUWSk7XG4gICAgZWxzZSBpZighaW5wdXQudHJhbnMpIGl0ZW0ucmVtb3ZlKCk7XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5hZGRbaV07XG4gICAgaWYoZW50ZXIpICBlbmNvZGUuY2FsbCh0aGlzLCBlbnRlciwgIGl0ZW0sIGlucHV0LnRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICBpZih1cGRhdGUpIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpO1xuICAgIGl0ZW0uc3RhdHVzID0gQy5VUERBVEU7XG4gIH1cblxuICBpZih1cGRhdGUpIHtcbiAgICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGlucHV0Lm1vZFtpXTtcbiAgICAgIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMsIGRiLCBzZywgcHJlZHMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZShwcm9wLCBpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcykge1xuICB2YXIgZW5jID0gcHJvcC5lbmNvZGU7XG4gIGVuYy5jYWxsKGVuYywgaXRlbSwgaXRlbS5tYXJrLmdyb3VwfHxpdGVtLCB0cmFucywgZGIsIHNnLCBwcmVkcyk7XG59XG5cbi8vIElmIGEgc3BlY2lmaWVkIHByb3BlcnR5IHNldCBjYWxsZWQsIG9yIHVwZGF0ZSBwcm9wZXJ0eSBzZXQgXG4vLyB1c2VzIG5lc3RlZCBmaWVsZHJlZnMsIHJlZXZhbHVhdGUgYWxsIGl0ZW1zLlxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX21hcmsuZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGU7XG5cbiAgcmV0dXJuIHB1bHNlLnJlcXVlc3QgfHwgXG4gICAgTm9kZS5wcm90b3R5cGUucmVldmFsdWF0ZS5jYWxsKHRoaXMsIHB1bHNlKSB8fCBcbiAgICAodXBkYXRlID8gdXBkYXRlLnJlZmxvdyA6IGZhbHNlKTtcbn07XG5cbi8vIFNob3J0LWNpcmN1aXQgZW5jb2RlciBpZiB1c2VyIHNwZWNpZmllcyBpdGVtc1xuRW5jb2Rlci51cGRhdGUgPSBmdW5jdGlvbihncmFwaCwgdHJhbnMsIHJlcXVlc3QsIGl0ZW1zKSB7XG4gIGl0ZW1zID0gZGwuYXJyYXkoaXRlbXMpO1xuICB2YXIgcHJlZHMgPSBncmFwaC5wcmVkaWNhdGVzKCksIFxuICAgICAgZGIgPSBncmFwaC5kYXRhVmFsdWVzKCksXG4gICAgICBzZyA9IGdyYXBoLnNpZ25hbFZhbHVlcygpLFxuICAgICAgaSwgbGVuLCBpdGVtLCBwcm9wcywgcHJvcDtcblxuICBmb3IgKGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBwcm9wcyA9IGl0ZW0ubWFyay5kZWYucHJvcGVydGllcztcbiAgICBwcm9wID0gcHJvcHMgJiYgcHJvcHNbcmVxdWVzdF07XG4gICAgaWYgKHByb3ApIHtcbiAgICAgIGVuY29kZS5jYWxsKG51bGwsIHByb3AsIGl0ZW0sIHRyYW5zLCBkYiwgc2csIHByZWRzKTtcbiAgICAgIGJvdW5kcy5pdGVtKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVuY29kZXI7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgQ29sbGVjdG9yID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvQ29sbGVjdG9yJyksXG4gICAgQnVpbGRlciA9IHJlcXVpcmUoJy4vQnVpbGRlcicpLFxuICAgIFNjYWxlID0gcmVxdWlyZSgnLi9TY2FsZScpLFxuICAgIHBhcnNlQXhlcyA9IHJlcXVpcmUoJy4uL3BhcnNlL2F4ZXMnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gR3JvdXBCdWlsZGVyKCkge1xuICB0aGlzLl9jaGlsZHJlbiA9IHt9O1xuICB0aGlzLl9zY2FsZXIgPSBudWxsO1xuICB0aGlzLl9yZWN1cnNvciA9IG51bGw7XG5cbiAgdGhpcy5fc2NhbGVzID0ge307XG4gIHRoaXMuc2NhbGUgPSBzY2FsZS5iaW5kKHRoaXMpO1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbn1cblxudmFyIHByb3RvID0gKEdyb3VwQnVpbGRlci5wcm90b3R5cGUgPSBuZXcgQnVpbGRlcigpKTtcblxucHJvdG8uaW5pdCA9IGZ1bmN0aW9uKGdyYXBoLCBkZWYsIG1hcmssIHBhcmVudCwgcGFyZW50X2lkLCBpbmhlcml0RnJvbSkge1xuICB2YXIgYnVpbGRlciA9IHRoaXM7XG5cbiAgdGhpcy5fc2NhbGVyID0gbmV3IE5vZGUoZ3JhcGgpO1xuXG4gIChkZWYuc2NhbGVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7IFxuICAgIHMgPSBidWlsZGVyLnNjYWxlKHMubmFtZSwgbmV3IFNjYWxlKGdyYXBoLCBzLCBidWlsZGVyKSk7XG4gICAgYnVpbGRlci5fc2NhbGVyLmFkZExpc3RlbmVyKHMpOyAgLy8gU2NhbGVzIHNob3VsZCBiZSBjb21wdXRlZCBhZnRlciBncm91cCBpcyBlbmNvZGVkXG4gIH0pO1xuXG4gIHRoaXMuX3JlY3Vyc29yID0gbmV3IE5vZGUoZ3JhcGgpO1xuICB0aGlzLl9yZWN1cnNvci5ldmFsdWF0ZSA9IHJlY3Vyc2UuYmluZCh0aGlzKTtcblxuICB2YXIgc2NhbGVzID0gKGRlZi5heGVzfHxbXSkucmVkdWNlKGZ1bmN0aW9uKGFjYywgeCkge1xuICAgIHJldHVybiAoYWNjW3guc2NhbGVdID0gMSwgYWNjKTtcbiAgfSwge30pO1xuICB0aGlzLl9yZWN1cnNvci5kZXBlbmRlbmN5KEMuU0NBTEVTLCBkbC5rZXlzKHNjYWxlcykpO1xuXG4gIC8vIFdlIG9ubHkgbmVlZCBhIGNvbGxlY3RvciBmb3IgdXAtcHJvcGFnYXRpb24gb2YgYm91bmRzIGNhbGN1bGF0aW9uLFxuICAvLyBzbyBvbmx5IEdyb3VwQnVpbGRlcnMsIGFuZCBub3QgcmVndWxhciBCdWlsZGVycywgaGF2ZSBjb2xsZWN0b3JzLlxuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcblxuICByZXR1cm4gQnVpbGRlci5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gQnVpbGRlci5wcm90b3R5cGUuZXZhbHVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIG91dHB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbihncm91cCkgeyBidWlsZEdyb3VwLmNhbGwoYnVpbGRlciwgb3V0cHV0LCBncm91cCk7IH0pO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxucHJvdG8ucGlwZWxpbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt0aGlzLCB0aGlzLl9zY2FsZXIsIHRoaXMuX3JlY3Vyc29yLCB0aGlzLl9jb2xsZWN0b3IsIHRoaXMuX2JvdW5kZXJdO1xufTtcblxucHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVpbGRlciA9IHRoaXM7XG4gIGRsLmtleXMoYnVpbGRlci5fY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24oZ3JvdXBfaWQpIHtcbiAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cF9pZF0uZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICBidWlsZGVyLl9yZWN1cnNvci5yZW1vdmVMaXN0ZW5lcihjLmJ1aWxkZXIpO1xuICAgICAgYy5idWlsZGVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9KVxuICB9KTtcblxuICBidWlsZGVyLl9jaGlsZHJlbiA9IHt9O1xuICByZXR1cm4gQnVpbGRlci5wcm90b3R5cGUuZGlzY29ubmVjdC5jYWxsKHRoaXMpO1xufTtcblxucHJvdG8uY2hpbGQgPSBmdW5jdGlvbihuYW1lLCBncm91cF9pZCkge1xuICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbltncm91cF9pZF0sXG4gICAgICBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgY2hpbGQ7XG5cbiAgZm9yKDsgaTxsZW47ICsraSkge1xuICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYoY2hpbGQudHlwZSA9PSBDLk1BUksgJiYgY2hpbGQuYnVpbGRlci5fZGVmLm5hbWUgPT0gbmFtZSkgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gY2hpbGQuYnVpbGRlcjtcbn07XG5cbmZ1bmN0aW9uIHJlY3Vyc2UoaW5wdXQpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzLFxuICAgICAgaGFzTWFya3MgPSB0aGlzLl9kZWYubWFya3MgJiYgdGhpcy5fZGVmLm1hcmtzLmxlbmd0aCA+IDAsXG4gICAgICBoYXNBeGVzID0gdGhpcy5fZGVmLmF4ZXMgJiYgdGhpcy5fZGVmLmF4ZXMubGVuZ3RoID4gMCxcbiAgICAgIGksIGxlbiwgZ3JvdXAsIHBpcGVsaW5lLCBkZWYsIGlubGluZSA9IGZhbHNlO1xuXG4gIGZvcihpPTAsIGxlbj1pbnB1dC5hZGQubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgZ3JvdXAgPSBpbnB1dC5hZGRbaV07XG4gICAgaWYoaGFzTWFya3MpIGJ1aWxkTWFya3MuY2FsbCh0aGlzLCBpbnB1dCwgZ3JvdXApO1xuICAgIGlmKGhhc0F4ZXMpICBidWlsZEF4ZXMuY2FsbCh0aGlzLCBpbnB1dCwgZ3JvdXApO1xuICB9XG5cbiAgLy8gV2lyZSB1cCBuZXcgY2hpbGRyZW4gYnVpbGRlcnMgaW4gcmV2ZXJzZSB0byBtaW5pbWl6ZSBncmFwaCByZXdyaXRlcy5cbiAgZm9yIChpPWlucHV0LmFkZC5sZW5ndGgtMTsgaT49MDsgLS1pKSB7XG4gICAgZ3JvdXAgPSBpbnB1dC5hZGRbaV07XG4gICAgZm9yIChqPXRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0ubGVuZ3RoLTE7IGo+PTA7IC0taikge1xuICAgICAgYyA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF1bal07XG4gICAgICBjLmJ1aWxkZXIuY29ubmVjdCgpO1xuICAgICAgcGlwZWxpbmUgPSBjLmJ1aWxkZXIucGlwZWxpbmUoKTtcbiAgICAgIGRlZiA9IGMuYnVpbGRlci5fZGVmO1xuXG4gICAgICAvLyBUaGlzIG5ldyBjaGlsZCBuZWVkcyB0byBiZSBidWlsdCBkdXJpbmcgdGhpcyBwcm9wYWdhdGlvbiBjeWNsZS5cbiAgICAgIC8vIFdlIGNvdWxkIGFkZCBpdHMgYnVpbGRlciBhcyBhIGxpc3RlbmVyIG9mZiB0aGUgX3JlY3Vyc29yIG5vZGUsIFxuICAgICAgLy8gYnV0IHRyeSB0byBpbmxpbmUgaXQgaWYgd2UgY2FuIHRvIG1pbmltaXplIGdyYXBoIGRpc3BhdGNoZXMuXG4gICAgICBpbmxpbmUgPSAoZGVmLnR5cGUgIT09IEMuR1JPVVApO1xuICAgICAgaW5saW5lID0gaW5saW5lICYmICh0aGlzLl9ncmFwaC5kYXRhKGMuZnJvbSkgIT09IHVuZGVmaW5lZCk7IFxuICAgICAgaW5saW5lID0gaW5saW5lICYmIChwaXBlbGluZVtwaXBlbGluZS5sZW5ndGgtMV0ubGlzdGVuZXJzKCkubGVuZ3RoID09IDEpOyAvLyBSZWFjdGl2ZSBnZW9tXG4gICAgICBjLmlubGluZSA9IGlubGluZTtcblxuICAgICAgaWYoaW5saW5lKSBjLmJ1aWxkZXIuZXZhbHVhdGUoaW5wdXQpO1xuICAgICAgZWxzZSB0aGlzLl9yZWN1cnNvci5hZGRMaXN0ZW5lcihjLmJ1aWxkZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZvcihpPTAsIGxlbj1pbnB1dC5tb2QubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgZ3JvdXAgPSBpbnB1dC5tb2RbaV07XG4gICAgLy8gUmVtb3ZlIHRlbXBvcmFyeSBjb25uZWN0aW9uIGZvciBtYXJrcyB0aGF0IGRyYXcgZnJvbSBhIHNvdXJjZVxuICAgIGlmKGhhc01hcmtzKSB7XG4gICAgICBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgICBpZihjLnR5cGUgPT0gQy5NQVJLICYmICFjLmlubGluZSAmJiBidWlsZGVyLl9ncmFwaC5kYXRhKGMuZnJvbSkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBidWlsZGVyLl9yZWN1cnNvci5yZW1vdmVMaXN0ZW5lcihjLmJ1aWxkZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgYXhlcyBkYXRhIGRlZnNcbiAgICBpZihoYXNBeGVzKSB7XG4gICAgICBwYXJzZUF4ZXMoYnVpbGRlci5fZ3JhcGgsIGJ1aWxkZXIuX2RlZi5heGVzLCBncm91cC5heGVzLCBncm91cCk7XG4gICAgICBncm91cC5heGVzLmZvckVhY2goZnVuY3Rpb24oYSwgaSkgeyBhLmRlZigpIH0pO1xuICAgIH0gICAgICBcbiAgfVxuXG4gIGZvcihpPTAsIGxlbj1pbnB1dC5yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgZ3JvdXAgPSBpbnB1dC5yZW1baV07XG4gICAgLy8gRm9yIGRlbGV0ZWQgZ3JvdXBzLCBkaXNjb25uZWN0IHRoZWlyIGNoaWxkcmVuXG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsgXG4gICAgICBidWlsZGVyLl9yZWN1cnNvci5yZW1vdmVMaXN0ZW5lcihjLmJ1aWxkZXIpO1xuICAgICAgYy5idWlsZGVyLmRpc2Nvbm5lY3QoKTsgXG4gICAgfSk7XG4gICAgZGVsZXRlIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF07XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5mdW5jdGlvbiBzY2FsZShuYW1lLCBzY2FsZSkge1xuICB2YXIgZ3JvdXAgPSB0aGlzO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSByZXR1cm4gKGdyb3VwLl9zY2FsZXNbbmFtZV0gPSBzY2FsZSwgc2NhbGUpO1xuICB3aGlsZShzY2FsZSA9PSBudWxsKSB7XG4gICAgc2NhbGUgPSBncm91cC5fc2NhbGVzW25hbWVdO1xuICAgIGdyb3VwID0gZ3JvdXAubWFyayA/IGdyb3VwLm1hcmsuZ3JvdXAgOiBncm91cC5fcGFyZW50O1xuICAgIGlmKCFncm91cCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBidWlsZEdyb3VwKGlucHV0LCBncm91cCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiYnVpbGRpbmcgZ3JvdXBcIiwgZ3JvdXAuX2lkXSk7XG5cbiAgZ3JvdXAuX3NjYWxlcyA9IGdyb3VwLl9zY2FsZXMgfHwge307ICAgIFxuICBncm91cC5zY2FsZSAgPSBzY2FsZS5iaW5kKGdyb3VwKTtcblxuICBncm91cC5pdGVtcyA9IGdyb3VwLml0ZW1zIHx8IFtdO1xuICB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdID0gdGhpcy5fY2hpbGRyZW5bZ3JvdXAuX2lkXSB8fCBbXTtcblxuICBncm91cC5heGVzID0gZ3JvdXAuYXhlcyB8fCBbXTtcbiAgZ3JvdXAuYXhpc0l0ZW1zID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IFtdO1xufVxuXG5mdW5jdGlvbiBidWlsZE1hcmtzKGlucHV0LCBncm91cCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiYnVpbGRpbmcgbWFya3NcIiwgZ3JvdXAuX2lkXSk7XG4gIHZhciBtYXJrcyA9IHRoaXMuX2RlZi5tYXJrcyxcbiAgICAgIGxpc3RlbmVycyA9IFtdLFxuICAgICAgbWFyaywgZnJvbSwgaW5oZXJpdCwgaSwgbGVuLCBtLCBiO1xuXG4gIGZvcihpPTAsIGxlbj1tYXJrcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBtYXJrID0gbWFya3NbaV07XG4gICAgZnJvbSA9IG1hcmsuZnJvbSB8fCB7fTtcbiAgICBpbmhlcml0ID0gXCJ2Z19cIitncm91cC5kYXR1bS5faWQ7XG4gICAgZ3JvdXAuaXRlbXNbaV0gPSB7Z3JvdXA6IGdyb3VwfTtcbiAgICBiID0gKG1hcmsudHlwZSA9PT0gQy5HUk9VUCkgPyBuZXcgR3JvdXBCdWlsZGVyKCkgOiBuZXcgQnVpbGRlcigpO1xuICAgIGIuaW5pdCh0aGlzLl9ncmFwaCwgbWFyaywgZ3JvdXAuaXRlbXNbaV0sIHRoaXMsIGdyb3VwLl9pZCwgaW5oZXJpdCk7XG4gICAgdGhpcy5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5wdXNoKHsgXG4gICAgICBidWlsZGVyOiBiLCBcbiAgICAgIGZyb206IGZyb20uZGF0YSB8fCAoZnJvbS5tYXJrID8gKFwidmdfXCIgKyBncm91cC5faWQgKyBcIl9cIiArIGZyb20ubWFyaykgOiBpbmhlcml0KSwgXG4gICAgICB0eXBlOiBDLk1BUksgXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRBeGVzKGlucHV0LCBncm91cCkge1xuICB2YXIgYXhlcyA9IGdyb3VwLmF4ZXMsXG4gICAgICBheGlzSXRlbXMgPSBncm91cC5heGlzSXRlbXMsXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBwYXJzZUF4ZXModGhpcy5fZ3JhcGgsIHRoaXMuX2RlZi5heGVzLCBheGVzLCBncm91cCk7XG4gIGF4ZXMuZm9yRWFjaChmdW5jdGlvbihhLCBpKSB7XG4gICAgdmFyIHNjYWxlID0gYnVpbGRlci5fZGVmLmF4ZXNbaV0uc2NhbGUsXG4gICAgICAgIGRlZiA9IGEuZGVmKCksXG4gICAgICAgIGIgPSBudWxsO1xuXG4gICAgYXhpc0l0ZW1zW2ldID0ge2dyb3VwOiBncm91cCwgYXhpc0RlZjogZGVmfTtcbiAgICBiID0gKGRlZi50eXBlID09PSBDLkdST1VQKSA/IG5ldyBHcm91cEJ1aWxkZXIoKSA6IG5ldyBCdWlsZGVyKCk7XG4gICAgYi5pbml0KGJ1aWxkZXIuX2dyYXBoLCBkZWYsIGF4aXNJdGVtc1tpXSwgYnVpbGRlcilcbiAgICAgIC5kZXBlbmRlbmN5KEMuU0NBTEVTLCBzY2FsZSk7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5wdXNoKHsgYnVpbGRlcjogYiwgdHlwZTogQy5BWElTLCBzY2FsZTogc2NhbGUgfSk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwQnVpbGRlcjsiLCJmdW5jdGlvbiBJdGVtKG1hcmspIHtcbiAgdGhpcy5tYXJrID0gbWFyaztcbn1cblxudmFyIHByb3RvdHlwZSA9IEl0ZW0ucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaGFzUHJvcGVydHlTZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBwcm9wcyA9IHRoaXMubWFyay5kZWYucHJvcGVydGllcztcbiAgcmV0dXJuIHByb3BzICYmIHByb3BzW25hbWVdICE9IG51bGw7XG59O1xuXG5wcm90b3R5cGUuY291c2luID0gZnVuY3Rpb24ob2Zmc2V0LCBpbmRleCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGdyb3VwID0gbWFyay5ncm91cCxcbiAgICAgIGlpZHggPSBpbmRleD09bnVsbCA/IG1hcmsuaXRlbXMuaW5kZXhPZih0aGlzKSA6IGluZGV4LFxuICAgICAgbWlkeCA9IGdyb3VwLml0ZW1zLmluZGV4T2YobWFyaykgKyBvZmZzZXQ7XG4gIHJldHVybiBncm91cC5pdGVtc1ttaWR4XS5pdGVtc1tpaWR4XTtcbn07XG5cbnByb3RvdHlwZS5zaWJsaW5nID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIGlmIChvZmZzZXQgPT09IDApIHJldHVybiB0aGlzO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgLTE7XG4gIHZhciBtYXJrID0gdGhpcy5tYXJrLFxuICAgICAgaWlkeCA9IG1hcmsuaXRlbXMuaW5kZXhPZih0aGlzKSArIG9mZnNldDtcbiAgcmV0dXJuIG1hcmsuaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtID0gdGhpcyxcbiAgICAgIGxpc3QgPSBpdGVtLm1hcmsuaXRlbXMsXG4gICAgICBpID0gbGlzdC5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaSA+PSAwKSAoaT09PWxpc3QubGVuZ3RoLTEpID8gbGlzdC5wb3AoKSA6IGxpc3Quc3BsaWNlKGksIDEpO1xuICByZXR1cm4gaXRlbTtcbn07XG5cbnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYXRoQ2FjaGUpIHRoaXMucGF0aENhY2hlID0gbnVsbDtcbiAgaWYgKHRoaXMubWFyay5wYXRoQ2FjaGUpIHRoaXMubWFyay5wYXRoQ2FjaGUgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJdGVtOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgQWdncmVnYXRlID0gcmVxdWlyZSgnLi4vdHJhbnNmb3Jtcy9BZ2dyZWdhdGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgR1JPVVBfUFJPUEVSVFkgPSB7d2lkdGg6IDEsIGhlaWdodDogMX07XG5cbmZ1bmN0aW9uIFNjYWxlKGdyYXBoLCBkZWYsIHBhcmVudCkge1xuICB0aGlzLl9kZWYgICAgID0gZGVmO1xuICB0aGlzLl9wYXJlbnQgID0gcGFyZW50O1xuICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xufVxuXG52YXIgcHJvdG8gPSAoU2NhbGUucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgZm4gPSBmdW5jdGlvbihncm91cCkgeyBzY2FsZS5jYWxsKHNlbGYsIGdyb3VwKTsgfTtcblxuICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gIGlucHV0LmFkZC5mb3JFYWNoKGZuKTtcbiAgaW5wdXQubW9kLmZvckVhY2goZm4pO1xuXG4gIC8vIFNjYWxlcyBhcmUgYXQgdGhlIGVuZCBvZiBhbiBlbmNvZGluZyBwaXBlbGluZSwgc28gdGhleSBzaG91bGQgZm9yd2FyZCBhXG4gIC8vIHJlZmxvdyBwdWxzZS4gVGh1cywgaWYgbXVsdGlwbGUgc2NhbGVzIHVwZGF0ZSBpbiB0aGUgcGFyZW50IGdyb3VwLCB3ZSBkb24ndFxuICAvLyByZWV2YWx1YXRlIGNoaWxkIG1hcmtzIG11bHRpcGxlIHRpbWVzLiBcbiAgaWYgKHRoaXMuX3VwZGF0ZWQpIGlucHV0LnNjYWxlc1t0aGlzLl9kZWYubmFtZV0gPSAxO1xuICByZXR1cm4gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCwgdHJ1ZSk7XG59O1xuXG4vLyBBbGwgb2YgYSBzY2FsZSdzIGRlcGVuZGVuY2llcyBhcmUgcmVnaXN0ZXJlZCBkdXJpbmcgcHJvcGFnYXRpb24gYXMgd2UgcGFyc2Vcbi8vIGRhdGFSZWZzLiBTbyBhIHNjYWxlIG11c3QgYmUgcmVzcG9uc2libGUgZm9yIGNvbm5lY3RpbmcgaXRzZWxmIHRvIGRlcGVuZGVudHMuXG5wcm90by5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgZGVwcyA9IGRsLmFycmF5KGRlcHMpO1xuICAgIGZvcih2YXIgaT0wLCBsZW49ZGVwcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2dyYXBoW3R5cGUgPT0gQy5EQVRBID8gQy5EQVRBIDogQy5TSUdOQUxdKGRlcHNbaV0pXG4gICAgICAgIC5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5kZXBlbmRlbmN5LmNhbGwodGhpcywgdHlwZSwgZGVwcyk7XG59O1xuXG5mdW5jdGlvbiBzY2FsZShncm91cCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX2RlZi5uYW1lLFxuICAgICAgcHJldiA9IG5hbWUgKyBcIjpwcmV2XCIsXG4gICAgICBzID0gaW5zdGFuY2UuY2FsbCh0aGlzLCBncm91cC5zY2FsZShuYW1lKSksXG4gICAgICBtID0gcy50eXBlPT09Qy5PUkRJTkFMID8gb3JkaW5hbCA6IHF1YW50aXRhdGl2ZSxcbiAgICAgIHJuZyA9IHJhbmdlLmNhbGwodGhpcywgZ3JvdXApO1xuXG4gIG0uY2FsbCh0aGlzLCBzLCBybmcsIGdyb3VwKTtcblxuICBncm91cC5zY2FsZShuYW1lLCBzKTtcbiAgZ3JvdXAuc2NhbGUocHJldiwgZ3JvdXAuc2NhbGUocHJldikgfHwgcyk7XG5cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlKHNjYWxlKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fZGVmLnR5cGUgfHwgQy5MSU5FQVI7XG4gIGlmICghc2NhbGUgfHwgdHlwZSAhPT0gc2NhbGUudHlwZSkge1xuICAgIHZhciBjdG9yID0gY29uZmlnLnNjYWxlW3R5cGVdIHx8IGQzLnNjYWxlW3R5cGVdO1xuICAgIGlmICghY3RvcikgZGwuZXJyb3IoXCJVbnJlY29nbml6ZWQgc2NhbGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAoc2NhbGUgPSBjdG9yKCkpLnR5cGUgPSBzY2FsZS50eXBlIHx8IHR5cGU7XG4gICAgc2NhbGUuc2NhbGVOYW1lID0gdGhpcy5fZGVmLm5hbWU7XG4gICAgc2NhbGUuX3ByZXYgPSB7fTtcbiAgfVxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIG9yZGluYWwoc2NhbGUsIHJuZywgZ3JvdXApIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZixcbiAgICAgIHByZXYgPSBzY2FsZS5fcHJldixcbiAgICAgIGRvbWFpbiwgc29ydCwgc3RyLCByZWZzLCBkYXRhRHJpdmVuUmFuZ2UgPSBmYWxzZTtcbiAgXG4gIC8vIHJhbmdlIHByZS1wcm9jZXNzaW5nIGZvciBkYXRhLWRyaXZlbiByYW5nZXNcbiAgaWYgKGRsLmlzT2JqZWN0KGRlZi5yYW5nZSkgJiYgIWRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgIGRhdGFEcml2ZW5SYW5nZSA9IHRydWU7XG4gICAgcm5nID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuUkFOR0UsIGRlZi5yYW5nZSwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuICBcbiAgLy8gZG9tYWluXG4gIGRvbWFpbiA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgaWYgKGRvbWFpbiAmJiAhZGwuZXF1YWwocHJldi5kb21haW4sIGRvbWFpbikpIHtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICBwcmV2LmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgfSBcblxuICAvLyByYW5nZVxuICBpZiAoZGwuZXF1YWwocHJldi5yYW5nZSwgcm5nKSkgcmV0dXJuO1xuXG4gIHN0ciA9IHR5cGVvZiBybmdbMF0gPT09ICdzdHJpbmcnO1xuICBpZiAoc3RyIHx8IHJuZy5sZW5ndGggPiAyIHx8IHJuZy5sZW5ndGg9PT0xIHx8IGRhdGFEcml2ZW5SYW5nZSkge1xuICAgIHNjYWxlLnJhbmdlKHJuZyk7IC8vIGNvbG9yIG9yIHNoYXBlIHZhbHVlc1xuICB9IGVsc2UgaWYgKGRlZi5wb2ludHMpIHtcbiAgICBzY2FsZS5yYW5nZVBvaW50cyhybmcsIGRlZi5wYWRkaW5nfHwwKTtcbiAgfSBlbHNlIGlmIChkZWYucm91bmQgfHwgZGVmLnJvdW5kPT09dW5kZWZpbmVkKSB7XG4gICAgc2NhbGUucmFuZ2VSb3VuZEJhbmRzKHJuZywgZGVmLnBhZGRpbmd8fDApO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlLnJhbmdlQmFuZHMocm5nLCBkZWYucGFkZGluZ3x8MCk7XG4gIH1cblxuICBwcmV2LnJhbmdlID0gcm5nO1xuICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpdGF0aXZlKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkb21haW4sIGludGVydmFsO1xuXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSAoZGVmLnR5cGUgPT09IEMuUVVBTlRJTEUpXG4gICAgPyBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cClcbiAgICA6IGRvbWFpbk1pbk1heC5jYWxsKHRoaXMsIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgLy8gdmVydGljYWwgc2NhbGVzIHNob3VsZCBmbGlwIGJ5IGRlZmF1bHQsIHNvIHVzZSBYT1IgaGVyZVxuICBpZiAoZGVmLnJhbmdlID09PSBcImhlaWdodFwiKSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICBpZiAoZGwuZXF1YWwocHJldi5yYW5nZSwgcm5nKSkgcmV0dXJuO1xuICBzY2FsZVtkZWYucm91bmQgJiYgc2NhbGUucmFuZ2VSb3VuZCA/IFwicmFuZ2VSb3VuZFwiIDogXCJyYW5nZVwiXShybmcpO1xuICBwcmV2LnJhbmdlID0gcm5nO1xuICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcblxuICAvLyBUT0RPOiBTdXBwb3J0IHNpZ25hbHMgZm9yIHRoZXNlIHByb3BlcnRpZXMuIFVudGlsIHRoZW4sIG9ubHkgZXZhbFxuICAvLyB0aGVtIG9uY2UuXG4gIGlmICh0aGlzLl9zdGFtcCA+IDApIHJldHVybjtcbiAgaWYgKGRlZi5leHBvbmVudCAmJiBkZWYudHlwZT09PUMuUE9XRVIpIHNjYWxlLmV4cG9uZW50KGRlZi5leHBvbmVudCk7XG4gIGlmIChkZWYuY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoZGVmLm5pY2UpIHtcbiAgICBpZiAoZGVmLnR5cGUgPT09IEMuVElNRSkge1xuICAgICAgaW50ZXJ2YWwgPSBkMy50aW1lW2RlZi5uaWNlXTtcbiAgICAgIGlmICghaW50ZXJ2YWwpIGRsLmVycm9yKFwiVW5yZWNvZ25pemVkIGludGVydmFsOiBcIiArIGludGVydmFsKTtcbiAgICAgIHNjYWxlLm5pY2UoaW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZS5uaWNlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5pcXVlcyhzY2FsZSkgeyBcbiAgcmV0dXJuIHNjYWxlLnR5cGUgPT09IEMuT1JESU5BTCB8fCBzY2FsZS50eXBlID09PSBDLlFVQU5USUxFOyBcbn1cblxuZnVuY3Rpb24gZ2V0UmVmcyhkZWYpIHsgXG4gIHJldHVybiBkZWYuZmllbGRzIHx8IGRsLmFycmF5KGRlZik7XG59XG5cbmZ1bmN0aW9uIGdldEZpZWxkcyhyZWYsIGdyb3VwKSB7XG4gIHJldHVybiBkbC5hcnJheShyZWYuZmllbGQpLm1hcChmdW5jdGlvbihmKSB7XG4gICAgaWYgKGYucGFyZW50KSByZXR1cm4gZGwuYWNjZXNzb3IoZi5wYXJlbnQpKGdyb3VwLmRhdHVtKVxuICAgIHJldHVybiBmOyAvLyBTdHJpbmcgb3Ige1wic2lnbmFsXCJ9XG4gIH0pO1xufVxuXG4vLyBTY2FsZSBkYXRhcmVmcyBjYW4gYmUgY29tcHV0ZWQgb3ZlciBtdWx0aXBsZSBzY2hlbWEgdHlwZXMuIFxuLy8gVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIGFnZ3JlZ2F0b3IgY3JlYXRlZCwgYW5kXG4vLyB3aGF0IGRhdGEgaXMgc2VudCB0byBpdDogdmFsdWVzLCB0dXBsZXMsIG9yIG11bHRpLXR1cGxlcyB0aGF0IG11c3Rcbi8vIGJlIHN0YW5kYXJkaXplZCBpbnRvIGEgY29uc2lzdGVudCBzY2hlbWEuIFxuZnVuY3Rpb24gYWdnclR5cGUoZGVmLCBzY2FsZSkge1xuICB2YXIgcmVmcyA9IGdldFJlZnMoZGVmKTtcblxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgb3ZlciBvbmx5IGEgc2luZ2xlIGRvbWFpbiwgc2VuZCBmdWxsIHR1cGxlc1xuICAvLyB0aHJvdWdoIGZvciBlZmZpY2llbmN5IChmZXdlciBhY2Nlc3NvciBjcmVhdGlvbnMvY2FsbHMpXG4gIGlmKHJlZnMubGVuZ3RoID09IDEgJiYgZGwuYXJyYXkocmVmc1swXS5maWVsZCkubGVuZ3RoID09IDEpIHtcbiAgICByZXR1cm4gQWdncmVnYXRlLlRZUEVTLlRVUExFO1xuICB9XG5cbiAgLy8gV2l0aCBxdWFudGl0YXRpdmUgc2NhbGVzLCB3ZSBvbmx5IGNhcmUgYWJvdXQgbWluL21heC5cbiAgaWYoIWlzVW5pcXVlcyhzY2FsZSkpIHJldHVybiBBZ2dyZWdhdGUuVFlQRVMuVkFMVUU7XG5cbiAgLy8gSWYgd2UgZG9uJ3Qgc29ydCwgdGhlbiB3ZSBjYW4gc2VuZCB2YWx1ZXMgZGlyZWN0bHkgdG8gYWdncnMgYXMgd2VsbFxuICBpZighZGVmLnNvcnQpIHJldHVybiBBZ2dyZWdhdGUuVFlQRVMuVkFMVUU7XG5cbiAgcmV0dXJuIEFnZ3JlZ2F0ZS5UWVBFUy5NVUxUSTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGUod2hpY2gsIGRlZiwgc2NhbGUsIGdyb3VwKSB7XG4gIHZhciByZWZzID0gZ2V0UmVmcyhkZWYpLFxuICAgICAgYXR5cGUgPSBhZ2dyVHlwZShkZWYsIHNjYWxlKSxcbiAgICAgIHVuaXF1ZXMgPSBpc1VuaXF1ZXMoc2NhbGUpLFxuICAgICAgc29ydCA9IGRlZi5zb3J0LFxuICAgICAgY2sgPSBcIl9cIit3aGljaCxcbiAgICAgIGZpZWxkcyA9IGdldEZpZWxkcyhyZWZzWzBdLCBncm91cCksXG4gICAgICBpLCBybGVuLCBqLCBmbGVuLCByZWYsIGZpZWxkO1xuXG4gIGlmKHNjYWxlW2NrXSkgcmV0dXJuIHNjYWxlW2NrXTtcblxuICB2YXIgY2FjaGUgPSBzY2FsZVtja10gPSBuZXcgQWdncmVnYXRlKHRoaXMuX2dyYXBoKS50eXBlKGF0eXBlKSxcbiAgICAgIGdyb3VwYnksIHN1bW1hcml6ZTtcblxuICBpZih1bmlxdWVzKSB7XG4gICAgaWYoYXR5cGUgPT09IEFnZ3JlZ2F0ZS5UWVBFUy5WQUxVRSkge1xuICAgICAgZ3JvdXBieSA9IFt7IG5hbWU6IEMuR1JPVVBCWSwgZ2V0OiBkbC5pZGVudGl0eSB9XTtcbiAgICAgIHN1bW1hcml6ZSA9IHtcIipcIjogQy5DT1VOVH07XG4gICAgfSBlbHNlIGlmKGF0eXBlID09PSBBZ2dyZWdhdGUuVFlQRVMuVFVQTEUpIHtcbiAgICAgIGdyb3VwYnkgPSBbeyBuYW1lOiBDLkdST1VQQlksIGdldDogZGwuJChmaWVsZHNbMF0pIH1dO1xuICAgICAgc3VtbWFyaXplID0gc29ydCA/IFt7XG4gICAgICAgIG5hbWU6IEMuVkFMVUUsXG4gICAgICAgIGdldDogIGRsLiQocmVmLnNvcnQgfHwgc29ydC5maWVsZCksXG4gICAgICAgIG9wczogW3NvcnQuc3RhdF1cbiAgICAgIH1dIDoge1wiKlwiOiBDLkNPVU5UfTtcbiAgICB9IGVsc2UgeyAgLy8gYXR5cGUgPT09IEFnZ3JlZ2F0ZS5UWVBFUy5NVUxUSVxuICAgICAgZ3JvdXBieSAgID0gQy5HUk9VUEJZO1xuICAgICAgc3VtbWFyaXplID0gW3sgbmFtZTogQy5WQUxVRSwgb3BzOiBbc29ydC5zdGF0XSB9XTsgXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdyb3VwYnkgPSBbXTtcbiAgICBzdW1tYXJpemUgPSBbe1xuICAgICAgbmFtZTogQy5WQUxVRSxcbiAgICAgIGdldDogKGF0eXBlID09IEFnZ3JlZ2F0ZS5UWVBFUy5UVVBMRSkgPyBkbC4kKGZpZWxkc1swXSkgOiBkbC5pZGVudGl0eSxcbiAgICAgIG9wczogW0MuTUlOLCBDLk1BWF0sXG4gICAgICBhczogIFtDLk1JTiwgQy5NQVhdXG4gICAgfV07XG4gIH1cblxuICBjYWNoZS5ncm91cGJ5LnNldChjYWNoZSwgZ3JvdXBieSlcbiAgICAuc3VtbWFyaXplLnNldChjYWNoZSwgc3VtbWFyaXplKTtcblxuICByZXR1cm4gY2FjaGU7XG59XG5cbmZ1bmN0aW9uIGRhdGFSZWYod2hpY2gsIGRlZiwgc2NhbGUsIGdyb3VwKSB7XG4gIGlmIChkZWYgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgaWYgKGRsLmlzQXJyYXkoZGVmKSkgcmV0dXJuIGRlZi5tYXAoc2lnbmFsLmJpbmQodGhpcykpO1xuXG4gIHZhciBzZWxmID0gdGhpcywgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHJlZnMgPSBnZXRSZWZzKGRlZiksXG4gICAgICBhdHlwZSA9IGFnZ3JUeXBlKGRlZiwgc2NhbGUpLFxuICAgICAgY2FjaGUgPSBnZXRDYWNoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgc29ydCAgPSBkZWYuc29ydCxcbiAgICAgIHVuaXF1ZXMgPSBpc1VuaXF1ZXMoc2NhbGUpLFxuICAgICAgaSwgcmxlbiwgaiwgZmxlbiwgcmVmLCBmaWVsZHMsIGZpZWxkO1xuXG4gIGZvcihpPTAsIHJsZW49cmVmcy5sZW5ndGg7IGk8cmxlbjsgKytpKSB7XG4gICAgcmVmID0gcmVmc1tpXTtcbiAgICBmcm9tID0gcmVmLmRhdGEgfHwgXCJ2Z19cIitncm91cC5kYXR1bS5faWQ7XG4gICAgZGF0YSA9IGdyYXBoLmRhdGEoZnJvbSlcbiAgICAgIC5yZXZpc2VzKHRydWUpXG4gICAgICAubGFzdCgpO1xuXG4gICAgaWYgKGRhdGEuc3RhbXAgPD0gdGhpcy5fc3RhbXApIGNvbnRpbnVlO1xuXG4gICAgZmllbGRzID0gZ2V0RmllbGRzKHJlZiwgZ3JvdXApO1xuICAgIGZvcihqPTAsIGZsZW49ZmllbGRzLmxlbmd0aDsgajxmbGVuOyArK2opIHtcbiAgICAgIGZpZWxkID0gZmllbGRzW2pdO1xuXG4gICAgICBpZihhdHlwZSA9PT0gQWdncmVnYXRlLlRZUEVTLlZBTFVFKSB7XG4gICAgICAgIGNhY2hlLmFjY2Vzc29ycyhudWxsLCBmaWVsZCk7XG4gICAgICB9IGVsc2UgaWYoYXR5cGUgPT09IEFnZ3JlZ2F0ZS5UWVBFUy5NVUxUSSkge1xuICAgICAgICBjYWNoZS5hY2Nlc3NvcnMoZmllbGQsIHJlZi5zb3J0IHx8IHNvcnQuZmllbGQpO1xuICAgICAgfSAvLyBFbHNlIChUdXBsZS1jYXNlKSBpcyBoYW5kbGVkIGJ5IHRoZSBhZ2dyZWdhdG9yIGFjY2Vzc29ycyBieSBkZWZhdWx0XG5cbiAgICAgIGNhY2hlLmV2YWx1YXRlKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZGVwZW5kZW5jeShDLkRBVEEsIGZyb20pO1xuICAgIGNhY2hlLmRlcGVuZGVuY3koQy5TSUdOQUxTKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgc2VsZi5kZXBlbmRlbmN5KEMuU0lHTkFMUywgcykgfSk7XG4gIH1cblxuICBkYXRhID0gY2FjaGUuYWdncigpLnJlc3VsdCgpO1xuICBpZiAodW5pcXVlcykge1xuICAgIGlmIChzb3J0KSB7XG4gICAgICBzb3J0ID0gc29ydC5vcmRlci5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoc29ydC5vcmRlci5zaWduYWwpIDogc29ydC5vcmRlcjtcbiAgICAgIHNvcnQgPSAoc29ydCA9PSBDLkRFU0MgPyBcIi1cIiA6IFwiK1wiKSArIEMuVkFMVUU7XG4gICAgICBzb3J0ID0gZGwuY29tcGFyYXRvcihzb3J0KTtcbiAgICAgIGRhdGEgPSBkYXRhLnNvcnQoc29ydCk7XG4gICAgLy8gfSBlbHNlIHsgIC8vIFwiRmlyc3Qgc2VlblwiIG9yZGVyXG4gICAgLy8gICBzb3J0ID0gZGwuY29tcGFyYXRvcihcInRwbC5faWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbQy5HUk9VUEJZXTsgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IGRhdGFbMF07XG4gICAgcmV0dXJuICFkbC5pc1ZhbGlkKGRhdGEpID8gW10gOiBbZGF0YVtDLk1JTl0sIGRhdGFbQy5NQVhdXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaWduYWwodikge1xuICB2YXIgcyA9IHYuc2lnbmFsLCByZWY7XG4gIGlmICghcykgcmV0dXJuIHY7XG4gIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIChyZWYgPSBkbC5maWVsZChzKSlbMF0pO1xuICByZXR1cm4gdGhpcy5fZ3JhcGguc2lnbmFsUmVmKHJlZik7XG59XG5cbmZ1bmN0aW9uIGRvbWFpbk1pbk1heChzY2FsZSwgZ3JvdXApIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZixcbiAgICAgIGRvbWFpbiA9IFtudWxsLCBudWxsXSwgcmVmcywgejtcblxuICBpZiAoZGVmLmRvbWFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9tYWluID0gKCFkbC5pc09iamVjdChkZWYuZG9tYWluKSkgPyBkb21haW4gOlxuICAgICAgZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOLCBkZWYuZG9tYWluLCBzY2FsZSwgZ3JvdXApO1xuICB9XG5cbiAgeiA9IGRvbWFpbi5sZW5ndGggLSAxO1xuICBpZiAoZGVmLmRvbWFpbk1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NaW4pKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1pbi5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluWzBdID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1pbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bMF0gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4rQy5NSU4sIGRlZi5kb21haW5NaW4sIHNjYWxlLCBncm91cClbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblswXSA9IGRlZi5kb21haW5NaW47XG4gICAgfVxuICB9XG4gIGlmIChkZWYuZG9tYWluTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGwuaXNPYmplY3QoZGVmLmRvbWFpbk1heCkpIHtcbiAgICAgIGlmIChkZWYuZG9tYWluTWF4LnNpZ25hbCkge1xuICAgICAgICBkb21haW5bel0gPSBzaWduYWwuY2FsbCh0aGlzLCBkZWYuZG9tYWluTWF4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbWFpblt6XSA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTitDLk1BWCwgZGVmLmRvbWFpbk1heCwgc2NhbGUsIGdyb3VwKVsxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZG9tYWluW3pdID0gZGVmLmRvbWFpbk1heDtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi50eXBlICE9PSBDLkxPRyAmJiBkZWYudHlwZSAhPT0gQy5USU1FICYmIChkZWYuemVybyB8fCBkZWYuemVybz09PXVuZGVmaW5lZCkpIHtcbiAgICBkb21haW5bMF0gPSBNYXRoLm1pbigwLCBkb21haW5bMF0pO1xuICAgIGRvbWFpblt6XSA9IE1hdGgubWF4KDAsIGRvbWFpblt6XSk7XG4gIH1cbiAgcmV0dXJuIGRvbWFpbjtcbn1cblxuZnVuY3Rpb24gcmFuZ2UoZ3JvdXApIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZixcbiAgICAgIHJuZyA9IFtudWxsLCBudWxsXTtcblxuICBpZiAoZGVmLnJhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGRlZi5yYW5nZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChHUk9VUF9QUk9QRVJUWVtkZWYucmFuZ2VdKSB7XG4gICAgICAgIHJuZyA9IFswLCBncm91cFtkZWYucmFuZ2VdXTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnJhbmdlW2RlZi5yYW5nZV0pIHtcbiAgICAgICAgcm5nID0gY29uZmlnLnJhbmdlW2RlZi5yYW5nZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkbC5lcnJvcihcIlVucmVjb2dpemVkIHJhbmdlOiBcIitkZWYucmFuZ2UpO1xuICAgICAgICByZXR1cm4gcm5nO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGwuaXNBcnJheShkZWYucmFuZ2UpKSB7XG4gICAgICBybmcgPSBkZWYucmFuZ2UubWFwKHNpZ25hbC5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2UgaWYgKGRsLmlzT2JqZWN0KGRlZi5yYW5nZSkpIHtcbiAgICAgIHJldHVybiBudWxsOyAvLyBlYXJseSBleGl0XG4gICAgfSBlbHNlIHtcbiAgICAgIHJuZyA9IFswLCBkZWYucmFuZ2VdO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLnJhbmdlTWluICE9PSB1bmRlZmluZWQpIHtcbiAgICBybmdbMF0gPSBkZWYucmFuZ2VNaW4uc2lnbmFsID8gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWluKSA6IGRlZi5yYW5nZU1pbjtcbiAgfVxuICBpZiAoZGVmLnJhbmdlTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBybmdbcm5nLmxlbmd0aC0xXSA9IGRlZi5yYW5nZU1heC5zaWduYWwgPyBzaWduYWwuY2FsbCh0aGlzLCBkZWYucmFuZ2VNYXgpIDogZGVmLnJhbmdlTWF4O1xuICB9XG4gIFxuICBpZiAoZGVmLnJldmVyc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXYgPSBkZWYucmV2ZXJzZTtcbiAgICBpZiAoZGwuaXNPYmplY3QocmV2KSkge1xuICAgICAgcmV2ID0gZGwuYWNjZXNzb3IocmV2LmZpZWxkKShncm91cC5kYXR1bSk7XG4gICAgfVxuICAgIGlmIChyZXYpIHJuZyA9IHJuZy5yZXZlcnNlKCk7XG4gIH1cbiAgXG4gIHJldHVybiBybmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2NhbGU7IiwidmFyIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBjYWxjQm91bmRzID0gcmVxdWlyZSgnLi4vdXRpbC9ib3VuZHMnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gVHJhbnNpdGlvbihkdXJhdGlvbiwgZWFzZSkge1xuICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb24gfHwgNTAwO1xuICB0aGlzLmVhc2UgPSBlYXNlICYmIGQzLmVhc2UoZWFzZSkgfHwgZDMuZWFzZShcImN1YmljLWluLW91dFwiKTtcbiAgdGhpcy51cGRhdGVzID0ge25leHQ6IG51bGx9O1xufVxuXG52YXIgcHJvdG90eXBlID0gVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbnZhciBza2lwID0ge1xuICBcInRleHRcIjogMSxcbiAgXCJ1cmxcIjogIDFcbn07XG5cbnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlcywgc3RhbXApIHtcbiAgdmFyIGtleSwgY3VyciwgbmV4dCwgaW50ZXJwLCBsaXN0ID0gbnVsbDtcblxuICBmb3IgKGtleSBpbiB2YWx1ZXMpIHtcbiAgICBjdXJyID0gaXRlbVtrZXldO1xuICAgIG5leHQgPSB2YWx1ZXNba2V5XTsgICAgICBcbiAgICBpZiAoY3VyciAhPT0gbmV4dCkge1xuICAgICAgaWYgKHNraXBba2V5XSB8fCBjdXJyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2tpcCBpbnRlcnBvbGF0aW9uIGZvciBzcGVjaWZpYyBrZXlzIG9yIHVuZGVmaW5lZCBzdGFydCB2YWx1ZXNcbiAgICAgICAgdHVwbGUuc2V0KGl0ZW0sIGtleSwgbmV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyID09PSBcIm51bWJlclwiICYmICFpc0Zpbml0ZShjdXJyKSkge1xuICAgICAgICAvLyBmb3IgTmFOIG9yIGluZmluaXRlIG51bWVyaWMgdmFsdWVzLCBza2lwIHRvIGZpbmFsIHZhbHVlXG4gICAgICAgIHR1cGxlLnNldChpdGVtLCBrZXksIG5leHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGxvb2t1cCBpbnRlcnBvbGF0b3JcbiAgICAgICAgaW50ZXJwID0gZDMuaW50ZXJwb2xhdGUoY3VyciwgbmV4dCk7XG4gICAgICAgIGludGVycC5wcm9wZXJ0eSA9IGtleTtcbiAgICAgICAgKGxpc3QgfHwgKGxpc3Q9W10pKS5wdXNoKGludGVycCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGxpc3QgPT09IG51bGwgJiYgaXRlbS5zdGF0dXMgPT09IEMuRVhJVCkge1xuICAgIGxpc3QgPSBbXTsgLy8gZW5zdXJlIGV4aXRpbmcgaXRlbXMgYXJlIGluY2x1ZGVkXG4gIH1cblxuICBpZiAobGlzdCAhPSBudWxsKSB7XG4gICAgbGlzdC5pdGVtID0gaXRlbTtcbiAgICBsaXN0LmVhc2UgPSBpdGVtLm1hcmsuZWFzZSB8fCB0aGlzLmVhc2U7XG4gICAgbGlzdC5uZXh0ID0gdGhpcy51cGRhdGVzLm5leHQ7XG4gICAgdGhpcy51cGRhdGVzLm5leHQgPSBsaXN0O1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIHQgPSB0aGlzLCBwcmV2ID0gdC51cGRhdGVzLCBjdXJyID0gcHJldi5uZXh0O1xuICBmb3IgKDsgY3VyciE9bnVsbDsgcHJldj1jdXJyLCBjdXJyPXByZXYubmV4dCkge1xuICAgIGlmIChjdXJyLml0ZW0uc3RhdHVzID09PSBDLkVYSVQpIGN1cnIucmVtb3ZlID0gdHJ1ZTtcbiAgfVxuICB0LmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIGQzLnRpbWVyKGZ1bmN0aW9uKGVsYXBzZWQpIHsgcmV0dXJuIHN0ZXAuY2FsbCh0LCBlbGFwc2VkKTsgfSk7XG59O1xuXG5mdW5jdGlvbiBzdGVwKGVsYXBzZWQpIHtcbiAgdmFyIGxpc3QgPSB0aGlzLnVwZGF0ZXMsIHByZXYgPSBsaXN0LCBjdXJyID0gcHJldi5uZXh0LFxuICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uLFxuICAgICAgaXRlbSwgZGVsYXksIGYsIGUsIGksIG4sIHN0b3AgPSB0cnVlO1xuXG4gIGZvciAoOyBjdXJyIT1udWxsOyBwcmV2PWN1cnIsIGN1cnI9cHJldi5uZXh0KSB7XG4gICAgaXRlbSA9IGN1cnIuaXRlbTtcbiAgICBkZWxheSA9IGl0ZW0uZGVsYXkgfHwgMDtcblxuICAgIGYgPSAoZWxhcHNlZCAtIGRlbGF5KSAvIGR1cmF0aW9uO1xuICAgIGlmIChmIDwgMCkgeyBzdG9wID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgaWYgKGYgPiAxKSBmID0gMTtcbiAgICBlID0gY3Vyci5lYXNlKGYpO1xuXG4gICAgZm9yIChpPTAsIG49Y3Vyci5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBpdGVtW2N1cnJbaV0ucHJvcGVydHldID0gY3VycltpXShlKTtcbiAgICB9XG4gICAgaXRlbS50b3VjaCgpO1xuICAgIGNhbGNCb3VuZHMuaXRlbShpdGVtKTtcblxuICAgIGlmIChmID09PSAxKSB7XG4gICAgICBpZiAoY3Vyci5yZW1vdmUpIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICBwcmV2Lm5leHQgPSBjdXJyLm5leHQ7XG4gICAgICBjdXJyID0gcHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuY2FsbGJhY2soKTtcbiAgcmV0dXJuIHN0b3A7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zaXRpb247IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICB0cGwgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIHBhcnNlTWFyayA9IHJlcXVpcmUoJy4uL3BhcnNlL21hcmsnKTtcblxuZnVuY3Rpb24gYXhzKG1vZGVsKSB7XG4gIHZhciBzY2FsZSxcbiAgICAgIG9yaWVudCA9IGNvbmZpZy5heGlzLm9yaWVudCxcbiAgICAgIG9mZnNldCA9IDAsXG4gICAgICB0aXRsZU9mZnNldCA9IGNvbmZpZy5heGlzLnRpdGxlT2Zmc2V0LFxuICAgICAgYXhpc0RlZiA9IHt9LFxuICAgICAgbGF5ZXIgPSBcImZyb250XCIsXG4gICAgICBncmlkID0gZmFsc2UsXG4gICAgICB0aXRsZSA9IG51bGwsXG4gICAgICB0aWNrTWFqb3JTaXplID0gY29uZmlnLmF4aXMudGlja1NpemUsXG4gICAgICB0aWNrTWlub3JTaXplID0gY29uZmlnLmF4aXMudGlja1NpemUsXG4gICAgICB0aWNrRW5kU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja1BhZGRpbmcgPSBjb25maWcuYXhpcy5wYWRkaW5nLFxuICAgICAgdGlja1ZhbHVlcyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0gbnVsbCxcbiAgICAgIHRpY2tGb3JtYXQgPSBudWxsLFxuICAgICAgdGlja1N1YmRpdmlkZSA9IDAsXG4gICAgICB0aWNrQXJndW1lbnRzID0gW2NvbmZpZy5heGlzLnRpY2tzXSxcbiAgICAgIGdyaWRMaW5lU3R5bGUgPSB7fSxcbiAgICAgIHRpY2tMYWJlbFN0eWxlID0ge30sXG4gICAgICBtYWpvclRpY2tTdHlsZSA9IHt9LFxuICAgICAgbWlub3JUaWNrU3R5bGUgPSB7fSxcbiAgICAgIHRpdGxlU3R5bGUgPSB7fSxcbiAgICAgIGRvbWFpblN0eWxlID0ge30sXG4gICAgICBtID0geyAvLyBBeGlzIG1hcmtzIGFzIHJlZmVyZW5jZXMgZm9yIHVwZGF0ZXNcbiAgICAgICAgZ3JpZExpbmVzOiBudWxsLFxuICAgICAgICBtYWpvclRpY2tzOiBudWxsLFxuICAgICAgICBtaW5vclRpY2tzOiBudWxsLFxuICAgICAgICB0aWNrTGFiZWxzOiBudWxsLFxuICAgICAgICBkb21haW46IG51bGwsXG4gICAgICAgIHRpdGxlOiBudWxsXG4gICAgICB9O1xuXG4gIHZhciBheGlzID0ge307XG5cbiAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgYXhpc0RlZi50eXBlID0gbnVsbDtcbiAgfTtcblxuICBheGlzLmRlZiA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKCFheGlzRGVmLnR5cGUpIGF4aXNfZGVmKHNjYWxlKTtcblxuICAgIC8vIHRpY2sgZm9ybWF0XG4gICAgdGlja0Zvcm1hdCA9ICF0aWNrRm9ybWF0U3RyaW5nID8gbnVsbCA6ICgoc2NhbGUudHlwZSA9PT0gJ3RpbWUnKVxuICAgICAgPyBkMy50aW1lLmZvcm1hdCh0aWNrRm9ybWF0U3RyaW5nKVxuICAgICAgOiBkMy5mb3JtYXQodGlja0Zvcm1hdFN0cmluZykpO1xuXG4gICAgLy8gZ2VuZXJhdGUgZGF0YVxuICAgIC8vIFdlIGRvbid0IF9yZWFsbHlfIG5lZWQgdG8gbW9kZWwgdGhlc2UgYXMgdHVwbGVzIGFzIG5vIGZ1cnRoZXJcbiAgICAvLyBkYXRhIHRyYW5zZm9ybWF0aW9uIGlzIGRvbmUuIFNvIHdlIG9wdGltaXplIGZvciBhIGhpZ2ggY2h1cm4gcmF0ZS4gXG4gICAgdmFyIGluamVzdCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHtkYXRhOiBkfTsgfTtcbiAgICB2YXIgbWFqb3IgPSB0aWNrVmFsdWVzID09IG51bGxcbiAgICAgID8gKHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogc2NhbGUuZG9tYWluKCkpXG4gICAgICA6IHRpY2tWYWx1ZXM7XG4gICAgdmFyIG1pbm9yID0gdmdfYXhpc1N1YmRpdmlkZShzY2FsZSwgbWFqb3IsIHRpY2tTdWJkaXZpZGUpLm1hcChpbmplc3QpO1xuICAgIG1ham9yID0gbWFqb3IubWFwKGluamVzdCk7XG4gICAgdmFyIGZtdCA9IHRpY2tGb3JtYXQ9PW51bGwgPyAoc2NhbGUudGlja0Zvcm1hdCA/IHNjYWxlLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogU3RyaW5nKSA6IHRpY2tGb3JtYXQ7XG4gICAgbWFqb3IuZm9yRWFjaChmdW5jdGlvbihkKSB7IGQubGFiZWwgPSBmbXQoZC5kYXRhKTsgfSk7XG4gICAgdmFyIHRkYXRhID0gdGl0bGUgPyBbdGl0bGVdLm1hcChpbmplc3QpIDogW107XG5cbiAgICBheGlzRGVmLm1hcmtzWzBdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIGdyaWQgPyBtYWpvciA6IFtdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFqb3I7IH07XG4gICAgYXhpc0RlZi5tYXJrc1syXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBtaW5vcjsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzNdLmZyb20gPSBheGlzRGVmLm1hcmtzWzFdLmZyb207XG4gICAgYXhpc0RlZi5tYXJrc1s0XS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBbMV07IH07XG4gICAgYXhpc0RlZi5tYXJrc1s1XS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiB0ZGF0YTsgfTtcbiAgICBheGlzRGVmLm9mZnNldCA9IG9mZnNldDtcbiAgICBheGlzRGVmLm9yaWVudCA9IG9yaWVudDtcbiAgICBheGlzRGVmLmxheWVyID0gbGF5ZXI7XG4gICAgcmV0dXJuIGF4aXNEZWY7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXhpc19kZWYoc2NhbGUpIHtcbiAgICAvLyBzZXR1cCBzY2FsZSBtYXBwaW5nXG4gICAgdmFyIG5ld1NjYWxlLCBvbGRTY2FsZSwgcmFuZ2U7XG4gICAgaWYgKHNjYWxlLnR5cGUgPT09IFwib3JkaW5hbFwiKSB7XG4gICAgICBuZXdTY2FsZSA9IHtzY2FsZTogc2NhbGUuc2NhbGVOYW1lLCBvZmZzZXQ6IDAuNSArIHNjYWxlLnJhbmdlQmFuZCgpLzJ9O1xuICAgICAgb2xkU2NhbGUgPSBuZXdTY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjV9O1xuICAgICAgb2xkU2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZStcIjpwcmV2XCIsIG9mZnNldDogMC41fTtcbiAgICB9XG4gICAgcmFuZ2UgPSB2Z19heGlzU2NhbGVSYW5nZShzY2FsZSk7XG5cbiAgICAvLyBzZXR1cCBheGlzIG1hcmtzXG4gICAgaWYgKCFtLmdyaWRMaW5lcykgIG0uZ3JpZExpbmVzICA9IHZnX2F4aXNUaWNrcygpO1xuICAgIGlmICghbS5tYWpvclRpY2tzKSBtLm1ham9yVGlja3MgPSB2Z19heGlzVGlja3MoKTtcbiAgICBpZiAoIW0ubWlub3JUaWNrcykgbS5taW5vclRpY2tzID0gdmdfYXhpc1RpY2tzKCk7XG4gICAgaWYgKCFtLnRpY2tMYWJlbHMpIG0udGlja0xhYmVscyA9IHZnX2F4aXNUaWNrTGFiZWxzKCk7XG4gICAgaWYgKCFtLmRvbWFpbikgbS5kb21haW4gPSB2Z19heGlzRG9tYWluKCk7XG4gICAgaWYgKCFtLnRpdGxlKSAgbS50aXRsZSAgPSB2Z19heGlzVGl0bGUoKTtcbiAgICBtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLmVudGVyLnN0cm9rZSA9IHt2YWx1ZTogY29uZmlnLmF4aXMuZ3JpZENvbG9yfTtcblxuICAgIC8vIGV4dGVuZCBheGlzIG1hcmtzIGJhc2VkIG9uIGF4aXMgb3JpZW50YXRpb25cbiAgICB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCBtLmdyaWRMaW5lcywgb2xkU2NhbGUsIG5ld1NjYWxlLCBJbmZpbml0eSk7XG4gICAgdmdfYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5tYWpvclRpY2tzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUpO1xuICAgIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWlub3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWlub3JTaXplKTtcbiAgICB2Z19heGlzTGFiZWxFeHRlbmQob3JpZW50LCBtLnRpY2tMYWJlbHMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01ham9yU2l6ZSwgdGlja1BhZGRpbmcpO1xuXG4gICAgdmdfYXhpc0RvbWFpbkV4dGVuZChvcmllbnQsIG0uZG9tYWluLCByYW5nZSwgdGlja0VuZFNpemUpO1xuICAgIHZnX2F4aXNUaXRsZUV4dGVuZChvcmllbnQsIG0udGl0bGUsIHJhbmdlLCB0aXRsZU9mZnNldCk7IC8vIFRPRE8gZ2V0IG9mZnNldFxuICAgIFxuICAgIC8vIGFkZCAvIG92ZXJyaWRlIGN1c3RvbSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgZGwuZXh0ZW5kKG0uZ3JpZExpbmVzLnByb3BlcnRpZXMudXBkYXRlLCBncmlkTGluZVN0eWxlKTtcbiAgICBkbC5leHRlbmQobS5tYWpvclRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCBtYWpvclRpY2tTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWlub3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWlub3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLnRpY2tMYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHRpY2tMYWJlbFN0eWxlKTtcbiAgICBkbC5leHRlbmQobS5kb21haW4ucHJvcGVydGllcy51cGRhdGUsIGRvbWFpblN0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aXRsZS5wcm9wZXJ0aWVzLnVwZGF0ZSwgdGl0bGVTdHlsZSk7XG5cbiAgICB2YXIgbWFya3MgPSBbbS5ncmlkTGluZXMsIG0ubWFqb3JUaWNrcywgbS5taW5vclRpY2tzLCBtLnRpY2tMYWJlbHMsIG0uZG9tYWluLCBtLnRpdGxlXTtcbiAgICBkbC5leHRlbmQoYXhpc0RlZiwge1xuICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgICAgcHJvcGVydGllczogeyBcbiAgICAgICAgZW50ZXI6IHtcbiAgICAgICAgICBlbmNvZGU6IHZnX2F4aXNVcGRhdGUsXG4gICAgICAgICAgc2NhbGVzOiBbc2NhbGUuc2NhbGVOYW1lXSxcbiAgICAgICAgICBzaWduYWxzOiBbXSwgZGF0YTogW11cbiAgICAgICAgfSxcbiAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19heGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGF4aXNEZWYubWFya3MgPSBtYXJrcy5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSk7XG4gIH07XG5cbiAgYXhpcy5zY2FsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBzY2FsZTtcbiAgICBpZiAoc2NhbGUgIT09IHgpIHsgc2NhbGUgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5vcmllbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb3JpZW50O1xuICAgIGlmIChvcmllbnQgIT09IHgpIHtcbiAgICAgIG9yaWVudCA9IHggaW4gdmdfYXhpc09yaWVudHMgPyB4ICsgXCJcIiA6IGNvbmZpZy5heGlzLm9yaWVudDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGl0bGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGl0bGU7XG4gICAgaWYgKHRpdGxlICE9PSB4KSB7IHRpdGxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja3MgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrQXJndW1lbnRzO1xuICAgIHRpY2tBcmd1bWVudHMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrVmFsdWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tWYWx1ZXM7XG4gICAgdGlja1ZhbHVlcyA9IHg7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tGb3JtYXRTdHJpbmc7XG4gICAgaWYgKHRpY2tGb3JtYXRTdHJpbmcgIT09IHgpIHtcbiAgICAgIHRpY2tGb3JtYXRTdHJpbmcgPSB4O1xuICAgICAgcmVzZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIFxuICBheGlzLnRpY2tTaXplID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tNYWpvclNpemU7XG4gICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMSxcbiAgICAgICAgbWFqb3IgPSAreCxcbiAgICAgICAgbWlub3IgPSBuID4gMSA/ICt5IDogdGlja01ham9yU2l6ZSxcbiAgICAgICAgZW5kICAgPSBuID4gMCA/ICthcmd1bWVudHNbbl0gOiB0aWNrTWFqb3JTaXplO1xuXG4gICAgaWYgKHRpY2tNYWpvclNpemUgIT09IG1ham9yIHx8XG4gICAgICAgIHRpY2tNaW5vclNpemUgIT09IG1pbm9yIHx8XG4gICAgICAgIHRpY2tFbmRTaXplICE9PSBlbmQpIHtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuXG4gICAgdGlja01ham9yU2l6ZSA9IG1ham9yO1xuICAgIHRpY2tNaW5vclNpemUgPSBtaW5vcjtcbiAgICB0aWNrRW5kU2l6ZSA9IGVuZDtcbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tTdWJkaXZpZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1N1YmRpdmlkZTtcbiAgICB0aWNrU3ViZGl2aWRlID0gK3g7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG4gIFxuICBheGlzLm9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBvZmZzZXQ7XG4gICAgb2Zmc2V0ID0gZGwuaXNPYmplY3QoeCkgPyB4IDogK3g7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrUGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrUGFkZGluZztcbiAgICBpZiAodGlja1BhZGRpbmcgIT09ICt4KSB7IHRpY2tQYWRkaW5nID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlT2Zmc2V0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlT2Zmc2V0O1xuICAgIGlmICh0aXRsZU9mZnNldCAhPT0gK3gpIHsgdGl0bGVPZmZzZXQgPSAreDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubGF5ZXIgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbGF5ZXI7XG4gICAgaWYgKGxheWVyICE9PSB4KSB7IGxheWVyID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBncmlkO1xuICAgIGlmIChncmlkICE9PSB4KSB7IGdyaWQgPSB4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5ncmlkTGluZVByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZExpbmVTdHlsZTtcbiAgICBpZiAoZ3JpZExpbmVTdHlsZSAhPT0geCkgeyBncmlkTGluZVN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWFqb3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtYWpvclRpY2tTdHlsZTtcbiAgICBpZiAobWFqb3JUaWNrU3R5bGUgIT09IHgpIHsgbWFqb3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5taW5vclRpY2tQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG1pbm9yVGlja1N0eWxlO1xuICAgIGlmIChtaW5vclRpY2tTdHlsZSAhPT0geCkgeyBtaW5vclRpY2tTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tMYWJlbFByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0xhYmVsU3R5bGU7XG4gICAgaWYgKHRpY2tMYWJlbFN0eWxlICE9PSB4KSB7IHRpY2tMYWJlbFN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGl0bGVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlU3R5bGU7XG4gICAgaWYgKHRpdGxlU3R5bGUgIT09IHgpIHsgdGl0bGVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmRvbWFpblByb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZG9tYWluU3R5bGU7XG4gICAgaWYgKGRvbWFpblN0eWxlICE9PSB4KSB7IGRvbWFpblN0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5yZXNldCA9IGZ1bmN0aW9uKCkgeyByZXNldCgpOyB9O1xuXG4gIHJldHVybiBheGlzO1xufTtcblxudmFyIHZnX2F4aXNPcmllbnRzID0ge3RvcDogMSwgcmlnaHQ6IDEsIGJvdHRvbTogMSwgbGVmdDogMX07XG5cbmZ1bmN0aW9uIHZnX2F4aXNTdWJkaXZpZGUoc2NhbGUsIHRpY2tzLCBtKSB7XG4gIHN1YnRpY2tzID0gW107XG4gIGlmIChtICYmIHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICB2YXIgZXh0ZW50ID0gdmdfYXhpc1NjYWxlRXh0ZW50KHNjYWxlLmRvbWFpbigpKSxcbiAgICAgICAgc3VidGlja3MsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IHRpY2tzLmxlbmd0aCxcbiAgICAgICAgZCA9ICh0aWNrc1sxXSAtIHRpY2tzWzBdKSAvICsrbSxcbiAgICAgICAgaixcbiAgICAgICAgdjtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgZm9yIChqID0gbTsgLS1qID4gMDspIHtcbiAgICAgICAgaWYgKCh2ID0gK3RpY2tzW2ldIC0gaiAqIGQpID49IGV4dGVudFswXSkge1xuICAgICAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICgtLWksIGogPSAwOyArK2ogPCBtICYmICh2ID0gK3RpY2tzW2ldICsgaiAqIGQpIDwgZXh0ZW50WzFdOykge1xuICAgICAgc3VidGlja3MucHVzaCh2KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1YnRpY2tzO1xufVxuXG5mdW5jdGlvbiB2Z19heGlzU2NhbGVFeHRlbnQoZG9tYWluKSB7XG4gIHZhciBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBzdGFydCA8IHN0b3AgPyBbc3RhcnQsIHN0b3BdIDogW3N0b3AsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpIHtcbiAgcmV0dXJuIHNjYWxlLnJhbmdlRXh0ZW50XG4gICAgPyBzY2FsZS5yYW5nZUV4dGVudCgpXG4gICAgOiB2Z19heGlzU2NhbGVFeHRlbnQoc2NhbGUucmFuZ2UoKSk7XG59XG5cbnZhciB2Z19heGlzQWxpZ24gPSB7XG4gIGJvdHRvbTogXCJjZW50ZXJcIixcbiAgdG9wOiBcImNlbnRlclwiLFxuICBsZWZ0OiBcInJpZ2h0XCIsXG4gIHJpZ2h0OiBcImxlZnRcIlxufTtcblxudmFyIHZnX2F4aXNCYXNlbGluZSA9IHtcbiAgYm90dG9tOiBcInRvcFwiLFxuICB0b3A6IFwiYm90dG9tXCIsXG4gIGxlZnQ6IFwibWlkZGxlXCIsXG4gIHJpZ2h0OiBcIm1pZGRsZVwiXG59O1xuXG5mdW5jdGlvbiB2Z19heGlzTGFiZWxFeHRlbmQob3JpZW50LCBsYWJlbHMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgc2l6ZSwgcGFkKSB7XG4gIHNpemUgPSBNYXRoLm1heChzaXplLCAwKSArIHBhZDtcbiAgaWYgKG9yaWVudCA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSB7XG4gICAgc2l6ZSAqPSAtMTtcbiAgfSAgXG4gIGlmIChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiBvbGRTY2FsZSxcbiAgICAgIHk6IHt2YWx1ZTogc2l6ZX0sXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDogbmV3U2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgICAgYWxpZ246IHt2YWx1ZTogXCJjZW50ZXJcIn0sXG4gICAgICBiYXNlbGluZToge3ZhbHVlOiB2Z19heGlzQmFzZWxpbmVbb3JpZW50XX1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkbC5leHRlbmQobGFiZWxzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6IHt2YWx1ZTogc2l6ZX0sXG4gICAgICB5OiBvbGRTY2FsZSxcbiAgICB9KTtcbiAgICBkbC5leHRlbmQobGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogbmV3U2NhbGUsXG4gICAgICBhbGlnbjoge3ZhbHVlOiB2Z19heGlzQWxpZ25bb3JpZW50XX0sXG4gICAgICBiYXNlbGluZToge3ZhbHVlOiBcIm1pZGRsZVwifVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIHRpY2tzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUpIHtcbiAgdmFyIHNpZ24gPSAob3JpZW50ID09PSBcImxlZnRcIiB8fCBvcmllbnQgPT09IFwidG9wXCIpID8gLTEgOiAxO1xuICBpZiAoc2l6ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBzaXplID0gKG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwiYm90dG9tXCIpXG4gICAgICA/IHtmaWVsZDoge2dyb3VwOiBcImhlaWdodFwiLCBsZXZlbDogMn0sIG11bHQ6IC1zaWdufVxuICAgICAgOiB7ZmllbGQ6IHtncm91cDogXCJ3aWR0aFwiLCAgbGV2ZWw6IDJ9LCBtdWx0OiAtc2lnbn07XG4gIH0gZWxzZSB7XG4gICAgc2l6ZSA9IHt2YWx1ZTogc2lnbiAqIHNpemV9O1xuICB9XG4gIGlmIChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKSB7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZW50ZXIsIHtcbiAgICAgIHg6ICBvbGRTY2FsZSxcbiAgICAgIHk6ICB7dmFsdWU6IDB9LFxuICAgICAgeTI6IHNpemVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6ICBuZXdTY2FsZSxcbiAgICAgIHk6ICB7dmFsdWU6IDB9LFxuICAgICAgeTI6IHNpemVcbiAgICB9KTtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5leGl0LCB7XG4gICAgICB4OiAgbmV3U2NhbGUsXG4gICAgfSk7ICAgICAgICBcbiAgfSBlbHNlIHtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogIHt2YWx1ZTogMH0sXG4gICAgICB4Mjogc2l6ZSxcbiAgICAgIHk6ICBvbGRTY2FsZVxuICAgIH0pO1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDogIHt2YWx1ZTogMH0sXG4gICAgICB4Mjogc2l6ZSxcbiAgICAgIHk6ICBuZXdTY2FsZVxuICAgIH0pO1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmV4aXQsIHtcbiAgICAgIHk6ICBuZXdTY2FsZSxcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzVGl0bGVFeHRlbmQob3JpZW50LCB0aXRsZSwgcmFuZ2UsIG9mZnNldCkge1xuICB2YXIgbWlkID0gfn4oKHJhbmdlWzBdICsgcmFuZ2VbMV0pIC8gMiksXG4gICAgICBzaWduID0gKG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwibGVmdFwiKSA/IC0xIDogMTtcbiAgXG4gIGlmIChvcmllbnQgPT09IFwiYm90dG9tXCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSB7XG4gICAgZGwuZXh0ZW5kKHRpdGxlLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiB7dmFsdWU6IG1pZH0sXG4gICAgICB5OiB7dmFsdWU6IHNpZ24qb2Zmc2V0fSxcbiAgICAgIGFuZ2xlOiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKHRpdGxlLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpZ24qb2Zmc2V0fSxcbiAgICAgIHk6IHt2YWx1ZTogbWlkfSxcbiAgICAgIGFuZ2xlOiB7dmFsdWU6IC05MH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzRG9tYWluRXh0ZW5kKG9yaWVudCwgZG9tYWluLCByYW5nZSwgc2l6ZSkge1xuICB2YXIgcGF0aDtcbiAgaWYgKG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwibGVmdFwiKSB7XG4gICAgc2l6ZSA9IC0xICogc2l6ZTtcbiAgfVxuICBpZiAob3JpZW50ID09PSBcImJvdHRvbVwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIHBhdGggPSBcIk1cIiArIHJhbmdlWzBdICsgXCIsXCIgKyBzaXplICsgXCJWMEhcIiArIHJhbmdlWzFdICsgXCJWXCIgKyBzaXplO1xuICB9IGVsc2Uge1xuICAgIHBhdGggPSBcIk1cIiArIHNpemUgKyBcIixcIiArIHJhbmdlWzBdICsgXCJIMFZcIiArIHJhbmdlWzFdICsgXCJIXCIgKyBzaXplO1xuICB9XG4gIGRvbWFpbi5wcm9wZXJ0aWVzLnVwZGF0ZS5wYXRoID0ge3ZhbHVlOiBwYXRofTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1VwZGF0ZShpdGVtLCBncm91cCwgdHJhbnMsIGRiLCBzaWduYWxzLCBwcmVkaWNhdGVzKSB7XG4gIHZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW0sXG4gICAgICBvZmZzZXQgPSBpdGVtLm1hcmsuZGVmLm9mZnNldCxcbiAgICAgIG9yaWVudCA9IGl0ZW0ubWFyay5kZWYub3JpZW50LFxuICAgICAgd2lkdGggID0gZ3JvdXAud2lkdGgsXG4gICAgICBoZWlnaHQgPSBncm91cC5oZWlnaHQ7IC8vIFRPRE8gZmFsbGJhY2sgdG8gZ2xvYmFsIHcsaD9cblxuICBpZiAoZGwuaXNPYmplY3Qob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IC1ncm91cC5zY2FsZShvZmZzZXQuc2NhbGUpKG9mZnNldC52YWx1ZSk7XG4gIH1cblxuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgXCJsZWZ0XCI6ICAgeyB0cGwuc2V0KG8sICd4JywgLW9mZnNldCk7IHRwbC5zZXQobywgJ3knLCAwKTsgYnJlYWs7IH1cbiAgICBjYXNlIFwicmlnaHRcIjogIHsgdHBsLnNldChvLCAneCcsIHdpZHRoICsgb2Zmc2V0KTsgdHBsLnNldChvLCAneScsIDApOyBicmVhazsgfVxuICAgIGNhc2UgXCJib3R0b21cIjogeyB0cGwuc2V0KG8sICd4JywgMCk7IHRwbC5zZXQobywgJ3knLCBoZWlnaHQgKyBvZmZzZXQpOyBicmVhazsgfVxuICAgIGNhc2UgXCJ0b3BcIjogICAgeyB0cGwuc2V0KG8sICd4JywgMCk7IHRwbC5zZXQobywgJ3knLCAtb2Zmc2V0KTsgYnJlYWs7IH1cbiAgICBkZWZhdWx0OiAgICAgICB7IHRwbC5zZXQobywgJ3gnLCAwKTsgdHBsLnNldChvLCAneScsIDApOyB9XG4gIH1cblxuICBpZiAodHJhbnMpIHRyYW5zLmludGVycG9sYXRlKGl0ZW0sIG8pO1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja3MoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJydWxlXCIsXG4gICAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICAgIGtleTogXCJkYXRhXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgc3Ryb2tlOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tDb2xvcn0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tXaWR0aH0sXG4gICAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMWUtNn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZTogeyBvcGFjaXR5OiB7dmFsdWU6IDF9IH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNUaWNrTGFiZWxzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidGV4dFwiLFxuICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgIGtleTogXCJkYXRhXCIsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgZmlsbDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxDb2xvcn0sXG4gICAgICAgIGZvbnQ6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsRm9udH0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbEZvbnRTaXplfSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiBcImxhYmVsXCJ9XG4gICAgICB9LFxuICAgICAgZXhpdDogeyBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9IH0sXG4gICAgICB1cGRhdGU6IHsgb3BhY2l0eToge3ZhbHVlOiAxfSB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVGl0bGUoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUZvbnR9LFxuICAgICAgICBmb250U2l6ZToge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUZvbnRTaXplfSxcbiAgICAgICAgZm9udFdlaWdodDoge3ZhbHVlOiBjb25maWcuYXhpcy50aXRsZUZvbnRXZWlnaHR9LFxuICAgICAgICBmaWxsOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpdGxlQ29sb3J9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiBcImNlbnRlclwifSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn0sXG4gICAgICAgIHRleHQ6IHtmaWVsZDogXCJkYXRhXCJ9XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiB7fVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc0RvbWFpbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInBhdGhcIixcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgZW50ZXI6IHtcbiAgICAgICAgeDoge3ZhbHVlOiAwLjV9LFxuICAgICAgICB5OiB7dmFsdWU6IDAuNX0sXG4gICAgICAgIHN0cm9rZToge3ZhbHVlOiBjb25maWcuYXhpcy5heGlzQ29sb3J9LFxuICAgICAgICBzdHJva2VXaWR0aDoge3ZhbHVlOiBjb25maWcuYXhpcy5heGlzV2lkdGh9XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBheHM7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBGYWNldG9yID0gcmVxdWlyZSgnLi9GYWNldG9yJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSwgXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEFnZ3JlZ2F0ZShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaClcbiAgICAucm91dGVyKHRydWUpLnJldmlzZXModHJ1ZSk7XG5cbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGdyb3VwYnk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifVxuICB9KTtcblxuICB0aGlzLl9maWVsZHNEZWYgPSBbXTtcbiAgdGhpcy5fYWdnciA9IG51bGw7ICAvLyBkbC5BZ2dyZWdhdG9yXG5cbiAgdGhpcy5fdHlwZSA9IFRZUEVTLlRVUExFOyBcbiAgdGhpcy5fYWNjID0ge2dyb3VwYnk6IGRsLnRydWUsIHZhbHVlOiBkbC50cnVlfVxuICB0aGlzLl9jYWNoZSA9IHt9OyAgICAgLy8gQW5kIGNhY2hlIHRoZW0gYXMgYWdncmVnYXRvcnMgZXhwZWN0IG9yaWdpbmFsIHR1cGxlcy5cblxuICAvLyBBZ2dyZWdhdG9yIG5lZWRzIGEgZnVsbCBpbnN0YW50aWF0aW9uIG9mIHRoZSBwcmV2aW91cyB0dXBsZS4gXG4gIC8vIENhY2hlIHRoZW0gdG8gcmVkdWNlIGNyZWF0aW9uIGNvc3RzXG4gIHRoaXMuX3ByZXYgPSB7fTsgXG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChBZ2dyZWdhdGUucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxudmFyIFRZUEVTID0gQWdncmVnYXRlLlRZUEVTID0ge1xuICBWQUxVRTogMSwgXG4gIFRVUExFOiAyLCBcbiAgTVVMVEk6IDNcbn07XG5cbnByb3RvLnN1bW1hcml6ZSA9IHtcbiAgc2V0OiBmdW5jdGlvbih0cmFuc2Zvcm0sIHN1bW1hcml6ZSkge1xuICAgIHZhciBpLCBsZW4sIGYsIGZpZWxkcywgbmFtZSwgb3BzLCBzaWduYWxzID0ge307XG4gICAgaWYoIWRsLmlzQXJyYXkoZmllbGRzID0gc3VtbWFyaXplKSkgeyAvLyBPYmplY3Qgc3ludGF4IGZyb20gZGxcbiAgICAgIGZpZWxkcyA9IFtdO1xuICAgICAgZm9yIChuYW1lIGluIHN1bW1hcml6ZSkge1xuICAgICAgICBvcHMgPSBkbC5hcnJheShzdW1tYXJpemVbbmFtZV0pO1xuICAgICAgICBmaWVsZHMucHVzaCh7bmFtZTogbmFtZSwgb3BzOiBvcHN9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IoaT0wLCBsZW49ZmllbGRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgZiA9IGZpZWxkc1tpXTtcbiAgICAgIGlmKGYubmFtZS5zaWduYWwpIHNpZ25hbHNbZi5uYW1lLnNpZ25hbF0gPSAxO1xuICAgICAgZGwuYXJyYXkoZi5vcHMpLmZvckVhY2goZnVuY3Rpb24obyl7IGlmKG8uc2lnbmFsKSBzaWduYWxzW28uc2lnbmFsXSA9IDEgfSk7XG4gICAgfVxuXG4gICAgdHJhbnNmb3JtLl9maWVsZHNEZWYgPSBmaWVsZHM7XG4gICAgdHJhbnNmb3JtLl9hZ2dyID0gbnVsbDtcbiAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLlNJR05BTFMsIGRsLmtleXMoc2lnbmFscykpO1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG4gIH1cbn07XG5cbnByb3RvLnR5cGUgPSBmdW5jdGlvbih0eXBlKSB7IFxuICByZXR1cm4gKHRoaXMuX3R5cGUgPSB0eXBlLCB0aGlzKTsgXG59O1xuXG5wcm90by5hY2Nlc3NvcnMgPSBmdW5jdGlvbihncm91cGJ5LCB2YWx1ZSkge1xuICB2YXIgYWNjID0gdGhpcy5fYWNjO1xuICBhY2MuZ3JvdXBieSA9IGRsLiQoZ3JvdXBieSkgfHwgZGwudHJ1ZTtcbiAgYWNjLnZhbHVlID0gZGwuJCh2YWx1ZSkgfHwgZGwudHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIHN0YW5kYXJkaXplKHgpIHtcbiAgdmFyIGFjYyA9IHRoaXMuX2FjYztcbiAgaWYodGhpcy5fdHlwZSA9PT0gVFlQRVMuVFVQTEUpIHtcbiAgICByZXR1cm4geDtcbiAgfSBlbHNlIGlmKHRoaXMuX3R5cGUgPT09IFRZUEVTLlZBTFVFKSB7XG4gICAgcmV0dXJuIGFjYy52YWx1ZSh4KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVbeC5faWRdIHx8ICh0aGlzLl9jYWNoZVt4Ll9pZF0gPSB7XG4gICAgICBfaWQ6IHguX2lkLFxuICAgICAgZ3JvdXBieTogYWNjLmdyb3VwYnkoeCksXG4gICAgICB2YWx1ZTogYWNjLnZhbHVlKHgpXG4gICAgfSk7XG4gIH1cbn1cblxucHJvdG8uYWdnciA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLl9hZ2dyKSByZXR1cm4gdGhpcy5fYWdncjtcblxuICB2YXIgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIGdyb3VwYnkgPSB0aGlzLmdyb3VwYnkuZ2V0KGdyYXBoKS5maWVsZHM7XG5cbiAgdmFyIGZpZWxkcyA9IHRoaXMuX2ZpZWxkc0RlZi5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICB2YXIgZiAgPSBkbC5kdXBsaWNhdGUoZmllbGQpO1xuICAgIGlmKGZpZWxkLmdldCkgZi5nZXQgPSBmaWVsZC5nZXQ7XG5cbiAgICBmLm5hbWUgPSBmLm5hbWUuc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKGYubmFtZS5zaWduYWwpIDogZi5uYW1lO1xuICAgIGYub3BzICA9IGYub3BzLnNpZ25hbCA/IGdyYXBoLnNpZ25hbFJlZihmLm9wcy5zaWduYWwpIDogZGwuYXJyYXkoZi5vcHMpLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICByZXR1cm4gby5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoby5zaWduYWwpIDogbztcbiAgICB9KTtcblxuICAgIHJldHVybiBmO1xuICB9KTtcblxuICB2YXIgYWdnciA9IHRoaXMuX2FnZ3IgPSBuZXcgRmFjZXRvcigpXG4gICAgLmdyb3VwYnkoZ3JvdXBieSlcbiAgICAuc3RyZWFtKHRydWUpXG4gICAgLnN1bW1hcml6ZShmaWVsZHMpO1xuXG4gIGlmKHRoaXMuX3R5cGUgIT09IFRZUEVTLlZBTFVFKSBhZ2dyLmtleShcIl9pZFwiKTtcbiAgcmV0dXJuIGFnZ3I7XG59O1xuXG5wcm90by5fcmVzZXQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0KSB7XG4gIG91dHB1dC5yZW0ucHVzaC5hcHBseShvdXRwdXQucmVtLCB0aGlzLmFnZ3IoKS5yZXN1bHQoKSk7XG4gIHRoaXMuYWdncigpLmNsZWFyKCk7XG4gIHRoaXMuX2FnZ3IgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gc3Bvb2ZfcHJldih4KSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcHJldlt4Ll9pZF0gfHwgKHRoaXMuX3ByZXZbeC5faWRdID0gT2JqZWN0LmNyZWF0ZSh4KSk7XG4gIHJldHVybiBkbC5leHRlbmQocHJldiwgeC5fcHJldik7XG59XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiYWdncmVnYXRlXCJdKTtcblxuICB2YXIgb3V0cHV0ID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCk7XG4gIGlmKHJlc2V0KSB0aGlzLl9yZXNldChpbnB1dCwgb3V0cHV0KTtcblxuICB2YXIgdCA9IHRoaXMsXG4gICAgICB0cGwgID0gdGhpcy5fdHlwZSA9PT0gVFlQRVMuVFVQTEUsIC8vIHJlZHVjZSBjYWxscyB0byBzdGFuZGFyZGl6ZVxuICAgICAgYWdnciA9IHRoaXMuYWdncigpO1xuXG4gIGlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBhZ2dyLl9hZGQodHBsID8geCA6IHN0YW5kYXJkaXplLmNhbGwodCwgeCkpO1xuICB9KTtcblxuICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYocmVzZXQpIHtcbiAgICAgIGFnZ3IuX2FkZCh0cGwgPyB4IDogc3RhbmRhcmRpemUuY2FsbCh0LCB4KSk7ICAvLyBTaWduYWwgY2hhbmdlIHRyaWdnZXJlZCByZWZsb3dcbiAgICB9IGVsc2UgaWYodHVwbGUuaGFzX3ByZXYoeCkpIHtcbiAgICAgIHZhciBwcmV2ID0gc3Bvb2ZfcHJldi5jYWxsKHQsIHgpO1xuICAgICAgYWdnci5fbW9kKHRwbCA/IHggOiBzdGFuZGFyZGl6ZS5jYWxsKHQsIHgpLCBcbiAgICAgICAgdHBsID8gcHJldiA6IHN0YW5kYXJkaXplLmNhbGwodCwgcHJldikpO1xuICAgIH1cbiAgfSk7XG5cbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciB5ID0gdHVwbGUuaGFzX3ByZXYoeCkgPyBzcG9vZl9wcmV2LmNhbGwodCwgeCkgOiB4O1xuICAgIGFnZ3IuX3JlbSh0cGwgPyB5IDogc3RhbmRhcmRpemUuY2FsbCh0LCB5KSk7XG4gICAgdC5fY2FjaGVbeC5faWRdID0gdC5fcHJldlt4Ll9pZF0gPSBudWxsO1xuICB9KTtcblxuICByZXR1cm4gYWdnci5jaGFuZ2VzKGlucHV0LCBvdXRwdXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZ3JlZ2F0ZTsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKTtcblxuZnVuY3Rpb24gQmF0Y2hUcmFuc2Zvcm0oKSB7XG59XG5cbnZhciBwcm90byA9IChCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLlxuICAvLyBUT0RPOiBlZmZpY2llbnRseSBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG4gIHZhciBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKTtcbiAgcmV0dXJuIHRoaXMuYmF0Y2hUcmFuc2Zvcm0oaW5wdXQsIGRhdGEpO1xufTtcblxucHJvdG8uYmF0Y2hUcmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgZGF0YSkge1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXRjaFRyYW5zZm9ybTtcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gQmluKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBtaW46IHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIG1heDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgc3RlcDoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgbWF4Ymluczoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMjB9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcImJpblwiOiBcImJpblwifTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChCaW4ucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQuYmluO1xuICAgICAgXG4gIHZhciBiID0gZGwuYmlucyh7XG4gICAgbWluOiB0aGlzLm1pbi5nZXQoKSxcbiAgICBtYXg6IHRoaXMubWF4LmdldCgpLFxuICAgIHN0ZXA6IHRoaXMuc3RlcC5nZXQoKSxcbiAgICBtYXhiaW5zOiB0aGlzLm1heGJpbnMuZ2V0KClcbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGQpIHtcbiAgICB2YXIgdiA9IHRyYW5zZm9ybS5maWVsZC5nZXQoKS5hY2Nlc3NvcihkKTtcbiAgICB2ID0gdiA9PSBudWxsID8gbnVsbFxuICAgICAgOiBiLnN0YXJ0ICsgYi5zdGVwICogfn4oKHYgLSBiLnN0YXJ0KSAvIGIuc3RlcCk7XG4gICAgdHVwbGUuc2V0KGQsIG91dHB1dCwgdiwgaW5wdXQuc3RhbXApO1xuICB9XG4gIGlucHV0LmFkZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0Lm1vZC5mb3JFYWNoKHVwZGF0ZSk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKHVwZGF0ZSk7XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCaW47XG4iLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbmZ1bmN0aW9uIENyb3NzKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgZGlhZ29uYWw6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwidHJ1ZVwifVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XCJsZWZ0XCI6IFwiYVwiLCBcInJpZ2h0XCI6IFwiYlwifTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHRoaXMuX2xhc3RSZW0gID0gbnVsbDsgLy8gTW9zdCByZWNlbnQgc3RhbXAgdGhhdCByZW0gb2NjdXJlZC4gXG4gIHRoaXMuX2xhc3RXaXRoID0gbnVsbDsgLy8gTGFzdCB0aW1lIHdlIGNyb3NzZWQgdy93aXRoZHMuXG4gIHRoaXMuX2lkcyAgID0ge307XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQ3Jvc3MucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuLy8gRWFjaCBjYWNoZWQgaW5jb21pbmcgdHVwbGUgYWxzbyBoYXMgYSBzdGFtcCB0byB0cmFjayBpZiB3ZSBuZWVkIHRvIGRvXG4vLyBsYXp5IGZpbHRlcmluZyBvZiByZW1vdmVkIHR1cGxlcy5cbmZ1bmN0aW9uIGNhY2hlKHgsIHQpIHtcbiAgdmFyIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwge2M6IFtdLCBzOiB0aGlzLl9zdGFtcH07XG4gIGMuYy5wdXNoKHQpO1xufVxuXG5mdW5jdGlvbiBhZGQob3V0cHV0LCBsZWZ0LCB3ZGF0YSwgZGlhZywgeCkge1xuICB2YXIgZGF0YSA9IGxlZnQgPyB3ZGF0YSA6IHRoaXMuX2NvbGxlY3Rvci5kYXRhKCksIC8vIExlZnQgdHVwbGVzIGNyb3NzIHcvcmlnaHQuXG4gICAgICBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBwcmV2ICA9IHguX3ByZXYgIT09IHVuZGVmaW5lZCA/IG51bGwgOiB1bmRlZmluZWQsIFxuICAgICAgdCwgeSwgaWQ7XG5cbiAgZm9yKDsgaTxsZW47ICsraSkge1xuICAgIHkgPSBkYXRhW2ldO1xuICAgIGlkID0gbGVmdCA/IHguX2lkK1wiX1wiK3kuX2lkIDogeS5faWQrXCJfXCIreC5faWQ7XG4gICAgaWYodGhpcy5faWRzW2lkXSkgY29udGludWU7XG4gICAgaWYoeC5faWQgPT0geS5faWQgJiYgIWRpYWcpIGNvbnRpbnVlO1xuXG4gICAgdCA9IHR1cGxlLmluZ2VzdCh7fSwgcHJldik7XG4gICAgdFt0aGlzLl9vdXRwdXQubGVmdF0gID0gbGVmdCA/IHggOiB5O1xuICAgIHRbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IGxlZnQgPyB5IDogeDtcbiAgICBvdXRwdXQuYWRkLnB1c2godCk7XG4gICAgY2FjaGUuY2FsbCh0aGlzLCB4LCB0KTtcbiAgICBjYWNoZS5jYWxsKHRoaXMsIHksIHQpO1xuICAgIHRoaXMuX2lkc1tpZF0gPSAxO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vZChvdXRwdXQsIGxlZnQsIHgpIHtcbiAgdmFyIGNyb3NzID0gdGhpcyxcbiAgICAgIGMgPSB0aGlzLl9jYWNoZVt4Ll9pZF07XG5cbiAgaWYodGhpcy5fbGFzdFJlbSA+IGMucykgeyAgLy8gUmVtb3ZlZCB0dXBsZXMgaGF2ZW4ndCBiZWVuIGZpbHRlcmVkIHlldFxuICAgIGMuYyA9IGMuYy5maWx0ZXIoZnVuY3Rpb24oeSkge1xuICAgICAgdmFyIHQgPSB5W2Nyb3NzLl9vdXRwdXRbbGVmdCA/IFwicmlnaHRcIiA6IFwibGVmdFwiXV07XG4gICAgICByZXR1cm4gY3Jvc3MuX2NhY2hlW3QuX2lkXSAhPT0gbnVsbDtcbiAgICB9KTtcbiAgICBjLnMgPSB0aGlzLl9sYXN0UmVtO1xuICB9XG5cbiAgb3V0cHV0Lm1vZC5wdXNoLmFwcGx5KG91dHB1dC5tb2QsIGMuYyk7XG59XG5cbmZ1bmN0aW9uIHJlbShvdXRwdXQsIHgpIHtcbiAgb3V0cHV0LnJlbS5wdXNoLmFwcGx5KG91dHB1dC5yZW0sIHRoaXMuX2NhY2hlW3guX2lkXS5jKTtcbiAgdGhpcy5fY2FjaGVbeC5faWRdID0gbnVsbDtcbiAgdGhpcy5fbGFzdFJlbSA9IHRoaXMuX3N0YW1wO1xufVxuXG5mdW5jdGlvbiB1cEZpZWxkcyhpbnB1dCwgb3V0cHV0KSB7XG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmxlZnRdICA9IDE7IFxuICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LnJpZ2h0XSA9IDE7XG4gIH1cbn1cblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImNyb3NzaW5nXCJdKTtcblxuICAvLyBNYXRlcmlhbGl6ZSB0aGUgY3VycmVudCBkYXRhc291cmNlLiBUT0RPOiBzaGFyZSBjb2xsZWN0b3JzXG4gIHRoaXMuX2NvbGxlY3Rvci5ldmFsdWF0ZShpbnB1dCk7XG5cbiAgdmFyIHcgPSB0aGlzLndpdGguZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGRpYWcgPSB0aGlzLmRpYWdvbmFsLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBzZWxmQ3Jvc3MgPSAoIXcubmFtZSksXG4gICAgICBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSxcbiAgICAgIHdvdXRwdXQgPSBzZWxmQ3Jvc3MgPyBpbnB1dCA6IHcuc291cmNlLmxhc3QoKSxcbiAgICAgIHdkYXRhICAgPSBzZWxmQ3Jvc3MgPyBkYXRhIDogdy5zb3VyY2UudmFsdWVzKCksXG4gICAgICBvdXRwdXQgID0gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCksXG4gICAgICByID0gcmVtLmJpbmQodGhpcywgb3V0cHV0KTsgXG5cbiAgaW5wdXQucmVtLmZvckVhY2gocik7XG4gIGlucHV0LmFkZC5mb3JFYWNoKGFkZC5iaW5kKHRoaXMsIG91dHB1dCwgdHJ1ZSwgd2RhdGEsIGRpYWcpKTtcblxuICBpZighc2VsZkNyb3NzICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0V2l0aCkge1xuICAgIHdvdXRwdXQucmVtLmZvckVhY2gocik7XG4gICAgd291dHB1dC5hZGQuZm9yRWFjaChhZGQuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlLCBkYXRhLCBkaWFnKSk7XG4gICAgd291dHB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIGZhbHNlKSk7XG4gICAgdXBGaWVsZHMuY2FsbCh0aGlzLCB3b3V0cHV0LCBvdXRwdXQpO1xuICAgIHRoaXMuX2xhc3RXaXRoID0gd291dHB1dC5zdGFtcDtcbiAgfVxuXG4gIC8vIE1vZHMgbmVlZCB0byBjb21lIGFmdGVyIGFsbCByZW1vdmFscyBoYXZlIGJlZW4gcnVuLlxuICBpbnB1dC5tb2QuZm9yRWFjaChtb2QuYmluZCh0aGlzLCBvdXRwdXQsIHRydWUpKTtcbiAgdXBGaWVsZHMuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDcm9zczsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBBZ2dyZWdhdGUgPSByZXF1aXJlKCcuL0FnZ3JlZ2F0ZScpO1xuXG5mdW5jdGlvbiBGYWNldChncmFwaCkge1xuICB0aGlzLl9waXBlbGluZSA9IFtdO1xuICByZXR1cm4gQWdncmVnYXRlLmNhbGwodGhpcywgZ3JhcGgpO1xufVxuXG52YXIgcHJvdG8gPSAoRmFjZXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBZ2dyZWdhdGUucHJvdG90eXBlKSk7XG5cbnByb3RvLnBpcGVsaW5lID0ge1xuICBzZXQ6IGZ1bmN0aW9uKGZhY2V0LCBwaXBlbGluZSkge1xuICAgIGZhY2V0Ll9waXBlbGluZSA9IHBpcGVsaW5lO1xuICAgIHJldHVybiBmYWNldDtcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihtb2RlbCwgZmFjZXQpIHtcbiAgICB2YXIgcGFyc2UgPSByZXF1aXJlKCcuLi9wYXJzZS90cmFuc2Zvcm1zJyk7XG4gICAgcmV0dXJuIGZhY2V0Ll9waXBlbGluZS5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2UobW9kZWwsIHQpIH0pO1xuICB9XG59O1xuXG5wcm90by5hZ2dyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBBZ2dyZWdhdGUucHJvdG90eXBlLmFnZ3IuY2FsbCh0aGlzKS5mYWNldCh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjZXQ7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gRmFjZXRvcigpIHtcbiAgQWdncmVnYXRvci5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xuICB0aGlzLl9mYWNldCA9IG51bGw7XG59XG5cbnZhciBBZ2dyZWdhdG9yID0gZGwuZ3JvdXBieSgpO1xudmFyIHByb3RvID0gKEZhY2V0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShBZ2dyZWdhdG9yKSk7XG5cbnByb3RvLmZhY2V0ID0gZnVuY3Rpb24oZikge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2ZhY2V0O1xuICByZXR1cm4gKHRoaXMuX2ZhY2V0ID0gZiwgdGhpcyk7XG59O1xuXG5wcm90by5faW5nZXN0ID0gZnVuY3Rpb24odCkgeyBcbiAgcmV0dXJuIHR1cGxlLmluZ2VzdCh0LCBudWxsKSBcbn07XG5cbnByb3RvLl9hc3NpZ24gPSB0dXBsZS5zZXQ7XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RfY2VsbChmYWNldCkge1xuICBkZWJ1Zyh7fSwgW1wiZGVsZXRpbmcgY2VsbFwiLCB0aGlzLnR1cGxlLl9pZF0pO1xuICB2YXIgcGlwZWxpbmUgPSB0aGlzLmRzLnBpcGVsaW5lKCk7XG4gIGZhY2V0LnJlbW92ZUxpc3RlbmVyKHBpcGVsaW5lWzBdKTtcbiAgZmFjZXQuX2dyYXBoLmRpc2Nvbm5lY3QocGlwZWxpbmUpO1xufVxuXG5wcm90by5fbmV3Y2VsbCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgID0gQWdncmVnYXRvci5fbmV3Y2VsbC5jYWxsKHRoaXMsIHgpLFxuICAgICAgZmFjZXQgPSB0aGlzLl9mYWNldCxcbiAgICAgIHR1cGxlID0gY2VsbC50dXBsZSxcbiAgICAgIGdyYXBoLCBwaXBlbGluZTtcblxuICBpZih0aGlzLl9mYWNldCAhPT0gbnVsbCkge1xuICAgIGdyYXBoID0gZmFjZXQuX2dyYXBoO1xuICAgIHBpcGVsaW5lID0gZmFjZXQucGlwZWxpbmUuZ2V0KGdyYXBoLCBmYWNldCk7XG4gICAgY2VsbC5kcyAgPSBncmFwaC5kYXRhKFwidmdfXCIrdHVwbGUuX2lkLCBwaXBlbGluZSwgdHVwbGUpO1xuICAgIGNlbGwuZGVsZXRlID0gZGlzY29ubmVjdF9jZWxsO1xuICAgIGZhY2V0LmFkZExpc3RlbmVyKHBpcGVsaW5lWzBdKTtcbiAgfVxuXG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX25ld3R1cGxlID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdCA9IEFnZ3JlZ2F0b3IuX25ld3R1cGxlLmNhbGwodGhpcywgeCk7XG4gIGlmKHRoaXMuX2ZhY2V0ICE9PSBudWxsKSB7XG4gICAgdHVwbGUuc2V0KHQsIFwia2V5XCIsIHRoaXMuX2NlbGxrZXkoeCkpO1xuICB9XG4gIHJldHVybiB0O1xufTtcblxucHJvdG8uY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5fZmFjZXQgIT09IG51bGwpIGZvciAodmFyIGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICB0aGlzLl9jZWxsc1trXS5kZWxldGUodGhpcy5fZmFjZXQpO1xuICB9XG4gIHJldHVybiBBZ2dyZWdhdG9yLmNsZWFyLmNhbGwodGhpcyk7XG59O1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCk7XG4gIEFnZ3JlZ2F0b3IuX2FkZC5jYWxsKHRoaXMsIHgpO1xuICBpZih0aGlzLl9mYWNldCAhPT0gbnVsbCkgY2VsbC5kcy5faW5wdXQuYWRkLnB1c2goeCk7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oeCwgcHJldikge1xuICB2YXIgY2VsbDAgPSB0aGlzLl9jZWxsKHByZXYpLFxuICAgICAgY2VsbDEgPSB0aGlzLl9jZWxsKHgpO1xuXG4gIEFnZ3JlZ2F0b3IuX21vZC5jYWxsKHRoaXMsIHgsIHByZXYpO1xuICBpZih0aGlzLl9mYWNldCAhPT0gbnVsbCkgeyAgLy8gUHJvcGFnYXRlIHR1cGxlc1xuICAgIGlmKGNlbGwwID09PSBjZWxsMSkge1xuICAgICAgY2VsbDAuZHMuX2lucHV0Lm1vZC5wdXNoKHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsMC5kcy5faW5wdXQucmVtLnB1c2goeCk7XG4gICAgICBjZWxsMS5kcy5faW5wdXQuYWRkLnB1c2goeCk7XG4gICAgfVxuICB9XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IHRoaXMuX2NlbGwoeCk7XG4gIEFnZ3JlZ2F0b3IuX3JlbS5jYWxsKHRoaXMsIHgpO1xuICBpZih0aGlzLl9mYWNldCAhPT0gbnVsbCkgY2VsbC5kcy5faW5wdXQucmVtLnB1c2goeCk7ICBcbn07XG5cbnByb3RvLmNoYW5nZXMgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0KSB7XG4gIHZhciBhZ2dyID0gdGhpcy5fYWdncixcbiAgICAgIGNlbGwsIGZsYWcsIGksIGs7XG5cbiAgZm9yIChrIGluIHRoaXMuX2NlbGxzKSB7XG4gICAgY2VsbCA9IHRoaXMuX2NlbGxzW2tdO1xuICAgIGZsYWcgPSBjZWxsLmZsYWc7XG5cbiAgICAvLyBjb25zb2xpZGF0ZSBjb2xsZWN0b3IgdmFsdWVzXG4gICAgaWYgKGNlbGwuY29sbGVjdCkge1xuICAgICAgY2VsbC5kYXRhLnZhbHVlcygpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0dXBsZSBwcm9wZXJ0aWVzXG4gICAgZm9yIChpPTA7IGk8YWdnci5sZW5ndGg7ICsraSkge1xuICAgICAgY2VsbC5hZ2dzW2FnZ3JbaV0ubmFtZV0uc2V0KCk7XG4gICAgfVxuXG4gICAgLy8gb3JnYW5pemUgb3V0cHV0IHR1cGxlc1xuICAgIGlmIChjZWxsLm51bSA8PSAwKSB7XG4gICAgICBpZiAoZmxhZyA9PT0gQy5NT0RfQ0VMTCkge1xuICAgICAgICBvdXRwdXQucmVtLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9XG4gICAgICBpZih0aGlzLl9mYWNldCAhPT0gbnVsbCkgY2VsbC5kZWxldGUodGhpcy5fZmFjZXQpO1xuICAgICAgZGVsZXRlIHRoaXMuX2NlbGxzW2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZih0aGlzLl9mYWNldCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBwcm9wYWdhdGUgc29ydCwgc2lnbmFscywgZmllbGRzLCBldGMuXG4gICAgICAgIGNoYW5nZXNldC5jb3B5KGlucHV0LCBjZWxsLmRzLl9pbnB1dCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGFnICYgQy5BRERfQ0VMTCkge1xuICAgICAgICBvdXRwdXQuYWRkLnB1c2goY2VsbC50dXBsZSk7XG4gICAgICB9IGVsc2UgaWYgKGZsYWcgJiBDLk1PRF9DRUxMKSB7XG4gICAgICAgIG91dHB1dC5tb2QucHVzaChjZWxsLnR1cGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjZWxsLmZsYWcgPSAwO1xuICB9XG5cbiAgdGhpcy5fcmVtcyA9IGZhbHNlO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNldG9yOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLCBcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBGaWx0ZXIoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7dGVzdDoge3R5cGU6IFwiZXhwclwifSB9KTtcblxuICB0aGlzLl9za2lwID0ge307XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRmlsdGVyLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIHRlc3QoeCkge1xuICByZXR1cm4gZXhwci5ldmFsKHRoaXMuX2dyYXBoLCB0aGlzLnRlc3QuZ2V0KHRoaXMuX2dyYXBoKSwgXG4gICAgeCwgbnVsbCwgbnVsbCwgbnVsbCwgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUykpO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImZpbHRlcmluZ1wiXSk7XG4gIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIHNraXAgPSB0aGlzLl9za2lwLFxuICAgICAgZiA9IHRoaXM7XG5cbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmIChza2lwW3guX2lkXSAhPT0gMSkgb3V0cHV0LnJlbS5wdXNoKHgpO1xuICAgIGVsc2Ugc2tpcFt4Ll9pZF0gPSAwO1xuICB9KTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYgKHRlc3QuY2FsbChmLCB4KSkgb3V0cHV0LmFkZC5wdXNoKHgpO1xuICAgIGVsc2Ugc2tpcFt4Ll9pZF0gPSAxO1xuICB9KTtcblxuICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgdmFyIGIgPSB0ZXN0LmNhbGwoZiwgeCksXG4gICAgICAgIHMgPSAoc2tpcFt4Ll9pZF0gPT09IDEpO1xuICAgIGlmIChiICYmIHMpIHtcbiAgICAgIHNraXBbeC5faWRdID0gMDtcbiAgICAgIG91dHB1dC5hZGQucHVzaCh4KTtcbiAgICB9IGVsc2UgaWYgKGIgJiYgIXMpIHtcbiAgICAgIG91dHB1dC5tb2QucHVzaCh4KTtcbiAgICB9IGVsc2UgaWYgKCFiICYmIHMpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcsIGtlZXAgc2tpcCB0cnVlXG4gICAgfSBlbHNlIHsgLy8gIWIgJiYgIXNcbiAgICAgIG91dHB1dC5yZW0ucHVzaCh4KTtcbiAgICAgIHNraXBbeC5faWRdID0gMTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcjsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSwgXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gRm9sZChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZHM6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSBcbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge2tleTogXCJrZXlcIiwgdmFsdWU6IFwidmFsdWVcIn07XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpLnJldmlzZXModHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChGb2xkLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIHJzdChpbnB1dCwgb3V0cHV0KSB7IFxuICBmb3IodmFyIGlkIGluIHRoaXMuX2NhY2hlKSBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgdGhpcy5fY2FjaGVbaWRdKTtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcbn07XG5cbmZ1bmN0aW9uIGdldF90dXBsZSh4LCBpLCBsZW4pIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwgKHRoaXMuX2NhY2hlW3guX2lkXSA9IEFycmF5KGxlbikpO1xuICByZXR1cm4gbGlzdFtpXSB8fCAobGlzdFtpXSA9IHR1cGxlLmRlcml2ZSh4LCB4Ll9wcmV2KSk7XG59O1xuXG5mdW5jdGlvbiBmbihkYXRhLCBmaWVsZHMsIGFjY2Vzc29ycywgb3V0LCBzdGFtcCkge1xuICB2YXIgaSA9IDAsIGRsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIGosIGZsZW4gPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgZCwgdDtcblxuICBmb3IoOyBpPGRsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvcihqPTA7IGo8ZmxlbjsgKytqKSB7XG4gICAgICB0ID0gZ2V0X3R1cGxlLmNhbGwodGhpcywgZCwgaiwgZmxlbik7ICBcbiAgICAgIHR1cGxlLnNldCh0LCB0aGlzLl9vdXRwdXQua2V5LCBmaWVsZHNbal0pO1xuICAgICAgdHVwbGUuc2V0KHQsIHRoaXMuX291dHB1dC52YWx1ZSwgYWNjZXNzb3JzW2pdKGQpKTtcbiAgICAgIG91dC5wdXNoKHQpO1xuICAgIH0gICAgICBcbiAgfVxufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmb2xkaW5nXCJdKTtcblxuICB2YXIgZm9sZCA9IHRoaXMsXG4gICAgICBvbiA9IHRoaXMuZmllbGRzLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBmaWVsZHMgPSBvbi5maWVsZHMsIGFjY2Vzc29ycyA9IG9uLmFjY2Vzc29ycyxcbiAgICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gIGlmKHJlc2V0KSByc3QuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICBmbi5jYWxsKHRoaXMsIGlucHV0LmFkZCwgZmllbGRzLCBhY2Nlc3NvcnMsIG91dHB1dC5hZGQsIGlucHV0LnN0YW1wKTtcbiAgZm4uY2FsbCh0aGlzLCBpbnB1dC5tb2QsIGZpZWxkcywgYWNjZXNzb3JzLCByZXNldCA/IG91dHB1dC5hZGQgOiBvdXRwdXQubW9kLCBpbnB1dC5zdGFtcCk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgZm9sZC5fY2FjaGVbeC5faWRdKTtcbiAgICBmb2xkLl9jYWNoZVt4Ll9pZF0gPSBudWxsO1xuICB9KTtcblxuICAvLyBJZiB3ZSdyZSBvbmx5IHByb3BhZ2F0aW5nIHZhbHVlcywgZG9uJ3QgbWFyayBrZXkvdmFsdWUgYXMgdXBkYXRlZC5cbiAgaWYoaW5wdXQuYWRkLmxlbmd0aCB8fCBpbnB1dC5yZW0ubGVuZ3RoIHx8IFxuICAgIGZpZWxkcy5zb21lKGZ1bmN0aW9uKGYpIHsgcmV0dXJuICEhaW5wdXQuZmllbGRzW2ZdOyB9KSlcbiAgICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmtleV0gPSAxLCBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC52YWx1ZV0gPSAxO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb2xkOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBGb3JjZShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBzaXplOiB7dHlwZTogXCJhcnJheTx2YWx1ZT5cIiwgZGVmYXVsdDogWzUwMCwgNTAwXX0sXG4gICAgbGlua3M6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgbGlua0Rpc3RhbmNlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAyMH0sXG4gICAgbGlua1N0cmVuZ3RoOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAxfSxcbiAgICBjaGFyZ2U6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IDMwfSxcbiAgICBjaGFyZ2VEaXN0YW5jZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogSW5maW5pdHl9LFxuICAgIGl0ZXJhdGlvbnM6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDUwMH0sXG4gICAgZnJpY3Rpb246IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuOX0sXG4gICAgdGhldGE6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuOH0sXG4gICAgZ3Jhdml0eToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC4xfSxcbiAgICBhbHBoYToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC4xfVxuICB9KTtcblxuICB0aGlzLl9ub2RlcyA9IFtdO1xuICB0aGlzLl9saW5rcyA9IFtdO1xuICB0aGlzLl9sYXlvdXQgPSBkMy5sYXlvdXQuZm9yY2UoKTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6IFwibGF5b3V0OnhcIixcbiAgICBcInlcIjogXCJsYXlvdXQ6eVwiLFxuICAgIFwic291cmNlXCI6IFwiX3NvdXJjZVwiLFxuICAgIFwidGFyZ2V0XCI6IFwiX3RhcmdldFwiXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGb3JjZS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBnZXQodHJhbnNmb3JtLCBuYW1lKSB7XG4gIHZhciB2ID0gdHJhbnNmb3JtW25hbWVdLmdldCh0cmFuc2Zvcm0uX2dyYXBoKTtcbiAgcmV0dXJuIHYuYWNjZXNzb3JcbiAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHYuYWNjZXNzb3IoeC50dXBsZSk7IH1cbiAgICA6IHYuZmllbGQ7XG59XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG5vZGVJbnB1dCkge1xuICAvLyBnZXQgdmFyaWFibGVzXG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBsaW5rSW5wdXQgPSB0aGlzLmxpbmtzLmdldChnKS5zb3VyY2UubGFzdCgpLFxuICAgICAgbGF5b3V0ID0gdGhpcy5fbGF5b3V0LFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgbm9kZXMgPSB0aGlzLl9ub2RlcyxcbiAgICAgIGxpbmtzID0gdGhpcy5fbGlua3MsXG4gICAgICBpdGVyID0gdGhpcy5pdGVyYXRpb25zLmdldChnKTtcblxuICAvLyBwcm9jZXNzIGFkZGVkIG5vZGVzXG4gIG5vZGVJbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgbm9kZXMucHVzaCh7dHVwbGU6IG59KTtcbiAgfSk7XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBlZGdlc1xuICBsaW5rSW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgIHZhciBsaW5rID0ge1xuICAgICAgdHVwbGU6IGwsXG4gICAgICBzb3VyY2U6IG5vZGVzW2wuc291cmNlXSxcbiAgICAgIHRhcmdldDogbm9kZXNbbC50YXJnZXRdXG4gICAgfTtcbiAgICB0dXBsZS5zZXQobCwgb3V0cHV0LnNvdXJjZSwgbGluay5zb3VyY2UudHVwbGUpO1xuICAgIHR1cGxlLnNldChsLCBvdXRwdXQudGFyZ2V0LCBsaW5rLnRhcmdldC50dXBsZSk7XG4gICAgbGlua3MucHVzaChsaW5rKTtcbiAgfSk7XG5cbiAgLy8gVE9ETyBwcm9jZXNzIFwibW9kXCIgb2YgZWRnZSBzb3VyY2Ugb3IgdGFyZ2V0P1xuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgbGF5b3V0XG4gICAgLnNpemUodGhpcy5zaXplLmdldChnKSlcbiAgICAubGlua0Rpc3RhbmNlKGdldCh0aGlzLCBcImxpbmtEaXN0YW5jZVwiKSlcbiAgICAubGlua1N0cmVuZ3RoKGdldCh0aGlzLCBcImxpbmtTdHJlbmd0aFwiKSlcbiAgICAuY2hhcmdlKGdldCh0aGlzLCBcImNoYXJnZVwiKSlcbiAgICAuY2hhcmdlRGlzdGFuY2UoZ2V0KHRoaXMsIFwiY2hhcmdlRGlzdGFuY2VcIikpXG4gICAgLmZyaWN0aW9uKHRoaXMuZnJpY3Rpb24uZ2V0KGcpKVxuICAgIC50aGV0YSh0aGlzLnRoZXRhLmdldChnKSlcbiAgICAuZ3Jhdml0eSh0aGlzLmdyYXZpdHkuZ2V0KGcpKVxuICAgIC5hbHBoYSh0aGlzLmFscGhhLmdldChnKSlcbiAgICAubm9kZXMobm9kZXMpXG4gICAgLmxpbmtzKGxpbmtzKTtcblxuICAvLyBydW4gbGF5b3V0XG4gIGxheW91dC5zdGFydCgpO1xuICBmb3IgKHZhciBpPTA7IGk8aXRlcjsgKytpKSB7XG4gICAgbGF5b3V0LnRpY2soKTtcbiAgfVxuICBsYXlvdXQuc3RvcCgpO1xuXG4gIC8vIGNvcHkgbGF5b3V0IHZhbHVlcyB0byBub2Rlc1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB0dXBsZS5zZXQobi50dXBsZSwgb3V0cHV0LngsIG4ueCk7XG4gICAgdHVwbGUuc2V0KG4udHVwbGUsIG91dHB1dC55LCBuLnkpO1xuICB9KTtcblxuICAvLyBwcm9jZXNzIHJlbW92ZWQgbm9kZXNcbiAgaWYgKG5vZGVJbnB1dC5yZW0ubGVuZ3RoID4gMCkge1xuICAgIHZhciBub2RlSWRzID0gdHVwbGUuaWRNYXAobm9kZUlucHV0LnJlbSk7XG4gICAgdGhpcy5fbm9kZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gIW5vZGVJZHNbbi50dXBsZS5faWRdOyB9KTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgcmVtb3ZlZCBlZGdlc1xuICBpZiAobGlua0lucHV0LnJlbS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGxpbmtJZHMgPSB0dXBsZS5pZE1hcChsaW5rSW5wdXQucmVtKTtcbiAgICB0aGlzLl9saW5rcyA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7IHJldHVybiAhbGlua0lkc1tsLnR1cGxlLl9pZF07IH0pO1xuICB9XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBub2RlSW5wdXQuZmllbGRzW291dHB1dC54XSA9IDE7XG4gIG5vZGVJbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgcmV0dXJuIG5vZGVJbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9yY2U7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBleHByZXNzaW9uID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBGb3JtdWxhKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBleHByOiAge3R5cGU6IFwiZXhwclwifVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZvcm11bGEucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImZvcm11bGF0aW5nXCJdKTtcbiAgdmFyIHQgPSB0aGlzLCBcbiAgICAgIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGZpZWxkID0gdGhpcy5maWVsZC5nZXQoZyksXG4gICAgICBleHByID0gdGhpcy5leHByLmdldChnKSxcbiAgICAgIGRlcHMgPSB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTKTtcbiAgXG4gIGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgdmFyIHZhbCA9IGV4cHJlc3Npb24uZXZhbChnLCBleHByLCB4LCBudWxsLCBudWxsLCBudWxsLCBkZXBzKTtcbiAgICB0dXBsZS5zZXQoeCwgZmllbGQsIHZhbCk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW2ZpZWxkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybXVsYTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gR2VvKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywgR2VvLlBhcmFtZXRlcnMpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgbG9uOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBsYXQ6IHt0eXBlOiBcImZpZWxkXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInhcIjogXCJnZW86eFwiLFxuICAgIFwieVwiOiBcImdlbzp5XCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBOb25lXG5cbkdlby5QYXJhbWV0ZXJzID0ge1xuICBwcm9qZWN0aW9uOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcIm1lcmNhdG9yXCJ9LFxuICBjZW50ZXI6ICAgICB7dHlwZTogXCJhcnJheVt2YWx1ZV1cIn0sXG4gIHRyYW5zbGF0ZTogIHt0eXBlOiBcImFycmF5W3ZhbHVlXVwifSxcbiAgcm90YXRlOiAgICAge3R5cGU6IFwiYXJyYXlbdmFsdWVdXCJ9LFxuICBzY2FsZTogICAgICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgcHJlY2lzaW9uOiAge3R5cGU6IFwidmFsdWVcIn0sXG4gIGNsaXBBbmdsZTogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICBjbGlwRXh0ZW50OiB7dHlwZTogXCJ2YWx1ZVwifVxufTtcblxuR2VvLmQzUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgcCA9IHRoaXMucHJvamVjdGlvbi5nZXQoZyksXG4gICAgICBwYXJhbSA9IEdlby5QYXJhbWV0ZXJzLFxuICAgICAgcHJvaiwgbmFtZSwgdmFsdWU7XG5cbiAgaWYgKHAgIT09IHRoaXMuX21vZGUpIHtcbiAgICB0aGlzLl9tb2RlID0gcDtcbiAgICB0aGlzLl9wcm9qZWN0aW9uID0gZDMuZ2VvW3BdKCk7XG4gIH1cbiAgcHJvaiA9IHRoaXMuX3Byb2plY3Rpb247XG5cbiAgZm9yIChuYW1lIGluIHBhcmFtKSB7XG4gICAgaWYgKG5hbWUgPT09IFwicHJvamVjdGlvblwiIHx8ICFwcm9qW25hbWVdKSBjb250aW51ZTtcbiAgICB2YWx1ZSA9IHRoaXNbbmFtZV0uZ2V0KGcpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IChkbC5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBwcm9qW25hbWVdKCkpIHtcbiAgICAgIHByb2pbbmFtZV0odmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9qO1xufTtcblxudmFyIHByb3RvID0gKEdlby5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgbG9uID0gdGhpcy5sb24uZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgbGF0ID0gdGhpcy5sYXQuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgcHJvaiA9IEdlby5kM1Byb2plY3Rpb24uY2FsbCh0aGlzKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHZhciBsbCA9IFtsb24odCksIGxhdCh0KV07XG4gICAgdmFyIHh5ID0gcHJvaihsbCk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC54LCB4eVswXSk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC55LCB4eVsxXSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW87XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBHZW8gPSByZXF1aXJlKCcuL0dlbycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBHZW9QYXRoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywgR2VvLlBhcmFtZXRlcnMpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJwYXRoXCI6IFwiZ2VvOnBhdGhcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEdlb1BhdGgucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGdlb2pzb24gPSB0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvciB8fCBkbC5pZGVudGl0eSxcbiAgICAgIHByb2ogPSBHZW8uZDNQcm9qZWN0aW9uLmNhbGwodGhpcyksXG4gICAgICBwYXRoID0gZDMuZ2VvLnBhdGgoKS5wcm9qZWN0aW9uKHByb2opO1xuXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5wYXRoLCBwYXRoKGdlb2pzb24odCkpKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgICBpbnB1dC5yZW0uZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5wYXRoXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvUGF0aDtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gTGlua1BhdGgoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc291cmNlOiAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJfc291cmNlXCJ9LFxuICAgIHRhcmdldDogIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiX3RhcmdldFwifSxcbiAgICB4OiAgICAgICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImxheW91dDp4XCJ9LFxuICAgIHk6ICAgICAgIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwibGF5b3V0OnlcIn0sXG4gICAgdGVuc2lvbjoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC4yfSxcbiAgICBzaGFwZTogICB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcImxpbmVcIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1wicGF0aFwiOiBcImxpbms6cGF0aFwifTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChMaW5rUGF0aC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBsaW5lKGQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKSB7XG4gIHZhciBzID0gc291cmNlKGQpLCBzeCA9IHgocyksIHN5ID0geShzKSxcbiAgICAgIHQgPSB0YXJnZXQoZCksIHR4ID0geCh0KSwgdHkgPSB5KHQpO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiTFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBjdXJ2ZShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KSxcbiAgICAgIGR4ID0gdHggLSBzeCxcbiAgICAgIGR5ID0gdHkgLSBzeSxcbiAgICAgIGl4ID0gdGVuc2lvbiAqIChkeCArIGR5KSxcbiAgICAgIGl5ID0gdGVuc2lvbiAqIChkeSAtIGR4KTtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIChzeCtpeCkgKyBcIixcIiArIChzeStpeSlcbiAgICAgICArIFwiIFwiICsgKHR4K2l5KSArIFwiLFwiICsgKHR5LWl4KVxuICAgICAgICsgXCIgXCIgKyB0eCArIFwiLFwiICsgdHk7XG59XG5cbmZ1bmN0aW9uIGRpYWdvbmFsWChkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KSxcbiAgICAgIG0gPSAoc3ggKyB0eCkgLyAyO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiQ1wiICsgbSAgKyBcIixcIiArIHN5XG4gICAgICAgKyBcIiBcIiArIG0gICsgXCIsXCIgKyB0eVxuICAgICAgICsgXCIgXCIgKyB0eCArIFwiLFwiICsgdHk7XG59XG5cbmZ1bmN0aW9uIGRpYWdvbmFsWShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KSxcbiAgICAgIG0gPSAoc3kgKyB0eSkgLyAyO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiQ1wiICsgc3ggKyBcIixcIiArIG1cbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIG1cbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG52YXIgc2hhcGVzID0ge1xuICBsaW5lOiAgICAgIGxpbmUsXG4gIGN1cnZlOiAgICAgY3VydmUsXG4gIGRpYWdvbmFsOiAgZGlhZ29uYWxYLFxuICBkaWFnb25hbFg6IGRpYWdvbmFsWCxcbiAgZGlhZ29uYWxZOiBkaWFnb25hbFlcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBzaGFwZSA9IHNoYXBlc1t0aGlzLnNoYXBlLmdldChnKV0gfHwgc2hhcGVzLmxpbmUsXG4gICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldC5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB4ID0gdGhpcy54LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHkgPSB0aGlzLnkuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgdGVuc2lvbiA9IHRoaXMudGVuc2lvbi5nZXQoZyk7XG4gIFxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHZhciBwYXRoID0gc2hhcGUodCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pXG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5wYXRoLCBwYXRoKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQucGF0aF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtQYXRoOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgYXJyYXlUeXBlID0gL2FycmF5L2ksXG4gICAgZGF0YVR5cGUgID0gL2RhdGEvaSxcbiAgICBmaWVsZFR5cGUgPSAvZmllbGQvaSxcbiAgICBleHByVHlwZSAgPSAvZXhwci9pO1xuXG5mdW5jdGlvbiBQYXJhbWV0ZXIobmFtZSwgdHlwZSkge1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgLy8gSWYgcGFyYW1ldGVyIGlzIGRlZmluZWQgdy9zaWduYWxzLCBpdCBtdXN0IGJlIHJlc29sdmVkXG4gIC8vIG9uIGV2ZXJ5IHB1bHNlLlxuICB0aGlzLl92YWx1ZSA9IFtdO1xuICB0aGlzLl9hY2Nlc3NvcnMgPSBbXTtcbiAgdGhpcy5fcmVzb2x1dGlvbiA9IGZhbHNlO1xuICB0aGlzLl9zaWduYWxzID0ge307XG59XG5cbnZhciBwcm90byA9IFBhcmFtZXRlci5wcm90b3R5cGU7XG5cbnByb3RvLl9nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzQXJyYXkgPSBhcnJheVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpO1xuXG4gIGlmIChpc0RhdGEpIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHsgbmFtZXM6IHRoaXMuX3ZhbHVlLCBzb3VyY2VzOiB0aGlzLl9hY2Nlc3NvcnMgfSA6XG4gICAgICB7IG5hbWU6IHRoaXMuX3ZhbHVlWzBdLCBzb3VyY2U6IHRoaXMuX2FjY2Vzc29yc1swXSB9O1xuICB9IGVsc2UgaWYgKGlzRmllbGQpIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHsgZmllbGRzOiB0aGlzLl92YWx1ZSwgYWNjZXNzb3JzOiB0aGlzLl9hY2Nlc3NvcnMgfSA6XG4gICAgICB7IGZpZWxkOiB0aGlzLl92YWx1ZVswXSwgYWNjZXNzb3I6IHRoaXMuX2FjY2Vzc29yc1swXSB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc0FycmF5ID8gdGhpcy5fdmFsdWUgOiB0aGlzLl92YWx1ZVswXTtcbiAgfVxufTtcblxucHJvdG8uZ2V0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdmFyIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgcywgaWR4LCB2YWw7XG5cbiAgLy8gSWYgd2UgZG9uJ3QgcmVxdWlyZSByZXNvbHV0aW9uLCByZXR1cm4gdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICBpZiAoIXRoaXMuX3Jlc29sdXRpb24pIHJldHVybiB0aGlzLl9nZXQoKTtcblxuICBpZiAoaXNEYXRhKSB7XG4gICAgdGhpcy5fYWNjZXNzb3JzID0gdGhpcy5fdmFsdWUubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGdyYXBoLmRhdGEodik7IH0pO1xuICAgIHJldHVybiB0aGlzLl9nZXQoKTsgLy8gVE9ETzogc3VwcG9ydCBzaWduYWwgYXMgZGF0YVR5cGVzXG4gIH1cblxuICBmb3IocyBpbiB0aGlzLl9zaWduYWxzKSB7XG4gICAgaWR4ICA9IHRoaXMuX3NpZ25hbHNbc107XG4gICAgdmFsICA9IGdyYXBoLnNpZ25hbFJlZihzKTtcblxuICAgIGlmIChpc0ZpZWxkKSB7XG4gICAgICB0aGlzLl9hY2Nlc3NvcnNbaWR4XSA9IHRoaXMuX3ZhbHVlW2lkeF0gIT0gdmFsID8gXG4gICAgICAgIGRsLmFjY2Vzc29yKHZhbCkgOiB0aGlzLl9hY2Nlc3NvcnNbaWR4XTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZVtpZHhdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2dldCgpO1xufTtcblxucHJvdG8uc2V0ID0gZnVuY3Rpb24odHJhbnNmb3JtLCB2YWx1ZSkge1xuICB2YXIgcGFyYW0gPSB0aGlzLCBcbiAgICAgIGlzRXhwciA9IGV4cHJUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICB0aGlzLl92YWx1ZSA9IGRsLmFycmF5KHZhbHVlKS5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgIGlmIChkbC5pc1N0cmluZyh2KSkge1xuICAgICAgaWYgKGlzRXhwcikge1xuICAgICAgICB2YXIgZSA9IGV4cHIodik7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCAgZS5maWVsZHMpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLlNJR05BTFMsIGUuc2lnbmFscyk7XG4gICAgICAgIHJldHVybiBlLmZuO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7ICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBwYXJhbS5fYWNjZXNzb3JzW2ldID0gZGwuYWNjZXNzb3Iodik7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCB2KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEYXRhKSB7XG4gICAgICAgIHBhcmFtLl9yZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5EQVRBLCB2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAodi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdi52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHYuZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW0uX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYuZmllbGQpO1xuICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5GSUVMRFMsIHYuZmllbGQpO1xuICAgICAgcmV0dXJuIHYuZmllbGQ7XG4gICAgfSBlbHNlIGlmICh2LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbS5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICBwYXJhbS5fc2lnbmFsc1t2LnNpZ25hbF0gPSBpO1xuICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCB2LnNpZ25hbCk7XG4gICAgICByZXR1cm4gdi5zaWduYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFtZXRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gUGllKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgdmFsdWU6ICAgICAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogbnVsbH0sXG4gICAgc3RhcnRBbmdsZToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMH0sXG4gICAgZW5kQW5nbGU6ICAge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMiAqIE1hdGguUEl9LFxuICAgIHNvcnQ6ICAgICAgIHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IGZhbHNlfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJzdGFydFwiOiBcImxheW91dDpzdGFydFwiLFxuICAgIFwic3RvcFwiOiAgXCJsYXlvdXQ6c3RvcFwiLFxuICAgIFwibWlkXCI6ICAgXCJsYXlvdXQ6bWlkXCJcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFBpZS5wcm90b3R5cGUgPSBuZXcgQmF0Y2hUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIG9uZXMoKSB7IHJldHVybiAxOyB9XG5cbnByb3RvLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IgfHwgb25lcyxcbiAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydEFuZ2xlLmdldChnKSxcbiAgICAgIHN0b3AgPSB0aGlzLmVuZEFuZ2xlLmdldChnKSxcbiAgICAgIHNvcnQgPSB0aGlzLnNvcnQuZ2V0KGcpO1xuXG4gIHZhciB2YWx1ZXMgPSBkYXRhLm1hcCh2YWx1ZSksXG4gICAgICBhID0gc3RhcnQsXG4gICAgICBrID0gKHN0b3AgLSBzdGFydCkgLyBkMy5zdW0odmFsdWVzKSxcbiAgICAgIGluZGV4ID0gZGwucmFuZ2UoZGF0YS5sZW5ndGgpLFxuICAgICAgaSwgdCwgdjtcblxuICBpZiAoc29ydCkge1xuICAgIGluZGV4LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHZhbHVlc1thXSAtIHZhbHVlc1tiXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPGluZGV4Lmxlbmd0aDsgKytpKSB7XG4gICAgdCA9IGRhdGFbaW5kZXhbaV1dO1xuICAgIHYgPSB2YWx1ZXNbaW5kZXhbaV1dO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQubWlkLCAoYSArIDAuNSAqIHYgKiBrKSk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5zdG9wLCAoYSArPSB2ICogaykpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdGFydF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0b3BdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5taWRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWU7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBTb3J0KGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge2J5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0gfSk7XG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKFNvcnQucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcInNvcnRpbmdcIl0pO1xuXG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQubW9kLmxlbmd0aCB8fCBpbnB1dC5yZW0ubGVuZ3RoKSB7XG4gICAgaW5wdXQuc29ydCA9IGRsLmNvbXBhcmF0b3IodGhpcy5ieS5nZXQodGhpcy5fZ3JhcGgpLmZpZWxkcyk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvcnQ7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBTdGFjayhncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGdyb3VwYnk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSxcbiAgICBzb3J0Ynk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSxcbiAgICB2YWx1ZToge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgb2Zmc2V0OiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcInplcm9cIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwic3RhcnRcIjogXCJsYXlvdXQ6c3RhcnRcIixcbiAgICBcInN0b3BcIjogIFwibGF5b3V0OnN0b3BcIixcbiAgICBcIm1pZFwiOiAgIFwibGF5b3V0Om1pZFwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoU3RhY2sucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBncm91cGJ5ID0gdGhpcy5ncm91cGJ5LmdldChnKS5hY2Nlc3NvcnMsXG4gICAgICBzb3J0YnkgPSBkbC5jb21wYXJhdG9yKHRoaXMuc29ydGJ5LmdldChnKS5maWVsZHMpLFxuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvcixcbiAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0LmdldChnKSxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dDtcblxuICAvLyBwYXJ0aXRpb24sIHN1bSwgYW5kIHNvcnQgdGhlIHN0YWNrIGdyb3Vwc1xuICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnRieSwgdmFsdWUpO1xuXG4gIC8vIGNvbXB1dGUgc3RhY2sgbGF5b3V0cyBwZXIgZ3JvdXBcbiAgZm9yICh2YXIgaT0wLCBtYXg9Z3JvdXBzLm1heDsgaTxncm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV0sXG4gICAgICAgIHN1bSA9IGdyb3VwLnN1bSxcbiAgICAgICAgb2ZmID0gb2Zmc2V0PT09XCJjZW50ZXJcIiA/IChtYXggLSBzdW0pLzIgOiAwLFxuICAgICAgICBzY2FsZSA9IG9mZnNldD09PVwibm9ybWFsaXplXCIgPyAoMS9zdW0pIDogMSxcbiAgICAgICAgaSwgeCwgYSwgYiA9IG9mZiwgdiA9IDA7XG5cbiAgICAvLyBzZXQgc3RhY2sgY29vcmRpbmF0ZXMgZm9yIGVhY2ggZGF0dW0gaW4gZ3JvdXBcbiAgICBmb3IgKGo9MDsgajxncm91cC5sZW5ndGg7ICsraikge1xuICAgICAgeCA9IGdyb3VwW2pdO1xuICAgICAgYSA9IGI7IC8vIHVzZSBwcmV2aW91cyB2YWx1ZSBmb3Igc3RhcnQgcG9pbnRcbiAgICAgIHYgKz0gdmFsdWUoeCk7XG4gICAgICBiID0gc2NhbGUgKiB2ICsgb2ZmOyAvLyBjb21wdXRlIGVuZCBwb2ludFxuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5zdGFydCwgYSk7XG4gICAgICB0dXBsZS5zZXQoeCwgb3V0cHV0LnN0b3AsIGIpO1xuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5taWQsIDAuNSAqIChhICsgYikpO1xuICAgIH1cbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdG9wXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQubWlkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBzb3J0YnksIHZhbHVlKSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIG1hcCwgaSwgeCwgaywgZywgcywgbWF4O1xuXG4gIC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5zbGljZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcD17fSwgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgayA9IChncm91cGJ5Lm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBmKHgpOyB9KSk7XG4gICAgICBnID0gbWFwW2tdIHx8IChncm91cHMucHVzaChtYXBba10gPSBbXSksIG1hcFtrXSk7XG4gICAgICBnLnB1c2goeCk7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBzdW1zIG9mIGdyb3Vwcywgc29ydCBncm91cHMgYXMgbmVlZGVkXG4gIGZvciAoaz0wLCBtYXg9MDsgazxncm91cHMubGVuZ3RoOyArK2spIHtcbiAgICBnID0gZ3JvdXBzW2tdO1xuICAgIGZvciAoaT0wLCBzPTA7IGk8Zy5sZW5ndGg7ICsraSkge1xuICAgICAgcyArPSB2YWx1ZShnW2ldKTtcbiAgICB9XG4gICAgZy5zdW0gPSBzO1xuICAgIGlmIChzID4gbWF4KSBtYXggPSBzO1xuICAgIGlmIChzb3J0YnkgIT0gbnVsbCkgZy5zb3J0KHNvcnRieSk7XG4gIH1cbiAgZ3JvdXBzLm1heCA9IG1heDtcblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrOyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIFBhcmFtZXRlciA9IHJlcXVpcmUoJy4vUGFyYW1ldGVyJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShncmFwaCkge1xuICBpZihncmFwaCkgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocHJvdG8sIHBhcmFtcykge1xuICB2YXIgcDtcbiAgZm9yICh2YXIgbmFtZSBpbiBwYXJhbXMpIHtcbiAgICBwID0gcGFyYW1zW25hbWVdO1xuICAgIHByb3RvW25hbWVdID0gbmV3IFBhcmFtZXRlcihuYW1lLCBwLnR5cGUpO1xuICAgIGlmIChwLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHByb3RvW25hbWVdLnNldChwcm90bywgcC5kZWZhdWx0KTtcbiAgfVxuICBwcm90by5fcGFyYW1ldGVycyA9IHBhcmFtcztcbn07XG5cbnZhciBwcm90byA9IChUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gTm9kZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgbi50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgbi5fcGFyYW1ldGVycyA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gIGZvcih2YXIgayBpbiB0aGlzKSB7IFxuICAgIGlmKG5ba10pIGNvbnRpbnVlO1xuICAgIG5ba10gPSB0aGlzW2tdOyBcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkgeyByZXR1cm4gaW5wdXQ7IH07XG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIE1hbnkgdHJhbnNmb3JtcyBzdG9yZSBjYWNoZXMgdGhhdCBtdXN0IGJlIGludmFsaWRhdGVkIGlmXG4gIC8vIGEgc2lnbmFsIHZhbHVlIGhhcyBjaGFuZ2VkLiBcbiAgdmFyIHJlc2V0ID0gdGhpcy5fc3RhbXAgPCBpbnB1dC5zdGFtcCAmJiB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTKS5zb21lKGZ1bmN0aW9uKHMpIHsgXG4gICAgcmV0dXJuICEhaW5wdXQuc2lnbmFsc1tzXSBcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGlucHV0LCByZXNldCk7XG59O1xuXG5wcm90by5vdXRwdXQgPSBmdW5jdGlvbihtYXApIHtcbiAgZm9yICh2YXIga2V5IGluIHRoaXMuX291dHB1dCkge1xuICAgIGlmIChtYXBba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9vdXRwdXRba2V5XSA9IG1hcFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBUcmVlbWFwKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgLy8gaGllcmFyY2h5IHBhcmFtZXRlcnNcbiAgICBzb3J0OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIiwgZGVmYXVsdDogW1wiLXZhbHVlXCJdfSxcbiAgICBjaGlsZHJlbjoge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJjaGlsZHJlblwifSxcbiAgICB2YWx1ZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJ2YWx1ZVwifSxcbiAgICAvLyB0cmVlbWFwIHBhcmFtZXRlcnNcbiAgICBzaXplOiB7dHlwZTogXCJhcnJheTx2YWx1ZT5cIiwgZGVmYXVsdDogWzUwMCwgNTAwXX0sXG4gICAgcm91bmQ6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IHRydWV9LFxuICAgIHN0aWNreToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogZmFsc2V9LFxuICAgIHJhdGlvOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjUgKiAoMSArIE1hdGguc3FydCg1KSl9LFxuICAgIHBhZGRpbmc6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIG1vZGU6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwic3F1YXJpZnlcIn1cbiAgfSk7XG5cbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LnRyZWVtYXAoKTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6ICAgICAgXCJsYXlvdXQ6eFwiLFxuICAgIFwieVwiOiAgICAgIFwibGF5b3V0OnlcIixcbiAgICBcIndpZHRoXCI6ICBcImxheW91dDp3aWR0aFwiLFxuICAgIFwiaGVpZ2h0XCI6IFwibGF5b3V0OmhlaWdodFwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoVHJlZW1hcC5wcm90b3R5cGUgPSBuZXcgQmF0Y2hUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgbGF5b3V0ID0gdGhpcy5fbGF5b3V0LFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0O1xuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgbGF5b3V0XG4gICAgLnNvcnQoZGwuY29tcGFyYXRvcih0aGlzLnNvcnQuZ2V0KGcpLmZpZWxkcykpXG4gICAgLmNoaWxkcmVuKHRoaXMuY2hpbGRyZW4uZ2V0KGcpLmFjY2Vzc29yKVxuICAgIC52YWx1ZSh0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvcilcbiAgICAuc2l6ZSh0aGlzLnNpemUuZ2V0KGcpKVxuICAgIC5yb3VuZCh0aGlzLnJvdW5kLmdldChnKSlcbiAgICAuc3RpY2t5KHRoaXMuc3RpY2t5LmdldChnKSlcbiAgICAucmF0aW8odGhpcy5yYXRpby5nZXQoZykpXG4gICAgLnBhZGRpbmcodGhpcy5wYWRkaW5nLmdldChnKSlcbiAgICAubW9kZSh0aGlzLm1vZGUuZ2V0KGcpKVxuICAgIC5ub2RlcyhkYXRhWzBdKTtcblxuICAvLyBjb3B5IGxheW91dCB2YWx1ZXMgdG8gbm9kZXNcbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LngsIG4ueCk7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC55LCBuLnkpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQud2lkdGgsIG4uZHgpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQuaGVpZ2h0LCBuLmR5KTtcbiAgfSk7XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQud2lkdGhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5oZWlnaHRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlbWFwOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBaaXAoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgd2l0aDoge3R5cGU6IFwiZGF0YVwifSxcbiAgICBhczogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICAgIGtleToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJkYXRhXCJ9LFxuICAgIHdpdGhLZXk6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIGRlZmF1bHQ6IHt0eXBlOiBcInZhbHVlXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgdGhpcy5fbGFzdEpvaW4gPSAwO1xuXG4gIHJldHVybiB0aGlzLnJldmlzZXModHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChaaXAucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxuZnVuY3Rpb24gbXAoaykge1xuICByZXR1cm4gdGhpcy5fbWFwW2tdIHx8ICh0aGlzLl9tYXBba10gPSBbXSk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgdyA9IHRoaXMud2l0aC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgd2RzID0gdy5zb3VyY2UsXG4gICAgICB3b3V0cHV0ID0gd2RzLmxhc3QoKSxcbiAgICAgIHdkYXRhID0gd2RzLnZhbHVlcygpLFxuICAgICAga2V5ID0gdGhpcy5rZXkuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIHdpdGhLZXkgPSB0aGlzLndpdGhLZXkuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGFzID0gdGhpcy5hcy5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgZGZsdCA9IHRoaXMuZGVmYXVsdC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgbWFwID0gbXAuYmluZCh0aGlzKSxcbiAgICAgIHJlbSA9IHt9O1xuXG4gIGRlYnVnKGlucHV0LCBbXCJ6aXBwaW5nXCIsIHcubmFtZV0pO1xuXG4gIGlmKHdpdGhLZXkuZmllbGQpIHtcbiAgICBpZih3b3V0cHV0ICYmIHdvdXRwdXQuc3RhbXAgPiB0aGlzLl9sYXN0Sm9pbikge1xuICAgICAgd291dHB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBtID0gbWFwKHdpdGhLZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICBpZihtWzBdKSBtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IGRmbHQgfSk7XG4gICAgICAgIG1bMV0gPSBudWxsO1xuICAgICAgfSk7XG5cbiAgICAgIHdvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkgeyBcbiAgICAgICAgdmFyIG0gPSBtYXAod2l0aEtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgIGlmKG1bMF0pIG1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0geCB9KTtcbiAgICAgICAgbVsxXSA9IHg7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gT25seSBwcm9jZXNzIHdvdXRwdXQubW9kIHR1cGxlcyBpZiB0aGUgam9pbiBrZXkgaGFzIGNoYW5nZWQuXG4gICAgICAvLyBPdGhlciBmaWVsZCB1cGRhdGVzIHdpbGwgYXV0by1wcm9wYWdhdGUgdmlhIHByb3RvdHlwZS5cbiAgICAgIGlmKHdvdXRwdXQuZmllbGRzW3dpdGhLZXkuZmllbGRdKSB7XG4gICAgICAgIHdvdXRwdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHZhciBwcmV2O1xuICAgICAgICAgIGlmKCF4Ll9wcmV2IHx8IChwcmV2ID0gd2l0aEtleS5hY2Nlc3Nvcih4Ll9wcmV2KSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgICAgIHZhciBwcmV2bSA9IG1hcChwcmV2KTtcbiAgICAgICAgICBpZihwcmV2bVswXSkgcHJldm1bMF0uZm9yRWFjaChmdW5jdGlvbihkKSB7IGRbYXNdID0gZGZsdCB9KTtcbiAgICAgICAgICBwcmV2bVsxXSA9IG51bGw7XG5cbiAgICAgICAgICB2YXIgbSA9IG1hcCh3aXRoS2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgICBpZihtWzBdKSBtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IHggfSk7XG4gICAgICAgICAgbVsxXSA9IHg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9sYXN0Sm9pbiA9IHdvdXRwdXQuc3RhbXA7XG4gICAgfVxuICBcbiAgICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgbSA9IG1hcChrZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgeFthc10gPSBtWzFdIHx8IGRmbHQ7XG4gICAgICAobVswXT1tWzBdfHxbXSkucHVzaCh4KTtcbiAgICB9KTtcblxuICAgIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgXG4gICAgICB2YXIgayA9IGtleS5hY2Nlc3Nvcih4KTtcbiAgICAgIChyZW1ba109cmVtW2tdfHx7fSlbeC5faWRdID0gMTtcbiAgICB9KTtcblxuICAgIGlmKGlucHV0LmZpZWxkc1trZXkuZmllbGRdKSB7XG4gICAgICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICBpZigheC5fcHJldiB8fCAocHJldiA9IGtleS5hY2Nlc3Nvcih4Ll9wcmV2KSkgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBtID0gbWFwKGtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgIHhbYXNdID0gbVsxXSB8fCBkZmx0O1xuICAgICAgICAobVswXT1tWzBdfHxbXSkucHVzaCh4KTtcbiAgICAgICAgKHJlbVtwcmV2XT1yZW1bcHJldl18fHt9KVt4Ll9pZF0gPSAxO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGwua2V5cyhyZW0pLmZvckVhY2goZnVuY3Rpb24oaykgeyBcbiAgICAgIHZhciBtID0gbWFwKGspO1xuICAgICAgaWYoIW1bMF0pIHJldHVybjtcbiAgICAgIG1bMF0gPSBtWzBdLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiByZW1ba11beC5faWRdICE9PSAxIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBydW4gYSBub24ta2V5LWpvaW4gYWdhaW4gaWYgd2UndmUgZ290IGFueSBhZGQvcmVtXG4gICAgLy8gb24gaW5wdXQgb3Igd291dHB1dFxuICAgIGlmKGlucHV0LmFkZC5sZW5ndGggPT0gMCAmJiBpbnB1dC5yZW0ubGVuZ3RoID09IDAgJiYgXG4gICAgICAgIHdvdXRwdXQuYWRkLmxlbmd0aCA9PSAwICYmIHdvdXRwdXQucmVtLmxlbmd0aCA9PSAwKSByZXR1cm4gaW5wdXQ7XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEga2V5LWpvaW4sIHRoZW4gd2UgbmVlZCB0byBtYXRlcmlhbGl6ZSBib3RoXG4gICAgLy8gZGF0YSBzb3VyY2VzIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtLiBcbiAgICB0aGlzLl9jb2xsZWN0b3IuZXZhbHVhdGUoaW5wdXQpO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpLCBcbiAgICAgICAgd2xlbiA9IHdkYXRhLmxlbmd0aCwgaTtcblxuICAgIGZvcihpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHsgZGF0YVtpXVthc10gPSB3ZGF0YVtpJXdsZW5dOyB9XG4gIH1cblxuICBpbnB1dC5maWVsZHNbYXNdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBaaXA7IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFnZ3JlZ2F0ZTogIHJlcXVpcmUoJy4vQWdncmVnYXRlJyksXG4gIGJpbjogICAgICAgIHJlcXVpcmUoJy4vQmluJyksXG4gIGNyb3NzOiAgICAgIHJlcXVpcmUoJy4vQ3Jvc3MnKSxcbiAgbGlua3BhdGg6ICAgcmVxdWlyZSgnLi9MaW5rUGF0aCcpLFxuICBmYWNldDogICAgICByZXF1aXJlKCcuL0ZhY2V0JyksXG4gIGZpbHRlcjogICAgIHJlcXVpcmUoJy4vRmlsdGVyJyksXG4gIGZvbGQ6ICAgICAgIHJlcXVpcmUoJy4vRm9sZCcpLFxuICBmb3JjZTogICAgICByZXF1aXJlKCcuL0ZvcmNlJyksXG4gIGZvcm11bGE6ICAgIHJlcXVpcmUoJy4vRm9ybXVsYScpLFxuICBnZW86ICAgICAgICByZXF1aXJlKCcuL0dlbycpLFxuICBnZW9wYXRoOiAgICByZXF1aXJlKCcuL0dlb1BhdGgnKSxcbiAgcGllOiAgICAgICAgcmVxdWlyZSgnLi9QaWUnKSxcbiAgc29ydDogICAgICAgcmVxdWlyZSgnLi9Tb3J0JyksXG4gIHN0YWNrOiAgICAgIHJlcXVpcmUoJy4vU3RhY2snKSxcbiAgdHJlZW1hcDogICAgcmVxdWlyZSgnLi9UcmVlbWFwJyksXG4gIHppcDogICAgICAgIHJlcXVpcmUoJy4vWmlwJylcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZHMnKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvY2FudmFzL3BhdGgnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgcGFyc2UgPSBjYW52YXMucGFyc2UsXG4gICAgYm91bmRQYXRoID0gY2FudmFzLmJvdW5kcyxcbiAgICBhcmVhUGF0aCA9IGNhbnZhcy5hcmVhLFxuICAgIGxpbmVQYXRoID0gY2FudmFzLmxpbmUsXG4gICAgaGFsZnBpID0gTWF0aC5QSSAvIDIsXG4gICAgc3FydDMgPSBNYXRoLnNxcnQoMyksXG4gICAgdGFuMzAgPSBNYXRoLnRhbigzMCAqIE1hdGguUEkgLyAxODApLFxuICAgIGdmeCA9IG51bGw7XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICByZXR1cm4gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbn1cblxuZnVuY3Rpb24gY29udGV4dCgpIHtcbiAgLy8gVE9ETzogaG93IHRvIGNoZWNrIGlmIG5vZGVKUyBpbiByZXF1aXJlSlM/XG4gIHJldHVybiBnZnggfHwgKGdmeCA9ICgvKmNvbmZpZy5pc05vZGVcbiAgICA/IG5ldyAocmVxdWlyZShcImNhbnZhc1wiKSkoMSwxKVxuICAgIDogKi9kMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcImNhbnZhc1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidmVnYV9oaWRkZW5cIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAubm9kZSgpKVxuICAgIC5nZXRDb250ZXh0KFwiMmRcIikpO1xufVxuXG5mdW5jdGlvbiBwYXRoQm91bmRzKG8sIHBhdGgsIGJvdW5kcykge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgYm91bmRzLnNldCgwLCAwLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZFBhdGgocGF0aCwgYm91bmRzKTtcbiAgICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBwYXRoKG8sIGJvdW5kcykge1xuICB2YXIgcCA9IG8ucGF0aFxuICAgID8gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2Uoby5wYXRoKSlcbiAgICA6IG51bGw7XG4gIHJldHVybiBwYXRoQm91bmRzKG8sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIGFyZWEobywgYm91bmRzKSB7XG4gIHZhciBpdGVtcyA9IG8ubWFyay5pdGVtcywgbyA9IGl0ZW1zWzBdO1xuICB2YXIgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGFyZWFQYXRoKGl0ZW1zKSkpO1xuICByZXR1cm4gcGF0aEJvdW5kcyhpdGVtc1swXSwgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gbGluZShvLCBib3VuZHMpIHtcbiAgdmFyIGl0ZW1zID0gby5tYXJrLml0ZW1zLCBvID0gaXRlbXNbMF07XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2UobGluZVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW1zWzBdLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiByZWN0KG8sIGJvdW5kcykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgdyA9ICh4ICsgby53aWR0aCkgfHwgMCxcbiAgICAgIGggPSAoeSArIG8uaGVpZ2h0KSB8fCAwO1xuICBib3VuZHMuc2V0KHgsIHksIHcsIGgpO1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBpbWFnZShvLCBib3VuZHMpIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMCxcbiAgICAgIHggPSAoby54fHwwKSAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKSxcbiAgICAgIHkgPSAoby55fHwwKSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSk7XG4gIHJldHVybiBib3VuZHMuc2V0KHgsIHksIHgrdywgeStoKTtcbn1cblxuZnVuY3Rpb24gcnVsZShvLCBib3VuZHMpIHtcbiAgdmFyIHgxLCB5MTtcbiAgYm91bmRzLnNldChcbiAgICB4MSA9IG8ueCB8fCAwLFxuICAgIHkxID0gby55IHx8IDAsXG4gICAgby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgIG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MVxuICApO1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBhcmMobywgYm91bmRzKSB7XG4gIHZhciBjeCA9IG8ueCB8fCAwLFxuICAgICAgY3kgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gaGFsZnBpLFxuICAgICAgeG1pbiA9IEluZmluaXR5LCB4bWF4ID0gLUluZmluaXR5LFxuICAgICAgeW1pbiA9IEluZmluaXR5LCB5bWF4ID0gLUluZmluaXR5LFxuICAgICAgYSwgaSwgbiwgeCwgeSwgaXgsIGl5LCBveCwgb3k7XG5cbiAgdmFyIGFuZ2xlcyA9IFtzYSwgZWFdLFxuICAgICAgcyA9IHNhIC0gKHNhJWhhbGZwaSk7XG4gIGZvciAoaT0wOyBpPDQgJiYgczxlYTsgKytpLCBzKz1oYWxmcGkpIHtcbiAgICBhbmdsZXMucHVzaChzKTtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPWFuZ2xlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgYSA9IGFuZ2xlc1tpXTtcbiAgICB4ID0gTWF0aC5jb3MoYSk7IGl4ID0gaXIqeDsgb3ggPSBvcip4O1xuICAgIHkgPSBNYXRoLnNpbihhKTsgaXkgPSBpcip5OyBveSA9IG9yKnk7XG4gICAgeG1pbiA9IE1hdGgubWluKHhtaW4sIGl4LCBveCk7XG4gICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIGl4LCBveCk7XG4gICAgeW1pbiA9IE1hdGgubWluKHltaW4sIGl5LCBveSk7XG4gICAgeW1heCA9IE1hdGgubWF4KHltYXgsIGl5LCBveSk7XG4gIH1cblxuICBib3VuZHMuc2V0KGN4K3htaW4sIGN5K3ltaW4sIGN4K3htYXgsIGN5K3ltYXgpO1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobywgYm91bmRzKSB7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICByLCB0LCByeCwgcnk7XG5cbiAgc3dpdGNoIChvLnNoYXBlKSB7XG4gICAgY2FzZSBcImNyb3NzXCI6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICB0ID0gMypyO1xuICAgICAgYm91bmRzLnNldCh4LXQsIHktciwgeCt0LCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgIHQgPSBNYXRoLnNxcnQoc2l6ZSk7XG4gICAgICByID0gdCAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS1kb3duXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS11cFwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgciA9IE1hdGguc3FydChzaXplL01hdGguUEkpO1xuICAgICAgYm91bmRzLnNldCh4LXIsIHktciwgeCtyLCB5K3IpO1xuICB9XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHRleHQobywgYm91bmRzLCBub1JvdGF0ZSkge1xuICB2YXIgeCA9IChvLnggfHwgMCkgKyAoby5keCB8fCAwKSxcbiAgICAgIHkgPSAoby55IHx8IDApICsgKG8uZHkgfHwgMCksXG4gICAgICBoID0gby5mb250U2l6ZSB8fCBjb25maWcucmVuZGVyLmZvbnRTaXplLFxuICAgICAgYSA9IG8uYWxpZ24sXG4gICAgICBiID0gby5iYXNlbGluZSxcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgZyA9IGNvbnRleHQoKSwgdywgdDtcblxuICBnLmZvbnQgPSBmb250U3RyaW5nKG8pO1xuICBnLnRleHRBbGlnbiA9IGEgfHwgXCJsZWZ0XCI7XG4gIGcudGV4dEJhc2VsaW5lID0gYiB8fCBcImFscGhhYmV0aWNcIjtcbiAgdyA9IGcubWVhc3VyZVRleHQoby50ZXh0IHx8IFwiXCIpLndpZHRoO1xuXG4gIGlmIChyKSB7XG4gICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgLy8gaG9yaXpvbnRhbFxuICBpZiAoYSA9PT0gXCJjZW50ZXJcIikge1xuICAgIHggPSB4IC0gKHcgLyAyKTtcbiAgfSBlbHNlIGlmIChhID09PSBcInJpZ2h0XCIpIHtcbiAgICB4ID0geCAtIHc7XG4gIH0gZWxzZSB7XG4gICAgLy8gbGVmdCBieSBkZWZhdWx0LCBkbyBub3RoaW5nXG4gIH1cblxuICAvLy8gVE9ETyBmaW5kIGEgcm9idXN0IHNvbHV0aW9uIGZvciBoZWlnaHRzLlxuICAvLy8gVGhlc2Ugb2Zmc2V0cyB3b3JrIGZvciBzb21lIGJ1dCBub3QgYWxsIGZvbnRzLlxuXG4gIC8vIHZlcnRpY2FsXG4gIGlmIChiID09PSBcInRvcFwiKSB7XG4gICAgeSA9IHkgKyAoaC81KTtcbiAgfSBlbHNlIGlmIChiID09PSBcImJvdHRvbVwiKSB7XG4gICAgeSA9IHkgLSBoO1xuICB9IGVsc2UgaWYgKGIgPT09IFwibWlkZGxlXCIpIHtcbiAgICB5ID0geSAtIChoLzIpICsgKGgvMTApO1xuICB9IGVsc2Uge1xuICAgIHkgPSB5IC0gNCpoLzU7IC8vIGFscGhhYmV0aWMgYnkgZGVmYXVsdFxuICB9XG4gIFxuICBib3VuZHMuc2V0KHgsIHksIHgrdywgeStoKTtcbiAgaWYgKG8uYW5nbGUgJiYgIW5vUm90YXRlKSB7XG4gICAgYm91bmRzLnJvdGF0ZShvLmFuZ2xlKk1hdGguUEkvMTgwLCBvLnh8fDAsIG8ueXx8MCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcy5leHBhbmQobm9Sb3RhdGUgPyAwIDogMSk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKGcsIGJvdW5kcywgaW5jbHVkZUxlZ2VuZHMpIHtcbiAgdmFyIGF4ZXMgPSBnLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGxlZ2VuZHMgPSBnLmxlZ2VuZEl0ZW1zIHx8IFtdLCBqLCBtO1xuXG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGJvdW5kcy51bmlvbihheGVzW2pdLmJvdW5kcyk7XG4gIH1cbiAgZm9yIChqPTAsIG09Zy5pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgYm91bmRzLnVuaW9uKGcuaXRlbXNbal0uYm91bmRzKTtcbiAgfVxuICBpZiAoaW5jbHVkZUxlZ2VuZHMpIHtcbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGJvdW5kcy51bmlvbihsZWdlbmRzW2pdLmJvdW5kcyk7XG4gICAgfVxuICAgIGlmIChnLndpZHRoICE9IG51bGwgJiYgZy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgYm91bmRzLmFkZChnLndpZHRoLCBnLmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChnLnggIT0gbnVsbCAmJiBnLnkgIT0gbnVsbCkge1xuICAgICAgYm91bmRzLmFkZCgwLCAwKTtcbiAgICB9XG4gIH1cbiAgYm91bmRzLnRyYW5zbGF0ZShnLnh8fDAsIGcueXx8MCk7XG4gIHJldHVybiBib3VuZHM7XG59XG5cbnZhciBtZXRob2RzID0ge1xuICBncm91cDogIGdyb3VwLFxuICBzeW1ib2w6IHN5bWJvbCxcbiAgaW1hZ2U6ICBpbWFnZSxcbiAgcmVjdDogICByZWN0LFxuICBydWxlOiAgIHJ1bGUsXG4gIGFyYzogICAgYXJjLFxuICB0ZXh0OiAgIHRleHQsXG4gIHBhdGg6ICAgcGF0aCxcbiAgYXJlYTogICBhcmVhLFxuICBsaW5lOiAgIGxpbmVcbn07XG5cbmZ1bmN0aW9uIGl0ZW1Cb3VuZHMoaXRlbSwgZnVuYywgb3B0KSB7XG4gIGZ1bmMgPSBmdW5jIHx8IG1ldGhvZHNbaXRlbS5tYXJrLm1hcmt0eXBlXTtcbiAgaWYgKCFpdGVtLmJvdW5kc19wcmV2KSBpdGVtWydib3VuZHM6cHJldiddID0gbmV3IEJvdW5kcygpO1xuICB2YXIgYiA9IGl0ZW0uYm91bmRzLCBwYiA9IGl0ZW1bJ2JvdW5kczpwcmV2J107XG4gIGlmIChiKSBwYi5jbGVhcigpLnVuaW9uKGIpO1xuICBpdGVtLmJvdW5kcyA9IGZ1bmMoaXRlbSwgYiA/IGIuY2xlYXIoKSA6IG5ldyBCb3VuZHMoKSwgb3B0KTtcbiAgaWYgKCFiKSBwYi5jbGVhcigpLnVuaW9uKGl0ZW0uYm91bmRzKTtcbiAgcmV0dXJuIGl0ZW0uYm91bmRzO1xufVxuXG5mdW5jdGlvbiBtYXJrQm91bmRzKG1hcmssIGJvdW5kcywgb3B0KSB7XG4gIGJvdW5kcyA9IGJvdW5kcyB8fCBtYXJrLmJvdW5kcyAmJiBtYXJrLmJvdW5kcy5jbGVhcigpIHx8IG5ldyBCb3VuZHMoKTtcbiAgdmFyIHR5cGUgID0gbWFyay5tYXJrdHlwZSxcbiAgICAgIGZ1bmMgID0gbWV0aG9kc1t0eXBlXSxcbiAgICAgIGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgIGl0ZW0sIGksIGxlbjtcbiAgICAgIFxuICBpZiAodHlwZT09PVwiYXJlYVwiIHx8IHR5cGU9PT1cImxpbmVcIikge1xuICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgIGl0ZW1zWzBdLmJvdW5kcyA9IGZ1bmMoaXRlbXNbMF0sIGJvdW5kcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBib3VuZHMudW5pb24oaXRlbUJvdW5kcyhpdGVtc1tpXSwgZnVuYywgb3B0KSk7XG4gICAgfVxuICB9XG4gIG1hcmsuYm91bmRzID0gYm91bmRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFyazogIG1hcmtCb3VuZHMsXG4gIGl0ZW06ICBpdGVtQm91bmRzLFxuICB0ZXh0OiAgdGV4dCxcbiAgZ3JvdXA6IGdyb3VwXG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGNvbmZpZyA9IHt9O1xuXG5jb25maWcuZGVidWcgPSBmYWxzZTtcblxuY29uZmlnLmxvYWQgPSB7XG4gIC8vIGJhc2UgdXJsIGZvciBsb2FkaW5nIGV4dGVybmFsIGRhdGEgZmlsZXNcbiAgLy8gdXNlZCBvbmx5IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25cbiAgYmFzZVVSTDogXCJcIixcbiAgLy8gQWxsb3dzIGRvbWFpbiByZXN0cmljdGlvbiB3aGVuIHVzaW5nIGRhdGEgbG9hZGluZyB2aWEgWEhSLlxuICAvLyBUbyBlbmFibGUsIHNldCBpdCB0byBhIGxpc3Qgb2YgYWxsb3dlZCBkb21haW5zXG4gIC8vIGUuZy4sIFsnd2lraXBlZGlhLm9yZycsICdlZmYub3JnJ11cbiAgZG9tYWluV2hpdGVMaXN0OiBmYWxzZVxufTtcblxuLy8gdmVyc2lvbiBhbmQgbmFtZXBzYWNlcyBmb3IgZXhwb3J0ZWQgc3ZnXG5jb25maWcuc3ZnTmFtZXNwYWNlID1cbiAgJ3ZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXG4gICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIic7XG5cbi8vIGluc2V0IHBhZGRpbmcgZm9yIGF1dG9tYXRpYyBwYWRkaW5nIGNhbGN1bGF0aW9uXG5jb25maWcuYXV0b3BhZEluc2V0ID0gNTtcblxuLy8gZXh0ZW5zaWJsZSBzY2FsZSBsb29rdXAgdGFibGVcbi8vIGFsbCBkMy5zY2FsZS4qIGluc3RhbmNlcyBhbHNvIHN1cHBvcnRlZFxuY29uZmlnLnNjYWxlID0ge1xuICB0aW1lOiBkMy50aW1lLnNjYWxlLFxuICB1dGM6ICBkMy50aW1lLnNjYWxlLnV0Y1xufTtcblxuLy8gZGVmYXVsdCByZW5kZXJpbmcgc2V0dGluZ3NcbmNvbmZpZy5yZW5kZXIgPSB7XG4gIGxpbmVXaWR0aDogMSxcbiAgbGluZUNhcDogICBcImJ1dHRcIixcbiAgZm9udDogICAgICBcInNhbnMtc2VyaWZcIixcbiAgZm9udFNpemU6ICAxMVxufTtcblxuLy8gZGVmYXVsdCBheGlzIHByb3BlcnRpZXNcbmNvbmZpZy5heGlzID0ge1xuICBvcmllbnQ6IFwiYm90dG9tXCIsXG4gIHRpY2tzOiAxMCxcbiAgcGFkZGluZzogMyxcbiAgYXhpc0NvbG9yOiBcIiMwMDBcIixcbiAgZ3JpZENvbG9yOiBcIiNkOGQ4ZDhcIixcbiAgdGlja0NvbG9yOiBcIiMwMDBcIixcbiAgdGlja0xhYmVsQ29sb3I6IFwiIzAwMFwiLFxuICBheGlzV2lkdGg6IDEsXG4gIHRpY2tXaWR0aDogMSxcbiAgdGlja1NpemU6IDYsXG4gIHRpY2tMYWJlbEZvbnRTaXplOiAxMSxcbiAgdGlja0xhYmVsRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIHRpdGxlQ29sb3I6IFwiIzAwMFwiLFxuICB0aXRsZUZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiBcImJvbGRcIixcbiAgdGl0bGVPZmZzZXQ6IDM1XG59O1xuXG4vLyBkZWZhdWx0IGxlZ2VuZCBwcm9wZXJ0aWVzXG5jb25maWcubGVnZW5kID0ge1xuICBvcmllbnQ6IFwicmlnaHRcIixcbiAgb2Zmc2V0OiAxMCxcbiAgcGFkZGluZzogMyxcbiAgZ3JhZGllbnRTdHJva2VDb2xvcjogXCIjODg4XCIsXG4gIGdyYWRpZW50U3Ryb2tlV2lkdGg6IDEsXG4gIGdyYWRpZW50SGVpZ2h0OiAxNixcbiAgZ3JhZGllbnRXaWR0aDogMTAwLFxuICBsYWJlbENvbG9yOiBcIiMwMDBcIixcbiAgbGFiZWxGb250U2l6ZTogMTAsXG4gIGxhYmVsRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIGxhYmVsQWxpZ246IFwibGVmdFwiLFxuICBsYWJlbEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICBsYWJlbE9mZnNldDogOCxcbiAgc3ltYm9sU2hhcGU6IFwiY2lyY2xlXCIsXG4gIHN5bWJvbFNpemU6IDUwLFxuICBzeW1ib2xDb2xvcjogXCIjODg4XCIsXG4gIHN5bWJvbFN0cm9rZVdpZHRoOiAxLFxuICB0aXRsZUNvbG9yOiBcIiMwMDBcIixcbiAgdGl0bGVGb250OiBcInNhbnMtc2VyaWZcIixcbiAgdGl0bGVGb250U2l6ZTogMTEsXG4gIHRpdGxlRm9udFdlaWdodDogXCJib2xkXCJcbn07XG5cbi8vIGRlZmF1bHQgY29sb3IgdmFsdWVzXG5jb25maWcuY29sb3IgPSB7XG4gIHJnYjogWzEyOCwgMTI4LCAxMjhdLFxuICBsYWI6IFs1MCwgMCwgMF0sXG4gIGhjbDogWzAsIDAsIDUwXSxcbiAgaHNsOiBbMCwgMCwgMC41XVxufTtcblxuLy8gZGVmYXVsdCBzY2FsZSByYW5nZXNcbmNvbmZpZy5yYW5nZSA9IHtcbiAgY2F0ZWdvcnkxMDogW1xuICAgIFwiIzFmNzdiNFwiLFxuICAgIFwiI2ZmN2YwZVwiLFxuICAgIFwiIzJjYTAyY1wiLFxuICAgIFwiI2Q2MjcyOFwiLFxuICAgIFwiIzk0NjdiZFwiLFxuICAgIFwiIzhjNTY0YlwiLFxuICAgIFwiI2UzNzdjMlwiLFxuICAgIFwiIzdmN2Y3ZlwiLFxuICAgIFwiI2JjYmQyMlwiLFxuICAgIFwiIzE3YmVjZlwiXG4gIF0sXG4gIGNhdGVnb3J5MjA6IFtcbiAgICBcIiMxZjc3YjRcIixcbiAgICBcIiNhZWM3ZThcIixcbiAgICBcIiNmZjdmMGVcIixcbiAgICBcIiNmZmJiNzhcIixcbiAgICBcIiMyY2EwMmNcIixcbiAgICBcIiM5OGRmOGFcIixcbiAgICBcIiNkNjI3MjhcIixcbiAgICBcIiNmZjk4OTZcIixcbiAgICBcIiM5NDY3YmRcIixcbiAgICBcIiNjNWIwZDVcIixcbiAgICBcIiM4YzU2NGJcIixcbiAgICBcIiNjNDljOTRcIixcbiAgICBcIiNlMzc3YzJcIixcbiAgICBcIiNmN2I2ZDJcIixcbiAgICBcIiM3ZjdmN2ZcIixcbiAgICBcIiNjN2M3YzdcIixcbiAgICBcIiNiY2JkMjJcIixcbiAgICBcIiNkYmRiOGRcIixcbiAgICBcIiMxN2JlY2ZcIixcbiAgICBcIiM5ZWRhZTVcIlxuICBdLFxuICBzaGFwZXM6IFtcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiY3Jvc3NcIixcbiAgICBcImRpYW1vbmRcIixcbiAgICBcInNxdWFyZVwiLFxuICAgIFwidHJpYW5nbGUtZG93blwiLFxuICAgIFwidHJpYW5nbGUtdXBcIlxuICBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZzsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUREX0NFTEw6IDEsXG4gIE1PRF9DRUxMOiAyLFxuXG4gIElEOiBcIl9pZFwiLFxuXG4gIERBVEE6IFwiZGF0YVwiLFxuICBGSUVMRFM6ICBcImZpZWxkc1wiLFxuICBTQ0FMRVM6ICBcInNjYWxlc1wiLFxuICBTSUdOQUw6ICBcInNpZ25hbFwiLFxuICBTSUdOQUxTOiBcInNpZ25hbHNcIixcblxuICBHUk9VUDogXCJncm91cFwiLFxuXG4gIEVOVEVSOiBcImVudGVyXCIsXG4gIFVQREFURTogXCJ1cGRhdGVcIixcbiAgRVhJVDogXCJleGl0XCIsXG5cbiAgU0VOVElORUw6IHtcInNlbnRpbmVsXCI6IDF9LFxuICBTSU5HTEVUT046IFwiX3NpbmdsZXRvblwiLFxuXG4gIEFERDogXCJhZGRcIixcbiAgUkVNT1ZFOiBcInJlbW92ZVwiLFxuICBUT0dHTEU6IFwidG9nZ2xlXCIsXG4gIENMRUFSOiBcImNsZWFyXCIsXG5cbiAgTElORUFSOiBcImxpbmVhclwiLFxuICBPUkRJTkFMOiBcIm9yZGluYWxcIixcbiAgTE9HOiBcImxvZ1wiLFxuICBQT1dFUjogXCJwb3dcIixcbiAgVElNRTogXCJ0aW1lXCIsXG4gIFFVQU5USUxFOiBcInF1YW50aWxlXCIsXG5cbiAgRE9NQUlOOiBcImRvbWFpblwiLFxuICBSQU5HRTogXCJyYW5nZVwiLFxuXG4gIE1BUks6IFwibWFya1wiLFxuICBBWElTOiBcImF4aXNcIixcblxuICBDT1VOVDogXCJjb3VudFwiLFxuICBHUk9VUEJZOiBcImdyb3VwYnlcIixcbiAgTUlOOiBcIm1pblwiLFxuICBNQVg6IFwibWF4XCIsXG4gIFZBTFVFOiBcInZhbHVlXCIsXG5cbiAgU09SVDogXCJzb3J0XCIsXG4gIEFTQzogXCJhc2NcIixcbiAgREVTQzogXCJkZXNjXCJcbn07IiwidmFyIGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG52YXIgdHM7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5wdXQsIGFyZ3MpIHtcbiAgaWYgKCFjb25maWcuZGVidWcpIHJldHVybjtcbiAgdmFyIGxvZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICBhcmdzLnVuc2hpZnQoaW5wdXQuc3RhbXB8fC0xKTtcbiAgYXJncy51bnNoaWZ0KERhdGUubm93KCkgLSB0cyk7XG4gIGlmKGlucHV0LmFkZCkgYXJncy5wdXNoKGlucHV0LmFkZC5sZW5ndGgsIGlucHV0Lm1vZC5sZW5ndGgsIGlucHV0LnJlbS5sZW5ndGgsICEhaW5wdXQucmVmbG93KTtcbiAgbG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB0cyA9IERhdGUubm93KCk7XG59OyJdfQ==\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('../util'),\n    Measures = require('./measures'),\n    Collector = require('./collector');\n\nfunction Aggregator() {\n  this._cells = {};\n  this._aggr = [];\n  this._stream = false;\n}\n\nvar Flags = Aggregator.Flags = {\n  ADD_CELL: 1,\n  MOD_CELL: 2\n};\n\nvar proto = Aggregator.prototype;\n\n// Parameters\n\nproto.stream = function(v) {\n  if (v == null) return this._stream;\n  this._stream = !!v;\n  this._aggr = [];\n  return this;\n};\n\n// key accessor to use for streaming removes\nproto.key = function(key) {\n  if (key == null) return this._key;\n  this._key = util.$(key);\n  return this;\n};\n\n// Input: array of objects of the form\n// {name: string, get: function}\nproto.groupby = function(dims) {\n  this._dims = util.array(dims).map(function(d, i) {\n    d = util.isString(d) ? {name: d, get: util.$(d)}\n      : util.isFunction(d) ? {name: util.name(d) || d.name || ('_' + i), get: d}\n      : (d.name && util.isFunction(d.get)) ? d : null;\n    if (d == null) throw 'Invalid groupby argument: ' + d;\n    return d;\n  });\n  return this.clear();\n};\n\n// Input: array of objects of the form\n// {name: string, ops: [string, ...]}\nproto.summarize = function(fields) {\n  fields = summarize_args(fields);\n  this._count = true;\n  var aggr = (this._aggr = []),\n      m, f, i, j, op, as, get;\n\n  for (i=0; i<fields.length; ++i) {\n    for (j=0, m=[], f=fields[i]; j<f.ops.length; ++j) {\n      op = f.ops[j];\n      if (op !== 'count') this._count = false;\n      as = (f.as && f.as[j]) || (op + (f.name==='*' ? '' : '_'+f.name));\n      m.push(Measures[op](as));\n    }\n    get = f.get && util.$(f.get) ||\n      (f.name === '*' ? util.identity : util.$(f.name));\n    aggr.push({\n      name: f.name,\n      measures: Measures.create(\n        m,\n        this._stream, // streaming remove flag\n        get,          // input tuple getter\n        this._assign) // output tuple setter\n    });\n  }\n  return this.clear();\n};\n\n// Convenience method to summarize by count\nproto.count = function() {\n  return this.summarize({'*':'count'});\n};\n\n// Override to perform custom tuple value assignment\nproto._assign = function(object, name, value) {\n  object[name] = value;\n};\n\nfunction summarize_args(fields) {\n  if (util.isArray(fields)) { return fields; }\n  if (fields == null) { return []; }\n  var a = [], name, ops;\n  for (name in fields) {\n    ops = util.array(fields[name]);\n    a.push({name: name, ops: ops});\n  }\n  return a;\n}\n\n// Cell Management\n\nproto.clear = function() {\n  return (this._cells = {}, this);\n};\n\nproto._cellkey = function(x) {\n  var d = this._dims,\n      n = d.length, i,\n      k = String(d[0].get(x));\n  for (i=1; i<n; ++i) {\n    k += '|' + d[i].get(x);\n  }\n  return k;\n};\n\nproto._cell = function(x) {\n  var key = this._dims.length ? this._cellkey(x) : '';\n  return this._cells[key] || (this._cells[key] = this._newcell(x));\n};\n\nproto._newcell = function(x) {\n  var cell = {\n    num:   0,\n    tuple: this._newtuple(x),\n    flag:  Flags.ADD_CELL,\n    aggs:  {}\n  };\n\n  var aggr = this._aggr, i;\n  for (i=0; i<aggr.length; ++i) {\n    cell.aggs[aggr[i].name] = new aggr[i].measures(cell, cell.tuple);\n  }\n  if (cell.collect) {\n    cell.data = new Collector(this._key);\n  }\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var dims = this._dims,\n      t = {}, i, n;\n  for (i=0, n=dims.length; i<n; ++i) {\n    t[dims[i].name] = dims[i].get(x);\n  }\n  return this._ingest(t);\n};\n\n// Override to perform custom tuple ingestion\nproto._ingest = util.identity;\n\n// Process Tuples\n\nproto._add = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num += 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.add(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].add(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x),\n      aggr = this._aggr, i;\n\n  cell.num -= 1;\n  if (!this._count) { // skip if count-only\n    if (cell.collect) cell.data.rem(x);\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].rem(x);\n    }\n  }\n  cell.flag |= Flags.MOD_CELL;\n};\n\nproto._mod = function(curr, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(curr),\n      aggr = this._aggr, i;\n\n  if (cell0 !== cell1) {\n    cell0.num -= 1;\n    cell1.num += 1;\n    if (cell0.collect) cell0.data.rem(prev);\n    if (cell1.collect) cell1.data.add(curr);\n  } else if (cell0.collect && !util.isObject(curr)) {\n    cell0.data.rem(prev);\n    cell0.data.add(curr);\n  }\n\n  for (i=0; i<aggr.length; ++i) {\n    cell0.aggs[aggr[i].name].rem(prev);\n    cell1.aggs[aggr[i].name].add(curr);\n  }\n  cell0.flag |= Flags.MOD_CELL;\n  cell1.flag |= Flags.MOD_CELL;\n};\n\nproto.result = function() {\n  var result = [],\n      aggr = this._aggr,\n      cell, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    if (cell.num > 0) {\n      if (cell.collect) {\n        cell.data.values();\n      }\n      for (i=0; i<aggr.length; ++i) {\n        cell.aggs[aggr[i].name].set();\n      }\n      result.push(cell.tuple);\n    }\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return result;\n};\n\nproto.changes = function() {\n  var changes = {add:[], rem:[], mod:[]},\n      aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === Flags.MOD_CELL) {\n        changes.rem.push(cell.tuple);\n      }\n      delete this._cells[k];\n    } else if (flag & Flags.ADD_CELL) {\n      changes.add.push(cell.tuple);\n    } else if (flag & Flags.MOD_CELL) {\n      changes.mod.push(cell.tuple);\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return changes;\n};\n\nproto.execute = function(input) {\n  return this.clear().insert(input).result();\n};\n\nproto.insert = function(input) {\n  this._consolidate();\n  for (var i=0; i<input.length; ++i) {\n    this._add(input[i]);\n  }\n  return this;\n};\n\nproto.remove = function(input) {\n  if (!this._stream) {\n    throw 'Aggregator not configured for streaming removes.' +\n      ' Call stream(true) prior to calling summarize.';\n  }\n  for (var i=0; i<input.length; ++i) {\n    this._rem(input[i]);\n  }\n  this._rems = true;\n  return this;\n};\n\n// consolidate removals\nproto._consolidate = function() {\n  if (!this._rems) return;\n  for (var k in this._cells) {\n    if (this._cells[k].collect) {\n      this._cells[k].data.values();\n    }\n  }\n  this._rems = false;\n};\n\nmodule.exports = Aggregator;","var util = require('../util');\nvar stats = require('../stats');\n\nvar REM = '__dl_rem__';\n\nfunction Collector(key) {\n  this._add = [];\n  this._rem = [];\n  this._key = key || null;\n  this._last = null;\n}\n\nvar proto = Collector.prototype;\n\nproto.add = function(v) {\n  this._add.push(v);\n};\n\nproto.rem = function(v) {\n  this._rem.push(v);\n};\n\nproto.values = function() {\n  if (this._rem.length === 0) return (this._get = null, this._add);\n  var a = this._add,\n      r = this._rem,\n      k = this._key,\n      x = Array(a.length - r.length),\n      i, j, n, m;\n\n  if (!util.isObject(r[0])) {\n    // processing raw values\n    m = stats.count.map(r);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (m[a[i]] > 0) {\n        m[a[i]] -= 1;\n      } else {\n        x[j++] = a[i];\n      }\n    }\n  } else if (k) {\n    // has unique key field, so use that\n    m = util.toMap(r, k);\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!m.hasOwnProperty(k(a[i]))) { x[j++] = a[i]; }\n    }\n  } else {\n    // no unique key, mark tuples directly\n    for (i=0, n=r.length; i<n; ++i) {\n      r[i][REM] = 1;\n    }\n    for (i=0, j=0, n=a.length; i<n; ++i) {\n      if (!a[i][REM]) { x[j++] = a[i]; }\n    }\n    for (i=0, n=r.length; i<n; ++i) {\n      delete r[i][REM];\n    }\n  }\n\n  this._rem = [];\n  this._get = null;\n  return (this._add = x);\n};\n\n// memoizing statistics methods\n\nproto.extent = function(get) {\n  if (this._get !== get || !this._ext) {\n    var v = this.values(),\n        i = stats.extent.index(v, get);\n    this._ext = [v[i[0]], v[i[1]]];\n    this._get = get;    \n  }\n  return this._ext;\n};\n\nproto.argmin = function(get) {\n  return this.extent(get)[0];\n};\n\nproto.argmax = function(get) {\n  return this.extent(get)[1];\n};\n\nproto.min = function(get) {\n  var m = this.extent(get)[0];\n  return m ? get(m) : +Infinity;\n};\nproto.max = function(get) {\n  var m = this.extent(get)[1];\n  return m ? get(m) : -Infinity;\n};\n\nproto.quartile = function(get) {\n  if (this._get !== get || !this._q) {\n    this._q = stats.quartile(this.values(), get);\n    this._get = get;    \n  }\n  return this._q;\n};\n\nproto.q1 = function(get) {\n  return this.quartile(get)[0];\n};\n\nproto.q2 = function(get) {\n  return this.quartile(get)[1];\n};\n\nproto.q3 = function(get) {\n  return this.quartile(get)[2];\n};\n\nmodule.exports = Collector;","var util = require('../util');\nvar Aggregator = require('./aggregator');\n\nmodule.exports = function() {\n  // flatten arguments into a single array\n  var args = [].reduce.call(arguments, function(a, x) {\n    return a.concat(util.array(x));\n  }, []);\n  // create and return an aggregator\n  return new Aggregator()\n    .groupby(args)\n    .summarize({'*':'values'});\n};\n","var util = require('../util');\n\nvar types = {\n  'values': measure({\n    name: 'values',\n    init: 'cell.collect = true;',\n    set:  'cell.data.values()', idx: -1\n  }),\n  'count': measure({\n    name: 'count',\n    set:  'cell.num'\n  }),\n  'missing': measure({\n    name: 'missing',\n    set:  'this.missing'\n  }),\n  'valid': measure({\n    name: 'valid',\n    set:  'this.valid'\n  }),\n  'sum': measure({\n    name: 'sum',\n    init: 'this.sum = 0;',\n    add:  'this.sum += v;',\n    rem:  'this.sum -= v;',\n    set:  'this.sum'\n  }),\n  'mean': measure({\n    name: 'mean',\n    init: 'this.mean = 0;',\n    add:  'var d = v - this.mean; this.mean += d / this.valid;',\n    rem:  'var d = v - this.mean; this.mean -= d / this.valid;',\n    set:  'this.mean'\n  }),\n  'average': measure({\n    name: 'average',\n    set:  'this.mean',\n    req:  ['mean'], idx: 1\n  }),\n  'variance': measure({\n    name: 'variance',\n    init: 'this.dev = 0;',\n    add:  'this.dev += d * (v - this.mean);',\n    rem:  'this.dev -= d * (v - this.mean);',\n    set:  'this.dev / (this.valid-1)',\n    req:  ['mean'], idx: 1\n  }),\n  'variancep': measure({\n    name: 'variancep',\n    set:  'this.dev / this.valid',\n    req:  ['variance'], idx: 2\n  }),\n  'stdev': measure({\n    name: 'stdev',\n    set:  'Math.sqrt(this.dev / (this.valid-1))',\n    req:  ['variance'], idx: 2\n  }),\n  'stdevp': measure({\n    name: 'stdevp',\n    set:  'Math.sqrt(this.dev / this.valid)',\n    req:  ['variance'], idx: 2\n  }),\n  'median': measure({\n    name: 'median',\n    set:  'cell.data.q2(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q1': measure({\n    name: 'q1',\n    set:  'cell.data.q1(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'q3': measure({\n    name: 'q3',\n    set:  'cell.data.q3(this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'distinct': measure({\n    name: 'distinct',\n    set:  'this.distinct(cell.data.values(), this.get)',\n    req:  ['values'], idx: 3\n  }),\n  'argmin': measure({\n    name: 'argmin',\n    add:  'if (v < this.min) this.argmin = t;',\n    rem:  'if (v <= this.min) this.argmin = null;',\n    set:  'this.argmin = this.argmin || cell.data.argmin(this.get)',\n    req:  ['min'], str: ['values'], idx: 3\n  }),\n  'argmax': measure({\n    name: 'argmax',\n    add:  'if (v > this.max) this.argmax = t;',\n    rem:  'if (v >= this.max) this.argmax = null;',\n    set:  'this.argmax = this.argmax || cell.data.argmax(this.get)',\n    req:  ['max'], str: ['values'], idx: 3\n  }),\n  'min': measure({\n    name: 'min',\n    init: 'this.min = +Infinity;',\n    add:  'if (v < this.min) this.min = v;',\n    rem:  'if (v <= this.min) this.min = NaN;',\n    set:  'this.min = (isNaN(this.min) ? cell.data.min(this.get) : this.min)',\n    str:  ['values'], idx: 4\n  }),\n  'max': measure({\n    name: 'max',\n    init: 'this.max = -Infinity;',\n    add:  'if (v > this.max) this.max = v;',\n    rem:  'if (v >= this.max) this.max = NaN;',\n    set:  'this.max = (isNaN(this.max) ? cell.data.max(this.get) : this.max)',\n    str:  ['values'], idx: 4\n  }),\n  'modeskew': measure({\n    name: 'modeskew',\n    set:  'this.dev===0 ? 0 : (this.mean - cell.data.q2(this.get)) / Math.sqrt(this.dev/(this.valid-1))',\n    req:  ['mean', 'stdev', 'median'], idx: 5\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = util.extend({init:'', add:'', rem:'', idx:0}, base);\n    m.out = out || base.name;\n    return m;\n  };\n}\n\nfunction resolve(agg, stream) {\n  function collect(m, a) {\n    function helper(r) { if (!m[r]) collect(m, m[r] = types[r]()); }\n    if (a.req) a.req.forEach(helper);\n    if (stream && a.str) a.str.forEach(helper);\n    return m;\n  }\n  var map = agg.reduce(\n    collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {})\n  );\n  return util.vals(map).sort(function(a, b) { return a.idx - b.idx; });\n}\n\nfunction create(agg, stream, accessor, mutator) {\n  var all = resolve(agg, stream),\n      ctr = 'this.cell = cell; this.tuple = t; this.valid = 0; this.missing = 0;',\n      add = 'if (v==null) this.missing++; if (!this.isValid(v)) return; this.valid++;',\n      rem = 'if (v==null) this.missing--; if (!this.isValid(v)) return; this.valid--;',\n      set = 'var t = this.tuple; var cell = this.cell;';\n\n  all.forEach(function(a) {\n    if (a.idx < 0) {\n      ctr = a.init + ctr;\n      add = a.add + add;\n      rem = a.rem + rem;\n    } else {\n      ctr += a.init;\n      add += a.add;\n      rem += a.rem;\n    }\n  });\n  agg.slice()\n    .sort(function(a, b) { return a.idx - b.idx; })\n    .forEach(function(a) {\n      set += 'this.assign(t,\\''+a.out+'\\','+a.set+');';\n    });\n  set += 'return t;';\n\n  /* jshint evil: true */\n  ctr = Function('cell', 't', ctr);\n  ctr.prototype.assign = mutator;\n  ctr.prototype.add = Function('t', 'var v = this.get(t);' + add);\n  ctr.prototype.rem = Function('t', 'var v = this.get(t);' + rem);\n  ctr.prototype.set = Function(set);\n  ctr.prototype.get = accessor;\n  ctr.prototype.mod = mod;\n  ctr.prototype.distinct = require('../stats').count.distinct;\n  ctr.prototype.isValid = util.isValid;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n}\n\ntypes.create = create;\nmodule.exports = types;","var util = require('../util');\nvar units = require('../time-units');\nvar EPSILON = 1e-15;\n\nfunction bins(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n","var stats = require('../stats');\nvar type = require('../import/type');\nvar util = require('../util');\nvar gen = require('../generate');\nvar bins = require('./bins');\n\nvar qtype = {\n  'integer': 1,\n  'number': 1,\n  'date': 1\n};\n\nfunction $bin(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return !b ? (opt.accessor || util.identity) :\n    util.$func('bin', b.unit.unit ?\n      function(x) { return b.value(b.unit.unit(x)); } :\n      function(x) { return b.value(x); }\n    )(opt.accessor);\n}\n\nfunction histogram(values, f, opt) {\n  opt = options(values, f, opt);\n  var b = spec(opt);\n  return b ?\n    numerical(values, opt.accessor, b) :\n    categorical(values, opt.accessor, opt && opt.sort);\n}\n\nfunction spec(opt) {\n  var t = opt.type, b = null;\n  if (t == null || qtype[t]) {\n    if (t === 'integer' && opt.minstep == null) opt.minstep = 1;\n    b = (t === 'date') ? bins.date(opt) : bins(opt);\n  }\n  return b;\n}\n\nfunction options() {\n  var a = arguments,\n      i = 0,\n      values = util.isArray(a[i]) ? a[i++] : null,\n      f = util.isFunction(a[i]) || util.isString(a[i]) ? util.$(a[i++]) : null,\n      opt = util.extend({}, a[i]);\n  \n  if (values) {\n    opt.type = opt.type || type(values, f);\n    if (qtype[opt.type]) {\n      var ext = stats.extent(values, f);\n      opt = util.extend({min: ext[0], max: ext[1]}, opt);\n    }\n  }\n  if (f) { opt.accessor = f; }\n  return opt;\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var u = stats.unique(values, f),\n      c = stats.count.map(values, f);\n  return u.map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? '-count' : '+value'));\n}\n\nmodule.exports = {\n  $bin: $bin,\n  histogram: histogram\n};","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) { return gen.zeros(n).map(f); };\n  return f;\n};","var util = require('../../util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nfunction dsv(data, format) {\n  if (data) {\n    var h = format.header;\n    data = (h ? h.join(format.delimiter) + '\\n' : '') + data;\n  }\n  return d3.dsv(format.delimiter).parse(data);\n}\n\ndsv.delimiter = function(delim) {\n  var fmt = {delimiter: delim};\n  return function(data, format) {\n    return dsv(data, format ? util.extend(format, fmt) : fmt);\n  };\n};\n\nmodule.exports = dsv;","var dsv = require('./dsv');\n\nmodule.exports = {\n  json: require('./json'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson'),\n  dsv: dsv,\n  csv: dsv.delimiter(','),\n  tsv: dsv.delimiter('\\t')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data) ?\n    data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error('TopoJSON library not loaded.'); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if ((obj = t.objects[format.feature])) {\n      return topojson.feature(t, obj).features;\n    } else {\n      throw Error('Invalid TopoJSON object: '+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if ((obj = t.objects[format.mesh])) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error('Invalid TopoJSON object: ' + format.mesh);\n    }\n  } else {\n    throw Error('Missing TopoJSON feature or mesh parameter.');\n  }\n\n  return [];\n};\n","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || 'children';\n  var table = [];\n  \n  function visit(node) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host === '') {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function(d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; }, url;\n\n  try {\n    url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else if (url.indexOf('://') < 0) { // TODO better protocol check?\n    // if node.js, if no protocol assume file\n    return file(url, callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== 'text' ?\n    request.response : // null on error\n    request.responseText; // '' on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest();\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest &&\n      !('withCredentials' in request) &&\n      /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest();\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    if ('onload' in request) {\n      request.onload = request.onerror = respond;\n    } else {\n      request.onreadystatechange = function() {\n        if (request.readyState > 3) respond();\n      };\n    }\n  }\n  \n  request.open('GET', url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(filename, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(filename, 'utf8');\n  }\n  require('fs').readFile(filename, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar type = require('./type');\nvar formats = require('./formats');\n\nfunction read(data, format) {\n  var type = (format && format.type) || 'json';\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? type.inferAll(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return type.parsers[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  type.annotation(data, types);\n}\n\nread.formats = formats;\nmodule.exports = read;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) { opt = {url: opt}; }\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x==='' ? null : x; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction type(values, f) {\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, f), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer(data, f);\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;","var util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  type:      require('./import/type'),\n  bins:      require('./bins/bins'),\n  $bin:      require('./bins/histogram').$bin,\n  groupby:   require('./aggregate/groupby'),\n  histogram: require('./bins/histogram').histogram,\n  print:     require('./print'),\n  template:  require('./template'),\n  timeunits: require('./time-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/readers'));\n\nmodule.exports = dl;","var util = require('./util');\nvar type = require('./import/type');\nvar stats = require('./stats');\nvar template = require('./template');\n\nvar FMT = {\n  'date':    '|time:\"%m/%d/%Y %H:%M:%S\"',\n  'number':  '|number:\".4f\"',\n  'integer': '|number:\"d\"'\n};\n\nvar POS = {\n  'number':  'left',\n  'integer': 'left'\n};\n\nmodule.exports.table = function(data, opt) {\n  opt = util.extend({separator:' ', minwidth: 8, maxwidth: 15}, opt);\n  var fields = opt.fields || util.keys(data[0]),\n      types = type.all(data);\n\n  if (opt.start || opt.limit) {\n    var a = opt.start || 0,\n        b = opt.limit ? a + opt.limit : data.length;\n    data = data.slice(a, b);\n  }\n\n  // determine char width of fields\n  var lens = fields.map(function(name) {\n    var format = FMT[types[name]] || '',\n        t = template('{{' + name + format + '}}'),\n        l = stats.max(data, function(x) { return t(x).length; });\n    l = Math.max(Math.min(name.length, opt.minwidth), l);\n    return opt.maxwidth > 0 ? Math.min(l, opt.maxwidth) : l;\n  });\n\n  // print header row\n  var head = fields.map(function(name, i) {\n    return util.truncate(util.pad(name, lens[i], 'center'), lens[i]);\n  }).join(opt.separator);\n\n  // build template function for each row\n  var tmpl = template(fields.map(function(name, i) {\n    return '{{' +\n      name +\n      (FMT[types[name]] || '') +\n      ('|pad:' + lens[i] + ',' + POS[types[name]] || 'right') +\n      ('|truncate:' + lens[i]) +\n    '}}';\n  }).join(opt.separator));\n\n  // print table\n  return head + \"\\n\" + data.map(tmpl).join('\\n');\n};\n\nmodule.exports.summary = function(s) {\n  s = s ? s.__summary__ ? s : stats.summary(s) : this;\n  var str = [], i, n;\n  for (i=0, n=s.length; i<n; ++i) {\n    str.push('-- ' + s[i].field + ' --');\n    if (s[i].type === 'string' || s[i].distinct < 10) {\n      str.push(printCategoricalProfile(s[i]));\n    } else {\n      str.push(printQuantitativeProfile(s[i]));\n    }\n    str.push('');\n  }\n  return str.join('\\n');\n};\n\nfunction printQuantitativeProfile(p) {\n  return [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'min:      ' + p.min,\n    'max:      ' + p.max,\n    'median:   ' + p.median,\n    'mean:     ' + p.mean,\n    'stdev:    ' + p.stdev,\n    'modeskew: ' + p.modeskew\n  ].join('\\n');\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    'valid:    ' + p.valid,\n    'missing:  ' + p.missing,\n    'distinct: ' + p.distinct,\n    'top values: '\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return ' \\'' + v + '\\' (' + u[v] + ')'; });\n  return list.concat(top).join('\\n');\n}","var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!Number.isNaN(v)) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!Number.isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, util.$(a)) : stats.rank(values),\n      rb = b ? stats.rank(values, util.$(b)) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance] \n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate,\n  pad:        util.pad\n};\n\nfunction template(text) {\n  var src = source(text, 'd');\n  src = 'var __t; return ' + src + ';';\n\n  try {\n    /* jshint evil: true */\n    return (new Function('d', src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\ntemplate.source = source;\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || 'obj';\n  var index = 0;\n  var src = '\\'';\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += '\\'\\n+((__t=(' +\n        template_var(interpolate, variable) +\n        '))==null?\\'\\':__t)+\\n\\'';\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + '\\'';\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || '';\n    if (stringCast) {\n      stringCast = false;\n      src = 'String(' + src + ')' + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  function date() {\n    return '(typeof ' + src + '===\"number\"?new Date('+src+'):'+src+')';\n  }\n  \n  var src = util.field(prop).map(util.str).join('][');\n  src = variable + '[' + src + ']';\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a +\n          (args.length > 1 ? ',' + util.number(args[1]) : '') +\n          ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'pad':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!=='left' && b!=='middle' && b!=='center') ? 'right' : b;\n        src = 'this.pad(' + strcall() + ',' + a + ',\\'' + b + '\\')';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+date()+')';\n        break;\n      default:\n        throw Error('Unrecognized template filter: ' + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  '\\'':     '\\'',\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === '\\'' && pattern[pattern.length-1] === '\\'') ||\n      (pattern[0] === '\"'  && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error('Format pattern must be quoted: ' + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n","var STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction isNumber(d) { return typeof d === 'number'; }\n\nvar entries = [\n  {\n    type: 'second',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M:%S.%L',\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: 'minute',\n    minstep: 1,\n    format: '%Y %b %-d %H:%M',\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: 'hour',\n    minstep: 1,\n    format: '%Y %b %-d %H:00',\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: 'day',\n    minstep: 1,\n    step: [1, 7],\n    format: '%Y %b %-d',\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: 'month',\n    minstep: 1,\n    step: [1, 3, 6],\n    format: '%b %Y',\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: 'year',\n    minstep: 1,\n    format: '%Y',\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: 'minuteOfHour',\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: '%M',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: 'hourOfDay',\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: '%H',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: 'dayOfWeek',\n  min: 0,\n  max: 6,\n  step: [1],\n  format: '%a',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: 'dayOfMonth',\n  min: 1,\n  max: 31,\n  step: [1],\n  format: '%-d',\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: 'monthOfYear',\n  min: 0,\n  max: 11,\n  step: [1],\n  format: '%b',\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  'second':       entries[0],\n  'minute':       entries[1],\n  'hour':         entries[2],\n  'day':          entries[3],\n  'month':        entries[4],\n  'year':         entries[5],\n  'minuteOfHour': minuteOfHour,\n  'hourOfDay':    hourOfDay,\n  'dayOfWeek':    dayOfWeek,\n  'dayOfMonth':   dayOfMonth,\n  'monthOfYear':  monthOfYear,\n  'timesteps':    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var Buffer = require('buffer').Buffer;\nvar units = require('./time-units');\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined' &&\n           typeof process.stderr !== 'undefined';\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && !Number.isNaN(obj);\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\nu.date = function(s) {\n  return s == null || s === '' ? null : Date.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? ('\\''+util_escape_str(x)+'\\'') : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, '$1\\\\\\'');\n}\n\n// data access functions\n\nu.field = function(f) {\n  return String(f).split('\\\\.')\n    .map(function(d) { return d.split('.'); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += '.' + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, (s = u.field(f)).length > 1 ?\n      function(x) { return s.reduce(function(x,f) { return x[f]; }, x); } :\n      function(x) { return x[f]; }\n    );\n};\n\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\nu.$year   = u.$func('year', units.year.unit);\nu.$month  = u.$func('month', units.monthOfYear.unit);\nu.$date   = u.$func('date', units.dayOfMonth.unit);\nu.$day    = u.$func('day', units.dayOfWeek.unit);\nu.$hour   = u.$func('hour', units.hourOfDay.unit);\nu.$minute = u.$func('minute', units.minuteOfHour.unit);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith ?\n  function(string, searchString) {\n    return string.startsWith(searchString);\n  } :\n  function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","var bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;","var dl = require('datalib'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg-headless/index'),\n    View = require('./View'),\n    debug = require('../util/debug');\n\nvar HeadlessView = function(width, height, model) {\n  View.call(null, width, height, model);\n  this._el = \"body\";\n  this._type = \"canvas\";\n  this._renderers = {canvas: canvas, svg: svg};\n  this._canvas = null;\n}\n\nvar prototype = (HeadlessView.prototype = new View());\n\nprototype.renderer = function(type) {\n  if(type) this._type = type;\n  return View.prototype.renderer.apply(this, arguments);\n};\n\nprototype.canvas = function() {\n  return this._canvas;\n};\n\nprototype.canvasAsync = function(callback) {\n  var r = this._renderer, view = this;\n  \n  function wait() {\n    if (r.pendingImages() === 0) {\n      view.render(); // re-render with all images\n      callback(view._canvas);\n    } else {\n      setTimeout(wait, 10);\n    }\n  }\n\n  // if images loading, poll until ready\n  (r.pendingImages() > 0) ? wait() : callback(this._canvas);\n};\n\nprototype.svg = function() {\n  return (this._type === \"svg\")\n    ? this._renderer.svg()\n    : null;\n};\n\nprototype.initialize = function() {    \n  var w = this._width,\n      h = this._height,\n      pad = this._padding;\n\n  if (this._viewport) {\n    w = this._viewport[0] - (pad ? pad.left + pad.right : 0);\n    h = this._viewport[1] - (pad ? pad.top + pad.bottom : 0);\n  }\n\n  this._renderer = this._renderer || new this._io.Renderer();\n  \n  if (this._type === \"svg\") {\n    this.initSVG(w, h, pad);\n  } else {\n    this.initCanvas(w, h, pad);\n  }\n  \n  return this;\n};\n\nprototype.initCanvas = function(w, h, pad) {\n  var Canvas = (typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null),\n      tw = w + pad.left + pad.right,\n      th = h + pad.top + pad.bottom,\n      canvas = this._canvas = dl.isNode ? new Canvas(tw, th) : document.createElement('canvas'),\n      ctx = canvas.getContext(\"2d\");\n\n  if(!dl.isNode) {  // Manually set width/height on DOM elements\n    canvas.setAttribute(\"width\", tw);\n    canvas.setAttribute(\"height\", th);\n  }\n  \n  // setup canvas context\n  ctx.setTransform(1, 0, 0, 1, pad.left, pad.top);\n\n  // configure renderer\n  this._renderer.context(ctx);\n  this._renderer.resize(w, h, pad);\n};\n\nprototype.initSVG = function(w, h, pad) {\n  // configure renderer\n  this._renderer.initialize(this._el, w, h, pad);\n};\n\nmodule.exports = HeadlessView;\n","var Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this._node = null;\n  this._builder = null; // Top-level scenegraph builder\n\n  Graph.prototype.init.call(this);\n};\n\nvar proto = (Model.prototype = new Graph());\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.node = function() {\n  return this._node || (this._node = new Node(this));\n};\n\nproto.data = function() {\n  var data = Graph.prototype.data.apply(this, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this.node().addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this.node().removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this.node().addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this.node().addListener(l); };\nproto.removeListener = function(l) { this.node().removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.propagate(cs, this.node());\n};\n\nmodule.exports = Model;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    Encoder = require('../scene/Encoder'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height  = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler  = null;\n  this._streamer = null; // Targeted update for streaming changes\n  this._changeset = null;\n  this._renderers = {canvas: canvas, svg: svg};\n  this._io  = canvas;\n  this._api = {}; // Stash streaming data API sandboxes.\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    this._streamer = new Node(model);\n    this._changeset = changeset.create();\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\n// Sandboxed streaming data API\nfunction streaming(src) {\n  var view = this,\n      ds = this._model.data(src),\n      listener = ds.pipeline()[0],\n      streamer = this._streamer,\n      cs  = this._changeset,\n      api = {};\n\n  if(dl.keys(cs.signals).length > 0) {\n    throw \"New signal values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating data values.\"\n  }\n\n  // If we have it stashed, don't create a new closure. \n  if(this._api[src]) return this._api[src];\n\n  api.insert = function(vals) {\n    ds.insert(dl.duplicate(vals));  // Don't pollute the environment\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return api;\n  };\n\n  api.update = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.update.apply(ds, arguments), api);\n  };\n\n  api.remove = function() {\n    streamer.addListener(listener);\n    cs.data[ds.name()] = 1;\n    return (ds.remove.apply(ds, arguments), api);\n  };\n\n  api.values = function() { return ds.values() };    \n\n  return (this._api[src] = api);\n};\n\nprototype.data = function(data) {\n  var v = this;\n  if(!arguments.length) return v._model.dataValues();\n  else if(dl.isString(data)) return streaming.call(v, data);\n  else if(dl.isObject(data)) {\n    dl.keys(data).forEach(function(k) {\n      var api = streaming.call(v, k);\n      data[k](api);\n    });\n  }\n  return this;\n};\n\nprototype.signal = function(name, value) {\n  var m  = this._model,\n      cs = this._changeset,\n      streamer = this._streamer,\n      setter = name; \n\n  if(!arguments.length) return m.signalValues();\n  else if(arguments.length == 1 && dl.isString(name)) return m.signalValues(name);\n\n  if(dl.keys(cs.data).length > 0) {\n    throw \"New data values are not reflected in the visualization.\" +\n      \" Please call view.update() before updating signal values.\"\n  }\n\n  if(arguments.length == 2) {\n    setter = {};\n    setter[name] = value;\n  }\n\n  dl.keys(setter).forEach(function(k) {\n    streamer.addListener(m.signal(k).value(setter[k]));\n    cs.signals[k] = 1;\n    cs.reflow = true;\n  });\n\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    this.initialize();\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      if(this._handler) this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    this.initialize();\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    this.initialize();\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (this._renderers[type]) type = this._renderers[type];\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    this.initialize();\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n\n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n    if(!el) return this;  // This View cannot init w/o an\n  }\n  \n  // clear pre-existing container\n  d3.select(el).select(\"div.vega\").remove();\n  \n  // add div container\n  this._el = el = d3.select(el)\n    .append(\"div\")\n    .attr(\"class\", \"vega\")\n    .style(\"position\", \"relative\")\n    .node();\n  if (v._viewport) {\n    d3.select(el)\n      .style(\"width\",  (v._viewport[0] || w)+\"px\")\n      .style(\"height\", (v._viewport[1] || h)+\"px\")\n      .style(\"overflow\", \"auto\");\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  // input handler\n  prevHandler = v._handler;\n  v._handler = new this._io.Handler()\n    .initialize(el, pad, v)\n    .model(v._model);\n\n  if (prevHandler) {\n    prevHandler.handlers().forEach(function(h) {\n      v._handler.on(h.type, h.handler);\n    });\n  } else {\n    // Register event listeners for signal stream definitions.\n    parseStreams(this);\n  }\n  \n  return this;\n};\n\nfunction build() {\n  var v = this;\n  v._renderNode = new Node(v._model)\n    .router(true);\n\n  v._renderNode.evaluate = function(input) {\n    debug(input, [\"rendering\"]);\n\n    var s = v._model.scene();\n    if(input.trans) {\n      input.trans.start(function(items) { v._renderer.render(s, items); });\n    } else {\n      v._renderer.render(s);\n    }\n\n    // For all updated datasources, finalize their changesets.\n    var d, ds;\n    for(d in input.data) {\n      ds = v._model.data(d);\n      if(!ds.revises()) continue;\n      changeset.finalize(ds.last());\n    }\n\n    return input;\n  };\n\n  return (v._model.scene(v._renderNode), true);  \n}\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  var cs = v._changeset;\n  if(trans) cs.trans = trans;\n  if(opt.props !== undefined) {\n    if(dl.keys(cs.data).length > 0) {\n      throw \"New data values are not reflected in the visualization.\" +\n        \" Please call view.update() before updating a specified property set.\"\n    }\n\n    cs.reflow  = true;\n    cs.request = opt.props;\n  }\n\n  v._build = v._build || build.call(this);\n\n  // If specific items are specified, short-circuit dataflow graph.\n  // Else-If there are streaming updates, perform a targeted propagation.\n  // Otherwise, reevaluate the entire model (datasources + scene).\n  if(opt.items) { \n    Encoder.update(this._model, opt.trans, opt.props, opt.items);\n    v._renderNode.evaluate(cs);\n  } else if(v._streamer.listeners().length) {\n    v._model.propagate(cs, v._streamer);\n    v._streamer.disconnect();\n  } else {\n    v._model.fire(cs);\n  }\n\n  v._changeset = changeset.create();\n\n  return v.autopad(opt);\n};\n\nprototype.render = function(items) {\n  this._renderer.render(this._model.scene(), items);\n  return this;\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.onSignal = function(name, handler) {\n  this._model.signal(name).on(handler);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.offSignal = function(name, handler) {\n  this._model.signal(name).off(handler);\n  return this;\n};\n\nView.factory = function(model) {\n  var HeadlessView = require('./HeadlessView');\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = (opt.el ? new View() : new HeadlessView())\n      .model(model)\n      .renderer(opt.renderer || \"canvas\")\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding);\n\n    if(opt.el || (!opt.el && v instanceof HeadlessView)) v.initialize(opt.el);\n    if(opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n","var Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.insert = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.insert(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]);\n  return this;\n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;","var dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n}\n\nvar proto = Graph.prototype;\n\nproto.init = function() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n};\n\nproto.data = function(name, pipeline, facet) {\n  var db = this._data;\n  if(!arguments.length) return dl.keys(db).map(function(d) { return db[d]; });\n  if(arguments.length === 1) return db[name];\n  return (db[name] = new Datasource(this, name, facet).pipeline(pipeline));\n};\n\nproto.dataValues = function(names) {\n  var graph = this;\n  if (!arguments.length) names = dl.keys(this._data);\n  if (!dl.isArray(names)) return this._data[names].values();\n  return names.reduce(function(db, n) {\n    return (db[n] = graph._data[n].values(), db);\n  }, {});\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(names) {\n  var graph = this;\n  if(!arguments.length) names = dl.keys(this._signals);\n  if(!dl.isArray(names)) return this._signals[names].value();\n  return names.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;","var dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;","var Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  this._handlers = [];\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nproto.on = function(handler) {\n  var sg = this,\n      node = new Node(this._graph);\n\n  node.evaluate = function(input) {\n    return (handler(sg.name(), sg.value()), input);\n  };\n\n  this._handlers.push({ handler: handler, node: node });\n  return this.addListener(node);\n};\n\nproto.off = function(handler) {\n  var sg = this, h = this._handlers;\n  for(var i=h.length; --i>=0;) {\n    if(!handler || h[i].handler === handler) {\n      sg.removeListener(h.splice(i, 1)[0].node);\n    }\n  }\n  return this;\n};\n\nmodule.exports = Signal;","var C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  b.request = a ? a.request : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};","var dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction has_prev(t) {\n  return t._prev && t._prev !== C.SENTINEL;\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  set_prev: set_prev,\n  has_prev: has_prev,\n  reset:  reset,\n  idMap:  idMap\n};","var dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};","module.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};","var datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;","var dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n","/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};","var dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;","var dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};","var parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(model);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate.call(predicate, {}, db, model.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? model.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}","var dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}","var dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate),\n            p = \"predicates[\"+dl.str(o.predicate)+\"]\";\n\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= p+\".call(\"+p+\", args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item], code = \"\";\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) {\n      code = parseScale(spec.scale, o);\n    }\n\n    var ops = parseOperands(o);\n    code = ops.code + code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = scale(o1);\\no2 = scale(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  // Populate ops such that ultimate scale/inversion function will be in `scale` var. \n  function parseScale(spec, ops) {\n    var code = \"var scale = \", \n        idx  = ops.length;\n\n    if(dl.isString(spec)) {\n      ops.push({ value: spec });\n      code += \"this.root().scale(o\"+idx+\")\";\n    } else if(spec.arg) {  // Scale function is being passed as an arg\n      ops.push(spec);\n      code += \"o\"+idx;\n    } else if(spec.name) { // Full scale parameter {name: ..}\n      ops.push(dl.isString(spec.name) ? {value: spec.name} : spec.name);\n      code += \"(this.isFunction(o\"+idx+\") ? o\"+idx+\" : \";\n      if(spec.scope) {\n        ops.push(spec.scope);\n        code += \"(o\"+(idx+1)+\".scale || this.root().scale)(o\"+idx+\")\";\n      } else {\n        code += \"this.root().scale(o\"+idx+\")\";\n      }\n      code += \")\"\n    }\n\n    if(spec.invert === true) {  // Allow spec.invert.arg?\n      code += \".invert\"\n    }\n\n    return code+\";\\n\";\n  }\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s),\n        pred  = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.root = function() { return model.scene().items[0] }; // For global scales\n    pred.isFunction = dl.isFunction;\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nvar DEPS = [\"signals\", \"scales\", \"data\", \"fields\"];\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales:  {},\n        data:    {},\n        fields:  {},\n        reflow:  false\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    DEPS.forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n    deps.reflow = deps.reflow || ref.reflow;\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode:  encoder,\n      signals: dl.keys(deps.signals),\n      scales:  dl.keys(deps.scales),\n      data:    dl.keys(deps.data),\n      fields:  dl.keys(deps.fields),\n      reflow:  deps.reflow\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        p = \"predicates[\"+dl.str(predName)+\"]\",\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(\"+p+\".call(\"+p+\",\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n\n  if (name===\"fill\" || name===\"stroke\") {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, scale = null, \n      sgRef = {}, fRef = {}, sRef = {},\n      signals = [], fields = [], reflow = false;\n\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    sgRef = dl.field(ref.signal);\n    val = \"signals[\"+sgRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(sgRef.shift());\n  }\n\n  if(ref.field !== undefined) {\n    ref.field = dl.isString(ref.field) ? {datum: ref.field} : ref.field;\n    fRef  = fieldRef(ref.field);\n    val = fRef.val;\n  }\n\n  if (ref.scale !== undefined) {\n    sRef = scaleRef(ref.scale);\n    scale = sRef.val;\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n\n  // Collate dependencies\n  return {\n    val: val,\n    signals: signals.concat(dl.array(fRef.signals)).concat(dl.array(sRef.signals)),\n    fields:  fields.concat(dl.array(fRef.fields)).concat(dl.array(sRef.fields)),\n    scales:  ref.scale ? (ref.scale.name || ref.scale) : null, // TODO: connect sRef'd scale?\n    reflow:  reflow || fRef.reflow || sRef.reflow\n  };\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\n// {field: {datum: \"foo\"} }  -> item.datum.foo\n// {field: {group: \"foo\"} }  -> group.foo\n// {field: {parent: \"foo\"} } -> group.datum.foo\nfunction fieldRef(ref) {\n  if(dl.isString(ref)) {\n    return {val: dl.field(ref).map(dl.str).join(\"][\")};\n  } \n\n  // Resolve nesting/parent lookups\n  var l = ref.level,\n      nested = (ref.group || ref.parent) && l,\n      scope = nested ? Array(l).join(\"group.mark.\") : \"\",\n      r = fieldRef(ref.datum || ref.group || ref.parent || ref.signal),\n      val = r.val,\n      fields  = r.fields  || [],\n      signals = r.signals || [],\n      reflow  = r.reflow  || false; // Nested fieldrefs trigger full reeval of Encoder.\n\n  if(ref.datum) {\n    val = \"item.datum[\"+val+\"]\";\n    fields.push(ref.datum);\n  } else if(ref.group) {\n    val = scope+\"group[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.parent) {\n    val = scope+\"group.datum[\"+val+\"]\";\n    reflow = true;\n  } else if(ref.signal) {\n    val = \"signals[\"+val+\"]\";\n    signals.push(dl.field(ref.signal)[0]);\n    reflow = true;\n  }\n\n  return {val: val, fields: fields, signals: signals, reflow: reflow};\n}\n\n// {scale: \"x\"}\n// {scale: {name: \"x\"}},\n// {scale: fieldRef}\nfunction scaleRef(ref) {\n  var scale = null,\n      fr = null;\n\n  if(dl.isString(ref)) {\n    scale = dl.str(ref);\n  } else if(ref.name) {\n    scale = dl.isString(ref.name) ? dl.str(ref.name) : (fr = fieldRef(ref.name)).val;\n  } else {\n    scale = (fr = fieldRef(ref)).val;\n  }\n\n  scale = \"group.scale(\"+scale+\")\";\n  if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n  return fr ? (fr.val = scale, fr) : {val: scale};\n}\n\nmodule.exports = compile;","var expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = model.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { model.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};","var dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(spec, value) {\n    var def = spec.scale,\n        name  = def.name || def.signal || def,\n        scope = def.scope ? model.signalRef(def.scope.signal) : null;\n\n    if(!scope || !scope.scale) {\n      scope = (scope && scope.mark) ? scope.mark.group : model.scene().items[0];\n    }\n\n    var scale = scope.scale(name);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(model);\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return model.doNotPropagate;\n      var val = expr.eval(model, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    model.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(model);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = model.signal(name + START,  false);\n    s[MIDDLE] = model.signal(name + MIDDLE, false);\n    s[END]    = model.signal(name + END,    false);\n\n    var router = new Node(model);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return model.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return model.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = model.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(model, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(model, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      model.propagate(cs, node);\n    });\n  })\n};","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model);\n  \n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;","module.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};","var Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n","module.exports = {\n  Renderer: require('./Renderer')\n};\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n","var dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};","var Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(graph, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, graph)\n    .router(true)\n    .collector(true);\n\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? graph.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._graph, this._mark);\n  this._bounder = new Bounder(this._graph, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._graph.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._graph, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(graph, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, graph)\n\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n    this.dependency(C.FIELDS, update.fields);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var graph = this._graph,\n      items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      preds  = this._graph.predicates(),\n      sg = graph.signalValues(),  // For expediency, get all signal values\n      db = graph.dataValues(), \n      req = input.request,\n      i, len, item, prop;\n\n  if(req) {\n    if(prop = props[req]) {\n      for(i=0, len=input.mod.length; i<len; ++i) {\n        item = input.mod[i];\n        encode.call(this, prop, item, input.trans, db, sg, preds);\n      }\n    }\n\n    return input; // exit early if given request\n  }\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    if(exit)   encode.call(this, exit,   item, input.trans, db, sg, preds); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans, db, sg, preds);\n    if(update) encode.call(this, update, item, input.trans, db, sg, preds);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans, db, sg, preds);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, db, sg, preds) {\n  var enc = prop.encode;\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, preds);\n}\n\n// If a specified property set called, or update property set \n// uses nested fieldrefs, reevaluate all items.\nproto.reevaluate = function(pulse) {\n  var props = this._mark.def.properties || {},\n      update = props.update;\n\n  return pulse.request || \n    Node.prototype.reevaluate.call(this, pulse) || \n    (update ? update.reflow : false);\n};\n\n// Short-circuit encoder if user specifies items\nEncoder.update = function(graph, trans, request, items) {\n  items = dl.array(items);\n  var preds = graph.predicates(), \n      db = graph.dataValues(),\n      sg = graph.signalValues(),\n      i, len, item, props, prop;\n\n  for (i=0, len=items.length; i<len; ++i) {\n    item = items[i];\n    props = item.mark.def.properties;\n    prop = props && props[request];\n    if (prop) {\n      encode.call(null, prop, item, trans, db, sg, preds);\n      bounds.item(item);\n    }\n  }\n\n};\n\nmodule.exports = Encoder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(graph, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(graph, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._graph.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._graph.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._graph, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._graph, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._graph, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._graph, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(graph, def, parent) {\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction isUniques(scale) { \n  return scale.type === C.ORDINAL || scale.type === C.QUANTILE; \n}\n\nfunction getRefs(def) { \n  return def.fields || dl.array(def);\n}\n\nfunction getFields(ref, group) {\n  return dl.array(ref.field).map(function(f) {\n    if (f.parent) return dl.accessor(f.parent)(group.datum)\n    return f; // String or {\"signal\"}\n  });\n}\n\n// Scale datarefs can be computed over multiple schema types. \n// This function determines the type of aggregator created, and\n// what data is sent to it: values, tuples, or multi-tuples that must\n// be standardized into a consistent schema. \nfunction aggrType(def, scale) {\n  var refs = getRefs(def);\n\n  // If we're operating over only a single domain, send full tuples\n  // through for efficiency (fewer accessor creations/calls)\n  if(refs.length == 1 && dl.array(refs[0].field).length == 1) {\n    return Aggregate.TYPES.TUPLE;\n  }\n\n  // With quantitative scales, we only care about min/max.\n  if(!isUniques(scale)) return Aggregate.TYPES.VALUE;\n\n  // If we don't sort, then we can send values directly to aggrs as well\n  if(!def.sort) return Aggregate.TYPES.VALUE;\n\n  return Aggregate.TYPES.MULTI;\n}\n\nfunction getCache(which, def, scale, group) {\n  var refs = getRefs(def),\n      atype = aggrType(def, scale),\n      uniques = isUniques(scale),\n      sort = def.sort,\n      ck = \"_\"+which,\n      fields = getFields(refs[0], group),\n      i, rlen, j, flen, ref, field;\n\n  if(scale[ck]) return scale[ck];\n\n  var cache = scale[ck] = new Aggregate(this._graph).type(atype),\n      groupby, summarize;\n\n  if(uniques) {\n    if(atype === Aggregate.TYPES.VALUE) {\n      groupby = [{ name: C.GROUPBY, get: dl.identity }];\n      summarize = {\"*\": C.COUNT};\n    } else if(atype === Aggregate.TYPES.TUPLE) {\n      groupby = [{ name: C.GROUPBY, get: dl.$(fields[0]) }];\n      summarize = sort ? [{\n        name: C.VALUE,\n        get:  dl.$(ref.sort || sort.field),\n        ops: [sort.stat]\n      }] : {\"*\": C.COUNT};\n    } else {  // atype === Aggregate.TYPES.MULTI\n      groupby   = C.GROUPBY;\n      summarize = [{ name: C.VALUE, ops: [sort.stat] }]; \n    }\n  } else {\n    groupby = [];\n    summarize = [{\n      name: C.VALUE,\n      get: (atype == Aggregate.TYPES.TUPLE) ? dl.$(fields[0]) : dl.identity,\n      ops: [C.MIN, C.MAX],\n      as:  [C.MIN, C.MAX]\n    }];\n  }\n\n  cache.groupby.set(cache, groupby)\n    .summarize.set(cache, summarize);\n\n  return cache;\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = getRefs(def),\n      atype = aggrType(def, scale),\n      cache = getCache.apply(this, arguments),\n      sort  = def.sort,\n      uniques = isUniques(scale),\n      i, rlen, j, flen, ref, fields, field;\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    ref = refs[i];\n    from = ref.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = getFields(ref, group);\n    for(j=0, flen=fields.length; j<flen; ++j) {\n      field = fields[j];\n\n      if(atype === Aggregate.TYPES.VALUE) {\n        cache.accessors(null, field);\n      } else if(atype === Aggregate.TYPES.MULTI) {\n        cache.accessors(field, ref.sort || sort.field);\n      } // Else (Tuple-case) is handled by the aggregator accessors by default\n\n      cache.evaluate(data);\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.aggr().result();\n  if (uniques) {\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + C.VALUE;\n      sort = dl.comparator(sort);\n      data = data.sort(sort);\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return data.map(function(d) { return d[C.GROUPBY]; });\n  } else {\n    data = data[0];\n    return !dl.isValid(data) ? [] : [data[C.MIN], data[C.MAX]];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;","var tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {field: {group: \"height\", level: 2}, mult: -sign}\n      : {field: {group: \"width\",  level: 2}, mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Facetor = require('./Facetor'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"}\n  });\n\n  this._fieldsDef = [];\n  this._aggr = null;  // dl.Aggregator\n\n  this._type = TYPES.TUPLE; \n  this._acc = {groupby: dl.true, value: dl.true}\n  this._cache = {};     // And cache them as aggregators expect original tuples.\n\n  // Aggregator needs a full instantiation of the previous tuple. \n  // Cache them to reduce creation costs\n  this._prev = {}; \n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new Transform());\n\nvar TYPES = Aggregate.TYPES = {\n  VALUE: 1, \n  TUPLE: 2, \n  MULTI: 3\n};\n\nproto.summarize = {\n  set: function(transform, summarize) {\n    var i, len, f, fields, name, ops, signals = {};\n    if(!dl.isArray(fields = summarize)) { // Object syntax from dl\n      fields = [];\n      for (name in summarize) {\n        ops = dl.array(summarize[name]);\n        fields.push({name: name, ops: ops});\n      }\n    }\n\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._aggr = null;\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.type = function(type) { \n  return (this._type = type, this); \n};\n\nproto.accessors = function(groupby, value) {\n  var acc = this._acc;\n  acc.groupby = dl.$(groupby) || dl.true;\n  acc.value = dl.$(value) || dl.true;\n};\n\nfunction standardize(x) {\n  var acc = this._acc;\n  if(this._type === TYPES.TUPLE) {\n    return x;\n  } else if(this._type === TYPES.VALUE) {\n    return acc.value(x);\n  } else {\n    return this._cache[x._id] || (this._cache[x._id] = {\n      _id: x._id,\n      groupby: acc.groupby(x),\n      value: acc.value(x)\n    });\n  }\n}\n\nproto.aggr = function() {\n  if(this._aggr) return this._aggr;\n\n  var graph = this._graph,\n      groupby = this.groupby.get(graph).fields;\n\n  var fields = this._fieldsDef.map(function(field) {\n    var f  = dl.duplicate(field);\n    if(field.get) f.get = field.get;\n\n    f.name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    f.ops  = f.ops.signal ? graph.signalRef(f.ops.signal) : dl.array(f.ops).map(function(o) {\n      return o.signal ? graph.signalRef(o.signal) : o;\n    });\n\n    return f;\n  });\n\n  var aggr = this._aggr = new Facetor()\n    .groupby(groupby)\n    .stream(true)\n    .summarize(fields);\n\n  if(this._type !== TYPES.VALUE) aggr.key(\"_id\");\n  return aggr;\n};\n\nproto._reset = function(input, output) {\n  output.rem.push.apply(output.rem, this.aggr().result());\n  this.aggr().clear();\n  this._aggr = null;\n};\n\nfunction spoof_prev(x) {\n  var prev = this._prev[x._id] || (this._prev[x._id] = Object.create(x));\n  return dl.extend(prev, x._prev);\n}\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  var output = changeset.create(input);\n  if(reset) this._reset(input, output);\n\n  var t = this,\n      tpl  = this._type === TYPES.TUPLE, // reduce calls to standardize\n      aggr = this.aggr();\n\n  input.add.forEach(function(x) {\n    aggr._add(tpl ? x : standardize.call(t, x));\n  });\n\n  input.mod.forEach(function(x) {\n    if(reset) {\n      aggr._add(tpl ? x : standardize.call(t, x));  // Signal change triggered reflow\n    } else if(tuple.has_prev(x)) {\n      var prev = spoof_prev.call(t, x);\n      aggr._mod(tpl ? x : standardize.call(t, x), \n        tpl ? prev : standardize.call(t, prev));\n    }\n  });\n\n  input.rem.forEach(function(x) {\n    var y = tuple.has_prev(x) ? spoof_prev.call(t, x) : x;\n    aggr._rem(tpl ? y : standardize.call(t, y));\n    t._cache[x._id] = t._prev[x._id] = null;\n  });\n\n  return aggr.changes(input, output);\n}\n\nmodule.exports = Aggregate;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bins({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;","var Transform = require('./Transform'),\n    Aggregate = require('./Aggregate');\n\nfunction Facet(graph) {\n  this._pipeline = [];\n  return Aggregate.call(this, graph);\n}\n\nvar proto = (Facet.prototype = Object.create(Aggregate.prototype));\n\nproto.pipeline = {\n  set: function(facet, pipeline) {\n    facet._pipeline = pipeline;\n    return facet;\n  },\n  get: function(model, facet) {\n    var parse = require('../parse/transforms');\n    return facet._pipeline.map(function(t) { return parse(model, t) });\n  }\n};\n\nproto.aggr = function() {\n  return Aggregate.prototype.aggr.call(this).facet(this);\n};\n\nmodule.exports = Facet;","var dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facetor() {\n  Aggregator.constructor.call(this);\n  this._facet = null;\n}\n\nvar Aggregator = dl.groupby();\nvar proto = (Facetor.prototype = Object.create(Aggregator));\n\nproto.facet = function(f) {\n  if(!arguments.length) return this._facet;\n  return (this._facet = f, this);\n};\n\nproto._ingest = function(t) { \n  return tuple.ingest(t, null) \n};\n\nproto._assign = tuple.set;\n\nfunction disconnect_cell(facet) {\n  debug({}, [\"deleting cell\", this.tuple._id]);\n  var pipeline = this.ds.pipeline();\n  facet.removeListener(pipeline[0]);\n  facet._graph.disconnect(pipeline);\n}\n\nproto._newcell = function(x) {\n  var cell  = Aggregator._newcell.call(this, x),\n      facet = this._facet,\n      tuple = cell.tuple,\n      graph, pipeline;\n\n  if(this._facet !== null) {\n    graph = facet._graph;\n    pipeline = facet.pipeline.get(graph, facet);\n    cell.ds  = graph.data(\"vg_\"+tuple._id, pipeline, tuple);\n    cell.delete = disconnect_cell;\n    facet.addListener(pipeline[0]);\n  }\n\n  return cell;\n};\n\nproto._newtuple = function(x) {\n  var t = Aggregator._newtuple.call(this, x);\n  if(this._facet !== null) {\n    tuple.set(t, \"key\", this._cellkey(x));\n  }\n  return t;\n};\n\nproto.clear = function() {\n  if(this._facet !== null) for (var k in this._cells) {\n    this._cells[k].delete(this._facet);\n  }\n  return Aggregator.clear.call(this);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  Aggregator._add.call(this, x);\n  if(this._facet !== null) cell.ds._input.add.push(x);\n};\n\nproto._mod = function(x, prev) {\n  var cell0 = this._cell(prev),\n      cell1 = this._cell(x);\n\n  Aggregator._mod.call(this, x, prev);\n  if(this._facet !== null) {  // Propagate tuples\n    if(cell0 === cell1) {\n      cell0.ds._input.mod.push(x);\n    } else {\n      cell0.ds._input.rem.push(x);\n      cell1.ds._input.add.push(x);\n    }\n  }\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  Aggregator._rem.call(this, x);\n  if(this._facet !== null) cell.ds._input.rem.push(x);  \n};\n\nproto.changes = function(input, output) {\n  var aggr = this._aggr,\n      cell, flag, i, k;\n\n  for (k in this._cells) {\n    cell = this._cells[k];\n    flag = cell.flag;\n\n    // consolidate collector values\n    if (cell.collect) {\n      cell.data.values();\n    }\n\n    // update tuple properties\n    for (i=0; i<aggr.length; ++i) {\n      cell.aggs[aggr[i].name].set();\n    }\n\n    // organize output tuples\n    if (cell.num <= 0) {\n      if (flag === C.MOD_CELL) {\n        output.rem.push(cell.tuple);\n      }\n      if(this._facet !== null) cell.delete(this._facet);\n      delete this._cells[k];\n    } else {\n      if(this._facet !== null) {\n        // propagate sort, signals, fields, etc.\n        changeset.copy(input, cell.ds._input);\n      }\n\n      if (flag & C.ADD_CELL) {\n        output.add.push(cell.tuple);\n      } else if (flag & C.MOD_CELL) {\n        output.mod.push(cell.tuple);\n      }\n    }\n\n    cell.flag = 0;\n  }\n\n  this._rems = false;\n  return output;\n};\n\nmodule.exports = Facetor;","var Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;","var Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;","var dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;","var Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;","module.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  zip:        require('./Zip')\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;","module.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  ID: \"_id\",\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  GROUPBY: \"groupby\",\n  MIN: \"min\",\n  MAX: \"max\",\n  VALUE: \"value\",\n\n  SORT: \"sort\",\n  ASC: \"asc\",\n  DESC: \"desc\"\n};","var config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};"],"sourceRoot":"/source/"}