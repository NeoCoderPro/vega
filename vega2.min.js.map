{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src","vega2.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/bin.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/import/formats/csv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/formats/tsv.js","node_modules/datalib/src/import/infer-types.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/loaders.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/index.js","node_modules/datalib/src/log.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/summary.js","node_modules/datalib/src/template.js","node_modules/datalib/src/tree.js","node_modules/datalib/src/truncate.js","node_modules/datalib/src/util.js","node_modules/heap/index.js","node_modules/heap/lib/heap.js","src/core/Bounds.js","src/core/Model.js","src/core/View.js","src/dataflow/Collector.js","src/dataflow/Datasource.js","src/dataflow/Graph.js","src/dataflow/Node.js","src/dataflow/Signal.js","src/dataflow/changeset.js","src/dataflow/tuple.js","src/expression/codegen.js","src/expression/constants.js","src/expression/functions.js","src/expression/index.js","src/expression/parser.js","src/parse/axes.js","src/parse/data.js","src/parse/events.js","src/parse/expr.js","src/parse/interactors.js","src/parse/mark.js","src/parse/marks.js","src/parse/modify.js","src/parse/padding.js","src/parse/predicates.js","src/parse/properties.js","src/parse/signals.js","src/parse/spec.js","src/parse/streams.js","src/parse/transforms.js","src/render/canvas/Handler.js","src/render/canvas/Renderer.js","src/render/canvas/index.js","src/render/canvas/marks.js","src/render/canvas/path.js","src/render/svg-xml/Renderer.js","src/render/svg-xml/index.js","src/render/svg-xml/svg.js","src/render/svg/Handler.js","src/render/svg/Renderer.js","src/render/svg/marks.js","src/scene/Bounder.js","src/scene/Builder.js","src/scene/Encoder.js","src/scene/GroupBuilder.js","src/scene/Item.js","src/scene/Scale.js","src/scene/Transition.js","src/scene/axis.js","src/transforms/Aggregate.js","src/transforms/BatchTransform.js","src/transforms/Bin.js","src/transforms/Cross.js","src/transforms/Facet.js","src/transforms/Filter.js","src/transforms/Fold.js","src/transforms/Force.js","src/transforms/Formula.js","src/transforms/Geo.js","src/transforms/GeoPath.js","src/transforms/GroupBy.js","src/transforms/LinkPath.js","src/transforms/Parameter.js","src/transforms/Pie.js","src/transforms/Sort.js","src/transforms/Stack.js","src/transforms/Transform.js","src/transforms/Treemap.js","src/transforms/Unique.js","src/transforms/Zip.js","src/transforms/index.js","src/transforms/measures.js","src/util/bounds.js","src/util/config.js","src/util/constants.js","src/util/debug.js","src/util/quickselect.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","vg","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"core","View","dataflow","changeset","Datasource","Graph","Node","parse","spec","scene","Builder","GroupBuilder","transforms","config","util","./core/View","./dataflow/Datasource","./dataflow/Graph","./dataflow/Node","./dataflow/changeset","./parse/spec","./scene/Builder","./scene/GroupBuilder","./transforms/index","./util/config","datalib",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"bisectLeft","x","lo","hi","mid","cmp","opt","precision","v","eps","maxb","maxbins","base","div","mins","minstep","logb","Math","log","level","ceil","min","max","span","step","pow","round","nbins","steps","floor","start","stop","unit",5,"gen","repeat","val","Array","zeroes","range","arguments","Infinity","j","random","uniform","delta","samples","map","integer","b","undefined","normal","mean","stdev","next","rds","c","y","sqrt",6,"d3","data","format","d","csv","toString",7,"json","tsv","topojson","treejson","./csv","./json","./topojson","./treejson","./tsv",8,"isObject","JSON","property","accessor","../../util",9,"obj","feature","objects","features","mesh",10,"tree","toTable","children","../../tree",11,12,"tests","bool","isBoolean","date","isNaN","Date","num","isDate","values","types","type","test","splice","../util",13,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","idx","lastIndexOf","load","callback","error","err","slice","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","fs","readFile","readFileSync","body","statusCode","getBody","sync-request",14,"read","keys","formats","reduce","out","isString","isFunction","extend","./load","./read",15,"cols","parsers","clen","infer","PARSERS","number","boolean","./formats","./infer-types",16,"dl","bin","summary","template","truncate","msg","LOG","silent","ERR","./bin","./generate","./import/load","./import/loaders","./import/read","./log","./stats","./summary","./template","./truncate","./util",17,"prepare","now","join","console",18,"stats","unique","results","isArray","counts","count","distinct","nulls","median","filter","isNotNull","sort","half","variance","M2","skew","avg","med","std","minmax","minIndex","maxIndex","entropy","p","H","LN2","normalized","profile","sd","vals",19,"printSummary","profiles","str","forEach","field","printCategoricalProfile","printQuantitativeProfile","list","top","concat","fields",20,"text","src","source","Function","bind","context","variable","index","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","fn","stringCast","filters","split","prop","shift","trim","pidx","args","indexOf","template_format","time","template_escapes","pattern","fmt","format_map","clearFormatCache","'","\\","\r","\n"," "," ",21,"root","childrenField","parentField","visit","node","parent","table","FIELDS",22,"truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","pos","word","ellipsis","u_truncateOnWord","l1","l2",23,"util_escape_str","escape_str_re","stderr","Object","prototype","isNumber","parseFloat","isFinite","array","stringify","identity","duplicate","equal","k","toMap","keystr","apply","mutator","comparator","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","String","string","searchString","_process",24,"./lib/heap",25,"Heap","defaultCmp","heapify","heappop","heappush","heappushpop","heapreplace","insort","nlargest","nsmallest","updateItem","_siftdown","_siftup","item","lastelt","returnitem","pop","_ref","_i","_len","_ref1","_results","_results1","_j","elem","result","los","startpos","newitem","parentpos","childpos","endpos","rightpos","nodes","pushpop","peek","contains","clear","empty","size","clone","heap","toArray","insert","front","has","copy","factory",26,"bounds","union","x1","Number","MAX_VALUE","y1","x2","y2","set","add","expand","translate","dx","dy","rotate","angle","cos","sin","cx","cy","encloses","intersects","width","height",27,"Model","_defs","_predicates","_scene","graph","_node","_builder","predicates","m","proto","defs","pipeline","predicate","renderer","disconnect","marks","connect","fire","cs","create","propagate","../dataflow/Graph","../dataflow/Node","../dataflow/changeset","../scene/GroupBuilder",28,"parseStreams","canvas","svg","svgx","Transition","debug","el","model","_el","_model","_width","__width","_height","__height","_autopad","_padding","left","bottom","right","_viewport","_renderer","_handler","_io","initialize","parentNode","_strict","padding","pad","resize","autopad","inset","autopadInset","update","viewport","_build","render","prevHandler","h","select","remove","append","attr","style","Renderer","Handler","handlers","handler","trans","duration","ease","reflow","_renderNode","router","evaluate","input","items","ds","revises","finalize","last","../parse/streams","../render/canvas/index","../render/svg-xml/index","../render/svg/index","../scene/Transition","../util/config","../util/debug",29,"Collector","init","_data","collector","mod","rem","ids","_id","../util/constants","./Node","./changeset",30,"facet","_graph","_name","_source","_facet","_input","_output","_pipeline","_collector","_revises","set_prev","_prev","C","SENTINEL","tuple","prev","ingest","where","func","idMap","unshift","output","listener","dest","_srcMap","derive","listeners","./Collector","./tuple",31,"_stamp","_rank","_signals","doNotPropagate","signal","forEachNode","branch","Signal","signalValues","sg","value","signalRef","ref","schedule","rank","pulse","reflowed","pq","stamp","_listeners","dependency","DATA","signals","SIGNALS","reevaluate","run","./Datasource","./Signal",32,"REEVAL","SCALES","node_id","_registered","_deps","scales","_isRouter","_isCollector","deps","q","cur","foundSending","reeval",33,"_value",34,"reset_prev",35,"datum","tuple_id","reset",36,"codegen_wrap","ast","retval","codegen","generator","CODEGEN_TYPES","constants","functions","idWhiteList","idBlackList","memberDepth","DATUM","SIGNAL_PREFIX","Literal","raw","Identifier","id","hasOwnProperty","Program","MemberExpression","computed","object","CallExpression","callee","ArrayExpression","elements","BinaryExpression","operator","UnaryExpression","argument","UpdateExpression","prefix","ConditionalExpression","consequent","alternate","LogicalExpression","ObjectExpression","properties","Property","key","ExpressionStatement","expression","./constants","./functions",37,"E","LN10","LOG2E","LOG10E","PI","SQRT1_2","SQRT2",38,"fncall","cast","DATE","STRING","REGEXP","abs","acos","asin","atan","atan2","exp","tan","datetime","day","year","month","hours","minutes","seconds","milliseconds","timezoneoffset","utcdate","utcday","utcyear","utcmonth","utchours","utcminutes","utcseconds","utcmilliseconds","indexof","lastindexof","parseInt","upper","lower","substring","if",39,"parser","./codegen","./parser",40,"assert","condition","message","isDecimalDigit","ch","isHexDigit","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","Regex","NonAsciiIdentifierStart","fromCharCode","isIdentifierPart","NonAsciiIdentifierPart","isFutureReservedWord","isStrictModeReservedWord","isKeyword","strict","skipComment","charCodeAt","lineNumber","lineStart","scanHexEscape","scanUnicodeCodePointEscape","cu1","cu2","throwError","Messages","UnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","Token","Keyword","NullLiteral","BooleanLiteral","end","scanPunctuator","code2","ch2","ch3","ch4","ch1","extra","tokenize","openParenToken","tokens","openCurlyToken","Punctuator","scanHexLiteral","NumericLiteral","scanOctalLiteral","octal","scanNumericLiteral","scanStringLiteral","quote","unescaped","restore","startLineNumber","startLineStart","StringLiteral","testRegExp","flags","tmp","$0","$1","InvalidRegExp","RegExp","exception","scanRegExpBody","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","lookahead","RegularExpression","collectRegex","loc","token","line","column","isIdentifierName","advanceSlash","prevToken","checkToken","advance","EOF","collectToken","entry","TokenName","lex","Position","SourceLocation","WrappingSourceLocation","startToken","WrappingNode","peekLineTerminator","found","messageFormat","whole","description","errors","throwUnexpected","UnexpectedEOS","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","StrictReservedWord","expect","expectTolerant","matchKeyword","keyword","consumeSemicolon","parseArrayInitialiser","parseAssignmentExpression","finishArrayExpression","parseObjectPropertyKey","StrictOctalLiteral","finishLiteral","finishIdentifier","parseObjectProperty","finishProperty","parseObjectInitialiser","kind","Syntax","PropertyKind","Data","Get","Set","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","finishObjectExpression","parseGroupExpression","expr","state","parenthesisCount","parseExpression","parsePrimaryExpression","legalKeywords","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","finishMemberExpression","finishCallExpression","parsePostfixExpression","parseUnaryExpression","finishUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","parseConditionalExpression","finishConditionalExpression","oldParenthesisCount","parseExpressionStatement","finishExpressionStatement","parseStatement","parseSourceElement","parseSourceElements","sourceElement","directive","firstRestricted","sourceElements","parseProgram","finishProgram","filterTokenLocation","options","labelSet","inFunctionBody","inIteration","inSwitch","lastCommentStart","tolerant","lexError","program","AssignmentExpression","NewlineAfterThrow","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","finish","finishAssignmentExpression",41,"axes","group","def","axs","axis","scale","orient","ORIENT","layer","grid","titleOffset","tickValues","tickFormat","tickSubdivide","subdivide","tickPadding","tickSize","ts","tickSizeMajor","tickSizeMinor","tickSizeEnd","ticks","majorTickProperties","majorTicks","minorTickProperties","minorTicks","tickLabelProperties","labels","titleProperties","gridLineProperties","domainProperties","../scene/axis",42,"parseTransforms","parseModify","parseData","loaded","datasource","transform","modify","./modify","./transforms",43,"peg$subclass","child","ctor","constructor","SyntaxError","expected","peg$computePosDetails","details","startPos","endPos","charAt","seenCR","peg$cachedPos","peg$cachedPosDetails","peg$fail","peg$maxFailPos","peg$currPos","peg$maxFailExpected","peg$buildException","cleanupExpected","buildMessage","stringEscape","hex","toUpperCase","expectedDesc","foundDesc","expectedDescs","posDetails","peg$parsestart","s0","peg$parsemerged","s1","s2","s3","s4","s5","peg$parseordered","peg$FAILED","peg$parsesep","peg$c1","peg$silentFails","peg$c2","peg$reportedPos","peg$c3","peg$c0","peg$c4","s6","s7","s8","s9","s10","s11","s12","s13","peg$c5","peg$c6","peg$parsefiltered","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$parsestream","peg$parsefilter","peg$c13","peg$c14","peg$parseclass","peg$parseid","peg$c15","peg$parseeventType","peg$c16","peg$c17","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$parsevalue","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$c40","peg$c41","peg$c42","peg$c43","peg$c44","peg$c45","peg$c46","peg$c47","peg$c48","peg$c49","peg$c50","peg$c51","peg$c52","peg$c53","peg$c54","peg$c55","peg$c56","peg$c57","peg$c58","peg$c59","peg$c60","peg$c61","peg$c62","peg$c63","peg$c64","peg$c65","peg$c66","peg$c67","peg$c68","peg$c69","peg$c70","peg$result","peg$startRuleFunctions","peg$startRuleFunction","f1","f2","middle","event","target","stream","startRule",44,"eval","../expression",45,"defFactory","interactor","inject","pd","nsSignals","nsPredicates","nsMarks","mk","injectMarks","from","ENTER","UPDATE","EXIT","ns","streams","operands","nsOperand","nsProperties","enter","exit","propset","rule","interactors",46,"parseProperties","parseMark","mark","props","delay","./properties",47,"./mark",48,"signalName","db","ADD","REMOVE","TOGGLE","CLEAR","../dataflow/tuple",49,50,"parseSignal","parseOperands","decl","arg","pred","parseComparator","ops","parseLogical","parseIn","=","==","!=",">",">=","<","<=","and","&&","or","||","in",51,"compile","names","vars","valueRef","hasPath","encoder","tpl","encode","path","tension","rules","inputs","predName","isColor","colorRef","grp","GROUP_VARS","invert","band","mult","z","xx","color","yy","zz","mark.group.width","mark.group.height",52,"dep","./expr",53,"parsePadding","parseMarks","parseSignals","parsePredicates","parseInteractors","viewFactory","../core/Model","../core/View","../parse/data","../parse/interactors","../parse/marks","../parse/padding","../parse/predicates","../parse/signals",54,"changset","selector","START","MIDDLE","END","view","sig","register","orderedStream","trueFn","sp","mergedStream","sel","evt","filtered","preventDefault","mouse","./events",55,"tx","../transforms/index",56,"eventName","_active","_handlers","_canvas","_obj","that","events","addEventListener","touchmove","mousemove","getBoundingClientRect","clientX","clientY","pick","touchend","mouseout","DOMMouseScroll","getContext","gx","gy","marktype","picker","./marks",57,"scaleCanvas","ctx","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","setAttribute","initializeLineDash","vgLineDash","NODASH","setLineDash","dash","vgLineDashOffset","lineDashOffset","webkitLineDash","webkitLineDashOffset","mozDash","translatedBounds","Bounds","getBounds","setBounds","bbox","beginPath","rect","clip","_ctx","_imgload","selectAll","_ratio","setTransform","element","pendingImages","bb2","bb","save","clearRect","draw","renderAsync","_async_id","clearTimeout","loadImage","uri","image","Image","../../core/Bounds","../../util/config",58,"./Handler","./Renderer",59,"fontString","fontStyle","fontVariant","fontWeight","fontSize","font","arcPath","ir","innerRadius","outerRadius","startAngle","ea","endAngle","moveTo","arc","closePath","areaPath","pathCache","parsePath","area","renderPath","linePath","pathPath","symbolPath","rx","ry","shape","lineTo","tan30","sqrt3","lineStroke","lw","strokeWidth","lc","strokeCap","lineWidth","lineCap","ruleStroke","drawPathOne","opac","fill","stroke","opacity","globalAlpha","fillOpacity","fillStyle","strokeOpacity","strokeStyle","strokeDash","strokeDashOffset","drawPathAll","drawRect","fillRect","strokeRect","drawRule","drawImage","align","baseline","drawText","textAlign","textBaseline","radius","theta","fillText","strokeText","drawAll","pathFunc","drawOne","drawGroup","legends","axisItems","legendItems","gradient","grad","createLinearGradient","stops","addColorStop","pickGroup","subscene","hit","interactive","pickAll","hitTests","pickArea","pickLine","textHit","boundsCalc","tmpBounds","px","py","isPointInStroke","isPointInPath","symbol","../../util/bounds","./path",60,"currentPath","chunks","parsed","re","chunksParsed","jlen","command","commandLength","cmdLength","klen","drawArc","coords","rot","large","sweep","ex","ey","segs","arcToSegments","bez","segmentToBezier","bezierCurveTo","boundArc","rotateX","ox","oy","argsStr","arcToSegmentsCache","th","sin_th","cos_th","pl","a00","a01","a10","a11","x0","y0","sfactor_sq","sfactor","xc","yc","th0","th1","th_arc","segments","th2","th3","segmentToBezierCache","cos_th0","sin_th0","cos_th1","sin_th1","th_half","sin_th_h2","x3","y3","current","tempX","tempY","tempControlX","tempControlY","previous","controlX","controlY","quadraticCurveTo",61,"SVGBuilder","./svg",62,63,"tag","close","escape_text","escape_font","group_bg","styl","class","clip_id","clipping","arc_path","area_path_h","area_path_v","line_path","symbol_path","xlink:href","text-anchor","cssClass","cls","xw","yh","styleProps","styles","_gid","_text","head","foot","svgNamespace","buildDefs","all","dgrad","dclip","stop-color","meta","MARKS","sty","nest","center",64,"svgHandler","__data__","_svg","dom","removeEventListener",65,"updateDefs","each","grd","cr","renderItems","nested",66,"dup",67,"setProperty","removeProperty","area_path","setAttributeNS","removeAttribute","textContent","drawMark","evts","grps","childNodes","notG","mark_id",68,"Bounder","_mark","GROUP","../util/bounds",69,"inlineDs","sibling","_def","geom","_parent_id","_from","_ds","_isSuper","_bounder","newItem","Item","keyf","_map","joinDatasource","fullUpdate","keyFunction","joinValues","_items","Encoder","parent_id","inheritFrom","_parent","_encoder","builder","fcs","./Bounder","./Encoder","./Item",70,"enc","EMPTY",71,"_children","_scaler","_recursor","_scales","recurse","hasMarks","hasAxes","inline","buildMarks","buildAxes","MARK","parseAxes","buildGroup","inherit","axisDef","AXIS","Scale","acc","group_id","../dataflow/Collector","../parse/axes","./Builder","./Scale",72,"hasPropertySet","cousin","iidx","midx","touch",73,"_updated","instance","ORDINAL","ordinal","quantitative","rng","LINEAR","scaleName","dataDrivenRange","dataRef","RANGE","DOMAIN","points","rangePoints","rangeRoundBands","rangeBands","interval","QUANTILE","domainMinMax","rangeRound","exponent","POWER","clamp","nice","TIME","which","rlen","flen","refs","uniques","ck","cache","cacheField","Aggregate","singleton","stat","group_by","MIN","MAX","order","DESC","SINGLETON","domainMin","domainMax","zero","GROUP_PROPERTY","rangeMin","rangeMax","SIGNAL","../transforms/Aggregate",74,"updates","elapsed","curr","calcBounds","skip","interp","timer",75,"axis_def","newScale","oldScale","rangeBand","vg_axisScaleRange","gridLines","vg_axisTicks","tickLabels","vg_axisTickLabels","vg_axisDomain","vg_axisTitle","gridColor","vg_axisTicksExtend","tickMajorSize","tickMinorSize","vg_axisLabelExtend","vg_axisDomainExtend","tickEndSize","vg_axisTitleExtend","gridLineStyle","majorTickStyle","minorTickStyle","tickLabelStyle","domainStyle","titleStyle","vg_axisUpdate","tickFormatString","tickArguments","injest","major","minor","vg_axisSubdivide","label","tdata","vg_axisOrients","subticks","extent","vg_axisScaleExtent","rangeExtent","vg_axisBaseline","vg_axisAlign","tickColor","tickWidth","tickLabelColor","tickLabelFont","tickLabelFontSize","titleFont","titleFontSize","titleFontWeight","titleColor","axisColor","axisWidth","../parse/mark",76,"GroupBy","Transform","addParameters","sum","var","varp","stdevp","_fieldsDef","_Aggregators","_singleton","meas","aggs","measures","_reset","_keys","_gb","_new_cell","agg","cell","_add","_cell","flg","MOD_CELL","_rem","get","_cells","./GroupBy","./Transform","./measures",77,"BatchTransform","batchTransform",78,"Bin","default",79,"Cross","with","diagonal","_lastRem","_lastWith","_ids","_cache","wdata","diag","cross","upFields","selfCross","woutput",80,"Facet","_new_tuple","_mod","ADD_CELL",81,"Filter","_skip","../parse/expr",82,"Fold","rst","get_tuple","accessors","dlen","fold",83,"Force","links","linkDistance","linkStrength","charge","chargeDistance","iterations","friction","gravity","alpha","_nodes","_links","_layout","layout","force","nodeInput","linkInput","iter","link","tick","nodeIds","linkIds",84,"Formula",85,"Geo","Parameters","lon","lat","projection","clipAngle","clipExtent","d3Projection","proj","param","_mode","_projection","geo","ll","xy",86,"GeoPath","geojson","./Geo",87,"gb","groupBy",88,"LinkPath","sx","sy","ty","curve","ix","iy","diagonalX","diagonalY","shapes",89,"Parameter","_type","_accessors","_resolution","arrayType","dataType","fieldType","exprType","_get","isData","isField","sources","isExpr",90,"Pie","ones","./BatchTransform",91,"Sort","by",92,"Stack","groupby","sortby","partition","groups",93,"params","_parameters","./Parameter",94,"Treemap","sticky","mode","treemap",95,"Unique","as",96,"Zip","withKey","_lastJoin","mp","wds","dflt","prevm","wlen",97,"aggregate","linkpath","formula","geopath","pie","zip","./Aggregate","./Bin","./Cross","./Facet","./Filter","./Fold","./Force","./Formula","./GeoPath","./LinkPath","./Pie","./Sort","./Stack","./Treemap","./Unique","./Zip",98,"measure","resolve","collect","req","ctr","quickselect","v_new","v_old","_counts","../util/quickselect",99,"gfx","pathBounds","boundPath","halfpi","xmin","xmax","ymin","ymax","angles","noRotate","measureText","includeLegends","itemBounds","methods","bounds_prev","pb","markBounds","../core/Bounds","../render/canvas/path","./config",100,"utc","legend","gradientStrokeColor","gradientStrokeWidth","gradientHeight","gradientWidth","labelColor","labelFontSize","labelFont","labelAlign","labelBaseline","labelOffset","symbolShape","symbolSize","symbolColor","symbolStrokeWidth","rgb","lab","hcl","hsl","category10","category20",101,"sentinel","COUNT","ASC",102,103,"swap","pivot"],"mappings":"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","file":"vega2.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n  core: {\n    View: require('./core/View')\n  },\n  dataflow: {\n    changeset: require('./dataflow/changeset'),\n    Datasource: require('./dataflow/Datasource'),\n    Graph: require('./dataflow/Graph'),\n    Node: require('./dataflow/Node')\n  },\n  parse: {\n    spec: require('./parse/spec')\n  },\n  scene: {\n    Builder: require('./scene/Builder'),\n    GroupBuilder: require('./scene/GroupBuilder')\n  },\n  transforms: require('./transforms/index'),\n  config: require('./util/config'),\n  util: require('datalib')\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.vg = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n  core: {\n    View: require('./core/View')\n  },\n  dataflow: {\n    changeset: require('./dataflow/changeset'),\n    Datasource: require('./dataflow/Datasource'),\n    Graph: require('./dataflow/Graph'),\n    Node: require('./dataflow/Node')\n  },\n  parse: {\n    spec: require('./parse/spec')\n  },\n  scene: {\n    Builder: require('./scene/Builder'),\n    GroupBuilder: require('./scene/GroupBuilder')\n  },\n  transforms: require('./transforms/index'),\n  config: require('./util/config'),\n  util: require('datalib')\n};\n},{\"./core/View\":28,\"./dataflow/Datasource\":30,\"./dataflow/Graph\":31,\"./dataflow/Node\":32,\"./dataflow/changeset\":34,\"./parse/spec\":53,\"./scene/Builder\":69,\"./scene/GroupBuilder\":71,\"./transforms/index\":97,\"./util/config\":100,\"datalib\":16}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nmodule.exports = function(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 1024,\n      base = opt.base || 10,\n      div = opt.div || [5, 2],\n      mins = opt.minstep || 0,\n      logb = Math.log(base),\n      level = Math.ceil(Math.log(maxb) / logb),\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step = Math.max(mins, Math.pow(base, Math.round(Math.log(span) / logb) - level)),\n      nbins = Math.ceil(span / step),\n      precision, v, i, eps;\n\n  if (opt.step != null) {\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n        opt.steps.length - 1,\n        bisectLeft(opt.steps, span / maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // increase step size if too many bins\n    do {\n      step *= base;\n      nbins = Math.ceil(span / step);\n    } while (nbins > maxb);\n\n    // decrease step size if allowed\n    for (i = 0; i < div.length; ++i) {\n      v = step / div[i];\n      if (v >= mins && span / v <= maxb) {\n        step = v;\n        nbins = Math.ceil(span / step);\n      }\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = (min<0 ? -1 : 1) * Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop: max,\n    step: step,\n    unit: precision\n  };\n};\n\nfunction bisectLeft(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (u.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n},{}],5:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeroes = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n\tmin = min || 0;\n\tmax = max || 1;\n\tvar delta = max - min;\n\tvar f = function() {\n\t\treturn min + delta * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeroes(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tvar f = function() {\n\t\treturn a + Math.max(0, Math.floor(b*(Math.random()-0.001)));\n\t};\n\tf.samples = function(n) { return gen.zeroes(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeroes(n).map(f); };\n\treturn f;\n};\n},{}],6:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.csv.parse(data ? data.toString() : data);\n  return d;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],7:[function(require,module,exports){\nmodule.exports = {\n  json: require('./json'),\n  csv: require('./csv'),\n  tsv: require('./tsv'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson')\n};\n},{\"./csv\":6,\"./json\":8,\"./topojson\":9,\"./treejson\":10,\"./tsv\":11}],8:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) ? data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":23}],9:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error(\"TopoJSON library not loaded.\"); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if (obj = t.objects[format.feature]) {\n      return topojson.feature(t, obj).features\n    } else {\n      throw Error(\"Invalid TopoJSON object: \"+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if (obj = t.objects[format.mesh]) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error(\"Invalid TopoJSON object: \" + format.mesh);\n    }\n  } else {\n    throw Error(\"Missing TopoJSON feature or mesh parameter.\");\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":8}],10:[function(require,module,exports){\nvar tree = require('../../tree');\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return tree.toTable(data, (format && format.children));\n};\n},{\"../../tree\":21,\"./json\":8}],11:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.tsv.parse(data ? data.toString() : data);\n  return d;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],12:[function(require,module,exports){\nvar util = require('../util');\n\nvar tests = {\n  bool: function(x) { return x===\"true\" || x===\"false\" || util.isBoolean(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); },\n  num: function(x) { return !isNaN(+x) && !util.isDate(x); }\n};\n\nmodule.exports = function(values, f) {\n  var i, j, v;\n  \n  // types to test for\n  var types = [\n    {type: \"boolean\", test: tests.bool},\n    {type: \"number\", test: tests.num},\n    {type: \"date\", test: tests.date}\n  ];\n  \n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (v != null && !types[j].test(v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return \"string\";\n  }\n  \n  return types[0].type;\n};\n},{\"../util\":23}],13:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host == \"\") {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function (d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; };\n  \n  try {\n    var url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== \"text\"\n      ? request.response // null on error\n      : request.responseText; // \"\" on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest;\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest\n      && !(\"withCredentials\" in request)\n      && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest;\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    \"onload\" in request\n      ? request.onload = request.onerror = respond\n      : request.onreadystatechange = function() { request.readyState > 3 && respond(); };\n  }\n  \n  request.open(\"GET\", url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(file, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(file, 'utf8');\n  }\n  require('fs').readFile(file, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":23,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],14:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) opt = {url: opt};\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":23,\"./load\":13,\"./read\":15}],15:[function(require,module,exports){\nvar util = require('../util');\nvar formats = require('./formats');\nvar infer = require('./infer-types');\n\nvar PARSERS = {\n  \"number\": util.number,\n  \"boolean\": util.boolean,\n  \"date\": util.date\n};\n\nfunction read(data, format) {\n  var type = (format && format.type) || \"json\";\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  if (types === 'auto') {\n    // perform type inference\n    types = util.keys(data[0]).reduce(function(types, c) {\n      var type = infer(data, util.accessor(c));\n      if (PARSERS[type]) types[c] = type;\n      return types;\n    }, {});\n  }\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return PARSERS[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n}\n\nread.infer = infer;\nread.formats = formats;\nread.parse = parse;\nmodule.exports = read;\n\n},{\"../util\":23,\"./formats\":7,\"./infer-types\":12}],16:[function(require,module,exports){\nvar dl = module.exports = {};\nvar util = require('./util');\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\ndl.bin = require('./bin');\ndl.summary = require('./summary');\ndl.template = require('./template');\ndl.truncate = require('./truncate');\n\ndl.load = require('./import/load');\ndl.read = require('./import/read');\nutil.extend(dl, require('./import/loaders'));\n\nvar log = require('./log');\ndl.log = function(msg) { log(msg, log.LOG); };\ndl.log.silent = log.silent;\ndl.error = function(msg) { log(msg, log.ERR); };\n\n},{\"./bin\":4,\"./generate\":5,\"./import/load\":13,\"./import/loaders\":14,\"./import/read\":15,\"./log\":17,\"./stats\":18,\"./summary\":19,\"./template\":20,\"./truncate\":22,\"./util\":23}],17:[function(require,module,exports){\nvar LOG = \"LOG\";\nvar ERR = \"ERR\";\nvar silent = false;\n\nfunction prepare(msg, type) {\n  return '[' + [\n    '\"'+(type || LOG)+'\"',\n    Date.now(),\n    '\"'+msg+'\"'\n  ].join(\", \") + ']';\n}\n\nfunction log(msg, type) {\n  if (!silent) {\n    msg = prepare(msg, type);\n    console.error(msg);\n  }\n}\n\nlog.silent = function(val) { silent = !!val; };\n\nlog.LOG = LOG;\nlog.ERR = ERR;\nmodule.exports = log;\n},{}],18:[function(require,module,exports){\nvar util = require('./util');\nvar stats = {};\n\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\nstats.skew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\nstats.minmax = function(values, f) {\n  var s = {min: +Infinity, max: -Infinity}, v, i, n;\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      if (v > s.max) s.max = v;\n      if (v < s.min) s.min = v;\n    }\n  }\n  return s;\n};\n\nstats.minIndex = function(values, f) {\n  if (!util.isArray(values) || values.length==0) return -1;\n  var idx = 0, v, i, n, min = +Infinity;\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && v < min) { min = v; idx = i; }\n  }\n  return idx;\n};\n\nstats.maxIndex = function(values, f) {\n  if (!util.isArray(values) || values.length==0) return -1;\n  var idx = 0, v, i, n, max = -Infinity;\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && v > max) { max = v; idx = i; }\n  }\n  return idx;\n};\n\nstats.entropy = function(counts) {\n  var i, p, s = 0, H = 0;\n  for (i=0; i<counts.length; ++i) {\n    s += counts[i];\n  }\n  if (s === 0) return 0;\n  for (i=0; i<counts.length; ++i) {\n    p = counts[i] / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\nstats.entropy.normalized = function(counts) {\n  var H = stats.entropy(counts);\n  var max = -Math.log(1/counts.length) / Math.LN2;\n  return H / max;\n};\n\nstats.profile = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return null;\n\n  // init\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = f ? f(values[0]) : values[0],\n      max = min,\n      M2 = 0,\n      median = null,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      // update unique values\n      u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n      // update min/max\n      if (v < min) min = v;\n      if (v > max) max = v;\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // compute median\n  vals.sort(util.cmp);\n  half = Math.floor(vals.length/2);\n  median = (vals.length % 2)\n   ? vals[half]\n   : (vals[half-1] + vals[half]) / 2.0;\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    median:   median,\n    stdev:    sd,\n    skew:     sd === 0 ? 0 : (mean - median) / sd\n  };\n};\n\nmodule.exports = stats;\n},{\"./util\":23}],19:[function(require,module,exports){\nvar util = require('./util');\nvar stats = require('./stats');\n\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"skew:     \" + p.skew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}\n},{\"./stats\":18,\"./util\":23}],20:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   require('./truncate')\n};\n\nfunction template(text) {\n  var src = source(text, \"d\");\n  src = \"var __t; return \" + src + \";\";\n\n  try {\n    return (new Function(\"d\", src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || \"obj\";\n  var index = 0;\n  var src = \"'\";\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += \"'\\n+((__t=(\"\n        + template_var(interpolate, variable)\n        + \"))==null?'':__t)+\\n'\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + \"'\";\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var format = [];\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || \"\";\n    if (stringCast) {\n      stringCast = false;\n      src = \"String(\" + src + \")\" + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  var src = util.field(prop).map(util.str).join(\"][\");\n  src = variable + \"[\" + src + \"]\";\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a\n          + (args.length > 1 ? ',' + util.number(args[1]) : '')\n          + ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!==\"left\" && b!==\"middle\" && b!==\"center\") ? \"right\" : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\"' + b + '\")';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      default:\n        throw Error(\"Unrecognized template filter: \" + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n};\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === \"'\" && pattern[pattern.length-1] === \"'\") ||\n      (pattern[0] !== '\"' && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error(\"Format pattern must be quoted: \" + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./truncate\":22,\"./util\":23}],21:[function(require,module,exports){\nvar FIELDS = {\n  parent: \"parent\",\n  children: \"children\"\n};\n\nfunction toTable(root, childrenField, parentField) {\n  childrenField = childrenField || FIELDS.children;\n  parentField = parentField || FIELDS.parent;\n  var table = [];\n  \n  function visit(node, parent) {\n    node[parentField] = parent;\n    table.push(node);\n    \n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n\nmodule.exports = {\n  toTable: toTable,\n  fields: FIELDS\n};\n},{}],22:[function(require,module,exports){\nmodule.exports = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis || \"...\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? u_truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n},{}],23:[function(require,module,exports){\n(function (process){\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null; // TODO include NaN here?\n};\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n}).call(this,require('_process'))\n\n},{\"_process\":3}],24:[function(require,module,exports){\nmodule.exports = require('./lib/heap');\n\n},{\"./lib/heap\":25}],25:[function(require,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n},{}],26:[function(require,module,exports){\nvar bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;\n},{}],27:[function(require,module,exports){\nvar Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this.graph = new Graph();\n\n  this._node = new Node(this.graph);\n  this._builder = null; // Top-level scenegraph builder\n};\n\nvar proto = Model.prototype;\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.data = function() {\n  var data = this.graph.data.apply(this.graph, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this._node.addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this._node.removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this._node.addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this._node.addListener(l); };\nproto.removeListener = function(l) { this._node.removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.graph.propagate(cs, this._node);\n};\n\nmodule.exports = Model;\n},{\"../dataflow/Graph\":31,\"../dataflow/Node\":32,\"../dataflow/changeset\":34,\"../scene/GroupBuilder\":71,\"datalib\":16}],28:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    svgx = require('../render/svg-xml/index'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler = null;\n  this._io = canvas;\n  if (el) this.initialize(el);\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\nprototype.data = function(data) {\n  var m = this.model();\n  if (!arguments.length) return m.data();\n  dl.keys(data).forEach(function(d) { m.data(d).add(dl.duplicate(data[d])); });\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    if (this._el) this.initialize(this._el.parentNode);\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    if (this._el) this.initialize(this._el.parentNode);\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    if (this._el) this.initialize(this._el.parentNode);\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    if (this._el) this.initialize(this._el.parentNode);\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (type === \"canvas\") type = canvas;\n  else if (type === \"svg\") type = svg;\n  else if (type === \"svg-xml\") type = svgx;\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    if (this._el) this.initialize(this._el.parentNode);\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n  \n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n  }\n\n  if (el) {\n    // clear pre-existing container\n    d3.select(el).select(\"div.vega\").remove();\n    \n    // add div container\n    this._el = el = d3.select(el)\n      .append(\"div\")\n      .attr(\"class\", \"vega\")\n      .style(\"position\", \"relative\")\n      .node();\n    if (v._viewport) {\n      d3.select(el)\n        .style(\"width\",  (v._viewport[0] || w)+\"px\")\n        .style(\"height\", (v._viewport[1] || h)+\"px\")\n        .style(\"overflow\", \"auto\");\n    }\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  if (el) {\n    // input handler\n    prevHandler = v._handler;\n    v._handler = new this._io.Handler()\n      .initialize(el, pad, v)\n      .model(v._model);\n\n    if (prevHandler) {\n      prevHandler.handlers().forEach(function(h) {\n        v._handler.on(h.type, h.handler);\n      });\n    } else {\n      // Register event listeners for signal stream definitions.\n      parseStreams(this);\n    }\n  }\n  \n  return this;\n};\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  // TODO: with streaming data API, adds should dl.duplicate just parseSpec\n  // to prevent Vega from polluting the environment.\n\n  var cs = changeset.create();\n  if(trans) cs.trans = trans;\n  if(opt.reflow !== undefined) cs.reflow = opt.reflow\n\n  if(!v._build) {\n    v._renderNode = new Node(v._model.graph)\n      .router(true);\n\n    v._renderNode.evaluate = function(input) {\n      debug(input, [\"rendering\"]);\n\n      var s = v._model.scene();\n      if(input.trans) {\n        input.trans.start(function(items) { v._renderer.render(s, items); });\n      } else {\n        v._renderer.render(s);\n      }\n\n      // For all updated datasources, finalize their changesets.\n      var d, ds;\n      for(d in input.data) {\n        ds = v._model.data(d);\n        if(!ds.revises()) continue;\n        changeset.finalize(ds.last());\n      }\n\n      return input;\n    };\n\n    v._model.scene(v._renderNode);\n    v._build = true;\n  }\n\n  // Pulse the entire model (Datasources + scene).\n  v._model.fire(cs);\n\n  return v.autopad(opt);\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nView.factory = function(model) {\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = new View()\n      .model(model)\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding)\n      .renderer(opt.renderer || \"canvas\");\n\n    v.initialize(opt.el);\n    if (opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":32,\"../dataflow/changeset\":34,\"../parse/streams\":54,\"../render/canvas/index\":58,\"../render/svg-xml/index\":62,\"../render/svg/index\":66,\"../scene/Transition\":74,\"../util/config\":100,\"../util/debug\":102,\"datalib\":16}],29:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;\n},{\"../util/constants\":101,\"../util/debug\":102,\"./Node\":32,\"./changeset\":34}],30:[function(require,module,exports){\nvar dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.add = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.add(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;\n},{\"../util/constants\":101,\"../util/debug\":102,\"./Collector\":29,\"./Node\":32,\"./changeset\":34,\"./tuple\":35,\"datalib\":16}],31:[function(require,module,exports){\nvar dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n}\n\nvar proto = Graph.prototype;\n\nproto.data = function(name, pipeline, facet) {\n  if(arguments.length === 1) return this._data[name];\n  return (this._data[name] = new Datasource(this, name, facet)\n    .pipeline(pipeline));\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(name) {\n  var graph = this;\n  if(!dl.isArray(name)) return this._signals[name].value();\n  return name.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;\n},{\"../util/constants\":101,\"../util/debug\":102,\"./Datasource\":30,\"./Signal\":33,\"./changeset\":34,\"datalib\":16,\"heap\":24}],32:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;\n},{\"../util/constants\":101,\"datalib\":16}],33:[function(require,module,exports){\nvar Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nmodule.exports = Signal;\n},{\"./Node\":32,\"./changeset\":34}],34:[function(require,module,exports){\nvar C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};\n},{\"../util/constants\":101}],35:[function(require,module,exports){\nvar dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};\n},{\"../util/constants\":101,\"datalib\":16}],36:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};\n},{\"./constants\":37,\"./functions\":38,\"datalib\":16}],37:[function(require,module,exports){\nmodule.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};\n},{}],38:[function(require,module,exports){\nvar datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};\n},{\"datalib\":16}],39:[function(require,module,exports){\nvar parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n\n},{\"./codegen\":36,\"./parser\":40}],40:[function(require,module,exports){\n/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();\n},{}],41:[function(require,module,exports){\nvar dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;\n},{\"../scene/axis\":75,\"../util/config\":100,\"datalib\":16}],42:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n\n},{\"../util/config\":100,\"./modify\":48,\"./transforms\":55,\"datalib\":16}],43:[function(require,module,exports){\n/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};\n},{}],44:[function(require,module,exports){\nvar dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;\n},{\"../expression\":39,\"datalib\":16}],45:[function(require,module,exports){\nvar dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}\n},{\"../util/config\":100,\"../util/constants\":101,\"datalib\":16}],46:[function(require,module,exports){\nvar dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};\n},{\"./properties\":51,\"datalib\":16}],47:[function(require,module,exports){\nvar parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};\n},{\"./mark\":46}],48:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var graph = model.graph,\n      signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(graph);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate({}, db, graph.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? graph.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}\n},{\"../dataflow/Node\":32,\"../dataflow/tuple\":35,\"../util/constants\":101,\"../util/debug\":102,\"datalib\":16}],49:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}\n},{\"datalib\":16}],50:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate);\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= \"predicates[\"+dl.str(o.predicate)+\"](args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item];\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) o.push(spec.scale);\n\n    var ops = parseOperands(o),\n        code = ops.code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = o3(o1);\\no2 = o3(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s);\n    var pred = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}\n},{\"datalib\":16}],51:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales: {},\n        data: {}\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    ['signals', 'scales', 'data'].forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode: encoder,\n      signals: dl.keys(deps.signals),\n      scales: dl.keys(deps.scales),\n      data: dl.keys(deps.data)\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nvar GROUP_VARS = {\n  \"width\": 1,\n  \"height\": 1,\n  \"mark.group.width\": 1,\n  \"mark.group.height\": 1\n};\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(predicates[\"+dl.str(predName)+\"](\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n  var isColor = name===\"fill\" || name===\"stroke\";\n  var signals = [];\n\n  if (isColor) {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, signalRef = null;\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    signalRef = dl.field(ref.signal);\n    val = \"signals[\"+signalRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(signalRef.shift());\n  }\n\n  // get field reference for enclosing group\n  if (ref.group != null) {\n    var grp = \"group.datum\";\n    if (dl.isString(ref.group)) {\n      grp = GROUP_VARS[ref.group]\n        ? \"group.\" + ref.group\n        : \"group.datum[\"+dl.field(ref.group).map(dl.str).join(\"][\")+\"]\";\n    }\n  }\n\n  // get data field value\n  if (ref.field != null) {\n    if (dl.isString(ref.field)) {\n      val = \"item.datum[\"+dl.field(ref.field).map(dl.str).join(\"][\")+\"]\";\n      if (ref.group != null) { val = \"this.util.accessor(\"+val+\")(\"+grp+\")\"; }\n    } else if(ref.field.signal) {\n      signalRef = dl.field(ref.field.signal);\n      val = \"item.datum[signals[\"+signalRef.map(dl.str).join(\"][\")+\"]]\";\n      if (ref.group != null) { val = \"this.util.accessor(\"+val+\")(\"+grp+\")\"; }\n      signals.push(signalRef.shift());\n    } else {\n      val = \"this.util.accessor(group.datum[\"\n          + dl.field(ref.field.group).map(dl.str).join(\"][\")\n          + \"])(item.datum)\";\n    }\n  } else if (ref.group != null) {\n    val = grp;\n  }\n\n  if (ref.scale != null) {\n    var scale = null;\n    if(dl.isString(ref.scale)) {\n      scale = dl.str(ref.scale);\n    } else if(ref.scale.signal) {\n      signalRef = dl.field(ref.scale.signal);\n      scale = \"signals[\"+signalRef.map(dl.str).join(\"][\")+\"]\";\n      signals.push(signalRef.shift());\n    } else {\n      scale = (ref.scale.group ? \"group\" : \"item\")\n        + \".datum[\" + dl.str(ref.scale.group || ref.scale.field) + \"]\";\n    }\n\n    scale = \"group.scale(\" + scale + \")\";\n    if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n  return {val: val, signals: signals, scales: ref.scale};\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\nmodule.exports = compile;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"../util/config\":100,\"datalib\":16}],52:[function(require,module,exports){\nvar expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  var graph = model.graph;\n\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = graph.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(graph, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { graph.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};\n},{\"../util/constants\":101,\"./expr\":44}],53:[function(require,module,exports){\nvar dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n\n},{\"../core/Model\":27,\"../core/View\":28,\"../parse/data\":42,\"../parse/interactors\":45,\"../parse/marks\":47,\"../parse/padding\":49,\"../parse/predicates\":50,\"../parse/signals\":52,\"datalib\":16}],54:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      graph = model.graph,\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(def, value, item) {\n    if(!item || !item.scale) {\n      item = (item && item.mark) ? item.mark.group : model.scene().items[0];\n    }\n\n    var scale = item.scale(def.scale.signal || def.scale);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(graph),\n        item = spec.item ? graph.signal(spec.item.signal) : null;\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return graph.doNotPropagate;\n      var val = expr.eval(graph, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val, item ? item.value() : null);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    graph.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(graph);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = graph.signal(name + START,  false);\n    s[MIDDLE] = graph.signal(name + MIDDLE, false);\n    s[END]    = graph.signal(name + END,    false);\n\n    var router = new Node(graph);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return graph.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return graph.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = graph.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(graph, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(graph, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      graph.propagate(cs, node);\n    });\n  })\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":32,\"../dataflow/changeset\":34,\"../util/constants\":101,\"./events\":43,\"./expr\":44,\"datalib\":16}],55:[function(require,module,exports){\nvar dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model.graph);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};\n},{\"../transforms/index\":97,\"datalib\":16}],56:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":59,\"datalib\":16}],57:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":26,\"../../util/config\":100,\"./marks\":59,\"datalib\":16}],58:[function(require,module,exports){\nmodule.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};\n},{\"./Handler\":56,\"./Renderer\":57}],59:[function(require,module,exports){\nvar Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};\n},{\"../../core/Bounds\":26,\"../../util/bounds\":99,\"../../util/config\":100,\"./path\":60}],60:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../core/Bounds\":26}],61:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":100,\"./svg\":63,\"datalib\":16}],62:[function(require,module,exports){\nmodule.exports = {\n  Renderer: require('./Renderer')\n};\n\n},{\"./Renderer\":61}],63:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":100,\"datalib\":16}],64:[function(require,module,exports){\nvar dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;\n},{\"datalib\":16}],65:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./marks\":67,\"datalib\":16}],66:[function(require,module,exports){\narguments[4][58][0].apply(exports,arguments)\n},{\"./Handler\":64,\"./Renderer\":65,\"dup\":58}],67:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../../util/config\":100,\"datalib\":16}],68:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(model, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, model.graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;\n},{\"../dataflow/Node\":32,\"../util/bounds\":99,\"../util/constants\":101,\"../util/debug\":102}],69:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(model, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, model.graph)\n    .router(true)\n    .collector(true);\n\n  this._model = model;\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? model.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._model, this._mark);\n  this._bounder = new Bounder(this._model, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._model.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._model, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._model.graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._model.graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;\n},{\"../dataflow/Node\":32,\"../dataflow/changeset\":34,\"../dataflow/tuple\":35,\"../parse/data\":42,\"../util/constants\":101,\"../util/debug\":102,\"./Bounder\":68,\"./Encoder\":70,\"./Item\":72,\"datalib\":16}],70:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(model, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, model.graph)\n\n  this._model = model;\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      i, len, item;\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans);\n    if(exit)   encode.call(this, exit,   item, input.trans); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans);\n    if(update) encode.call(this, update, item, input.trans);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, stamp) {\n  var model = this._model,\n      enc = prop.encode,\n      sg = this._graph.signalValues(prop.signals||[]),\n      db = (prop.data||[]).reduce(function(db, ds) { \n        return db[ds] = model.data(ds).values(), db;\n      }, {});\n\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, model.predicates());\n}\n\nmodule.exports = Encoder;\n},{\"../dataflow/Node\":32,\"../util/constants\":101,\"../util/debug\":102}],71:[function(require,module,exports){\nvar dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(model, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(model.graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(model, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(model.graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(model.graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._model.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._model.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._model, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._model, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._model, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._model, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;\n},{\"../dataflow/Collector\":29,\"../dataflow/Node\":32,\"../parse/axes\":41,\"../util/constants\":101,\"../util/debug\":102,\"./Builder\":69,\"./Scale\":73,\"datalib\":16}],72:[function(require,module,exports){\nfunction Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;\n},{}],73:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(model, def, parent) {\n  this._model   = model;\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, model.graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.group) return dl.accessor(f.group)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/Node\":32,\"../dataflow/changeset\":34,\"../transforms/Aggregate\":76,\"../util/config\":100,\"../util/constants\":101,\"../util/debug\":102,\"datalib\":16}],74:[function(require,module,exports){\nvar tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;\n},{\"../dataflow/tuple\":35,\"../util/bounds\":99,\"../util/constants\":101}],75:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {group: \"mark.group.height\", mult: -sign}\n      : {group: \"mark.group.width\", mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"../parse/mark\":46,\"../util/config\":100,\"datalib\":16}],76:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;\n},{\"../dataflow/changeset\":34,\"../dataflow/tuple\":35,\"../util/constants\":101,\"../util/debug\":102,\"./GroupBy\":87,\"./Transform\":93,\"./measures\":98,\"datalib\":16}],77:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n\n},{\"../dataflow/Collector\":29,\"./Transform\":93}],78:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bin({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;\n},{\"../dataflow/tuple\":35,\"./Transform\":93,\"datalib\":16}],79:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;\n},{\"../dataflow/Collector\":29,\"../dataflow/changeset\":34,\"../dataflow/tuple\":35,\"../util/debug\":102,\"./Transform\":93}],80:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;\n},{\"../dataflow/changeset\":34,\"../dataflow/tuple\":35,\"../util/constants\":101,\"../util/debug\":102,\"./GroupBy\":87,\"./Transform\":93}],81:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;\n},{\"../dataflow/changeset\":34,\"../parse/expr\":44,\"../util/constants\":101,\"../util/debug\":102,\"./Transform\":93}],82:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;\n},{\"../dataflow/changeset\":34,\"../dataflow/tuple\":35,\"../util/debug\":102,\"./Transform\":93}],83:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"./Transform\":93}],84:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;\n},{\"../dataflow/tuple\":35,\"../parse/expr\":44,\"../util/constants\":101,\"../util/debug\":102,\"./Transform\":93}],85:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"./Transform\":93,\"datalib\":16}],86:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"./Geo\":85,\"./Transform\":93,\"datalib\":16}],87:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;\n},{\"../dataflow/changeset\":34,\"../dataflow/tuple\":35,\"../util/constants\":101,\"./Transform\":93}],88:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;\n},{\"../dataflow/tuple\":35,\"./Transform\":93}],89:[function(require,module,exports){\nvar dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;\n},{\"../parse/expr\":44,\"../util/constants\":101,\"datalib\":16}],90:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"./BatchTransform\":77,\"./Transform\":93,\"datalib\":16}],91:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;\n},{\"../parse/expr\":44,\"../util/debug\":102,\"./Transform\":93,\"datalib\":16}],92:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;\n},{\"../dataflow/tuple\":35,\"./BatchTransform\":77,\"./Transform\":93,\"datalib\":16}],93:[function(require,module,exports){\nvar Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;\n},{\"../dataflow/Node\":32,\"../util/constants\":101,\"./Parameter\":89}],94:[function(require,module,exports){\n(function (global){\nvar dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../dataflow/tuple\":35,\"./BatchTransform\":77,\"./Transform\":93,\"datalib\":16}],95:[function(require,module,exports){\nvar Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;\n},{\"../dataflow/tuple\":35,\"../util/debug\":102,\"./GroupBy\":87,\"./Transform\":93}],96:[function(require,module,exports){\nvar dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;\n},{\"../dataflow/Collector\":29,\"../util/debug\":102,\"./Transform\":93,\"datalib\":16}],97:[function(require,module,exports){\nmodule.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};\n},{\"./Aggregate\":76,\"./Bin\":78,\"./Cross\":79,\"./Facet\":80,\"./Filter\":81,\"./Fold\":82,\"./Force\":83,\"./Formula\":84,\"./Geo\":85,\"./GeoPath\":86,\"./LinkPath\":88,\"./Pie\":90,\"./Sort\":91,\"./Stack\":92,\"./Treemap\":94,\"./Unique\":95,\"./Zip\":96}],98:[function(require,module,exports){\nvar dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;\n},{\"../dataflow/tuple\":35,\"../util/constants\":101,\"../util/quickselect\":103,\"datalib\":16}],99:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../core/Bounds\":26,\"../render/canvas/path\":60,\"./config\":100}],100:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],101:[function(require,module,exports){\nmodule.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};\n},{}],102:[function(require,module,exports){\nvar config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};\n},{\"./config\":100}],103:[function(require,module,exports){\nvar dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};\n},{\"datalib\":16}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW4uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZ2VuZXJhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvY3N2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdG9wb2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdHJlZWpzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdHN2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9pbmZlci10eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvbG9hZGVycy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbXBvcnQvcmVhZC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9sb2cuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3RhdHMuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvc3VtbWFyeS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90ZW1wbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy90cmVlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3RydW5jYXRlLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvaGVhcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9oZWFwL2xpYi9oZWFwLmpzIiwic3JjL2NvcmUvQm91bmRzLmpzIiwic3JjL2NvcmUvTW9kZWwuanMiLCJzcmMvY29yZS9WaWV3LmpzIiwic3JjL2RhdGFmbG93L0NvbGxlY3Rvci5qcyIsInNyYy9kYXRhZmxvdy9EYXRhc291cmNlLmpzIiwic3JjL2RhdGFmbG93L0dyYXBoLmpzIiwic3JjL2RhdGFmbG93L05vZGUuanMiLCJzcmMvZGF0YWZsb3cvU2lnbmFsLmpzIiwic3JjL2RhdGFmbG93L2NoYW5nZXNldC5qcyIsInNyYy9kYXRhZmxvdy90dXBsZS5qcyIsInNyYy9leHByZXNzaW9uL2NvZGVnZW4uanMiLCJzcmMvZXhwcmVzc2lvbi9jb25zdGFudHMuanMiLCJzcmMvZXhwcmVzc2lvbi9mdW5jdGlvbnMuanMiLCJzcmMvZXhwcmVzc2lvbi9pbmRleC5qcyIsInNyYy9leHByZXNzaW9uL3BhcnNlci5qcyIsInNyYy9wYXJzZS9heGVzLmpzIiwic3JjL3BhcnNlL2RhdGEuanMiLCJzcmMvcGFyc2UvZXZlbnRzLmpzIiwic3JjL3BhcnNlL2V4cHIuanMiLCJzcmMvcGFyc2UvaW50ZXJhY3RvcnMuanMiLCJzcmMvcGFyc2UvbWFyay5qcyIsInNyYy9wYXJzZS9tYXJrcy5qcyIsInNyYy9wYXJzZS9tb2RpZnkuanMiLCJzcmMvcGFyc2UvcGFkZGluZy5qcyIsInNyYy9wYXJzZS9wcmVkaWNhdGVzLmpzIiwic3JjL3BhcnNlL3Byb3BlcnRpZXMuanMiLCJzcmMvcGFyc2Uvc2lnbmFscy5qcyIsInNyYy9wYXJzZS9zcGVjLmpzIiwic3JjL3BhcnNlL3N0cmVhbXMuanMiLCJzcmMvcGFyc2UvdHJhbnNmb3Jtcy5qcyIsInNyYy9yZW5kZXIvY2FudmFzL0hhbmRsZXIuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvY2FudmFzL2luZGV4LmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3MuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9wYXRoLmpzIiwic3JjL3JlbmRlci9zdmcteG1sL1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9zdmcteG1sL2luZGV4LmpzIiwic3JjL3JlbmRlci9zdmcteG1sL3N2Zy5qcyIsInNyYy9yZW5kZXIvc3ZnL0hhbmRsZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy9SZW5kZXJlci5qcyIsInNyYy9yZW5kZXIvc3ZnL21hcmtzLmpzIiwic3JjL3NjZW5lL0JvdW5kZXIuanMiLCJzcmMvc2NlbmUvQnVpbGRlci5qcyIsInNyYy9zY2VuZS9FbmNvZGVyLmpzIiwic3JjL3NjZW5lL0dyb3VwQnVpbGRlci5qcyIsInNyYy9zY2VuZS9JdGVtLmpzIiwic3JjL3NjZW5lL1NjYWxlLmpzIiwic3JjL3NjZW5lL1RyYW5zaXRpb24uanMiLCJzcmMvc2NlbmUvYXhpcy5qcyIsInNyYy90cmFuc2Zvcm1zL0FnZ3JlZ2F0ZS5qcyIsInNyYy90cmFuc2Zvcm1zL0JhdGNoVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvQmluLmpzIiwic3JjL3RyYW5zZm9ybXMvQ3Jvc3MuanMiLCJzcmMvdHJhbnNmb3Jtcy9GYWNldC5qcyIsInNyYy90cmFuc2Zvcm1zL0ZpbHRlci5qcyIsInNyYy90cmFuc2Zvcm1zL0ZvbGQuanMiLCJzcmMvdHJhbnNmb3Jtcy9Gb3JjZS5qcyIsInNyYy90cmFuc2Zvcm1zL0Zvcm11bGEuanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW8uanMiLCJzcmMvdHJhbnNmb3Jtcy9HZW9QYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvR3JvdXBCeS5qcyIsInNyYy90cmFuc2Zvcm1zL0xpbmtQYXRoLmpzIiwic3JjL3RyYW5zZm9ybXMvUGFyYW1ldGVyLmpzIiwic3JjL3RyYW5zZm9ybXMvUGllLmpzIiwic3JjL3RyYW5zZm9ybXMvU29ydC5qcyIsInNyYy90cmFuc2Zvcm1zL1N0YWNrLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJhbnNmb3JtLmpzIiwic3JjL3RyYW5zZm9ybXMvVHJlZW1hcC5qcyIsInNyYy90cmFuc2Zvcm1zL1VuaXF1ZS5qcyIsInNyYy90cmFuc2Zvcm1zL1ppcC5qcyIsInNyYy90cmFuc2Zvcm1zL2luZGV4LmpzIiwic3JjL3RyYW5zZm9ybXMvbWVhc3VyZXMuanMiLCJzcmMvdXRpbC9ib3VuZHMuanMiLCJzcmMvdXRpbC9jb25maWcuanMiLCJzcmMvdXRpbC9jb25zdGFudHMuanMiLCJzcmMvdXRpbC9kZWJ1Zy5qcyIsInNyYy91dGlsL3F1aWNrc2VsZWN0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ25OQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2owRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdlBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcmtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDanVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29yZToge1xuICAgIFZpZXc6IHJlcXVpcmUoJy4vY29yZS9WaWV3JylcbiAgfSxcbiAgZGF0YWZsb3c6IHtcbiAgICBjaGFuZ2VzZXQ6IHJlcXVpcmUoJy4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgRGF0YXNvdXJjZTogcmVxdWlyZSgnLi9kYXRhZmxvdy9EYXRhc291cmNlJyksXG4gICAgR3JhcGg6IHJlcXVpcmUoJy4vZGF0YWZsb3cvR3JhcGgnKSxcbiAgICBOb2RlOiByZXF1aXJlKCcuL2RhdGFmbG93L05vZGUnKVxuICB9LFxuICBwYXJzZToge1xuICAgIHNwZWM6IHJlcXVpcmUoJy4vcGFyc2Uvc3BlYycpXG4gIH0sXG4gIHNjZW5lOiB7XG4gICAgQnVpbGRlcjogcmVxdWlyZSgnLi9zY2VuZS9CdWlsZGVyJyksXG4gICAgR3JvdXBCdWlsZGVyOiByZXF1aXJlKCcuL3NjZW5lL0dyb3VwQnVpbGRlcicpXG4gIH0sXG4gIHRyYW5zZm9ybXM6IHJlcXVpcmUoJy4vdHJhbnNmb3Jtcy9pbmRleCcpLFxuICBjb25maWc6IHJlcXVpcmUoJy4vdXRpbC9jb25maWcnKSxcbiAgdXRpbDogcmVxdWlyZSgnZGF0YWxpYicpXG59OyIsbnVsbCwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgdmFyIG1heGIgPSBvcHQubWF4YmlucyB8fCAxMDI0LFxuICAgICAgYmFzZSA9IG9wdC5iYXNlIHx8IDEwLFxuICAgICAgZGl2ID0gb3B0LmRpdiB8fCBbNSwgMl0sXG4gICAgICBtaW5zID0gb3B0Lm1pbnN0ZXAgfHwgMCxcbiAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYiksXG4gICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgbWF4ID0gb3B0Lm1heCxcbiAgICAgIHNwYW4gPSBtYXggLSBtaW4sXG4gICAgICBzdGVwID0gTWF0aC5tYXgobWlucywgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpKSxcbiAgICAgIG5iaW5zID0gTWF0aC5jZWlsKHNwYW4gLyBzdGVwKSxcbiAgICAgIHByZWNpc2lvbiwgdiwgaSwgZXBzO1xuXG4gIGlmIChvcHQuc3RlcCAhPSBudWxsKSB7XG4gICAgc3RlcCA9IG9wdC5zdGVwO1xuICB9IGVsc2UgaWYgKG9wdC5zdGVwcykge1xuICAgIC8vIGlmIHByb3ZpZGVkLCBsaW1pdCBjaG9pY2UgdG8gYWNjZXB0YWJsZSBzdGVwIHNpemVzXG4gICAgc3RlcCA9IG9wdC5zdGVwc1tNYXRoLm1pbihcbiAgICAgICAgb3B0LnN0ZXBzLmxlbmd0aCAtIDEsXG4gICAgICAgIGJpc2VjdExlZnQob3B0LnN0ZXBzLCBzcGFuIC8gbWF4YiwgMCwgb3B0LnN0ZXBzLmxlbmd0aClcbiAgICApXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHtcbiAgICAgIHN0ZXAgKj0gYmFzZTtcbiAgICAgIG5iaW5zID0gTWF0aC5jZWlsKHNwYW4gLyBzdGVwKTtcbiAgICB9IHdoaWxlIChuYmlucyA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnMgJiYgc3BhbiAvIHYgPD0gbWF4Yikge1xuICAgICAgICBzdGVwID0gdjtcbiAgICAgICAgbmJpbnMgPSBNYXRoLmNlaWwoc3BhbiAvIHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcmVjaXNpb24sIG1pbiBhbmQgbWF4XG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxO1xuICBlcHMgPSAobWluPDAgPyAtMSA6IDEpICogTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogbWF4LFxuICAgIHN0ZXA6IHN0ZXAsXG4gICAgdW5pdDogcHJlY2lzaW9uXG4gIH07XG59O1xuXG5mdW5jdGlvbiBiaXNlY3RMZWZ0KGEsIHgsIGxvLCBoaSkge1xuICB3aGlsZSAobG8gPCBoaSkge1xuICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgIGlmICh1LmNtcChhW21pZF0sIHgpIDwgMCkgeyBsbyA9IG1pZCArIDE7IH1cbiAgICBlbHNlIHsgaGkgPSBtaWQ7IH1cbiAgfVxuICByZXR1cm4gbG87XG59IiwidmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmdlbi5yZXBlYXQgPSBmdW5jdGlvbih2YWwsIG4pIHtcbiAgdmFyIGEgPSBBcnJheShuKSwgaTtcbiAgZm9yIChpPTA7IGk8bjsgKytpKSBhW2ldID0gdmFsO1xuICByZXR1cm4gYTtcbn07XG5cbmdlbi56ZXJvZXMgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuXHRtaW4gPSBtaW4gfHwgMDtcblx0bWF4ID0gbWF4IHx8IDE7XG5cdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblx0dmFyIGYgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbWluICsgZGVsdGEgKiBNYXRoLnJhbmRvbSgpO1xuXHR9O1xuXHRmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb2VzKG4pLm1hcChmKTsgfTtcblx0cmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLmludGVnZXIgPSBmdW5jdGlvbihhLCBiKSB7XG5cdGlmIChiID09PSB1bmRlZmluZWQpIHtcblx0XHRiID0gYTtcblx0XHRhID0gMDtcblx0fVxuXHR2YXIgZiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBhICsgTWF0aC5tYXgoMCwgTWF0aC5mbG9vcihiKihNYXRoLnJhbmRvbSgpLTAuMDAxKSkpO1xuXHR9O1xuXHRmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb2VzKG4pLm1hcChmKTsgfTtcblx0cmV0dXJuIGY7XG59O1xuXG5nZW4ucmFuZG9tLm5vcm1hbCA9IGZ1bmN0aW9uKG1lYW4sIHN0ZGV2KSB7XG5cdG1lYW4gPSBtZWFuIHx8IDA7XG5cdHN0ZGV2ID0gc3RkZXYgfHwgMTtcblx0dmFyIG5leHQgPSB1bmRlZmluZWQ7XG5cdHZhciBmID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHggPSAwLCB5ID0gMCwgcmRzLCBjO1xuXHRcdGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHggPSBuZXh0O1xuXHRcdFx0bmV4dCA9IHVuZGVmaW5lZDtcblx0XHRcdHJldHVybiB4O1xuXHRcdH1cblx0XHRkbyB7XG5cdFx0XHR4ID0gTWF0aC5yYW5kb20oKSoyLTE7XG5cdFx0XHR5ID0gTWF0aC5yYW5kb20oKSoyLTE7XG5cdFx0XHRyZHMgPSB4KnggKyB5Knk7XG5cdFx0fSB3aGlsZSAocmRzID09IDAgfHwgcmRzID4gMSk7XG5cdFx0YyA9IE1hdGguc3FydCgtMipNYXRoLmxvZyhyZHMpL3Jkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG5cdFx0bmV4dCA9IG1lYW4gKyB5KmMqc3RkZXY7XG5cdFx0cmV0dXJuIG1lYW4gKyB4KmMqc3RkZXY7XG5cdH07XG5cdGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvZXMobikubWFwKGYpOyB9O1xuXHRyZXR1cm4gZjtcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIHZhciBkID0gZDMuY3N2LnBhcnNlKGRhdGEgPyBkYXRhLnRvU3RyaW5nKCkgOiBkYXRhKTtcbiAgcmV0dXJuIGQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGpzb246IHJlcXVpcmUoJy4vanNvbicpLFxuICBjc3Y6IHJlcXVpcmUoJy4vY3N2JyksXG4gIHRzdjogcmVxdWlyZSgnLi90c3YnKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSB1dGlsLmlzT2JqZWN0KGRhdGEpID8gZGF0YSA6IEpTT04ucGFyc2UoZGF0YSk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnByb3BlcnR5KSB7XG4gICAgZCA9IHV0aWwuYWNjZXNzb3IoZm9ybWF0LnByb3BlcnR5KShkKTtcbiAgfVxuICByZXR1cm4gZDtcbn07XG4iLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xudmFyIHRvcG9qc29uID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cudG9wb2pzb24gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLnRvcG9qc29uIDogbnVsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIGlmICh0b3BvanNvbiA9PSBudWxsKSB7IHRocm93IEVycm9yKFwiVG9wb0pTT04gbGlicmFyeSBub3QgbG9hZGVkLlwiKTsgfVxuXG4gIHZhciB0ID0ganNvbihkYXRhLCBmb3JtYXQpLCBvYmo7XG5cbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQuZmVhdHVyZSkge1xuICAgIGlmIChvYmogPSB0Lm9iamVjdHNbZm9ybWF0LmZlYXR1cmVdKSB7XG4gICAgICByZXR1cm4gdG9wb2pzb24uZmVhdHVyZSh0LCBvYmopLmZlYXR1cmVzXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBUb3BvSlNPTiBvYmplY3Q6IFwiK2Zvcm1hdC5mZWF0dXJlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZm9ybWF0ICYmIGZvcm1hdC5tZXNoKSB7XG4gICAgaWYgKG9iaiA9IHQub2JqZWN0c1tmb3JtYXQubWVzaF0pIHtcbiAgICAgIHJldHVybiBbdG9wb2pzb24ubWVzaCh0LCB0Lm9iamVjdHNbZm9ybWF0Lm1lc2hdKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBUb3BvSlNPTiBvYmplY3Q6IFwiICsgZm9ybWF0Lm1lc2gpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcIk1pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci5cIik7XG4gIH1cblxuICByZXR1cm4gW107XG59O1xuIiwidmFyIHRyZWUgPSByZXF1aXJlKCcuLi8uLi90cmVlJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdHJlZS50b1RhYmxlKGRhdGEsIChmb3JtYXQgJiYgZm9ybWF0LmNoaWxkcmVuKSk7XG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICB2YXIgZCA9IGQzLnRzdi5wYXJzZShkYXRhID8gZGF0YS50b1N0cmluZygpIDogZGF0YSk7XG4gIHJldHVybiBkO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgdGVzdHMgPSB7XG4gIGJvb2w6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg9PT1cInRydWVcIiB8fCB4PT09XCJmYWxzZVwiIHx8IHV0aWwuaXNCb29sZWFuKHgpOyB9LFxuICBkYXRlOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oRGF0ZS5wYXJzZSh4KSk7IH0sXG4gIG51bTogZnVuY3Rpb24oeCkgeyByZXR1cm4gIWlzTmFOKCt4KSAmJiAhdXRpbC5pc0RhdGUoeCk7IH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBpLCBqLCB2O1xuICBcbiAgLy8gdHlwZXMgdG8gdGVzdCBmb3JcbiAgdmFyIHR5cGVzID0gW1xuICAgIHt0eXBlOiBcImJvb2xlYW5cIiwgdGVzdDogdGVzdHMuYm9vbH0sXG4gICAge3R5cGU6IFwibnVtYmVyXCIsIHRlc3Q6IHRlc3RzLm51bX0sXG4gICAge3R5cGU6IFwiZGF0ZVwiLCB0ZXN0OiB0ZXN0cy5kYXRlfVxuICBdO1xuICBcbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gZ2V0IG5leHQgdmFsdWUgdG8gdGVzdFxuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIC8vIHRlc3QgdmFsdWUgYWdhaW5zdCByZW1haW5pbmcgdHlwZXNcbiAgICBmb3IgKGo9MDsgajx0eXBlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKHYgIT0gbnVsbCAmJiAhdHlwZXNbal0udGVzdCh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cbiAgXG4gIHJldHVybiB0eXBlc1swXS50eXBlO1xufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhYnNvbHV0ZSBVUkxzIHdpdGggb3B0aW9uYWwgcHJvdG9jb2xcbi8vICAgaHR0cHM6Ly8uLi4gICAgZmlsZTovLy4uLiAgICAvLy4uLlxudmFyIHByb3RvY29sX3JlID0gL14oW0EtWmEtel0rOik/XFwvXFwvLztcblxuLy8gU3BlY2lhbCB0cmVhdG1lbnQgaW4gbm9kZS5qcyBmb3IgdGhlIGZpbGU6IHByb3RvY29sXG52YXIgZmlsZVByb3RvY29sID0gJ2ZpbGU6Ly8nO1xuXG4vLyBWYWxpZGF0ZSBhbmQgY2xlYW51cCBVUkwgdG8gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBiZSBhY2Nlc3NlZFxuLy8gUmV0dXJucyBjbGVhbmVkIHVwIFVSTCwgb3IgZmFsc2UgaWYgYWNjZXNzIGlzIG5vdCBhbGxvd2VkXG5mdW5jdGlvbiBzYW5pdGl6ZVVybChvcHQpIHtcbiAgdmFyIHVybCA9IG9wdC51cmw7XG4gIGlmICghdXJsICYmIG9wdC5maWxlKSB7IHJldHVybiBmaWxlUHJvdG9jb2wgKyBvcHQuZmlsZTsgfVxuXG4gIC8vIEluIGNhc2UgdGhpcyBpcyBhIHJlbGF0aXZlIHVybCAoaGFzIG5vIGhvc3QpLCBwcmVwZW5kIG9wdC5iYXNlVVJMXG4gIGlmIChvcHQuYmFzZVVSTCAmJiAhcHJvdG9jb2xfcmUudGVzdCh1cmwpKSB7XG4gICAgaWYgKCF1dGlsLnN0YXJ0c1dpdGgodXJsLCAnLycpICYmIG9wdC5iYXNlVVJMW29wdC5iYXNlVVJMLmxlbmd0aC0xXSAhPT0gJy8nKSB7XG4gICAgICB1cmwgPSAnLycgKyB1cmw7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgc2xhc2ggYmV0d2VlbiB0aGUgYmFzZVVSTCAoZS5nLiBob3N0bmFtZSkgYW5kIHVybFxuICAgIH1cbiAgICB1cmwgPSBvcHQuYmFzZVVSTCArIHVybDtcbiAgfVxuICAvLyByZWxhdGl2ZSBwcm90b2NvbCwgc3RhcnRzIHdpdGggJy8vJ1xuICBpZiAodXRpbC5pc05vZGUgJiYgdXRpbC5zdGFydHNXaXRoKHVybCwgJy8vJykpIHtcbiAgICB1cmwgPSAob3B0LmRlZmF1bHRQcm90b2NvbCB8fCAnaHR0cCcpICsgJzonICsgdXJsO1xuICB9XG4gIC8vIElmIG9wdC5kb21haW5XaGl0ZUxpc3QgaXMgc2V0LCBvbmx5IGFsbG93cyB1cmwsIHdob3NlIGhvc3RuYW1lXG4gIC8vICogSXMgdGhlIHNhbWUgYXMgdGhlIG9yaWdpbiAod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKVxuICAvLyAqIEVxdWFscyBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIC8vICogSXMgYSBwcm9wZXIgc3ViZG9tYWluIG9mIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgaWYgKG9wdC5kb21haW5XaGl0ZUxpc3QpIHtcbiAgICB2YXIgZG9tYWluLCBvcmlnaW47XG4gICAgaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgICAvLyByZWxhdGl2ZSBwcm90b2NvbCBpcyBicm9rZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtdXJsL2lzc3Vlcy81XG4gICAgICB2YXIgcGFydHMgPSByZXF1aXJlKCd1cmwnKS5wYXJzZSh1cmwpO1xuICAgICAgZG9tYWluID0gcGFydHMuaG9zdG5hbWU7XG4gICAgICBvcmlnaW4gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgIC8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzY1MTMvaG93LWRvLWktcGFyc2UtYS11cmwtaW50by1ob3N0bmFtZS1hbmQtcGF0aC1pbi1qYXZhc2NyaXB0XG4gICAgICAvLyBJRSBkb2Vzbid0IHBvcHVsYXRlIGFsbCBsaW5rIHByb3BlcnRpZXMgd2hlbiBzZXR0aW5nIC5ocmVmIHdpdGggYSByZWxhdGl2ZSBVUkwsXG4gICAgICAvLyBob3dldmVyIC5ocmVmIHdpbGwgcmV0dXJuIGFuIGFic29sdXRlIFVSTCB3aGljaCB0aGVuIGNhbiBiZSB1c2VkIG9uIGl0c2VsZlxuICAgICAgLy8gdG8gcG9wdWxhdGUgdGhlc2UgYWRkaXRpb25hbCBmaWVsZHMuXG4gICAgICBpZiAoYS5ob3N0ID09IFwiXCIpIHtcbiAgICAgICAgYS5ocmVmID0gYS5ocmVmO1xuICAgICAgfVxuICAgICAgZG9tYWluID0gYS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikge1xuICAgICAgdmFyIHdoaXRlTGlzdGVkID0gb3B0LmRvbWFpbldoaXRlTGlzdC5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBpZHggPSBkb21haW4ubGVuZ3RoIC0gZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkID09PSBkb21haW4gfHxcbiAgICAgICAgICAoaWR4ID4gMSAmJiBkb21haW5baWR4LTFdID09PSAnLicgJiYgZG9tYWluLmxhc3RJbmRleE9mKGQpID09PSBpZHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXdoaXRlTGlzdGVkKSB7XG4gICAgICAgIHRocm93ICdVUkwgaXMgbm90IHdoaXRlbGlzdGVkOiAnICsgdXJsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBsb2FkKG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZSkgeyB0aHJvdyBlOyB9O1xuICBcbiAgdHJ5IHtcbiAgICB2YXIgdXJsID0gbG9hZC5zYW5pdGl6ZVVybChvcHQpOyAvLyBlbmFibGUgb3ZlcnJpZGVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IoZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIGVycm9yKCdJbnZhbGlkIFVSTDogJyArIHVybCk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOb2RlKSB7XG4gICAgLy8gaW4gYnJvd3NlciwgdXNlIHhoclxuICAgIHJldHVybiB4aHIodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodXRpbC5zdGFydHNXaXRoKHVybCwgZmlsZVByb3RvY29sKSkge1xuICAgIC8vIGluIG5vZGUuanMsIGlmIHVybCBzdGFydHMgd2l0aCAnZmlsZTovLycsIHN0cmlwIGl0IGFuZCBsb2FkIGZyb20gZmlsZVxuICAgIHJldHVybiBmaWxlKHVybC5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKSwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgaW4gbm9kZS5qc1xuICAgIHJldHVybiBodHRwKHVybCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gXCJ0ZXh0XCJcbiAgICAgID8gcmVxdWVzdC5yZXNwb25zZSAvLyBudWxsIG9uIGVycm9yXG4gICAgICA6IHJlcXVlc3QucmVzcG9uc2VUZXh0OyAvLyBcIlwiIG9uIGVycm9yXG59XG5cbmZ1bmN0aW9uIHhocih1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICAvLyBJZiBJRSBkb2VzIG5vdCBzdXBwb3J0IENPUlMsIHVzZSBYRG9tYWluUmVxdWVzdCAoY29waWVkIGZyb20gZDMueGhyKVxuICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdFxuICAgICAgJiYgIShcIndpdGhDcmVkZW50aWFsc1wiIGluIHJlcXVlc3QpXG4gICAgICAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0O1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzO1xuICAgIGlmICghc3RhdHVzICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlcXVlc3QsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3luYykge1xuICAgIFwib25sb2FkXCIgaW4gcmVxdWVzdFxuICAgICAgPyByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmRcbiAgICAgIDogcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHsgcmVxdWVzdC5yZWFkeVN0YXRlID4gMyAmJiByZXNwb25kKCk7IH07XG4gIH1cbiAgXG4gIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIGFzeW5jKTtcbiAgcmVxdWVzdC5zZW5kKCk7XG4gIFxuICBpZiAoIWFzeW5jICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGUoZmlsZSwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgfVxuICByZXF1aXJlKCdmcycpLnJlYWRGaWxlKGZpbGUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3luYy1yZXF1ZXN0JykoJ0dFVCcsIHVybCkuZ2V0Qm9keSgpO1xuICB9XG4gIHJlcXVpcmUoJ3JlcXVlc3QnKSh1cmwsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmxvYWQuc2FuaXRpemVVcmwgPSBzYW5pdGl6ZVVybDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgbG9hZCA9IHJlcXVpcmUoJy4vbG9hZCcpO1xudmFyIHJlYWQgPSByZXF1aXJlKCcuL3JlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsXG4gIC5rZXlzKHJlYWQuZm9ybWF0cylcbiAgLnJlZHVjZShmdW5jdGlvbihvdXQsIHR5cGUpIHtcbiAgICBvdXRbdHlwZV0gPSBmdW5jdGlvbihvcHQsIGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIHByb2Nlc3MgYXJndW1lbnRzXG4gICAgICBpZiAodXRpbC5pc1N0cmluZyhvcHQpKSBvcHQgPSB7dXJsOiBvcHR9O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdXRpbC5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHJlYWQgZm9ybWF0XG4gICAgICBmb3JtYXQgPSB1dGlsLmV4dGVuZCh7cGFyc2U6ICdhdXRvJ30sIGZvcm1hdCk7XG4gICAgICBmb3JtYXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIGxvYWQgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBsb2FkKG9wdCwgY2FsbGJhY2sgPyBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChhc3luYylcbiAgICAgICAgICBkYXRhID0gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoc3luYylcbiAgICAgIGlmIChkYXRhKSByZXR1cm4gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbiAgfSwge30pO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xudmFyIGluZmVyID0gcmVxdWlyZSgnLi9pbmZlci10eXBlcycpO1xuXG52YXIgUEFSU0VSUyA9IHtcbiAgXCJudW1iZXJcIjogdXRpbC5udW1iZXIsXG4gIFwiYm9vbGVhblwiOiB1dGlsLmJvb2xlYW4sXG4gIFwiZGF0ZVwiOiB1dGlsLmRhdGVcbn07XG5cbmZ1bmN0aW9uIHJlYWQoZGF0YSwgZm9ybWF0KSB7XG4gIHZhciB0eXBlID0gKGZvcm1hdCAmJiBmb3JtYXQudHlwZSkgfHwgXCJqc29uXCI7XG4gIGRhdGEgPSBmb3JtYXRzW3R5cGVdKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnBhcnNlKSBwYXJzZShkYXRhLCBmb3JtYXQucGFyc2UpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMpIHtcbiAgdmFyIGNvbHMsIHBhcnNlcnMsIGQsIGksIGosIGNsZW4sIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gIGlmICh0eXBlcyA9PT0gJ2F1dG8nKSB7XG4gICAgLy8gcGVyZm9ybSB0eXBlIGluZmVyZW5jZVxuICAgIHR5cGVzID0gdXRpbC5rZXlzKGRhdGFbMF0pLnJlZHVjZShmdW5jdGlvbih0eXBlcywgYykge1xuICAgICAgdmFyIHR5cGUgPSBpbmZlcihkYXRhLCB1dGlsLmFjY2Vzc29yKGMpKTtcbiAgICAgIGlmIChQQVJTRVJTW3R5cGVdKSB0eXBlc1tjXSA9IHR5cGU7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfSwge30pO1xuICB9XG4gIGNvbHMgPSB1dGlsLmtleXModHlwZXMpO1xuICBwYXJzZXJzID0gY29scy5tYXAoZnVuY3Rpb24oYykgeyByZXR1cm4gUEFSU0VSU1t0eXBlc1tjXV07IH0pO1xuXG4gIGZvciAoaT0wLCBjbGVuPWNvbHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgZCA9IGRhdGFbaV07XG4gICAgZm9yIChqPTA7IGo8Y2xlbjsgKytqKSB7XG4gICAgICBkW2NvbHNbal1dID0gcGFyc2Vyc1tqXShkW2NvbHNbal1dKTtcbiAgICB9XG4gIH1cbn1cblxucmVhZC5pbmZlciA9IGluZmVyO1xucmVhZC5mb3JtYXRzID0gZm9ybWF0cztcbnJlYWQucGFyc2UgPSBwYXJzZTtcbm1vZHVsZS5leHBvcnRzID0gcmVhZDtcbiIsInZhciBkbCA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG51dGlsLmV4dGVuZChkbCwgdXRpbCk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9nZW5lcmF0ZScpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL3N0YXRzJykpO1xuZGwuYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbmRsLnN1bW1hcnkgPSByZXF1aXJlKCcuL3N1bW1hcnknKTtcbmRsLnRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpO1xuZGwudHJ1bmNhdGUgPSByZXF1aXJlKCcuL3RydW5jYXRlJyk7XG5cbmRsLmxvYWQgPSByZXF1aXJlKCcuL2ltcG9ydC9sb2FkJyk7XG5kbC5yZWFkID0gcmVxdWlyZSgnLi9pbXBvcnQvcmVhZCcpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vaW1wb3J0L2xvYWRlcnMnKSk7XG5cbnZhciBsb2cgPSByZXF1aXJlKCcuL2xvZycpO1xuZGwubG9nID0gZnVuY3Rpb24obXNnKSB7IGxvZyhtc2csIGxvZy5MT0cpOyB9O1xuZGwubG9nLnNpbGVudCA9IGxvZy5zaWxlbnQ7XG5kbC5lcnJvciA9IGZ1bmN0aW9uKG1zZykgeyBsb2cobXNnLCBsb2cuRVJSKTsgfTtcbiIsInZhciBMT0cgPSBcIkxPR1wiO1xudmFyIEVSUiA9IFwiRVJSXCI7XG52YXIgc2lsZW50ID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHByZXBhcmUobXNnLCB0eXBlKSB7XG4gIHJldHVybiAnWycgKyBbXG4gICAgJ1wiJysodHlwZSB8fCBMT0cpKydcIicsXG4gICAgRGF0ZS5ub3coKSxcbiAgICAnXCInK21zZysnXCInXG4gIF0uam9pbihcIiwgXCIpICsgJ10nO1xufVxuXG5mdW5jdGlvbiBsb2cobXNnLCB0eXBlKSB7XG4gIGlmICghc2lsZW50KSB7XG4gICAgbXNnID0gcHJlcGFyZShtc2csIHR5cGUpO1xuICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgfVxufVxuXG5sb2cuc2lsZW50ID0gZnVuY3Rpb24odmFsKSB7IHNpbGVudCA9ICEhdmFsOyB9O1xuXG5sb2cuTE9HID0gTE9HO1xubG9nLkVSUiA9IEVSUjtcbm1vZHVsZS5leHBvcnRzID0gbG9nOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgc3RhdHMgPSB7fTtcblxuc3RhdHMudW5pcXVlID0gZnVuY3Rpb24odmFsdWVzLCBmLCByZXN1bHRzKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiBbXTtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIHZhciB1ID0ge30sIHYsIGk7XG4gIGZvciAoaT0wLCBuPXZhbHVlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgaW4gdSkge1xuICAgICAgdVt2XSArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICB1W3ZdID0gMTtcbiAgICAgIHJlc3VsdHMucHVzaCh2KTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0cy5jb3VudHMgPSB1O1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdiwgaSwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ICE9IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuc3RhdHMuY291bnQuZGlzdGluY3QgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIHZhciB1ID0ge30sIHYsIGksIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiBpbiB1KSBjb250aW51ZTtcbiAgICB1W3ZdID0gMTtcbiAgICBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbnN0YXRzLmNvdW50Lm51bGxzID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdiwgaSwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ID09IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuc3RhdHMubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcChmKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzTm90TnVsbCkuc29ydCh1dGlsLmNtcCk7XG4gIHZhciBoYWxmID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoLzIpO1xuICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICByZXR1cm4gdmFsdWVzW2hhbGZdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodmFsdWVzW2hhbGYtMV0gKyB2YWx1ZXNbaGFsZl0pIC8gMi4wO1xuICB9XG59O1xuXG5zdGF0cy5tZWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgbWVhbiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuc3RhdHMudmFyaWFuY2UgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIHZhciBtZWFuID0gMCwgTTIgPSAwLCBkZWx0YSwgaSwgYywgdjtcbiAgZm9yIChpPTAsIGM9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHYgLSBtZWFuKTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvIChjIC0gMSk7XG4gIHJldHVybiBNMjtcbn07XG5cbnN0YXRzLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UodmFsdWVzLCBmKSk7XG59O1xuXG5zdGF0cy5za2V3ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhdmcgPSBzdGF0cy5tZWFuKHZhbHVlcywgZiksXG4gICAgICBtZWQgPSBzdGF0cy5tZWRpYW4odmFsdWVzLCBmKSxcbiAgICAgIHN0ZCA9IHN0YXRzLnN0ZGV2KHZhbHVlcywgZik7XG4gIHJldHVybiBzdGQgPT09IDAgPyAwIDogKGF2ZyAtIG1lZCkgLyBzdGQ7XG59O1xuXG5zdGF0cy5taW5tYXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIHMgPSB7bWluOiArSW5maW5pdHksIG1heDogLUluZmluaXR5fSwgdiwgaSwgbjtcbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgaWYgKHYgPiBzLm1heCkgcy5tYXggPSB2O1xuICAgICAgaWYgKHYgPCBzLm1pbikgcy5taW4gPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbnN0YXRzLm1pbkluZGV4ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09MCkgcmV0dXJuIC0xO1xuICB2YXIgaWR4ID0gMCwgdiwgaSwgbiwgbWluID0gK0luZmluaXR5O1xuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiAhPSBudWxsICYmIHYgPCBtaW4pIHsgbWluID0gdjsgaWR4ID0gaTsgfVxuICB9XG4gIHJldHVybiBpZHg7XG59O1xuXG5zdGF0cy5tYXhJbmRleCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PTApIHJldHVybiAtMTtcbiAgdmFyIGlkeCA9IDAsIHYsIGksIG4sIG1heCA9IC1JbmZpbml0eTtcbiAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCAmJiB2ID4gbWF4KSB7IG1heCA9IHY7IGlkeCA9IGk7IH1cbiAgfVxuICByZXR1cm4gaWR4O1xufTtcblxuc3RhdHMuZW50cm9weSA9IGZ1bmN0aW9uKGNvdW50cykge1xuICB2YXIgaSwgcCwgcyA9IDAsIEggPSAwO1xuICBmb3IgKGk9MDsgaTxjb3VudHMubGVuZ3RoOyArK2kpIHtcbiAgICBzICs9IGNvdW50c1tpXTtcbiAgfVxuICBpZiAocyA9PT0gMCkgcmV0dXJuIDA7XG4gIGZvciAoaT0wOyBpPGNvdW50cy5sZW5ndGg7ICsraSkge1xuICAgIHAgPSBjb3VudHNbaV0gLyBzO1xuICAgIGlmIChwID4gMCkgSCArPSBwICogTWF0aC5sb2cocCkgLyBNYXRoLkxOMjtcbiAgfVxuICByZXR1cm4gLUg7XG59O1xuXG5zdGF0cy5lbnRyb3B5Lm5vcm1hbGl6ZWQgPSBmdW5jdGlvbihjb3VudHMpIHtcbiAgdmFyIEggPSBzdGF0cy5lbnRyb3B5KGNvdW50cyk7XG4gIHZhciBtYXggPSAtTWF0aC5sb2coMS9jb3VudHMubGVuZ3RoKSAvIE1hdGguTE4yO1xuICByZXR1cm4gSCAvIG1heDtcbn07XG5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gaW5pdFxuICB2YXIgcCA9IHt9LFxuICAgICAgbWVhbiA9IDAsXG4gICAgICBjb3VudCA9IDAsXG4gICAgICBkaXN0aW5jdCA9IDAsXG4gICAgICBtaW4gPSBmID8gZih2YWx1ZXNbMF0pIDogdmFsdWVzWzBdLFxuICAgICAgbWF4ID0gbWluLFxuICAgICAgTTIgPSAwLFxuICAgICAgbWVkaWFuID0gbnVsbCxcbiAgICAgIHZhbHMgPSBbXSxcbiAgICAgIHUgPSB7fSwgZGVsdGEsIHNkLCBpLCB2LCB4LCBoYWxmO1xuXG4gIC8vIGNvbXB1dGUgc3VtbWFyeSBzdGF0c1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgIC8vIHVwZGF0ZSB1bmlxdWUgdmFsdWVzXG4gICAgICB1W3ZdID0gKHYgaW4gdSkgPyB1W3ZdICsgMSA6IChkaXN0aW5jdCArPSAxLCAxKTtcbiAgICAgIC8vIHVwZGF0ZSBtaW4vbWF4XG4gICAgICBpZiAodiA8IG1pbikgbWluID0gdjtcbiAgICAgIGlmICh2ID4gbWF4KSBtYXggPSB2O1xuICAgICAgLy8gdXBkYXRlIHN0YXRzXG4gICAgICB4ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2NvdW50KTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoY291bnQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIGNvbXB1dGUgbWVkaWFuXG4gIHZhbHMuc29ydCh1dGlsLmNtcCk7XG4gIGhhbGYgPSBNYXRoLmZsb29yKHZhbHMubGVuZ3RoLzIpO1xuICBtZWRpYW4gPSAodmFscy5sZW5ndGggJSAyKVxuICAgPyB2YWxzW2hhbGZdXG4gICA6ICh2YWxzW2hhbGYtMV0gKyB2YWxzW2hhbGZdKSAvIDIuMDtcblxuICByZXR1cm4ge1xuICAgIHVuaXF1ZTogICB1LFxuICAgIGNvdW50OiAgICBjb3VudCxcbiAgICBudWxsczogICAgdmFsdWVzLmxlbmd0aCAtIGNvdW50LFxuICAgIGRpc3RpbmN0OiBkaXN0aW5jdCxcbiAgICBtaW46ICAgICAgbWluLFxuICAgIG1heDogICAgICBtYXgsXG4gICAgbWVhbjogICAgIG1lYW4sXG4gICAgbWVkaWFuOiAgIG1lZGlhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgc2tldzogICAgIHNkID09PSAwID8gMCA6IChtZWFuIC0gbWVkaWFuKSAvIHNkXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YXRzOyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgc3RhdHMgPSByZXF1aXJlKCcuL3N0YXRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZmllbGRzKSB7XG4gIGlmIChkYXRhID09IG51bGwgfHwgZGF0YS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICBmaWVsZHMgPSBmaWVsZHMgfHwgdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIHZhciBwcm9maWxlcyA9IGZpZWxkcy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBwID0gc3RhdHMucHJvZmlsZShkYXRhLCB1dGlsLmFjY2Vzc29yKGYpKTtcbiAgICByZXR1cm4gKHAuZmllbGQgPSBmLCBwKTtcbiAgfSk7XG4gIFxuICBwcm9maWxlcy50b1N0cmluZyA9IHByaW50U3VtbWFyeTtcbiAgcmV0dXJuIHByb2ZpbGVzO1xufTtcblxuZnVuY3Rpb24gcHJpbnRTdW1tYXJ5KCkge1xuICB2YXIgcHJvZmlsZXMgPSB0aGlzO1xuICB2YXIgc3RyID0gW107XG4gIHByb2ZpbGVzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgIHN0ci5wdXNoKFwiLS0tLS0gRmllbGQ6ICdcIiArIHAuZmllbGQgKyBcIicgLS0tLS1cIik7XG4gICAgaWYgKHR5cGVvZiBwLm1pbiA9PT0gJ3N0cmluZycgfHwgcC5kaXN0aW5jdCA8IDEwKSB7XG4gICAgICBzdHIucHVzaChwcmludENhdGVnb3JpY2FsUHJvZmlsZShwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ci5wdXNoKHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShwKSk7XG4gICAgfVxuICAgIHN0ci5wdXNoKFwiXCIpO1xuICB9KTtcbiAgcmV0dXJuIHN0ci5qb2luKFwiXFxuXCIpO1xufVxuXG5mdW5jdGlvbiBwcmludFF1YW50aXRhdGl2ZVByb2ZpbGUocCkge1xuICByZXR1cm4gW1xuICAgIFwiZGlzdGluY3Q6IFwiICsgcC5kaXN0aW5jdCxcbiAgICBcIm51bGxzOiAgICBcIiArIHAubnVsbHMsXG4gICAgXCJtaW46ICAgICAgXCIgKyBwLm1pbixcbiAgICBcIm1heDogICAgICBcIiArIHAubWF4LFxuICAgIFwibWVkaWFuOiAgIFwiICsgcC5tZWRpYW4sXG4gICAgXCJtZWFuOiAgICAgXCIgKyBwLm1lYW4sXG4gICAgXCJzdGRldjogICAgXCIgKyBwLnN0ZGV2LFxuICAgIFwic2tldzogICAgIFwiICsgcC5za2V3XG4gIF0uam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUocCkge1xuICB2YXIgbGlzdCA9IFtcbiAgICBcImRpc3RpbmN0OiBcIiArIHAuZGlzdGluY3QsXG4gICAgXCJudWxsczogICAgXCIgKyBwLm51bGxzLFxuICAgIFwidG9wIHZhbHVlczogXCJcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBcIiAnXCIgKyB2ICsgXCInIChcIiArIHVbdl0gKyBcIilcIjsgfSk7XG4gIHJldHVybiBsaXN0LmNvbmNhdCh0b3ApLmpvaW4oXCJcXG5cIik7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICByZXF1aXJlKCcuL3RydW5jYXRlJylcbn07XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKHRleHQpIHtcbiAgdmFyIHNyYyA9IHNvdXJjZSh0ZXh0LCBcImRcIik7XG4gIHNyYyA9IFwidmFyIF9fdDsgcmV0dXJuIFwiICsgc3JjICsgXCI7XCI7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbihcImRcIiwgc3JjKSkuYmluZChjb250ZXh0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGUuc291cmNlID0gc3JjO1xuICAgIHRocm93IGU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuLy8gY2xlYXIgY2FjaGUgb2YgZm9ybWF0IG9iamVjdHNcbi8vIGNhbiAqYnJlYWsqIHByaW9yIHRlbXBsYXRlIGZ1bmN0aW9ucywgc28gaW52b2tlIHdpdGggY2FyZVxudGVtcGxhdGUuY2xlYXJGb3JtYXRDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBjb250ZXh0LmZvcm1hdHMgPSBbXTtcbiAgY29udGV4dC5mb3JtYXRfbWFwID0ge307XG59O1xuXG5mdW5jdGlvbiBzb3VyY2UodGV4dCwgdmFyaWFibGUpIHtcbiAgdmFyaWFibGUgPSB2YXJpYWJsZSB8fCBcIm9ialwiO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc3JjID0gXCInXCI7XG4gIHZhciByZWdleCA9IHRlbXBsYXRlX3JlO1xuXG4gIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gIHRleHQucmVwbGFjZShyZWdleCwgZnVuY3Rpb24obWF0Y2gsIGludGVycG9sYXRlLCBvZmZzZXQpIHtcbiAgICBzcmMgKz0gdGV4dFxuICAgICAgLnNsaWNlKGluZGV4LCBvZmZzZXQpXG4gICAgICAucmVwbGFjZSh0ZW1wbGF0ZV9lc2NhcGVyLCB0ZW1wbGF0ZV9lc2NhcGVDaGFyKTtcbiAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgc3JjICs9IFwiJ1xcbisoKF9fdD0oXCJcbiAgICAgICAgKyB0ZW1wbGF0ZV92YXIoaW50ZXJwb2xhdGUsIHZhcmlhYmxlKVxuICAgICAgICArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgfVxuXG4gICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgIHJldHVybiBtYXRjaDtcbiAgfSk7XG4gIHJldHVybiBzcmMgKyBcIidcIjtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfdmFyKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhciBmaWx0ZXJzID0gdGV4dC5zcGxpdCgnfCcpO1xuICB2YXIgcHJvcCA9IGZpbHRlcnMuc2hpZnQoKS50cmltKCk7XG4gIHZhciBmb3JtYXQgPSBbXTtcbiAgdmFyIHN0cmluZ0Nhc3QgPSB0cnVlO1xuICBcbiAgZnVuY3Rpb24gc3RyY2FsbChmbikge1xuICAgIGZuID0gZm4gfHwgXCJcIjtcbiAgICBpZiAoc3RyaW5nQ2FzdCkge1xuICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgc3JjID0gXCJTdHJpbmcoXCIgKyBzcmMgKyBcIilcIiArIGZuO1xuICAgIH0gZWxzZSB7XG4gICAgICBzcmMgKz0gZm47XG4gICAgfVxuICAgIHJldHVybiBzcmM7XG4gIH1cbiAgXG4gIHZhciBzcmMgPSB1dGlsLmZpZWxkKHByb3ApLm1hcCh1dGlsLnN0cikuam9pbihcIl1bXCIpO1xuICBzcmMgPSB2YXJpYWJsZSArIFwiW1wiICsgc3JjICsgXCJdXCI7XG4gIFxuICBmb3IgKHZhciBpPTA7IGk8ZmlsdGVycy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmID0gZmlsdGVyc1tpXSwgYXJncyA9IG51bGwsIHBpZHgsIGEsIGI7XG5cbiAgICBpZiAoKHBpZHg9Zi5pbmRleE9mKCc6JykpID4gMCkge1xuICAgICAgZiA9IGYuc2xpY2UoMCwgcGlkeCk7XG4gICAgICBhcmdzID0gZmlsdGVyc1tpXS5zbGljZShwaWR4KzEpLnNwbGl0KCcsJylcbiAgICAgICAgLm1hcChmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfSk7XG4gICAgfVxuICAgIGYgPSBmLnRyaW0oKTtcblxuICAgIHN3aXRjaCAoZikge1xuICAgICAgY2FzZSAnbGVuZ3RoJzpcbiAgICAgICAgc3RyY2FsbCgnLmxlbmd0aCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG93ZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cHBlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b1VwcGVyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbG93ZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlTG93ZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd1cHBlci1sb2NhbGUnOlxuICAgICAgICBzdHJjYWxsKCcudG9Mb2NhbGVVcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RyaW0nOlxuICAgICAgICBzdHJjYWxsKCcudHJpbSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKDAsJyArIGEgKyAnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgYSA9IHV0aWwubnVtYmVyKGFyZ3NbMF0pO1xuICAgICAgICBzdHJjYWxsKCcuc2xpY2UoLScgKyBhICsnKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21pZCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGEgKyB1dGlsLm51bWJlcihhcmdzWzFdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKCsnK2ErJywnK2IrJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzbGljZSc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKCcrIGFcbiAgICAgICAgICArIChhcmdzLmxlbmd0aCA+IDEgPyAnLCcgKyB1dGlsLm51bWJlcihhcmdzWzFdKSA6ICcnKVxuICAgICAgICAgICsgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cnVuY2F0ZSc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgYiA9IGFyZ3NbMV07XG4gICAgICAgIGIgPSAoYiE9PVwibGVmdFwiICYmIGIhPT1cIm1pZGRsZVwiICYmIGIhPT1cImNlbnRlclwiKSA/IFwicmlnaHRcIiA6IGI7XG4gICAgICAgIHNyYyA9ICd0aGlzLnRydW5jYXRlKCcgKyBzdHJjYWxsKCkgKyAnLCcgKyBhICsgJyxcIicgKyBiICsgJ1wiKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgYSA9IHRlbXBsYXRlX2Zvcm1hdChhcmdzWzBdLCBkMy5mb3JtYXQpO1xuICAgICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrc3JjKycpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgICAgYSA9IHRlbXBsYXRlX2Zvcm1hdChhcmdzWzBdLCBkMy50aW1lLmZvcm1hdCk7XG4gICAgICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICAgICAgc3JjID0gJ3RoaXMuZm9ybWF0c1snK2ErJ10oJytzcmMrJyknO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IEVycm9yKFwiVW5yZWNvZ25pemVkIHRlbXBsYXRlIGZpbHRlcjogXCIgKyBmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3JjO1xufVxuXG52YXIgdGVtcGxhdGVfcmUgPSAvXFx7XFx7KC4rPylcXH1cXH18JC9nO1xuXG4vLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuLy8gc3RyaW5nIGxpdGVyYWwuXG52YXIgdGVtcGxhdGVfZXNjYXBlcyA9IHtcbiAgXCInXCI6ICAgICAgXCInXCIsXG4gICdcXFxcJzogICAgICdcXFxcJyxcbiAgJ1xccic6ICAgICAncicsXG4gICdcXG4nOiAgICAgJ24nLFxuICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICdcXHUyMDI5JzogJ3UyMDI5J1xufTtcblxudmFyIHRlbXBsYXRlX2VzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX2VzY2FwZUNoYXIobWF0Y2gpIHtcbiAgcmV0dXJuICdcXFxcJyArIHRlbXBsYXRlX2VzY2FwZXNbbWF0Y2hdO1xufTtcblxuZnVuY3Rpb24gdGVtcGxhdGVfZm9ybWF0KHBhdHRlcm4sIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09IFwiJ1wiICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09IFwiJ1wiKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gIT09ICdcIicgJiYgcGF0dGVybltwYXR0ZXJuLmxlbmd0aC0xXSA9PT0gJ1wiJykpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogXCIgKyBwYXR0ZXJuKTtcbiAgfVxuICBpZiAoIWNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSkge1xuICAgIHZhciBmID0gZm10KHBhdHRlcm4pO1xuICAgIHZhciBpID0gY29udGV4dC5mb3JtYXRzLmxlbmd0aDtcbiAgICBjb250ZXh0LmZvcm1hdHMucHVzaChmKTtcbiAgICBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl07XG59O1xuIiwidmFyIEZJRUxEUyA9IHtcbiAgcGFyZW50OiBcInBhcmVudFwiLFxuICBjaGlsZHJlbjogXCJjaGlsZHJlblwiXG59O1xuXG5mdW5jdGlvbiB0b1RhYmxlKHJvb3QsIGNoaWxkcmVuRmllbGQsIHBhcmVudEZpZWxkKSB7XG4gIGNoaWxkcmVuRmllbGQgPSBjaGlsZHJlbkZpZWxkIHx8IEZJRUxEUy5jaGlsZHJlbjtcbiAgcGFyZW50RmllbGQgPSBwYXJlbnRGaWVsZCB8fCBGSUVMRFMucGFyZW50O1xuICB2YXIgdGFibGUgPSBbXTtcbiAgXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUsIHBhcmVudCkge1xuICAgIG5vZGVbcGFyZW50RmllbGRdID0gcGFyZW50O1xuICAgIHRhYmxlLnB1c2gobm9kZSk7XG4gICAgXG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZVtjaGlsZHJlbkZpZWxkXTtcbiAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aXNpdChjaGlsZHJlbltpXSwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICB2aXNpdChyb290LCBudWxsKTtcbiAgcmV0dXJuICh0YWJsZS5yb290ID0gcm9vdCwgdGFibGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdG9UYWJsZTogdG9UYWJsZSxcbiAgZmllbGRzOiBGSUVMRFNcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgfHwgXCIuLi5cIjtcbiAgdmFyIGwgPSBNYXRoLm1heCgwLCBsZW5ndGggLSBlbGxpcHNpcy5sZW5ndGgpO1xuXG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdV90cnVuY2F0ZU9uV29yZChzLGwsMSkgOiBzLnNsaWNlKGxlbi1sKSk7XG4gICAgY2FzZSBcIm1pZGRsZVwiOlxuICAgIGNhc2UgXCJjZW50ZXJcIjpcbiAgICAgIHZhciBsMSA9IE1hdGguY2VpbChsLzIpLCBsMiA9IE1hdGguZmxvb3IobC8yKTtcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbDEpIDogcy5zbGljZSgwLGwxKSkgKyBlbGxpcHNpc1xuICAgICAgICArICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMiwxKSA6IHMuc2xpY2UobGVuLWwyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCkgOiBzLnNsaWNlKDAsbCkpICsgZWxsaXBzaXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHRydW5jYXRlT25Xb3JkKHMsIGxlbiwgcmV2KSB7XG4gIHZhciBjbnQgPSAwLCB0b2sgPSBzLnNwbGl0KHRydW5jYXRlX3dvcmRfcmUpO1xuICBpZiAocmV2KSB7XG4gICAgcyA9ICh0b2sgPSB0b2sucmV2ZXJzZSgpKVxuICAgICAgLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pXG4gICAgICAucmV2ZXJzZSgpO1xuICB9IGVsc2Uge1xuICAgIHMgPSB0b2suZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSk7XG4gIH1cbiAgcmV0dXJuIHMubGVuZ3RoID8gcy5qb2luKFwiXCIpLnRyaW0oKSA6IHRva1swXS5zbGljZSgwLCBsZW4pO1xufVxuXG52YXIgdHJ1bmNhdGVfd29yZF9yZSA9IC8oW1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUyMDI4XFx1MjAyOVxcdTMwMDBcXHVGRUZGXSkvO1xuIiwidmFyIHUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyB3aGVyZSBhcmUgd2U/XG5cbnUuaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICYmIHR5cGVvZiBwcm9jZXNzLnN0ZGVyciAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudS5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQob2JqKSkgJiYgaXNGaW5pdGUob2JqKTtcbn07XG5cbnUuaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxudS5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzTm90TnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGw7IC8vIFRPRE8gaW5jbHVkZSBOYU4gaGVyZT9cbn07XG5cbi8vIHR5cGUgY29lcmNpb24gZnVuY3Rpb25zXG5cbnUubnVtYmVyID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PSBudWxsID8gbnVsbCA6ICtzOyB9O1xuXG51LmJvb2xlYW4gPSBmdW5jdGlvbihzKSB7IHJldHVybiBzID09IG51bGwgPyBudWxsIDogcz09PSdmYWxzZScgPyBmYWxzZSA6ICEhczsgfTtcblxudS5kYXRlID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyA9PSBudWxsID8gbnVsbCA6IERhdGUucGFyc2Uocyk7IH1cblxudS5hcnJheSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggIT0gbnVsbCA/ICh1LmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdOyB9O1xuXG51LnN0ciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHUuaXNBcnJheSh4KSA/IFwiW1wiICsgeC5tYXAodS5zdHIpICsgXCJdXCJcbiAgICA6IHUuaXNPYmplY3QoeCkgPyBKU09OLnN0cmluZ2lmeSh4KVxuICAgIDogdS5pc1N0cmluZyh4KSA/IChcIidcIit1dGlsX2VzY2FwZV9zdHIoeCkrXCInXCIpIDogeDtcbn07XG5cbnZhciBlc2NhcGVfc3RyX3JlID0gLyhefFteXFxcXF0pJy9nO1xuXG5mdW5jdGlvbiB1dGlsX2VzY2FwZV9zdHIoeCkge1xuICByZXR1cm4geC5yZXBsYWNlKGVzY2FwZV9zdHJfcmUsIFwiJDFcXFxcJ1wiKTtcbn1cblxuLy8gdXRpbGl0eSBmdW5jdGlvbnNcblxudS5pZGVudGl0eSA9IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHg7IH07XG5cbnUudHJ1ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHtcbiAgICByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7XG4gIH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICByZXR1cm4gdmFsdWVzLmpvaW4oXCJ8XCIpO1xufTtcblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBmLnNwbGl0KFwiXFxcXC5cIilcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoXCIuXCIpOyB9KVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoKSB7IGFbYS5sZW5ndGgtMV0gKz0gXCIuXCIgKyBiLnNoaWZ0KCk7IH1cbiAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFtdKTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gKHUuaXNGdW5jdGlvbihmKSB8fCBmPT1udWxsKVxuICAgID8gZiA6IHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMVxuICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7XG4gICAgICAgICAgcmV0dXJuIHhbZl07XG4gICAgICAgIH0sIHgpO1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4geFtmXTsgfTtcbn07XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDFcbiAgICA/IGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICAgIHhbc1tpXV0gPSB2O1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSBcIi1cIikgeyBzID0gLTE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgZWxzZSBpZiAoZlswXSA9PT0gXCIrXCIpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuLy8gc3RyaW5nIGZ1bmN0aW9uc1xuXG4vLyBFUzYgY29tcGF0aWJpbGl0eSBwZXIgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGgjUG9seWZpbGxcbi8vIFdlIGNvdWxkIGhhdmUgdXNlZCB0aGUgcG9seWZpbGwgY29kZSwgYnV0IGxldHMgd2FpdCB1bnRpbCBFUzYgYmVjb21lcyBhIHN0YW5kYXJkIGZpcnN0XG51LnN0YXJ0c1dpdGggPSBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGhcbiAgPyBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xuICB9XG4gIDogZnVuY3Rpb24oc3RyaW5nLCBzZWFyY2hTdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxhc3RJbmRleE9mKHNlYXJjaFN0cmluZywgMCkgPT09IDA7XG4gIH07IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9oZWFwJyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOC4wXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIZWFwLCBkZWZhdWx0Q21wLCBmbG9vciwgaGVhcGlmeSwgaGVhcHBvcCwgaGVhcHB1c2gsIGhlYXBwdXNocG9wLCBoZWFwcmVwbGFjZSwgaW5zb3J0LCBtaW4sIG5sYXJnZXN0LCBuc21hbGxlc3QsIHVwZGF0ZUl0ZW0sIF9zaWZ0ZG93biwgX3NpZnR1cDtcblxuICBmbG9vciA9IE1hdGguZmxvb3IsIG1pbiA9IE1hdGgubWluO1xuXG5cbiAgLypcbiAgRGVmYXVsdCBjb21wYXJpc29uIGZ1bmN0aW9uIHRvIGJlIHVzZWRcbiAgICovXG5cbiAgZGVmYXVsdENtcCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA8IHkpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKHggPiB5KSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cblxuICAvKlxuICBJbnNlcnQgaXRlbSB4IGluIGxpc3QgYSwgYW5kIGtlZXAgaXQgc29ydGVkIGFzc3VtaW5nIGEgaXMgc29ydGVkLlxuICBcbiAgSWYgeCBpcyBhbHJlYWR5IGluIGEsIGluc2VydCBpdCB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCB4LlxuICBcbiAgT3B0aW9uYWwgYXJncyBsbyAoZGVmYXVsdCAwKSBhbmQgaGkgKGRlZmF1bHQgYS5sZW5ndGgpIGJvdW5kIHRoZSBzbGljZVxuICBvZiBhIHRvIGJlIHNlYXJjaGVkLlxuICAgKi9cblxuICBpbnNvcnQgPSBmdW5jdGlvbihhLCB4LCBsbywgaGksIGNtcCkge1xuICAgIHZhciBtaWQ7XG4gICAgaWYgKGxvID09IG51bGwpIHtcbiAgICAgIGxvID0gMDtcbiAgICB9XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobG8gPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvIG11c3QgYmUgbm9uLW5lZ2F0aXZlJyk7XG4gICAgfVxuICAgIGlmIChoaSA9PSBudWxsKSB7XG4gICAgICBoaSA9IGEubGVuZ3RoO1xuICAgIH1cbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gZmxvb3IoKGxvICsgaGkpIC8gMik7XG4gICAgICBpZiAoY21wKHgsIGFbbWlkXSkgPCAwKSB7XG4gICAgICAgIGhpID0gbWlkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG8gPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKFtdLnNwbGljZS5hcHBseShhLCBbbG8sIGxvIC0gbG9dLmNvbmNhdCh4KSksIHgpO1xuICB9O1xuXG5cbiAgLypcbiAgUHVzaCBpdGVtIG9udG8gaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcHVzaCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGFycmF5LnB1c2goaXRlbSk7XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgMCwgYXJyYXkubGVuZ3RoIC0gMSwgY21wKTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCB0aGUgc21hbGxlc3QgaXRlbSBvZmYgdGhlIGhlYXAsIG1haW50YWluaW5nIHRoZSBoZWFwIGludmFyaWFudC5cbiAgICovXG5cbiAgaGVhcHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBjbXApIHtcbiAgICB2YXIgbGFzdGVsdCwgcmV0dXJuaXRlbTtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGxhc3RlbHQgPSBhcnJheS5wb3AoKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgICBhcnJheVswXSA9IGxhc3RlbHQ7XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5pdGVtID0gbGFzdGVsdDtcbiAgICB9XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBQb3AgYW5kIHJldHVybiB0aGUgY3VycmVudCBzbWFsbGVzdCB2YWx1ZSwgYW5kIGFkZCB0aGUgbmV3IGl0ZW0uXG4gIFxuICBUaGlzIGlzIG1vcmUgZWZmaWNpZW50IHRoYW4gaGVhcHBvcCgpIGZvbGxvd2VkIGJ5IGhlYXBwdXNoKCksIGFuZCBjYW4gYmVcbiAgbW9yZSBhcHByb3ByaWF0ZSB3aGVuIHVzaW5nIGEgZml4ZWQgc2l6ZSBoZWFwLiBOb3RlIHRoYXQgdGhlIHZhbHVlXG4gIHJldHVybmVkIG1heSBiZSBsYXJnZXIgdGhhbiBpdGVtISBUaGF0IGNvbnN0cmFpbnMgcmVhc29uYWJsZSB1c2Ugb2ZcbiAgdGhpcyByb3V0aW5lIHVubGVzcyB3cml0dGVuIGFzIHBhcnQgb2YgYSBjb25kaXRpb25hbCByZXBsYWNlbWVudDpcbiAgICAgIGlmIGl0ZW0gPiBhcnJheVswXVxuICAgICAgICBpdGVtID0gaGVhcHJlcGxhY2UoYXJyYXksIGl0ZW0pXG4gICAqL1xuXG4gIGhlYXByZXBsYWNlID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcmV0dXJuaXRlbSA9IGFycmF5WzBdO1xuICAgIGFycmF5WzBdID0gaXRlbTtcbiAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIHJldHVybiByZXR1cm5pdGVtO1xuICB9O1xuXG5cbiAgLypcbiAgRmFzdCB2ZXJzaW9uIG9mIGEgaGVhcHB1c2ggZm9sbG93ZWQgYnkgYSBoZWFwcG9wLlxuICAgKi9cblxuICBoZWFwcHVzaHBvcCA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggJiYgY21wKGFycmF5WzBdLCBpdGVtKSA8IDApIHtcbiAgICAgIF9yZWYgPSBbYXJyYXlbMF0sIGl0ZW1dLCBpdGVtID0gX3JlZlswXSwgYXJyYXlbMF0gPSBfcmVmWzFdO1xuICAgICAgX3NpZnR1cChhcnJheSwgMCwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG4gIH07XG5cblxuICAvKlxuICBUcmFuc2Zvcm0gbGlzdCBpbnRvIGEgaGVhcCwgaW4tcGxhY2UsIGluIE8oYXJyYXkubGVuZ3RoKSB0aW1lLlxuICAgKi9cblxuICBoZWFwaWZ5ID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBpLCBfaSwgX2osIF9sZW4sIF9yZWYsIF9yZWYxLCBfcmVzdWx0cywgX3Jlc3VsdHMxO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgX3JlZjEgPSAoZnVuY3Rpb24oKSB7XG4gICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgIGZvciAodmFyIF9qID0gMCwgX3JlZiA9IGZsb29yKGFycmF5Lmxlbmd0aCAvIDIpOyAwIDw9IF9yZWYgPyBfaiA8IF9yZWYgOiBfaiA+IF9yZWY7IDAgPD0gX3JlZiA/IF9qKysgOiBfai0tKXsgX3Jlc3VsdHMxLnB1c2goX2opOyB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgIH0pLmFwcGx5KHRoaXMpLnJldmVyc2UoKTtcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGkgPSBfcmVmMVtfaV07XG4gICAgICBfcmVzdWx0cy5wdXNoKF9zaWZ0dXAoYXJyYXksIGksIGNtcCkpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cblxuICAvKlxuICBVcGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBpdGVtIGluIHRoZSBoZWFwLlxuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaXRlbSBpcyBiZWluZyBtb2RpZmllZC5cbiAgICovXG5cbiAgdXBkYXRlSXRlbSA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBjbXApIHtcbiAgICB2YXIgcG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgcG9zID0gYXJyYXkuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAocG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBfc2lmdGRvd24oYXJyYXksIDAsIHBvcywgY21wKTtcbiAgICByZXR1cm4gX3NpZnR1cChhcnJheSwgcG9zLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBsYXJnZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbmxhcmdlc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgY21wKSB7XG4gICAgdmFyIGVsZW0sIHJlc3VsdCwgX2ksIF9sZW4sIF9yZWY7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXN1bHQgPSBhcnJheS5zbGljZSgwLCBuKTtcbiAgICBpZiAoIXJlc3VsdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkocmVzdWx0LCBjbXApO1xuICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgIGhlYXBwdXNocG9wKHJlc3VsdCwgZWxlbSwgY21wKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KGNtcCkucmV2ZXJzZSgpO1xuICB9O1xuXG5cbiAgLypcbiAgRmluZCB0aGUgbiBzbWFsbGVzdCBlbGVtZW50cyBpbiBhIGRhdGFzZXQuXG4gICAqL1xuXG4gIG5zbWFsbGVzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgaSwgbG9zLCByZXN1bHQsIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKG4gKiAxMCA8PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pLnNvcnQoY21wKTtcbiAgICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbG9zID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIF9yZWYgPSBhcnJheS5zbGljZShuKTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBlbGVtID0gX3JlZltfaV07XG4gICAgICAgIGlmIChjbXAoZWxlbSwgbG9zKSA8IDApIHtcbiAgICAgICAgICBpbnNvcnQocmVzdWx0LCBlbGVtLCAwLCBudWxsLCBjbXApO1xuICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBoZWFwaWZ5KGFycmF5LCBjbXApO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChpID0gX2ogPSAwLCBfcmVmMSA9IG1pbihuLCBhcnJheS5sZW5ndGgpOyAwIDw9IF9yZWYxID8gX2ogPCBfcmVmMSA6IF9qID4gX3JlZjE7IGkgPSAwIDw9IF9yZWYxID8gKytfaiA6IC0tX2opIHtcbiAgICAgIF9yZXN1bHRzLnB1c2goaGVhcHBvcChhcnJheSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuICBfc2lmdGRvd24gPSBmdW5jdGlvbihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKSB7XG4gICAgdmFyIG5ld2l0ZW0sIHBhcmVudCwgcGFyZW50cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgd2hpbGUgKHBvcyA+IHN0YXJ0cG9zKSB7XG4gICAgICBwYXJlbnRwb3MgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgIHBhcmVudCA9IGFycmF5W3BhcmVudHBvc107XG4gICAgICBpZiAoY21wKG5ld2l0ZW0sIHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGFycmF5W3Bvc10gPSBwYXJlbnQ7XG4gICAgICAgIHBvcyA9IHBhcmVudHBvcztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W3Bvc10gPSBuZXdpdGVtO1xuICB9O1xuXG4gIF9zaWZ0dXAgPSBmdW5jdGlvbihhcnJheSwgcG9zLCBjbXApIHtcbiAgICB2YXIgY2hpbGRwb3MsIGVuZHBvcywgbmV3aXRlbSwgcmlnaHRwb3MsIHN0YXJ0cG9zO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgZW5kcG9zID0gYXJyYXkubGVuZ3RoO1xuICAgIHN0YXJ0cG9zID0gcG9zO1xuICAgIG5ld2l0ZW0gPSBhcnJheVtwb3NdO1xuICAgIGNoaWxkcG9zID0gMiAqIHBvcyArIDE7XG4gICAgd2hpbGUgKGNoaWxkcG9zIDwgZW5kcG9zKSB7XG4gICAgICByaWdodHBvcyA9IGNoaWxkcG9zICsgMTtcbiAgICAgIGlmIChyaWdodHBvcyA8IGVuZHBvcyAmJiAhKGNtcChhcnJheVtjaGlsZHBvc10sIGFycmF5W3JpZ2h0cG9zXSkgPCAwKSkge1xuICAgICAgICBjaGlsZHBvcyA9IHJpZ2h0cG9zO1xuICAgICAgfVxuICAgICAgYXJyYXlbcG9zXSA9IGFycmF5W2NoaWxkcG9zXTtcbiAgICAgIHBvcyA9IGNoaWxkcG9zO1xuICAgICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB9XG4gICAgYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gICAgcmV0dXJuIF9zaWZ0ZG93bihhcnJheSwgc3RhcnRwb3MsIHBvcywgY21wKTtcbiAgfTtcblxuICBIZWFwID0gKGZ1bmN0aW9uKCkge1xuICAgIEhlYXAucHVzaCA9IGhlYXBwdXNoO1xuXG4gICAgSGVhcC5wb3AgPSBoZWFwcG9wO1xuXG4gICAgSGVhcC5yZXBsYWNlID0gaGVhcHJlcGxhY2U7XG5cbiAgICBIZWFwLnB1c2hwb3AgPSBoZWFwcHVzaHBvcDtcblxuICAgIEhlYXAuaGVhcGlmeSA9IGhlYXBpZnk7XG5cbiAgICBIZWFwLnVwZGF0ZUl0ZW0gPSB1cGRhdGVJdGVtO1xuXG4gICAgSGVhcC5ubGFyZ2VzdCA9IG5sYXJnZXN0O1xuXG4gICAgSGVhcC5uc21hbGxlc3QgPSBuc21hbGxlc3Q7XG5cbiAgICBmdW5jdGlvbiBIZWFwKGNtcCkge1xuICAgICAgdGhpcy5jbXAgPSBjbXAgIT0gbnVsbCA/IGNtcCA6IGRlZmF1bHRDbXA7XG4gICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgfVxuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlYXBwb3AodGhpcy5ub2RlcywgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5pbmRleE9mKHgpICE9PSAtMTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcmVwbGFjZSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnB1c2hwb3AgPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gaGVhcHB1c2hwb3AodGhpcy5ub2RlcywgeCwgdGhpcy5jbXApO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oZWFwaWZ5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcGlmeSh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnVwZGF0ZUl0ZW0gPSBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdXBkYXRlSXRlbSh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlcyA9IFtdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMubGVuZ3RoID09PSAwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGg7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaGVhcDtcbiAgICAgIGhlYXAgPSBuZXcgSGVhcCgpO1xuICAgICAgaGVhcC5ub2RlcyA9IHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICByZXR1cm4gaGVhcDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZXMuc2xpY2UoMCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmluc2VydCA9IEhlYXAucHJvdG90eXBlLnB1c2g7XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b3AgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuZnJvbnQgPSBIZWFwLnByb3RvdHlwZS5wZWVrO1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaGFzID0gSGVhcC5wcm90b3R5cGUuY29udGFpbnM7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb3B5ID0gSGVhcC5wcm90b3R5cGUuY2xvbmU7XG5cbiAgICByZXR1cm4gSGVhcDtcblxuICB9KSgpO1xuXG4gIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgcmV0dXJuIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJvb3QuSGVhcCA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKHRoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBIZWFwO1xuICB9KTtcblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBib3VuZHMgPSBmdW5jdGlvbihiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59O1xuXG52YXIgcHJvdG90eXBlID0gYm91bmRzLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSArTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLngyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueTIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgdGhpcy54MSA9IHgxO1xuICB0aGlzLnkxID0geTE7XG4gIHRoaXMueDIgPSB4MjtcbiAgdGhpcy55MiA9IHkyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gIGlmICh5IDwgdGhpcy55MSkgdGhpcy55MSA9IHk7XG4gIGlmICh4ID4gdGhpcy54MikgdGhpcy54MiA9IHg7XG4gIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uKGQpIHtcbiAgdGhpcy54MSAtPSBkO1xuICB0aGlzLnkxIC09IGQ7XG4gIHRoaXMueDIgKz0gZDtcbiAgdGhpcy55MiArPSBkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLngxID0gTWF0aC5mbG9vcih0aGlzLngxKTtcbiAgdGhpcy55MSA9IE1hdGguZmxvb3IodGhpcy55MSk7XG4gIHRoaXMueDIgPSBNYXRoLmNlaWwodGhpcy54Mik7XG4gIHRoaXMueTIgPSBNYXRoLmNlaWwodGhpcy55Mik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKGR4LCBkeSkge1xuICB0aGlzLngxICs9IGR4O1xuICB0aGlzLngyICs9IGR4O1xuICB0aGlzLnkxICs9IGR5O1xuICB0aGlzLnkyICs9IGR5O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihhbmdsZSwgeCwgeSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpLFxuICAgICAgY3ggPSB4IC0geCpjb3MgKyB5KnNpbixcbiAgICAgIGN5ID0geSAtIHgqc2luIC0geSpjb3MsXG4gICAgICB4MSA9IHRoaXMueDEsIHgyID0gdGhpcy54MixcbiAgICAgIHkxID0gdGhpcy55MSwgeTIgPSB0aGlzLnkyO1xuXG4gIHJldHVybiB0aGlzLmNsZWFyKClcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MSArIGN4LCAgc2luKngxICsgY29zKnkxICsgY3kpXG4gICAgLmFkZChjb3MqeDEgLSBzaW4qeTIgKyBjeCwgIHNpbip4MSArIGNvcyp5MiArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkxICsgY3gsICBzaW4qeDIgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MiAtIHNpbip5MiArIGN4LCAgc2luKngyICsgY29zKnkyICsgY3kpO1xufVxuXG5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihiKSB7XG4gIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmVuY2xvc2VzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAoXG4gICAgdGhpcy54MSA8PSBiLngxICYmXG4gICAgdGhpcy54MiA+PSBiLngyICYmXG4gICAgdGhpcy55MSA8PSBiLnkxICYmXG4gICAgdGhpcy55MiA+PSBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIGIgJiYgIShcbiAgICB0aGlzLngyIDwgYi54MSB8fFxuICAgIHRoaXMueDEgPiBiLngyIHx8XG4gICAgdGhpcy55MiA8IGIueTEgfHxcbiAgICB0aGlzLnkxID4gYi55MlxuICApO1xufTtcblxucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gIShcbiAgICB4IDwgdGhpcy54MSB8fFxuICAgIHggPiB0aGlzLngyIHx8XG4gICAgeSA8IHRoaXMueTEgfHxcbiAgICB5ID4gdGhpcy55MlxuICApO1xufTtcblxucHJvdG90eXBlLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLngyIC0gdGhpcy54MTtcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBib3VuZHM7IiwidmFyIEdyYXBoID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvR3JhcGgnKSwgXG4gICAgTm9kZSAgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgR3JvdXBCdWlsZGVyID0gcmVxdWlyZSgnLi4vc2NlbmUvR3JvdXBCdWlsZGVyJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksIFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG5mdW5jdGlvbiBNb2RlbCgpIHtcbiAgdGhpcy5fZGVmcyA9IHt9O1xuICB0aGlzLl9wcmVkaWNhdGVzID0ge307XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcblxuICB0aGlzLmdyYXBoID0gbmV3IEdyYXBoKCk7XG5cbiAgdGhpcy5fbm9kZSA9IG5ldyBOb2RlKHRoaXMuZ3JhcGgpO1xuICB0aGlzLl9idWlsZGVyID0gbnVsbDsgLy8gVG9wLWxldmVsIHNjZW5lZ3JhcGggYnVpbGRlclxufTtcblxudmFyIHByb3RvID0gTW9kZWwucHJvdG90eXBlO1xuXG5wcm90by5kZWZzID0gZnVuY3Rpb24oZGVmcykge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9kZWZzO1xuICB0aGlzLl9kZWZzID0gZGVmcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gdGhpcy5ncmFwaC5kYXRhLmFwcGx5KHRoaXMuZ3JhcGgsIGFyZ3VtZW50cyk7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7ICAvLyBuZXcgRGF0YXNvdXJjZVxuICAgIHRoaXMuX25vZGUuYWRkTGlzdGVuZXIoZGF0YS5waXBlbGluZSgpWzBdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxuZnVuY3Rpb24gcHJlZGljYXRlcyhuYW1lKSB7XG4gIHZhciBtID0gdGhpcywgcHJlZGljYXRlcyA9IHt9O1xuICBpZighZGwuaXNBcnJheShuYW1lKSkgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZXNbbmFtZV07XG4gIG5hbWUuZm9yRWFjaChmdW5jdGlvbihuKSB7IHByZWRpY2F0ZXNbbl0gPSBtLl9wcmVkaWNhdGVzW25dIH0pO1xuICByZXR1cm4gcHJlZGljYXRlcztcbn1cblxucHJvdG8ucHJlZGljYXRlID0gZnVuY3Rpb24obmFtZSwgcHJlZGljYXRlKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBwcmVkaWNhdGVzLmNhbGwodGhpcywgbmFtZSk7XG4gIHJldHVybiAodGhpcy5fcHJlZGljYXRlc1tuYW1lXSA9IHByZWRpY2F0ZSk7XG59O1xuXG5wcm90by5wcmVkaWNhdGVzID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9wcmVkaWNhdGVzOyB9O1xuXG5wcm90by5zY2VuZSA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2NlbmU7XG4gIGlmKHRoaXMuX2J1aWxkZXIpIHRoaXMuX25vZGUucmVtb3ZlTGlzdGVuZXIodGhpcy5fYnVpbGRlci5kaXNjb25uZWN0KCkpO1xuICB0aGlzLl9idWlsZGVyID0gbmV3IEdyb3VwQnVpbGRlcih0aGlzLCB0aGlzLl9kZWZzLm1hcmtzLCB0aGlzLl9zY2VuZT17fSk7XG4gIHRoaXMuX25vZGUuYWRkTGlzdGVuZXIodGhpcy5fYnVpbGRlci5jb25uZWN0KCkpO1xuICB2YXIgcCA9IHRoaXMuX2J1aWxkZXIucGlwZWxpbmUoKTtcbiAgcFtwLmxlbmd0aC0xXS5hZGRMaXN0ZW5lcihyZW5kZXJlcik7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7IHRoaXMuX25vZGUuYWRkTGlzdGVuZXIobCk7IH07XG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHsgdGhpcy5fbm9kZS5yZW1vdmVMaXN0ZW5lcihsKTsgfTtcblxucHJvdG8uZmlyZSA9IGZ1bmN0aW9uKGNzKSB7XG4gIGlmKCFjcykgY3MgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG4gIHRoaXMuZ3JhcGgucHJvcGFnYXRlKGNzLCB0aGlzLl9ub2RlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBwYXJzZVN0cmVhbXMgPSByZXF1aXJlKCcuLi9wYXJzZS9zdHJlYW1zJyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi4vcmVuZGVyL2NhbnZhcy9pbmRleCcpLFxuICAgIHN2ZyA9IHJlcXVpcmUoJy4uL3JlbmRlci9zdmcvaW5kZXgnKSxcbiAgICBzdmd4ID0gcmVxdWlyZSgnLi4vcmVuZGVyL3N2Zy14bWwvaW5kZXgnKSxcbiAgICBUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vc2NlbmUvVHJhbnNpdGlvbicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0Jyk7XG5cbnZhciBWaWV3ID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIG1vZGVsKSB7XG4gIHRoaXMuX2VsICAgID0gbnVsbDtcbiAgdGhpcy5fbW9kZWwgPSBudWxsO1xuICB0aGlzLl93aWR0aCA9IHRoaXMuX193aWR0aCA9IHdpZHRoIHx8IDUwMDtcbiAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fX2hlaWdodCA9IGhlaWdodCB8fCAzMDA7XG4gIHRoaXMuX2F1dG9wYWQgPSAxO1xuICB0aGlzLl9wYWRkaW5nID0ge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgdGhpcy5fdmlld3BvcnQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXIgPSBudWxsO1xuICB0aGlzLl9pbyA9IGNhbnZhcztcbiAgaWYgKGVsKSB0aGlzLmluaXRpYWxpemUoZWwpO1xufTtcblxudmFyIHByb3RvdHlwZSA9IFZpZXcucHJvdG90eXBlO1xuXG5wcm90b3R5cGUubW9kZWwgPSBmdW5jdGlvbihtb2RlbCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgaWYgKHRoaXMuX21vZGVsICE9PSBtb2RlbCkge1xuICAgIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gICAgaWYgKHRoaXMuX2hhbmRsZXIpIHRoaXMuX2hhbmRsZXIubW9kZWwobW9kZWwpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtID0gdGhpcy5tb2RlbCgpO1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtLmRhdGEoKTtcbiAgZGwua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgbS5kYXRhKGQpLmFkZChkbC5kdXBsaWNhdGUoZGF0YVtkXSkpOyB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9fd2lkdGg7XG4gIGlmICh0aGlzLl9fd2lkdGggIT09IHdpZHRoKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgICBpZiAodGhpcy5fZWwpIHRoaXMuaW5pdGlhbGl6ZSh0aGlzLl9lbC5wYXJlbnROb2RlKTtcbiAgICBpZiAodGhpcy5fc3RyaWN0KSB0aGlzLl9hdXRvcGFkID0gMTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fX2hlaWdodDtcbiAgaWYgKHRoaXMuX19oZWlnaHQgIT09IGhlaWdodCkge1xuICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKHRoaXMuX2VsKSB0aGlzLmluaXRpYWxpemUodGhpcy5fZWwucGFyZW50Tm9kZSk7XG4gICAgaWYgKHRoaXMuX3N0cmljdCkgdGhpcy5fYXV0b3BhZCA9IDE7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9wYWRkaW5nO1xuICBpZiAodGhpcy5fcGFkZGluZyAhPT0gcGFkKSB7XG4gICAgaWYgKGRsLmlzU3RyaW5nKHBhZCkpIHtcbiAgICAgIHRoaXMuX2F1dG9wYWQgPSAxO1xuICAgICAgdGhpcy5fcGFkZGluZyA9IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gICAgICB0aGlzLl9zdHJpY3QgPSAocGFkID09PSBcInN0cmljdFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYXV0b3BhZCA9IDA7XG4gICAgICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICAgICAgdGhpcy5fc3RyaWN0ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9lbCkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVzaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHBhZCk7XG4gICAgICB0aGlzLl9oYW5kbGVyLnBhZGRpbmcocGFkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYXV0b3BhZCA9IGZ1bmN0aW9uKG9wdCkge1xuICBpZiAodGhpcy5fYXV0b3BhZCA8IDEpIHJldHVybiB0aGlzO1xuICBlbHNlIHRoaXMuX2F1dG9wYWQgPSAwO1xuXG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IHRoaXMubW9kZWwoKS5zY2VuZSgpLmJvdW5kcyxcbiAgICAgIGluc2V0ID0gY29uZmlnLmF1dG9wYWRJbnNldCxcbiAgICAgIGwgPSBiLngxIDwgMCA/IE1hdGguY2VpbCgtYi54MSkgKyBpbnNldCA6IDAsXG4gICAgICB0ID0gYi55MSA8IDAgPyBNYXRoLmNlaWwoLWIueTEpICsgaW5zZXQgOiAwLFxuICAgICAgciA9IGIueDIgPiB0aGlzLl93aWR0aCAgPyBNYXRoLmNlaWwoK2IueDIgLSB0aGlzLl93aWR0aCkgKyBpbnNldCA6IDAsXG4gICAgICBiID0gYi55MiA+IHRoaXMuX2hlaWdodCA/IE1hdGguY2VpbCgrYi55MiAtIHRoaXMuX2hlaWdodCkgKyBpbnNldCA6IDA7XG4gIHBhZCA9IHtsZWZ0OmwsIHRvcDp0LCByaWdodDpyLCBib3R0b206Yn07XG5cbiAgaWYgKHRoaXMuX3N0cmljdCkge1xuICAgIHRoaXMuX2F1dG9wYWQgPSAwO1xuICAgIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gICAgdGhpcy5fd2lkdGggPSBNYXRoLm1heCgwLCB0aGlzLl9fd2lkdGggLSAobCtyKSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5tYXgoMCwgdGhpcy5fX2hlaWdodCAtICh0K2IpKTtcbiAgICB0aGlzLl9tb2RlbC53aWR0aCh0aGlzLl93aWR0aCk7XG4gICAgdGhpcy5fbW9kZWwuaGVpZ2h0KHRoaXMuX2hlaWdodCk7XG4gICAgaWYgKHRoaXMuX2VsKSB0aGlzLmluaXRpYWxpemUodGhpcy5fZWwucGFyZW50Tm9kZSk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnBhZGRpbmcocGFkKS51cGRhdGUob3B0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS52aWV3cG9ydCA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XG4gIGlmICh0aGlzLl92aWV3cG9ydCAhPT0gc2l6ZSkge1xuICAgIHRoaXMuX3ZpZXdwb3J0ID0gc2l6ZTtcbiAgICBpZiAodGhpcy5fZWwpIHRoaXMuaW5pdGlhbGl6ZSh0aGlzLl9lbC5wYXJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXJlciA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gIGlmICh0eXBlID09PSBcImNhbnZhc1wiKSB0eXBlID0gY2FudmFzO1xuICBlbHNlIGlmICh0eXBlID09PSBcInN2Z1wiKSB0eXBlID0gc3ZnO1xuICBlbHNlIGlmICh0eXBlID09PSBcInN2Zy14bWxcIikgdHlwZSA9IHN2Z3g7XG4gIGVsc2UgaWYgKGRsLmlzU3RyaW5nKHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHJlbmRlcmVyOiBcIiArIHR5cGUpO1xuICBlbHNlIGlmICghdHlwZSkgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVuZGVyZXIgc3BlY2lmaWVkXCIpO1xuXG4gIGlmICh0aGlzLl9pbyAhPT0gdHlwZSkge1xuICAgIHRoaXMuX2lvID0gdHlwZTtcbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX2VsKSB0aGlzLmluaXRpYWxpemUodGhpcy5fZWwucGFyZW50Tm9kZSk7XG4gICAgaWYgKHRoaXMuX2J1aWxkKSB0aGlzLnJlbmRlcigpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCkge1xuICB2YXIgdiA9IHRoaXMsIHByZXZIYW5kbGVyLFxuICAgICAgdyA9IHYuX3dpZHRoLCBoID0gdi5faGVpZ2h0LCBwYWQgPSB2Ll9wYWRkaW5nO1xuICBcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IGVsID09PSBudWxsKSB7XG4gICAgZWwgPSB0aGlzLl9lbCA/IHRoaXMuX2VsLnBhcmVudE5vZGUgOiBudWxsO1xuICB9XG5cbiAgaWYgKGVsKSB7XG4gICAgLy8gY2xlYXIgcHJlLWV4aXN0aW5nIGNvbnRhaW5lclxuICAgIGQzLnNlbGVjdChlbCkuc2VsZWN0KFwiZGl2LnZlZ2FcIikucmVtb3ZlKCk7XG4gICAgXG4gICAgLy8gYWRkIGRpdiBjb250YWluZXJcbiAgICB0aGlzLl9lbCA9IGVsID0gZDMuc2VsZWN0KGVsKVxuICAgICAgLmFwcGVuZChcImRpdlwiKVxuICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInZlZ2FcIilcbiAgICAgIC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcbiAgICAgIC5ub2RlKCk7XG4gICAgaWYgKHYuX3ZpZXdwb3J0KSB7XG4gICAgICBkMy5zZWxlY3QoZWwpXG4gICAgICAgIC5zdHlsZShcIndpZHRoXCIsICAodi5fdmlld3BvcnRbMF0gfHwgdykrXCJweFwiKVxuICAgICAgICAuc3R5bGUoXCJoZWlnaHRcIiwgKHYuX3ZpZXdwb3J0WzFdIHx8IGgpK1wicHhcIilcbiAgICAgICAgLnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJhdXRvXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlbmRlcmVyXG4gIHYuX3JlbmRlcmVyID0gKHYuX3JlbmRlcmVyIHx8IG5ldyB0aGlzLl9pby5SZW5kZXJlcigpKVxuICAgIC5pbml0aWFsaXplKGVsLCB3LCBoLCBwYWQpO1xuICBcbiAgaWYgKGVsKSB7XG4gICAgLy8gaW5wdXQgaGFuZGxlclxuICAgIHByZXZIYW5kbGVyID0gdi5faGFuZGxlcjtcbiAgICB2Ll9oYW5kbGVyID0gbmV3IHRoaXMuX2lvLkhhbmRsZXIoKVxuICAgICAgLmluaXRpYWxpemUoZWwsIHBhZCwgdilcbiAgICAgIC5tb2RlbCh2Ll9tb2RlbCk7XG5cbiAgICBpZiAocHJldkhhbmRsZXIpIHtcbiAgICAgIHByZXZIYW5kbGVyLmhhbmRsZXJzKCkuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgIHYuX2hhbmRsZXIub24oaC50eXBlLCBoLmhhbmRsZXIpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVycyBmb3Igc2lnbmFsIHN0cmVhbSBkZWZpbml0aW9ucy5cbiAgICAgIHBhcnNlU3RyZWFtcyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG9wdCkgeyAgICBcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgdiA9IHRoaXMsXG4gICAgICB0cmFucyA9IG9wdC5kdXJhdGlvblxuICAgICAgICA/IG5ldyBUcmFuc2l0aW9uKG9wdC5kdXJhdGlvbiwgb3B0LmVhc2UpXG4gICAgICAgIDogbnVsbDtcblxuICAvLyBUT0RPOiB3aXRoIHN0cmVhbWluZyBkYXRhIEFQSSwgYWRkcyBzaG91bGQgZGwuZHVwbGljYXRlIGp1c3QgcGFyc2VTcGVjXG4gIC8vIHRvIHByZXZlbnQgVmVnYSBmcm9tIHBvbGx1dGluZyB0aGUgZW52aXJvbm1lbnQuXG5cbiAgdmFyIGNzID0gY2hhbmdlc2V0LmNyZWF0ZSgpO1xuICBpZih0cmFucykgY3MudHJhbnMgPSB0cmFucztcbiAgaWYob3B0LnJlZmxvdyAhPT0gdW5kZWZpbmVkKSBjcy5yZWZsb3cgPSBvcHQucmVmbG93XG5cbiAgaWYoIXYuX2J1aWxkKSB7XG4gICAgdi5fcmVuZGVyTm9kZSA9IG5ldyBOb2RlKHYuX21vZGVsLmdyYXBoKVxuICAgICAgLnJvdXRlcih0cnVlKTtcblxuICAgIHYuX3JlbmRlck5vZGUuZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgZGVidWcoaW5wdXQsIFtcInJlbmRlcmluZ1wiXSk7XG5cbiAgICAgIHZhciBzID0gdi5fbW9kZWwuc2NlbmUoKTtcbiAgICAgIGlmKGlucHV0LnRyYW5zKSB7XG4gICAgICAgIGlucHV0LnRyYW5zLnN0YXJ0KGZ1bmN0aW9uKGl0ZW1zKSB7IHYuX3JlbmRlcmVyLnJlbmRlcihzLCBpdGVtcyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi5fcmVuZGVyZXIucmVuZGVyKHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBGb3IgYWxsIHVwZGF0ZWQgZGF0YXNvdXJjZXMsIGZpbmFsaXplIHRoZWlyIGNoYW5nZXNldHMuXG4gICAgICB2YXIgZCwgZHM7XG4gICAgICBmb3IoZCBpbiBpbnB1dC5kYXRhKSB7XG4gICAgICAgIGRzID0gdi5fbW9kZWwuZGF0YShkKTtcbiAgICAgICAgaWYoIWRzLnJldmlzZXMoKSkgY29udGludWU7XG4gICAgICAgIGNoYW5nZXNldC5maW5hbGl6ZShkcy5sYXN0KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfTtcblxuICAgIHYuX21vZGVsLnNjZW5lKHYuX3JlbmRlck5vZGUpO1xuICAgIHYuX2J1aWxkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFB1bHNlIHRoZSBlbnRpcmUgbW9kZWwgKERhdGFzb3VyY2VzICsgc2NlbmUpLlxuICB2Ll9tb2RlbC5maXJlKGNzKTtcblxuICByZXR1cm4gdi5hdXRvcGFkKG9wdCk7XG59O1xuXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vbi5hcHBseSh0aGlzLl9oYW5kbGVyLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5faGFuZGxlci5vZmYuYXBwbHkodGhpcy5faGFuZGxlciwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5WaWV3LmZhY3RvcnkgPSBmdW5jdGlvbihtb2RlbCkge1xuICByZXR1cm4gZnVuY3Rpb24ob3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHZhciBkZWZzID0gbW9kZWwuZGVmcygpO1xuICAgIHZhciB2ID0gbmV3IFZpZXcoKVxuICAgICAgLm1vZGVsKG1vZGVsKVxuICAgICAgLndpZHRoKGRlZnMud2lkdGgpXG4gICAgICAuaGVpZ2h0KGRlZnMuaGVpZ2h0KVxuICAgICAgLnBhZGRpbmcoZGVmcy5wYWRkaW5nKVxuICAgICAgLnJlbmRlcmVyKG9wdC5yZW5kZXJlciB8fCBcImNhbnZhc1wiKTtcblxuICAgIHYuaW5pdGlhbGl6ZShvcHQuZWwpO1xuICAgIGlmIChvcHQuZGF0YSkgdi5kYXRhKG9wdC5kYXRhKTtcbiAgXG4gICAgcmV0dXJuIHY7XG4gIH07ICAgIFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3O1xuIiwidmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuL2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBDb2xsZWN0b3IoZ3JhcGgpIHtcbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgdGhpcy5fZGF0YSA9IFtdO1xuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoQ29sbGVjdG9yLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5kYXRhID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9kYXRhOyB9XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImNvbGxlY3RpbmdcIl0pO1xuXG4gIGlmIChpbnB1dC5yZWZsb3cpIHtcbiAgICBpbnB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuICAgIGlucHV0Lm1vZCA9IHRoaXMuX2RhdGEuc2xpY2UoKTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBpZiAoaW5wdXQucmVtLmxlbmd0aCkge1xuICAgIHZhciBpZHMgPSBpbnB1dC5yZW0ucmVkdWNlKGZ1bmN0aW9uKG0seCkgeyByZXR1cm4gKG1beC5faWRdPTEsIG0pOyB9LCB7fSk7XG4gICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGlkc1t4Ll9pZF0gIT09IDE7IH0pO1xuICB9XG5cbiAgaWYgKGlucHV0LmFkZC5sZW5ndGgpIHtcbiAgICB0aGlzLl9kYXRhID0gdGhpcy5fZGF0YS5sZW5ndGggPyB0aGlzLl9kYXRhLmNvbmNhdChpbnB1dC5hZGQpIDogaW5wdXQuYWRkO1xuICB9XG5cbiAgaWYgKGlucHV0LnNvcnQpIHtcbiAgICB0aGlzLl9kYXRhLnNvcnQoaW5wdXQuc29ydCk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbGxlY3RvcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKSwgXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuL3R1cGxlJyksIFxuICAgIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuL0NvbGxlY3RvcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBEYXRhc291cmNlKGdyYXBoLCBuYW1lLCBmYWNldCkge1xuICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5fZGF0YSA9IFtdO1xuICB0aGlzLl9zb3VyY2UgPSBudWxsO1xuICB0aGlzLl9mYWNldCA9IGZhY2V0O1xuICB0aGlzLl9pbnB1dCA9IGNoYW5nZXNldC5jcmVhdGUoKTtcbiAgdGhpcy5fb3V0cHV0ID0gbnVsbDsgICAgLy8gT3V0cHV0IGNoYW5nZXNldFxuXG4gIHRoaXMuX3BpcGVsaW5lICA9IG51bGw7IC8vIFBpcGVsaW5lIG9mIHRyYW5zZm9ybWF0aW9ucy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbnVsbDsgLy8gQ29sbGVjdG9yIHRvIG1hdGVyaWFsaXplIG91dHB1dCBvZiBwaXBlbGluZVxuICB0aGlzLl9yZXZpc2VzID0gZmFsc2U7IC8vIERvZXMgYW55IHBpcGVsaW5lIG9wZXJhdG9yIG5lZWQgdG8gdHJhY2sgcHJldj9cbn07XG5cbnZhciBwcm90byA9IERhdGFzb3VyY2UucHJvdG90eXBlO1xuXG5wcm90by5uYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX25hbWU7XG4gIHJldHVybiAodGhpcy5fbmFtZSA9IG5hbWUsIHRoaXMpO1xufTtcblxucHJvdG8uc291cmNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc291cmNlO1xuICByZXR1cm4gKHRoaXMuX3NvdXJjZSA9IHRoaXMuX2dyYXBoLmRhdGEoc3JjKSk7XG59O1xuXG5wcm90by5hZGQgPSBmdW5jdGlvbihkKSB7XG4gIHZhciBwcmV2ID0gdGhpcy5fcmV2aXNlcyA/IG51bGwgOiB1bmRlZmluZWQ7XG5cbiAgdGhpcy5faW5wdXQuYWRkID0gdGhpcy5faW5wdXQuYWRkXG4gICAgLmNvbmNhdChkbC5hcnJheShkKS5tYXAoZnVuY3Rpb24oZCkgeyByZXR1cm4gdHVwbGUuaW5nZXN0KGQsIHByZXYpOyB9KSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24od2hlcmUpIHtcbiAgdmFyIGQgPSB0aGlzLl9kYXRhLmZpbHRlcih3aGVyZSk7XG4gIHRoaXMuX2lucHV0LnJlbSA9IHRoaXMuX2lucHV0LnJlbS5jb25jYXQoZCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8udXBkYXRlID0gZnVuY3Rpb24od2hlcmUsIGZpZWxkLCBmdW5jKSB7XG4gIHZhciBtb2QgPSB0aGlzLl9pbnB1dC5tb2QsXG4gICAgICBpZHMgPSB0dXBsZS5pZE1hcChtb2QpLFxuICAgICAgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkOyBcblxuICB0aGlzLl9pbnB1dC5maWVsZHNbZmllbGRdID0gMTtcbiAgdGhpcy5fZGF0YS5maWx0ZXIod2hlcmUpLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIHZhciBwcmV2ID0geFtmaWVsZF0sXG4gICAgICAgIG5leHQgPSBmdW5jKHgpO1xuICAgIGlmIChwcmV2ICE9PSBuZXh0KSB7XG4gICAgICB0dXBsZS5zZXQoeCwgZmllbGQsIG5leHQpO1xuICAgICAgaWYoaWRzW3guX2lkXSAhPT0gMSkge1xuICAgICAgICBtb2QucHVzaCh4KTtcbiAgICAgICAgaWRzW3guX2lkXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by52YWx1ZXMgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgIHJldHVybiB0aGlzLl9jb2xsZWN0b3IgPyB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpIDogdGhpcy5fZGF0YTtcblxuICAvLyBSZXBsYWNlIGJhY2tpbmcgZGF0YVxuICB0aGlzLl9pbnB1dC5yZW0gPSB0aGlzLl9kYXRhLnNsaWNlKCk7XG4gIGlmIChkYXRhKSB7IHRoaXMuYWRkKGRhdGEpOyB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gc2V0X3ByZXYoZCkgeyBpZihkLl9wcmV2ID09PSB1bmRlZmluZWQpIGQuX3ByZXYgPSBDLlNFTlRJTkVMOyB9XG5cbnByb3RvLnJldmlzZXMgPSBmdW5jdGlvbihwKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmV2aXNlcztcblxuICAvLyBJZiB3ZSd2ZSBub3QgbmVlZGVkIHByZXYgaW4gdGhlIHBhc3QsIGJ1dCBhIG5ldyBkYXRhZmxvdyBub2RlIG5lZWRzIGl0IG5vd1xuICAvLyBlbnN1cmUgZXhpc3RpbmcgdHVwbGVzIGhhdmUgcHJldiBzZXQuXG4gIGlmKCF0aGlzLl9yZXZpc2VzICYmIHApIHtcbiAgICB0aGlzLl9kYXRhLmZvckVhY2goc2V0X3ByZXYpO1xuICAgIHRoaXMuX2lucHV0LmFkZC5mb3JFYWNoKHNldF9wcmV2KTsgLy8gTmV3IHR1cGxlcyB0aGF0IGhhdmVuJ3QgeWV0IGJlZW4gbWVyZ2VkIGludG8gX2RhdGFcbiAgfVxuXG4gIHRoaXMuX3JldmlzZXMgPSB0aGlzLl9yZXZpc2VzIHx8IHA7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ubGFzdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fb3V0cHV0OyB9O1xuXG5wcm90by5maXJlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYoaW5wdXQpIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZSh0aGlzLl9pbnB1dCwgdGhpcy5fcGlwZWxpbmVbMF0pOyBcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24ocGlwZWxpbmUpIHtcbiAgdmFyIGRzID0gdGhpcywgbiwgYztcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9waXBlbGluZTtcblxuICBpZihwaXBlbGluZS5sZW5ndGgpIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgcGlwZWxpbmUsIGFkZCBhIGNvbGxlY3RvciB0byB0aGUgZW5kIHRvIG1hdGVyaWFsaXplXG4gICAgLy8gdGhlIG91dHB1dC5cbiAgICBkcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3Rvcih0aGlzLl9ncmFwaCk7XG4gICAgcGlwZWxpbmUucHVzaChkcy5fY29sbGVjdG9yKTtcbiAgICBkcy5fcmV2aXNlcyA9IHBpcGVsaW5lLnNvbWUoZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5yZXZpc2VzKCk7IH0pO1xuICB9XG5cbiAgLy8gSW5wdXQgbm9kZSBhcHBsaWVzIHRoZSBkYXRhc291cmNlJ3MgZGVsdGEsIGFuZCBwcm9wYWdhdGVzIGl0IHRvIFxuICAvLyB0aGUgcmVzdCBvZiB0aGUgcGlwZWxpbmUuIEl0IHJlY2VpdmVzIHRvdWNoZXMgdG8gcmVmbG93IGRhdGEuXG4gIHZhciBpbnB1dCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSlcbiAgICAuY29sbGVjdG9yKHRydWUpO1xuXG4gIGlucHV0LmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZWJ1ZyhpbnB1dCwgW1wiaW5wdXRcIiwgZHMuX25hbWVdKTtcblxuICAgIHZhciBkZWx0YSA9IGRzLl9pbnB1dCwgXG4gICAgICAgIG91dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpLFxuICAgICAgICByZW07XG5cbiAgICAvLyBEZWx0YSBtaWdodCBjb250YWluIGZpZWxkcyB1cGRhdGVkIHRocm91Z2ggQVBJXG4gICAgZGwua2V5cyhkZWx0YS5maWVsZHMpLmZvckVhY2goZnVuY3Rpb24oZikgeyBvdXQuZmllbGRzW2ZdID0gMSB9KTtcblxuICAgIGlmKGlucHV0LnJlZmxvdykge1xuICAgICAgb3V0Lm1vZCA9IGRzLl9kYXRhLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZSBkYXRhXG4gICAgICBpZihkZWx0YS5yZW0ubGVuZ3RoKSB7XG4gICAgICAgIHJlbSA9IHR1cGxlLmlkTWFwKGRlbHRhLnJlbSk7XG4gICAgICAgIGRzLl9kYXRhID0gZHMuX2RhdGFcbiAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbVt4Ll9pZF0gIT09IDEgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmKGRlbHRhLmFkZC5sZW5ndGgpIGRzLl9kYXRhID0gZHMuX2RhdGEuY29uY2F0KGRlbHRhLmFkZCk7XG5cbiAgICAgIC8vIHJlc2V0IGNoYW5nZSBsaXN0XG4gICAgICBkcy5faW5wdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKCk7XG5cbiAgICAgIG91dC5hZGQgPSBkZWx0YS5hZGQ7IFxuICAgICAgb3V0Lm1vZCA9IGRlbHRhLm1vZDtcbiAgICAgIG91dC5yZW0gPSBkZWx0YS5yZW07XG4gICAgfVxuXG4gICAgcmV0dXJuIChvdXQuZmFjZXQgPSBkcy5fZmFjZXQsIG91dCk7XG4gIH07XG5cbiAgcGlwZWxpbmUudW5zaGlmdChpbnB1dCk7XG5cbiAgLy8gT3V0cHV0IG5vZGUgY2FwdHVyZXMgdGhlIGxhc3QgY2hhbmdlc2V0IHNlZW4gYnkgdGhpcyBkYXRhc291cmNlXG4gIC8vIChuZWVkZWQgZm9yIGpvaW5zIGFuZCBidWlsZHMpIGFuZCBtYXRlcmlhbGl6ZXMgYW55IG5lc3RlZCBkYXRhLlxuICAvLyBJZiB0aGlzIGRhdGFzb3VyY2UgaXMgZmFjZXRlZCwgbWF0ZXJpYWxpemVzIHRoZSB2YWx1ZXMgaW4gdGhlIGZhY2V0LlxuICB2YXIgb3V0cHV0ID0gbmV3IE5vZGUodGhpcy5fZ3JhcGgpXG4gICAgLnJvdXRlcih0cnVlKVxuICAgIC5jb2xsZWN0b3IodHJ1ZSk7XG5cbiAgb3V0cHV0LmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZWJ1ZyhpbnB1dCwgW1wib3V0cHV0XCIsIGRzLl9uYW1lXSk7XG4gICAgdmFyIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQsIHRydWUpO1xuXG4gICAgaWYoZHMuX2ZhY2V0KSB7XG4gICAgICBkcy5fZmFjZXQudmFsdWVzID0gZHMudmFsdWVzKCk7XG4gICAgICBpbnB1dC5mYWNldCA9IG51bGw7XG4gICAgfVxuXG4gICAgZHMuX291dHB1dCA9IGlucHV0O1xuICAgIG91dHB1dC5kYXRhW2RzLl9uYW1lXSA9IDE7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICBwaXBlbGluZS5wdXNoKG91dHB1dCk7XG5cbiAgdGhpcy5fcGlwZWxpbmUgPSBwaXBlbGluZTtcbiAgdGhpcy5fZ3JhcGguY29ubmVjdChkcy5fcGlwZWxpbmUpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxpc3RlbmVyID0gZnVuY3Rpb24oKSB7IFxuICB2YXIgbCA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKS5yb3V0ZXIodHJ1ZSksXG4gICAgICBkZXN0ID0gdGhpcyxcbiAgICAgIHByZXYgPSB0aGlzLl9yZXZpc2VzID8gbnVsbCA6IHVuZGVmaW5lZDtcblxuICBsLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICBkZXN0Ll9zcmNNYXAgPSBkZXN0Ll9zcmNNYXAgfHwge307ICAvLyB0byBwcm9wYWdhdGUgdHVwbGVzIGNvcnJlY3RseVxuICAgIHZhciBtYXAgPSBkZXN0Ll9zcmNNYXAsXG4gICAgICAgIG91dHB1dCAgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICAgIG91dHB1dC5hZGQgPSBpbnB1dC5hZGQubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiAobWFwW3QuX2lkXSA9IHR1cGxlLmRlcml2ZSh0LCB0Ll9wcmV2ICE9PSB1bmRlZmluZWQgPyB0Ll9wcmV2IDogcHJldikpO1xuICAgIH0pO1xuICAgIG91dHB1dC5tb2QgPSBpbnB1dC5tb2QubWFwKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIG1hcFt0Ll9pZF07IH0pO1xuICAgIG91dHB1dC5yZW0gPSBpbnB1dC5yZW0ubWFwKGZ1bmN0aW9uKHQpIHsgXG4gICAgICB2YXIgbyA9IG1hcFt0Ll9pZF07XG4gICAgICBtYXBbdC5faWRdID0gbnVsbDtcbiAgICAgIHJldHVybiBvO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIChkZXN0Ll9pbnB1dCA9IG91dHB1dCk7XG4gIH07XG5cbiAgbC5hZGRMaXN0ZW5lcih0aGlzLl9waXBlbGluZVswXSk7XG4gIHJldHVybiBsO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIGlmKGwgaW5zdGFuY2VvZiBEYXRhc291cmNlKSB7XG4gICAgaWYodGhpcy5fY29sbGVjdG9yKSB0aGlzLl9jb2xsZWN0b3IuYWRkTGlzdGVuZXIobC5saXN0ZW5lcigpKTtcbiAgICBlbHNlIHRoaXMuX3BpcGVsaW5lWzBdLmFkZExpc3RlbmVyKGwubGlzdGVuZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fcGlwZWxpbmVbdGhpcy5fcGlwZWxpbmUubGVuZ3RoLTFdLmFkZExpc3RlbmVyKGwpOyAgICAgIFxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgdGhpcy5fcGlwZWxpbmVbdGhpcy5fcGlwZWxpbmUubGVuZ3RoLTFdLnJlbW92ZUxpc3RlbmVyKGwpO1xufTtcblxucHJvdG8ubGlzdGVuZXJzID0gZnVuY3Rpb24oZHMpIHtcbiAgcmV0dXJuIGRzIFxuICAgID8gdGhpcy5fY29sbGVjdG9yID8gdGhpcy5fY29sbGVjdG9yLmxpc3RlbmVycygpIDogdGhpcy5fcGlwZWxpbmVbMF0ubGlzdGVuZXJzKClcbiAgICA6IHRoaXMuX3BpcGVsaW5lW3RoaXMuX3BpcGVsaW5lLmxlbmd0aC0xXS5saXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YXNvdXJjZTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgSGVhcCA9IHJlcXVpcmUoJ2hlYXAnKSxcbiAgICBEYXRhc291cmNlID0gcmVxdWlyZSgnLi9EYXRhc291cmNlJyksXG4gICAgU2lnbmFsID0gcmVxdWlyZSgnLi9TaWduYWwnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuL2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBHcmFwaCgpIHtcbiAgdGhpcy5fc3RhbXAgPSAwO1xuICB0aGlzLl9yYW5rICA9IDA7XG5cbiAgdGhpcy5fZGF0YSA9IHt9O1xuICB0aGlzLl9zaWduYWxzID0ge307XG5cbiAgdGhpcy5kb05vdFByb3BhZ2F0ZSA9IHt9O1xufVxuXG52YXIgcHJvdG8gPSBHcmFwaC5wcm90b3R5cGU7XG5cbnByb3RvLmRhdGEgPSBmdW5jdGlvbihuYW1lLCBwaXBlbGluZSwgZmFjZXQpIHtcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gIHJldHVybiAodGhpcy5fZGF0YVtuYW1lXSA9IG5ldyBEYXRhc291cmNlKHRoaXMsIG5hbWUsIGZhY2V0KVxuICAgIC5waXBlbGluZShwaXBlbGluZSkpO1xufTtcblxuZnVuY3Rpb24gc2lnbmFsKG5hbWUpIHtcbiAgdmFyIG0gPSB0aGlzLCBpLCBsZW47XG4gIGlmKCFkbC5pc0FycmF5KG5hbWUpKSByZXR1cm4gdGhpcy5fc2lnbmFsc1tuYW1lXTtcbiAgcmV0dXJuIG5hbWUubWFwKGZ1bmN0aW9uKG4pIHsgbS5fc2lnbmFsc1tuXTsgfSk7XG59XG5cbnByb3RvLnNpZ25hbCA9IGZ1bmN0aW9uKG5hbWUsIGluaXQpIHtcbiAgdmFyIG0gPSB0aGlzO1xuICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gc2lnbmFsLmNhbGwodGhpcywgbmFtZSk7XG4gIHJldHVybiAodGhpcy5fc2lnbmFsc1tuYW1lXSA9IG5ldyBTaWduYWwodGhpcywgbmFtZSwgaW5pdCkpO1xufTtcblxucHJvdG8uc2lnbmFsVmFsdWVzID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBpZighZGwuaXNBcnJheShuYW1lKSkgcmV0dXJuIHRoaXMuX3NpZ25hbHNbbmFtZV0udmFsdWUoKTtcbiAgcmV0dXJuIG5hbWUucmVkdWNlKGZ1bmN0aW9uKHNnLCBuKSB7XG4gICAgcmV0dXJuIChzZ1tuXSA9IGdyYXBoLl9zaWduYWxzW25dLnZhbHVlKCksIHNnKTtcbiAgfSwge30pO1xufTtcblxucHJvdG8uc2lnbmFsUmVmID0gZnVuY3Rpb24ocmVmKSB7XG4gIGlmKCFkbC5pc0FycmF5KHJlZikpIHJlZiA9IGRsLmZpZWxkKHJlZik7XG4gIHZhciB2YWx1ZSA9IHRoaXMuc2lnbmFsKHJlZi5zaGlmdCgpKS52YWx1ZSgpO1xuICBpZihyZWYubGVuZ3RoID4gMCkge1xuICAgIHZhciBmbiA9IEZ1bmN0aW9uKFwic1wiLCBcInJldHVybiBzW1wiK3JlZi5tYXAoZGwuc3RyKS5qb2luKFwiXVtcIikrXCJdXCIpO1xuICAgIHZhbHVlID0gZm4uY2FsbChudWxsLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgc2NoZWR1bGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIC8vIElmIHRoZSBub2RlcyBhcmUgZXF1YWwsIHByb3BhZ2F0ZSB0aGUgbm9uLXJlZmxvdyBwdWxzZSBmaXJzdCxcbiAgLy8gc28gdGhhdCB3ZSBjYW4gaWdub3JlIHN1YnNlcXVlbnQgcmVmbG93IHB1bHNlcy4gXG4gIGlmKGEucmFuayA9PSBiLnJhbmspIHJldHVybiBhLnB1bHNlLnJlZmxvdyA/IDEgOiAtMTtcbiAgZWxzZSByZXR1cm4gYS5yYW5rIC0gYi5yYW5rOyBcbn07XG5cbnByb3RvLnByb3BhZ2F0ZSA9IGZ1bmN0aW9uKHB1bHNlLCBub2RlKSB7XG4gIHZhciB2LCBsLCBuLCBwLCByLCBpLCBsZW4sIHJlZmxvd2VkO1xuXG4gIC8vIG5ldyBQUSB3aXRoIGVhY2ggcHJvcGFnYXRpb24gY3ljbGUgc28gdGhhdCB3ZSBjYW4gcHVsc2UgYnJhbmNoZXNcbiAgLy8gb2YgdGhlIGRhdGFmbG93IGdyYXBoIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuLCB3aGVuIGNyZWF0aW5nXG4gIC8vIGEgbmV3IGlubGluZSBkYXRhc291cmNlKS5cbiAgdmFyIHBxID0gbmV3IEhlYXAoc2NoZWR1bGUpOyBcblxuICBpZihwdWxzZS5zdGFtcCkgdGhyb3cgXCJQdWxzZSBhbHJlYWR5IGhhcyBhIG5vbi16ZXJvIHN0YW1wXCJcblxuICBwdWxzZS5zdGFtcCA9ICsrdGhpcy5fc3RhbXA7XG4gIHBxLnB1c2goeyBub2RlOiBub2RlLCBwdWxzZTogcHVsc2UsIHJhbms6IG5vZGUucmFuaygpIH0pO1xuXG4gIHdoaWxlIChwcS5zaXplKCkgPiAwKSB7XG4gICAgdiA9IHBxLnBvcCgpLCBuID0gdi5ub2RlLCBwID0gdi5wdWxzZSwgciA9IHYucmFuaywgbCA9IG4uX2xpc3RlbmVycztcbiAgICByZWZsb3dlZCA9IHAucmVmbG93ICYmIG4ubGFzdCgpID49IHAuc3RhbXA7XG5cbiAgICBpZihyZWZsb3dlZCkgY29udGludWU7IC8vIERvbid0IG5lZWRsZXNzbHkgcmVmbG93IG9wcy5cblxuICAgIC8vIEEgbm9kZSdzIHJhbmsgbWlnaHQgY2hhbmdlIGR1cmluZyBhIHByb3BhZ2F0aW9uIChlLmcuIGluc3RhbnRpYXRpbmdcbiAgICAvLyBhIGdyb3VwJ3MgZGF0YWZsb3cgYnJhbmNoKS4gUmUtcXVldWUgaWYgaXQgaGFzLiBUXG4gICAgLy8gVE9ETzogdXNlIHBxLnJlcGxhY2Ugb3IgcHEucG9wcHVzaD9cbiAgICBpZihyICE9IG4ucmFuaygpKSB7XG4gICAgICBkZWJ1ZyhwLCBbJ1JhbmsgbWlzbWF0Y2gnLCByLCBuLnJhbmsoKV0pO1xuICAgICAgcHEucHVzaCh7IG5vZGU6IG4sIHB1bHNlOiBwLCByYW5rOiBuLnJhbmsoKSB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHAgPSB0aGlzLmV2YWx1YXRlKHAsIG4pO1xuXG4gICAgLy8gRXZlbiBpZiB3ZSBkaWRuJ3QgcnVuIHRoZSBub2RlLCB3ZSBzdGlsbCB3YW50IHRvIHByb3BhZ2F0ZSBcbiAgICAvLyB0aGUgcHVsc2UuIFxuICAgIGlmIChwICE9PSB0aGlzLmRvTm90UHJvcGFnYXRlKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW4gPSBsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBxLnB1c2goeyBub2RlOiBsW2ldLCBwdWxzZTogcCwgcmFuazogbFtpXS5fcmFuayB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIENvbm5lY3QgYSBicmFuY2ggb2YgZGF0YWZsb3cgbm9kZXMuIFxuLy8gRGVwZW5kZW5jaWVzIGdldCB3aXJlZCB0byB0aGUgbmVhcmVzdCBjb2xsZWN0b3IuIFxuZnVuY3Rpb24gZm9yRWFjaE5vZGUoYnJhbmNoLCBmbikge1xuICB2YXIgbm9kZSwgY29sbGVjdG9yLCBpLCBsZW47XG4gIGZvcihpPTAsIGxlbj1icmFuY2gubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbm9kZSA9IGJyYW5jaFtpXTtcbiAgICBpZihub2RlLmNvbGxlY3RvcigpKSBjb2xsZWN0b3IgPSBub2RlO1xuICAgIGZuKG5vZGUsIGNvbGxlY3RvciwgaSk7XG4gIH1cbn1cblxucHJvdG8uY29ubmVjdCA9IGZ1bmN0aW9uKGJyYW5jaCkge1xuICBkZWJ1Zyh7fSwgWydjb25uZWN0aW5nJ10pO1xuICB2YXIgZ3JhcGggPSB0aGlzO1xuICBmb3JFYWNoTm9kZShicmFuY2gsIGZ1bmN0aW9uKG4sIGMsIGkpIHtcbiAgICB2YXIgZGF0YSA9IG4uZGVwZW5kZW5jeShDLkRBVEEpLFxuICAgICAgICBzaWduYWxzID0gbi5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG5cbiAgICBpZihkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IFxuICAgICAgICBncmFwaC5kYXRhKGQpXG4gICAgICAgICAgLnJldmlzZXMobi5yZXZpc2VzKCkpXG4gICAgICAgICAgLmFkZExpc3RlbmVyKGMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYoc2lnbmFscy5sZW5ndGggPiAwKSB7XG4gICAgICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24ocykgeyBncmFwaC5zaWduYWwocykuYWRkTGlzdGVuZXIoYyk7IH0pO1xuICAgIH1cblxuICAgIGlmKGkgPiAwKSB7XG4gICAgICBicmFuY2hbaS0xXS5hZGRMaXN0ZW5lcihicmFuY2hbaV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGJyYW5jaDtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbihicmFuY2gpIHtcbiAgZGVidWcoe30sIFsnZGlzY29ubmVjdGluZyddKTtcbiAgdmFyIGdyYXBoID0gdGhpcztcblxuICBmb3JFYWNoTm9kZShicmFuY2gsIGZ1bmN0aW9uKG4sIGMsIGkpIHtcbiAgICB2YXIgZGF0YSA9IG4uZGVwZW5kZW5jeShDLkRBVEEpLFxuICAgICAgICBzaWduYWxzID0gbi5kZXBlbmRlbmN5KEMuU0lHTkFMUyk7XG5cbiAgICBpZihkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IGdyYXBoLmRhdGEoZCkucmVtb3ZlTGlzdGVuZXIoYyk7IH0pO1xuICAgIH1cblxuICAgIGlmKHNpZ25hbHMubGVuZ3RoID4gMCkge1xuICAgICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgZ3JhcGguc2lnbmFsKHMpLnJlbW92ZUxpc3RlbmVyKGMpIH0pO1xuICAgIH1cblxuICAgIG4uZGlzY29ubmVjdCgpOyAgXG4gIH0pO1xuXG4gIHJldHVybiBicmFuY2g7XG59O1xuXG5wcm90by5yZWV2YWx1YXRlID0gZnVuY3Rpb24ocHVsc2UsIG5vZGUpIHtcbiAgdmFyIHJlZmxvd2VkID0gIXB1bHNlLnJlZmxvdyB8fCAocHVsc2UucmVmbG93ICYmIG5vZGUubGFzdCgpID49IHB1bHNlLnN0YW1wKSxcbiAgICAgIHJ1biA9ICEhcHVsc2UuYWRkLmxlbmd0aCB8fCAhIXB1bHNlLnJlbS5sZW5ndGggfHwgbm9kZS5yb3V0ZXIoKTtcbiAgcnVuID0gcnVuIHx8ICFyZWZsb3dlZDtcbiAgcmV0dXJuIHJ1biB8fCBub2RlLnJlZXZhbHVhdGUocHVsc2UpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSwgbm9kZSkge1xuICBpZighdGhpcy5yZWV2YWx1YXRlKHB1bHNlLCBub2RlKSkgcmV0dXJuIHB1bHNlO1xuICBwdWxzZSA9IG5vZGUuZXZhbHVhdGUocHVsc2UpO1xuICBub2RlLmxhc3QocHVsc2Uuc3RhbXApO1xuICByZXR1cm4gcHVsc2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIFJFRVZBTCA9IFtDLkRBVEEsIEMuRklFTERTLCBDLlNDQUxFUywgQy5TSUdOQUxTXTtcblxudmFyIG5vZGVfaWQgPSAxO1xuXG5mdW5jdGlvbiBOb2RlKGdyYXBoKSB7XG4gIGlmKGdyYXBoKSB0aGlzLmluaXQoZ3JhcGgpO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gTm9kZS5wcm90b3R5cGU7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLl9pZCA9IG5vZGVfaWQrKztcbiAgdGhpcy5fZ3JhcGggPSBncmFwaDtcbiAgdGhpcy5fcmFuayA9ICsrZ3JhcGguX3Jhbms7IC8vIEZvciB0b3BvbG9naWFsIHNvcnRcbiAgdGhpcy5fc3RhbXAgPSAwOyAgLy8gTGFzdCBzdGFtcCBzZWVuXG5cbiAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gIHRoaXMuX3JlZ2lzdGVyZWQgPSB7fTsgLy8gVG8gcHJldmVudCBkdXBsaWNhdGUgbGlzdGVuZXJzXG5cbiAgdGhpcy5fZGVwcyA9IHtcbiAgICBkYXRhOiAgICBbXSxcbiAgICBmaWVsZHM6ICBbXSxcbiAgICBzY2FsZXM6ICBbXSxcbiAgICBzaWduYWxzOiBbXSxcbiAgfTtcblxuICB0aGlzLl9pc1JvdXRlciA9IGZhbHNlOyAvLyBSZXNwb25zaWJsZSBmb3IgcHJvcGFnYXRpbmcgdHVwbGVzLCBjYW5ub3QgZXZlciBiZSBza2lwcGVkXG4gIHRoaXMuX2lzQ29sbGVjdG9yID0gZmFsc2U7ICAvLyBIb2xkcyBhIG1hdGVyaWFsaXplZCBkYXRhc2V0LCBwdWxzZSB0byByZWZsb3dcbiAgdGhpcy5fcmV2aXNlcyA9IGZhbHNlOyAvLyBEb2VzIHRoZSBvcGVyYXRvciByZXF1aXJlIHR1cGxlcycgcHJldmlvdXMgdmFsdWVzPyBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IG5ldyBOb2RlKHRoaXMuX2dyYXBoKTtcbiAgbi5ldmFsdWF0ZSA9IHRoaXMuZXZhbHVhdGU7XG4gIG4uX2RlcHMgPSB0aGlzLl9kZXBzO1xuICBuLl9pc1JvdXRlciA9IHRoaXMuX2lzUm91dGVyO1xuICBuLl9pc0NvbGxlY3RvciA9IHRoaXMuX2lzQ29sbGVjdG9yO1xuICByZXR1cm4gbjtcbn07XG5cbnByb3RvLnJhbmsgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX3Jhbms7IH07XG5cbnByb3RvLmxhc3QgPSBmdW5jdGlvbihzdGFtcCkgeyBcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zdGFtcDtcbiAgdGhpcy5fc3RhbXAgPSBzdGFtcDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICB2YXIgZCA9IHRoaXMuX2RlcHNbdHlwZV07XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHJldHVybiBkO1xuICBpZihkZXBzID09PSBudWxsKSB7IC8vIENsZWFyIGRlcGVuZGVuY2llcyBvZiBhIGNlcnRhaW4gdHlwZVxuICAgIHdoaWxlKGQubGVuZ3RoID4gMCkgZC5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBpZighZGwuaXNBcnJheShkZXBzKSAmJiBkLmluZGV4T2YoZGVwcykgPCAwKSBkLnB1c2goZGVwcyk7XG4gICAgZWxzZSBkLnB1c2guYXBwbHkoZCwgZGwuYXJyYXkoZGVwcykpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucm91dGVyID0gZnVuY3Rpb24oYm9vbCkge1xuICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2lzUm91dGVyO1xuICB0aGlzLl9pc1JvdXRlciA9ICEhYm9vbFxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmNvbGxlY3RvciA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9pc0NvbGxlY3RvcjtcbiAgdGhpcy5faXNDb2xsZWN0b3IgPSAhIWJvb2w7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ucmV2aXNlcyA9IGZ1bmN0aW9uKGJvb2wpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZXZpc2VzO1xuICB0aGlzLl9yZXZpc2VzID0gISFib29sO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmxpc3RlbmVycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzO1xufTtcblxucHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gIGlmKCEobCBpbnN0YW5jZW9mIE5vZGUpKSB0aHJvdyBcIkxpc3RlbmVyIGlzIG5vdCBhIE5vZGVcIjtcbiAgaWYodGhpcy5fcmVnaXN0ZXJlZFtsLl9pZF0pIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuX2xpc3RlbmVycy5wdXNoKGwpO1xuICB0aGlzLl9yZWdpc3RlcmVkW2wuX2lkXSA9IDE7XG4gIGlmKHRoaXMuX3JhbmsgPiBsLl9yYW5rKSB7XG4gICAgdmFyIHEgPSBbbF07XG4gICAgd2hpbGUocS5sZW5ndGgpIHtcbiAgICAgIHZhciBjdXIgPSBxLnNwbGljZSgwLDEpWzBdO1xuICAgICAgY3VyLl9yYW5rID0gKyt0aGlzLl9ncmFwaC5fcmFuaztcbiAgICAgIHEucHVzaC5hcHBseShxLCBjdXIuX2xpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChsKSB7XG4gIHZhciBmb3VuZFNlbmRpbmcgPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW4gJiYgIWZvdW5kU2VuZGluZzsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVyc1tpXSA9PT0gbCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRbbC5faWRdID0gbnVsbDtcbiAgICAgIGZvdW5kU2VuZGluZyA9IHRydWU7XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gZm91bmRTZW5kaW5nO1xufTtcblxucHJvdG8uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgdGhpcy5fcmVnaXN0ZXJlZCA9IHt9O1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihwdWxzZSkgeyByZXR1cm4gcHVsc2U7IH1cblxucHJvdG8ucmVldmFsdWF0ZSA9IGZ1bmN0aW9uKHB1bHNlKSB7XG4gIHZhciBub2RlID0gdGhpcywgcmVldmFsID0gZmFsc2U7XG4gIHJldHVybiBSRUVWQUwuc29tZShmdW5jdGlvbihwcm9wKSB7XG4gICAgcmVldmFsID0gcmVldmFsIHx8IG5vZGUuX2RlcHNbcHJvcF0uc29tZShmdW5jdGlvbihrKSB7IHJldHVybiAhIXB1bHNlW3Byb3BdW2tdIH0pO1xuICAgIHJldHVybiByZWV2YWw7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBOb2RlOyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi9jaGFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gU2lnbmFsKGdyYXBoLCBuYW1lLCBpbml0KSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX25hbWUgID0gbmFtZTtcbiAgdGhpcy5fdmFsdWUgPSBpbml0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBwcm90byA9IChTaWduYWwucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLm5hbWUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX25hbWU7IH07XG5cbnByb3RvLnZhbHVlID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIHRoaXMuX3ZhbHVlID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmZpcmUgPSBmdW5jdGlvbihjcykge1xuICBpZighY3MpIGNzID0gY2hhbmdlc2V0LmNyZWF0ZShudWxsLCB0cnVlKTtcbiAgY3Muc2lnbmFsc1t0aGlzLl9uYW1lXSA9IDE7XG4gIHRoaXMuX2dyYXBoLnByb3BhZ2F0ZShjcywgdGhpcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNpZ25hbDsiLCJ2YXIgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG52YXIgUkVFVkFMID0gW0MuREFUQSwgQy5GSUVMRFMsIEMuU0NBTEVTLCBDLlNJR05BTFNdO1xuXG5mdW5jdGlvbiBjcmVhdGUoY3MsIHJlZmxvdykge1xuICB2YXIgb3V0ID0ge307XG4gIGNvcHkoY3MsIG91dCk7XG5cbiAgb3V0LmFkZCA9IFtdO1xuICBvdXQubW9kID0gW107XG4gIG91dC5yZW0gPSBbXTtcblxuICBvdXQucmVmbG93ID0gcmVmbG93O1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHJlc2V0X3ByZXYoeCkge1xuICB4Ll9wcmV2ID0gKHguX3ByZXYgPT09IHVuZGVmaW5lZCkgPyB1bmRlZmluZWQgOiBDLlNFTlRJTkVMO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShjcykge1xuICBmb3IoaT0wLCBsZW49Y3MuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkgcmVzZXRfcHJldihjcy5hZGRbaV0pO1xuICBmb3IoaT0wLCBsZW49Y3MubW9kLmxlbmd0aDsgaTxsZW47ICsraSkgcmVzZXRfcHJldihjcy5tb2RbaV0pO1xufVxuXG5mdW5jdGlvbiBjb3B5KGEsIGIpIHtcbiAgYi5zdGFtcCA9IGEgPyBhLnN0YW1wIDogMDtcbiAgYi5zb3J0ICA9IGEgPyBhLnNvcnQgIDogbnVsbDtcbiAgYi5mYWNldCA9IGEgPyBhLmZhY2V0IDogbnVsbDtcbiAgYi50cmFucyA9IGEgPyBhLnRyYW5zIDogbnVsbDtcbiAgUkVFVkFMLmZvckVhY2goZnVuY3Rpb24oZCkgeyBiW2RdID0gYSA/IGFbZF0gOiB7fTsgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGU6IGNyZWF0ZSxcbiAgY29weTogY29weSxcbiAgZmluYWxpemU6IGZpbmFsaXplLFxufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyksXG4gICAgdHVwbGVfaWQgPSAxO1xuXG4vLyBPYmplY3QuY3JlYXRlIGlzIGV4cGVuc2l2ZS4gU28sIHdoZW4gaW5nZXN0aW5nLCB0cnVzdCB0aGF0IHRoZVxuLy8gZGF0dW0gaXMgYW4gb2JqZWN0IHRoYXQgaGFzIGJlZW4gYXBwcm9wcmlhdGVseSBzYW5kYm94ZWQgZnJvbSBcbi8vIHRoZSBvdXRzaWRlIGVudmlyb25tZW50LiBcbmZ1bmN0aW9uIGluZ2VzdChkYXR1bSwgcHJldikge1xuICBkYXR1bSA9IGRsLmlzT2JqZWN0KGRhdHVtKSA/IGRhdHVtIDoge2RhdGE6IGRhdHVtfTtcbiAgZGF0dW0uX2lkID0gdHVwbGVfaWQrKztcbiAgZGF0dW0uX3ByZXYgPSAocHJldiAhPT0gdW5kZWZpbmVkKSA/IChwcmV2IHx8IEMuU0VOVElORUwpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZGF0dW07XG59XG5cbmZ1bmN0aW9uIGRlcml2ZShkYXR1bSwgcHJldikge1xuICByZXR1cm4gaW5nZXN0KE9iamVjdC5jcmVhdGUoZGF0dW0pLCBwcmV2KTtcbn1cblxuLy8gV0FSTklORzogb3BlcmF0b3JzIHNob3VsZCBvbmx5IGNhbGwgdGhpcyBvbmNlIHBlciB0aW1lc3RhbXAhXG5mdW5jdGlvbiBzZXQodCwgaywgdikge1xuICB2YXIgcHJldiA9IHRba107XG4gIGlmKHByZXYgPT09IHYpIHJldHVybjtcbiAgc2V0X3ByZXYodCwgayk7XG4gIHRba10gPSB2O1xufVxuXG5mdW5jdGlvbiBzZXRfcHJldih0LCBrKSB7XG4gIGlmKHQuX3ByZXYgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICB0Ll9wcmV2ID0gKHQuX3ByZXYgPT09IEMuU0VOVElORUwpID8ge30gOiB0Ll9wcmV2O1xuICB0Ll9wcmV2W2tdID0gdFtrXTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7IHR1cGxlX2lkID0gMTsgfVxuXG5mdW5jdGlvbiBpZE1hcChhKSB7XG4gIHJldHVybiBhLnJlZHVjZShmdW5jdGlvbihtLHgpIHtcbiAgICByZXR1cm4gKG1beC5faWRdID0gMSwgbSk7XG4gIH0sIHt9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbmdlc3Q6IGluZ2VzdCxcbiAgZGVyaXZlOiBkZXJpdmUsXG4gIHNldDogICAgc2V0LFxuICBwcmV2OiAgIHNldF9wcmV2LFxuICByZXNldDogIHJlc2V0LFxuICBpZE1hcDogIGlkTWFwXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgY29uc3RhbnRzID0gb3B0LmNvbnN0YW50cyB8fCByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuICB2YXIgZnVuY3Rpb25zID0gKG9wdC5mdW5jdGlvbnMgfHwgcmVxdWlyZSgnLi9mdW5jdGlvbnMnKSkoY29kZWdlbik7XG4gIHZhciBpZFdoaXRlTGlzdCA9IG9wdC5pZFdoaXRlTGlzdCA/IGRsLnRvTWFwKG9wdC5pZFdoaXRlTGlzdCkgOiBudWxsO1xuICB2YXIgaWRCbGFja0xpc3QgPSBvcHQuaWRCbGFja0xpc3QgPyBkbC50b01hcChvcHQuaWRCbGFja0xpc3QpIDogbnVsbDtcbiAgdmFyIG1lbWJlckRlcHRoID0gMDtcblxuICAvLyBUT0RPIGdlbmVyYWxpemU/XG4gIHZhciBEQVRVTSA9ICdkJztcbiAgdmFyIFNJR05BTF9QUkVGSVggPSAnc2cuJztcbiAgdmFyIHNpZ25hbHMgPSB7fTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGNvZGVnZW5fd3JhcChhc3QpIHsgICAgXG4gICAgdmFyIHJldHZhbCA9IHtcbiAgICAgIGZuOiBjb2RlZ2VuKGFzdCksXG4gICAgICBzaWduYWxzOiBkbC5rZXlzKHNpZ25hbHMpLFxuICAgICAgZmllbGRzOiBkbC5rZXlzKGZpZWxkcylcbiAgICB9O1xuICAgIHNpZ25hbHMgPSB7fTtcbiAgICBmaWVsZHMgPSB7fTtcbiAgICByZXR1cm4gcmV0dmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gY29kZWdlbihhc3QpIHtcbiAgICBpZiAoYXN0IGluc3RhbmNlb2YgU3RyaW5nKSByZXR1cm4gYXN0O1xuICAgIHZhciBnZW5lcmF0b3IgPSBDT0RFR0VOX1RZUEVTW2FzdC50eXBlXTtcbiAgICBpZiAoZ2VuZXJhdG9yID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHR5cGU6IFwiICsgYXN0LnR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJhdG9yKGFzdCk7XG4gIH1cblxuICB2YXIgQ09ERUdFTl9UWVBFUyA9IHtcbiAgICBcIkxpdGVyYWxcIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi5yYXc7XG4gICAgICB9LFxuICAgIFwiSWRlbnRpZmllclwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBpZCA9IG4ubmFtZTtcbiAgICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RhbnRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgIHJldHVybiBjb25zdGFudHNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZFdoaXRlTGlzdCkge1xuICAgICAgICAgIGlmIChpZFdoaXRlTGlzdC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2lnbmFsc1tpZF0gPSAxO1xuICAgICAgICAgICAgcmV0dXJuIFNJR05BTF9QUkVGSVggKyBpZDsgLy8gSEFDS2lzaC4uLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRCbGFja0xpc3QgJiYgaWRCbGFja0xpc3QuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBpZGVudGlmaWVyOiBcIiArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9LFxuICAgIFwiUHJvZ3JhbVwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBuLmJvZHkubWFwKGNvZGVnZW4pLmpvaW4oXCJcXG5cIik7XG4gICAgICB9LFxuICAgIFwiTWVtYmVyRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHZhciBkID0gIW4uY29tcHV0ZWQ7XG4gICAgICAgIHZhciBvID0gY29kZWdlbihuLm9iamVjdCk7XG4gICAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgICB2YXIgcCA9IGNvZGVnZW4obi5wcm9wZXJ0eSk7XG4gICAgICAgIGlmIChvID09PSBEQVRVTSkgeyBmaWVsZHNbcF0gPSAxOyB9IC8vIEhBQ0tpc2guLi5cbiAgICAgICAgaWYgKGQpIG1lbWJlckRlcHRoIC09IDE7XG4gICAgICAgIHJldHVybiBvICsgKGQgPyBcIi5cIitwIDogXCJbXCIrcCtcIl1cIik7XG4gICAgICB9LFxuICAgIFwiQ2FsbEV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICBpZiAobi5jYWxsZWUudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGNhbGxlZSB0eXBlOiBcIiArIG4uY2FsbGVlLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsZWUgPSBuLmNhbGxlZS5uYW1lO1xuICAgICAgICB2YXIgYXJncyA9IG4uYXJndW1lbnRzO1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbnMuaGFzT3duUHJvcGVydHkoY2FsbGVlKSAmJiBmdW5jdGlvbnNbY2FsbGVlXTtcbiAgICAgICAgaWYgKCFmbikgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGZ1bmN0aW9uOiBcIiArIGNhbGxlZSk7XG4gICAgICAgIHJldHVybiBmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXG4gICAgICAgICAgPyBmbihhcmdzKVxuICAgICAgICAgIDogZm4gKyBcIihcIiArIGFyZ3MubWFwKGNvZGVnZW4pLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICB9LFxuICAgIFwiQXJyYXlFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiW1wiICsgbi5lbGVtZW50cy5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIl1cIjtcbiAgICAgIH0sXG4gICAgXCJCaW5hcnlFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgY29kZWdlbihuLmxlZnQpICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5yaWdodCkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJVbmFyeUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyBuLm9wZXJhdG9yICsgY29kZWdlbihuLmFyZ3VtZW50KSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIlVwZGF0ZUV4cHJlc3Npb25cIjogZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gXCIoXCIgKyAocHJlZml4XG4gICAgICAgICAgPyBuLm9wZXJhdG9yICsgY29kZWdlbihuLmFyZ3VtZW50KVxuICAgICAgICAgIDogY29kZWdlbihuLmFyZ3VtZW50KSArIG4ub3BlcmF0b3JcbiAgICAgICAgKSArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBcIihcIiArIGNvZGVnZW4obi50ZXN0KVxuICAgICAgICAgICsgXCI/XCIgKyBjb2RlZ2VuKG4uY29uc2VxdWVudClcbiAgICAgICAgICArIFwiOlwiICsgY29kZWdlbihuLmFsdGVybmF0ZSlcbiAgICAgICAgICArIFwiKVwiO1xuICAgICAgfSxcbiAgICBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwiKFwiICsgY29kZWdlbihuLmxlZnQpICsgbi5vcGVyYXRvciArIGNvZGVnZW4obi5yaWdodCkgKyBcIilcIjtcbiAgICAgIH0sXG4gICAgXCJPYmplY3RFeHByZXNzaW9uXCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIFwie1wiICsgbi5wcm9wZXJ0aWVzLm1hcChjb2RlZ2VuKS5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgICAgfSxcbiAgICBcIlByb3BlcnR5XCI6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgbWVtYmVyRGVwdGggKz0gMTtcbiAgICAgICAgdmFyIGsgPSBjb2RlZ2VuKG4ua2V5KTtcbiAgICAgICAgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgICAgcmV0dXJuIGsgKyBcIjpcIiArIGNvZGVnZW4obi52YWx1ZSk7XG4gICAgICB9LFxuICAgIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOiBmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiBjb2RlZ2VuKG4uZXhwcmVzc2lvbik7XG4gICAgICB9XG4gIH07XG4gIFxuICByZXR1cm4gY29kZWdlbl93cmFwO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgXCJOYU5cIjogICAgIFwiTmFOXCIsXG4gIFwiRVwiOiAgICAgICBcIk1hdGguRVwiLFxuICBcIkxOMlwiOiAgICAgXCJNYXRoLkxOMlwiLFxuICBcIkxOMTBcIjogICAgXCJNYXRoLkxOMTBcIixcbiAgXCJMT0cyRVwiOiAgIFwiTWF0aC5MT0cyRVwiLFxuICBcIkxPRzEwRVwiOiAgXCJNYXRoLkxPRzEwRVwiLFxuICBcIlBJXCI6ICAgICAgXCJNYXRoLlBJXCIsXG4gIFwiU1FSVDFfMlwiOiBcIk1hdGguU1FSVDFfMlwiLFxuICBcIlNRUlQyXCI6ICAgXCJNYXRoLlNRUlQyXCJcbn07IiwidmFyIGRhdGFsaWIgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oY29kZWdlbikge1xuXG4gIGZ1bmN0aW9uIGZuY2FsbChuYW1lLCBhcmdzLCBjYXN0LCB0eXBlKSB7XG4gICAgdmFyIG9iaiA9IGNvZGVnZW4oYXJnc1swXSk7XG4gICAgaWYgKGNhc3QpIHtcbiAgICAgIG9iaiA9IGNhc3QgKyBcIihcIiArIG9iaiArIFwiKVwiO1xuICAgICAgaWYgKGRsLnN0YXJ0c1dpdGgoY2FzdCwgXCJuZXcgXCIpKSBvYmogPSBcIihcIiArIG9iaiArIFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gb2JqICsgXCIuXCIgKyBuYW1lICsgKHR5cGUgPCAwID8gXCJcIiA6IHR5cGUgPT09IDBcbiAgICAgID8gXCIoKVwiXG4gICAgICA6IFwiKFwiICsgYXJncy5zbGljZSgxKS5tYXAoY29kZWdlbikuam9pbihcIixcIikgKyBcIilcIik7XG4gIH1cbiAgXG4gIHZhciBEQVRFID0gXCJuZXcgRGF0ZVwiO1xuICB2YXIgU1RSSU5HID0gXCJTdHJpbmdcIjtcbiAgdmFyIFJFR0VYUCA9IFwiUmVnRXhwXCI7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBNQVRIIGZ1bmN0aW9uc1xuICAgIFwiaXNOYU5cIjogICAgXCJpc05hTlwiLFxuICAgIFwiaXNGaW5pdGVcIjogXCJpc0Zpbml0ZVwiLFxuICAgIFwiYWJzXCI6ICAgICAgXCJNYXRoLmFic1wiLFxuICAgIFwiYWNvc1wiOiAgICAgXCJNYXRoLmFjb3NcIixcbiAgICBcImFzaW5cIjogICAgIFwiTWF0aC5hc2luXCIsXG4gICAgXCJhdGFuXCI6ICAgICBcIk1hdGguYXRhblwiLFxuICAgIFwiYXRhbjJcIjogICAgXCJNYXRoLmF0YW4yXCIsXG4gICAgXCJjZWlsXCI6ICAgICBcIk1hdGguY2VpbFwiLFxuICAgIFwiY29zXCI6ICAgICAgXCJNYXRoLmNvc1wiLFxuICAgIFwiZXhwXCI6ICAgICAgXCJNYXRoLmV4cFwiLFxuICAgIFwiZmxvb3JcIjogICAgXCJNYXRoLmZsb29yXCIsXG4gICAgXCJsb2dcIjogICAgICBcIk1hdGgubG9nXCIsXG4gICAgXCJtYXhcIjogICAgICBcIk1hdGgubWF4XCIsXG4gICAgXCJtaW5cIjogICAgICBcIk1hdGgubWluXCIsXG4gICAgXCJwb3dcIjogICAgICBcIk1hdGgucG93XCIsXG4gICAgXCJyYW5kb21cIjogICBcIk1hdGgucmFuZG9tXCIsXG4gICAgXCJyb3VuZFwiOiAgICBcIk1hdGgucm91bmRcIixcbiAgICBcInNpblwiOiAgICAgIFwiTWF0aC5zaW5cIixcbiAgICBcInNxcnRcIjogICAgIFwiTWF0aC5zcXJ0XCIsXG4gICAgXCJ0YW5cIjogICAgICBcIk1hdGgudGFuXCIsXG5cbiAgICAvLyBEQVRFIGZ1bmN0aW9uc1xuICAgIFwibm93XCI6ICAgICAgXCJEYXRlLm5vd1wiLFxuICAgIFwiZGF0ZXRpbWVcIjogXCJuZXcgRGF0ZVwiLFxuICAgIFwiZGF0ZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXREYXRlXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcImRheVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXREYXlcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwieWVhclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRGdWxsWWVhclwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJtb250aFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRNb250aFwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJob3Vyc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRIb3Vyc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJtaW51dGVzXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldE1pbnV0ZXNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwic2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRTZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcIm1pbGxpc2Vjb25kc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRNaWxsaXNlY29uZHNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidGltZVwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRUaW1lXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInRpbWV6b25lb2Zmc2V0XCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcImdldFRpbWV6b25lT2Zmc2V0XCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y2RhdGVcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDRGF0ZVwiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNkYXlcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDRGF5XCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y3llYXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDRnVsbFllYXJcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjbW9udGhcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDTW9udGhcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjaG91cnNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDSG91cnNcIiwgYXJncywgREFURSwgMCk7XG4gICAgICB9LFxuICAgIFwidXRjbWludXRlc1wiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJnZXRVVENNaW51dGVzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcbiAgICBcInV0Y3NlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDU2Vjb25kc1wiLCBhcmdzLCBEQVRFLCAwKTtcbiAgICAgIH0sXG4gICAgXCJ1dGNtaWxsaXNlY29uZHNcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiZ2V0VVRDTWlsbGlzZWNvbmRzXCIsIGFyZ3MsIERBVEUsIDApO1xuICAgICAgfSxcblxuICAgIC8vIHNoYXJlZCBzZXF1ZW5jZSBmdW5jdGlvbnNcbiAgICBcImxlbmd0aFwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJsZW5ndGhcIiwgYXJncywgbnVsbCwgLTEpO1xuICAgICAgfSxcbiAgICBcImluZGV4b2ZcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwiaW5kZXhPZlwiLCBhcmdzLCBudWxsKTtcbiAgICAgIH0sXG4gICAgXCJsYXN0aW5kZXhvZlwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJsYXN0SW5kZXhPZlwiLCBhcmdzLCBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAvLyBTVFJJTkcgZnVuY3Rpb25zXG4gICAgXCJwYXJzZUZsb2F0XCI6IFwicGFyc2VGbG9hdFwiLFxuICAgIFwicGFyc2VJbnRcIjogXCJwYXJzZUludFwiLFxuICAgIFwidXBwZXJcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwidG9VcHBlckNhc2VcIiwgYXJncywgU1RSSU5HLCAwKTtcbiAgICAgIH0sXG4gICAgXCJsb3dlclwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHJldHVybiBmbmNhbGwoXCJ0b0xvd2VyQ2FzZVwiLCBhcmdzLCBTVFJJTkcsIDApO1xuICAgICAgfSxcbiAgICBcInNsaWNlXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInNsaWNlXCIsIGFyZ3MsIFNUUklORyk7XG4gICAgICB9LFxuICAgIFwic3Vic3RyaW5nXCI6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGZuY2FsbChcInN1YnN0cmluZ1wiLCBhcmdzLCBTVFJJTkcpO1xuICAgICAgfSxcblxuICAgIC8vIFJFR0VYUCBmdW5jdGlvbnNcbiAgICBcInRlc3RcIjogZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gZm5jYWxsKFwidGVzdFwiLCBhcmdzLCBSRUdFWFApO1xuICAgICAgfSxcbiAgICBcbiAgICAvLyBDb250cm9sIEZsb3cgZnVuY3Rpb25zXG4gICAgXCJpZlwiOiBmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uXCIpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uXCIpO1xuICAgICAgICB2YXIgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgICByZXR1cm4gYVswXStcIj9cIithWzFdK1wiOlwiK2FbMl07XG4gICAgICB9XG4gIH07XG59OyIsInZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpLFxuICAgIGNvZGVnZW4gPSByZXF1aXJlKCcuL2NvZGVnZW4nKTtcbiAgICBcbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZTogZnVuY3Rpb24oaW5wdXQsIG9wdCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlKFwiKFwiK2lucHV0K1wiKVwiLCBvcHQpOyB9LFxuICBjb2RlOiBmdW5jdGlvbihvcHQpIHsgcmV0dXJuIGNvZGVnZW4ob3B0KTsgfVxufTtcbiIsIi8qXG4gIFRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiBwYXJzZXIgaXMgYmFzZWQgb24gRXNwcmltYSAoaHR0cDovL2VzcHJpbWEub3JnLykuXG4gIE9yaWdpbmFsIGhlYWRlciBjb21tZW50IGFuZCBsaWNlbnNlIGZvciBFc3ByaW1hIGlzIGluY2x1ZGVkIGhlcmU6XG5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgVG9rZW4sXG4gICAgICBUb2tlbk5hbWUsXG4gICAgICBTeW50YXgsXG4gICAgICBQcm9wZXJ0eUtpbmQsXG4gICAgICBNZXNzYWdlcyxcbiAgICAgIFJlZ2V4LFxuICAgICAgc291cmNlLFxuICAgICAgc3RyaWN0LFxuICAgICAgaW5kZXgsXG4gICAgICBsaW5lTnVtYmVyLFxuICAgICAgbGluZVN0YXJ0LFxuICAgICAgbGVuZ3RoLFxuICAgICAgbG9va2FoZWFkLFxuICAgICAgc3RhdGUsXG4gICAgICBleHRyYTtcblxuICBUb2tlbiA9IHtcbiAgICAgIEJvb2xlYW5MaXRlcmFsOiAxLFxuICAgICAgRU9GOiAyLFxuICAgICAgSWRlbnRpZmllcjogMyxcbiAgICAgIEtleXdvcmQ6IDQsXG4gICAgICBOdWxsTGl0ZXJhbDogNSxcbiAgICAgIE51bWVyaWNMaXRlcmFsOiA2LFxuICAgICAgUHVuY3R1YXRvcjogNyxcbiAgICAgIFN0cmluZ0xpdGVyYWw6IDgsXG4gICAgICBSZWd1bGFyRXhwcmVzc2lvbjogOVxuICB9O1xuXG4gIFRva2VuTmFtZSA9IHt9O1xuICBUb2tlbk5hbWVbVG9rZW4uQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuICBUb2tlbk5hbWVbVG9rZW4uRU9GXSA9ICc8ZW5kPic7XG4gIFRva2VuTmFtZVtUb2tlbi5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcbiAgVG9rZW5OYW1lW1Rva2VuLktleXdvcmRdID0gJ0tleXdvcmQnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVsbExpdGVyYWxdID0gJ051bGwnO1xuICBUb2tlbk5hbWVbVG9rZW4uTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuICBUb2tlbk5hbWVbVG9rZW4uUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG4gIFRva2VuTmFtZVtUb2tlbi5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuICBUb2tlbk5hbWVbVG9rZW4uUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcblxuICBTeW50YXggPSB7XG4gICAgICBBc3NpZ25tZW50RXhwcmVzc2lvbjogJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJyxcbiAgICAgIEFycmF5RXhwcmVzc2lvbjogJ0FycmF5RXhwcmVzc2lvbicsXG4gICAgICBCaW5hcnlFeHByZXNzaW9uOiAnQmluYXJ5RXhwcmVzc2lvbicsXG4gICAgICBDYWxsRXhwcmVzc2lvbjogJ0NhbGxFeHByZXNzaW9uJyxcbiAgICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogJ0NvbmRpdGlvbmFsRXhwcmVzc2lvbicsXG4gICAgICBFeHByZXNzaW9uU3RhdGVtZW50OiAnRXhwcmVzc2lvblN0YXRlbWVudCcsXG4gICAgICBJZGVudGlmaWVyOiAnSWRlbnRpZmllcicsXG4gICAgICBMaXRlcmFsOiAnTGl0ZXJhbCcsXG4gICAgICBMb2dpY2FsRXhwcmVzc2lvbjogJ0xvZ2ljYWxFeHByZXNzaW9uJyxcbiAgICAgIE1lbWJlckV4cHJlc3Npb246ICdNZW1iZXJFeHByZXNzaW9uJyxcbiAgICAgIE9iamVjdEV4cHJlc3Npb246ICdPYmplY3RFeHByZXNzaW9uJyxcbiAgICAgIFByb2dyYW06ICdQcm9ncmFtJyxcbiAgICAgIFByb3BlcnR5OiAnUHJvcGVydHknLFxuICAgICAgVW5hcnlFeHByZXNzaW9uOiAnVW5hcnlFeHByZXNzaW9uJyxcbiAgICAgIFVwZGF0ZUV4cHJlc3Npb246ICdVcGRhdGVFeHByZXNzaW9uJ1xuICB9O1xuXG4gIFByb3BlcnR5S2luZCA9IHtcbiAgICAgIERhdGE6IDEsXG4gICAgICBHZXQ6IDIsXG4gICAgICBTZXQ6IDRcbiAgfTtcblxuICAvLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxuICBNZXNzYWdlcyA9IHtcbiAgICAgIFVuZXhwZWN0ZWRUb2tlbjogICdVbmV4cGVjdGVkIHRva2VuICUwJyxcbiAgICAgIFVuZXhwZWN0ZWROdW1iZXI6ICAnVW5leHBlY3RlZCBudW1iZXInLFxuICAgICAgVW5leHBlY3RlZFN0cmluZzogICdVbmV4cGVjdGVkIHN0cmluZycsXG4gICAgICBVbmV4cGVjdGVkSWRlbnRpZmllcjogICdVbmV4cGVjdGVkIGlkZW50aWZpZXInLFxuICAgICAgVW5leHBlY3RlZFJlc2VydmVkOiAgJ1VuZXhwZWN0ZWQgcmVzZXJ2ZWQgd29yZCcsXG4gICAgICBVbmV4cGVjdGVkRU9TOiAgJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0JyxcbiAgICAgIE5ld2xpbmVBZnRlclRocm93OiAgJ0lsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvdycsXG4gICAgICBJbnZhbGlkUmVnRXhwOiAnSW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgVW50ZXJtaW5hdGVkUmVnRXhwOiAgJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uOiBtaXNzaW5nIC8nLFxuICAgICAgSW52YWxpZExIU0luQXNzaWdubWVudDogICdJbnZhbGlkIGxlZnQtaGFuZCBzaWRlIGluIGFzc2lnbm1lbnQnLFxuICAgICAgSW52YWxpZExIU0luRm9ySW46ICAnSW52YWxpZCBsZWZ0LWhhbmQgc2lkZSBpbiBmb3ItaW4nLFxuICAgICAgTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoOiAnTW9yZSB0aGFuIG9uZSBkZWZhdWx0IGNsYXVzZSBpbiBzd2l0Y2ggc3RhdGVtZW50JyxcbiAgICAgIE5vQ2F0Y2hPckZpbmFsbHk6ICAnTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGFmdGVyIHRyeScsXG4gICAgICBVbmtub3duTGFiZWw6ICdVbmRlZmluZWQgbGFiZWwgXFwnJTBcXCcnLFxuICAgICAgUmVkZWNsYXJhdGlvbjogJyUwIFxcJyUxXFwnIGhhcyBhbHJlYWR5IGJlZW4gZGVjbGFyZWQnLFxuICAgICAgSWxsZWdhbENvbnRpbnVlOiAnSWxsZWdhbCBjb250aW51ZSBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbEJyZWFrOiAnSWxsZWdhbCBicmVhayBzdGF0ZW1lbnQnLFxuICAgICAgSWxsZWdhbFJldHVybjogJ0lsbGVnYWwgcmV0dXJuIHN0YXRlbWVudCcsXG4gICAgICBTdHJpY3RNb2RlV2l0aDogICdTdHJpY3QgbW9kZSBjb2RlIG1heSBub3QgaW5jbHVkZSBhIHdpdGggc3RhdGVtZW50JyxcbiAgICAgIFN0cmljdENhdGNoVmFyaWFibGU6ICAnQ2F0Y2ggdmFyaWFibGUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RWYXJOYW1lOiAgJ1ZhcmlhYmxlIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RQYXJhbU5hbWU6ICAnUGFyYW1ldGVyIG5hbWUgZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0UGFyYW1EdXBlOiAnU3RyaWN0IG1vZGUgZnVuY3Rpb24gbWF5IG5vdCBoYXZlIGR1cGxpY2F0ZSBwYXJhbWV0ZXIgbmFtZXMnLFxuICAgICAgU3RyaWN0RnVuY3Rpb25OYW1lOiAgJ0Z1bmN0aW9uIG5hbWUgbWF5IG5vdCBiZSBldmFsIG9yIGFyZ3VtZW50cyBpbiBzdHJpY3QgbW9kZScsXG4gICAgICBTdHJpY3RPY3RhbExpdGVyYWw6ICAnT2N0YWwgbGl0ZXJhbHMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlLicsXG4gICAgICBTdHJpY3REZWxldGU6ICAnRGVsZXRlIG9mIGFuIHVucXVhbGlmaWVkIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUuJyxcbiAgICAgIFN0cmljdER1cGxpY2F0ZVByb3BlcnR5OiAgJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIEFjY2Vzc29yRGF0YVByb3BlcnR5OiAgJ09iamVjdCBsaXRlcmFsIG1heSBub3QgaGF2ZSBkYXRhIGFuZCBhY2Nlc3NvciBwcm9wZXJ0eSB3aXRoIHRoZSBzYW1lIG5hbWUnLFxuICAgICAgQWNjZXNzb3JHZXRTZXQ6ICAnT2JqZWN0IGxpdGVyYWwgbWF5IG5vdCBoYXZlIG11bHRpcGxlIGdldC9zZXQgYWNjZXNzb3JzIHdpdGggdGhlIHNhbWUgbmFtZScsXG4gICAgICBTdHJpY3RMSFNBc3NpZ25tZW50OiAgJ0Fzc2lnbm1lbnQgdG8gZXZhbCBvciBhcmd1bWVudHMgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUG9zdGZpeDogICdQb3N0Zml4IGluY3JlbWVudC9kZWNyZW1lbnQgbWF5IG5vdCBoYXZlIGV2YWwgb3IgYXJndW1lbnRzIG9wZXJhbmQgaW4gc3RyaWN0IG1vZGUnLFxuICAgICAgU3RyaWN0TEhTUHJlZml4OiAgJ1ByZWZpeCBpbmNyZW1lbnQvZGVjcmVtZW50IG1heSBub3QgaGF2ZSBldmFsIG9yIGFyZ3VtZW50cyBvcGVyYW5kIGluIHN0cmljdCBtb2RlJyxcbiAgICAgIFN0cmljdFJlc2VydmVkV29yZDogICdVc2Ugb2YgZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gc3RyaWN0IG1vZGUnXG4gIH07XG5cbiAgLy8gU2VlIGFsc28gdG9vbHMvZ2VuZXJhdGUtdW5pY29kZS1yZWdleC5weS5cbiAgUmVnZXggPSB7XG4gICAgICBOb25Bc2NpaUlkZW50aWZpZXJTdGFydDogbmV3IFJlZ0V4cCgnW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEIyXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4XFx1MEM1OVxcdTBDNjBcXHUwQzYxXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDYwXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUMxLVxcdTE5QzdcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEyRFxcdTIxMkYtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDlELVxcdTMwOUZcXHUzMEExLVxcdTMwRkFcXHUzMEZDLVxcdTMwRkZcXHUzMTA1LVxcdTMxMkRcXHUzMTMxLVxcdTMxOEVcXHUzMUEwLVxcdTMxQkFcXHUzMUYwLVxcdTMxRkZcXHUzNDAwLVxcdTREQjVcXHU0RTAwLVxcdTlGQ0NcXHVBMDAwLVxcdUE0OENcXHVBNEQwLVxcdUE0RkRcXHVBNTAwLVxcdUE2MENcXHVBNjEwLVxcdUE2MUZcXHVBNjJBXFx1QTYyQlxcdUE2NDAtXFx1QTY2RVxcdUE2N0YtXFx1QTY5RFxcdUE2QTAtXFx1QTZFRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNUZcXHVBQjY0XFx1QUI2NVxcdUFCQzAtXFx1QUJFMlxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFNzAtXFx1RkU3NFxcdUZFNzYtXFx1RkVGQ1xcdUZGMjEtXFx1RkYzQVxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKSxcbiAgICAgIE5vbkFzY2lpSWRlbnRpZmllclBhcnQ6IG5ldyBSZWdFeHAoJ1tcXHhBQVxceEI1XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFLVxcdTAzQTFcXHUwM0EzLVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA0ODdcXHUwNDhBLVxcdTA1MkZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDVEMC1cXHUwNUVBXFx1MDVGMC1cXHUwNUYyXFx1MDYxMC1cXHUwNjFBXFx1MDYyMC1cXHUwNjY5XFx1MDY2RS1cXHUwNkQzXFx1MDZENS1cXHUwNkRDXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTAtXFx1MDc0QVxcdTA3NEQtXFx1MDdCMVxcdTA3QzAtXFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MkRcXHUwODQwLVxcdTA4NUJcXHUwOEEwLVxcdTA4QjJcXHUwOEU0LVxcdTA5NjNcXHUwOTY2LVxcdTA5NkZcXHUwOTcxLVxcdTA5ODNcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJDLVxcdTA5QzRcXHUwOUM3XFx1MDlDOFxcdTA5Q0ItXFx1MDlDRVxcdTA5RDdcXHUwOURDXFx1MDlERFxcdTA5REYtXFx1MDlFM1xcdTA5RTYtXFx1MDlGMVxcdTBBMDEtXFx1MEEwM1xcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEEzQ1xcdTBBM0UtXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTY2LVxcdTBBNzVcXHUwQTgxLVxcdTBBODNcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkMtXFx1MEFDNVxcdTBBQzctXFx1MEFDOVxcdTBBQ0ItXFx1MEFDRFxcdTBBRDBcXHUwQUUwLVxcdTBBRTNcXHUwQUU2LVxcdTBBRUZcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4XFx1MEM1OVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODEtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1N1xcdTBENjAtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOUQ5XFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQy1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTJFMkZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMkZcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM0NcXHUzMDQxLVxcdTMwOTZcXHUzMDk5XFx1MzA5QVxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZDQ1xcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTY5RFxcdUE2OUYtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTc4RVxcdUE3OTAtXFx1QTdBRFxcdUE3QjBcXHVBN0IxXFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM0XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE5MDAtXFx1QTkyRFxcdUE5MzAtXFx1QTk1M1xcdUE5NjAtXFx1QTk3Q1xcdUE5ODAtXFx1QTlDMFxcdUE5Q0YtXFx1QTlEOVxcdUE5RTAtXFx1QTlGRVxcdUFBMDAtXFx1QUEzNlxcdUFBNDAtXFx1QUE0RFxcdUFBNTAtXFx1QUE1OVxcdUFBNjAtXFx1QUE3NlxcdUFBN0EtXFx1QUFDMlxcdUFBREItXFx1QUFERFxcdUFBRTAtXFx1QUFFRlxcdUFBRjItXFx1QUFGNlxcdUFCMDEtXFx1QUIwNlxcdUFCMDktXFx1QUIwRVxcdUFCMTEtXFx1QUIxNlxcdUFCMjAtXFx1QUIyNlxcdUFCMjgtXFx1QUIyRVxcdUFCMzAtXFx1QUI1QVxcdUFCNUMtXFx1QUI1RlxcdUFCNjRcXHVBQjY1XFx1QUJDMC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRFxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ10nKVxuICB9O1xuXG4gIC8vIEVuc3VyZSB0aGUgY29uZGl0aW9uIGlzIHRydWUsIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgLy8gVGhpcyBpcyBvbmx5IHRvIGhhdmUgYSBiZXR0ZXIgY29udHJhY3Qgc2VtYW50aWMsIGkuZS4gYW5vdGhlciBzYWZldHkgbmV0XG4gIC8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuICAvLyBEbyBOT1QgdXNlIHRoaXMgdG8gZW5mb3JjZSBhIGNlcnRhaW4gY29uZGl0aW9uIG9uIGFueSB1c2VyIGlucHV0LlxuXG4gIGZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1NFUlQ6ICcgKyBtZXNzYWdlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID49IDB4MzAgJiYgY2ggPD0gMHgzOSk7ICAgLy8gMC4uOVxuICB9XG5cbiAgZnVuY3Rpb24gaXNIZXhEaWdpdChjaCkge1xuICAgICAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPY3RhbERpZ2l0KGNoKSB7XG4gICAgICByZXR1cm4gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKSA+PSAwO1xuICB9XG5cbiAgLy8gNy4yIFdoaXRlIFNwYWNlXG5cbiAgZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDIwKSB8fCAoY2ggPT09IDB4MDkpIHx8IChjaCA9PT0gMHgwQikgfHwgKGNoID09PSAweDBDKSB8fCAoY2ggPT09IDB4QTApIHx8XG4gICAgICAgICAgKGNoID49IDB4MTY4MCAmJiBbMHgxNjgwLCAweDE4MEUsIDB4MjAwMCwgMHgyMDAxLCAweDIwMDIsIDB4MjAwMywgMHgyMDA0LCAweDIwMDUsIDB4MjAwNiwgMHgyMDA3LCAweDIwMDgsIDB4MjAwOSwgMHgyMDBBLCAweDIwMkYsIDB4MjA1RiwgMHgzMDAwLCAweEZFRkZdLmluZGV4T2YoY2gpID49IDApO1xuICB9XG5cbiAgLy8gNy4zIExpbmUgVGVybWluYXRvcnNcblxuICBmdW5jdGlvbiBpc0xpbmVUZXJtaW5hdG9yKGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDBBKSB8fCAoY2ggPT09IDB4MEQpIHx8IChjaCA9PT0gMHgyMDI4KSB8fCAoY2ggPT09IDB4MjAyOSk7XG4gIH1cblxuICAvLyA3LjYgSWRlbnRpZmllciBOYW1lcyBhbmQgSWRlbnRpZmllcnNcblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjaCkge1xuICAgICAgcmV0dXJuIChjaCA9PT0gMHgyNCkgfHwgKGNoID09PSAweDVGKSB8fCAgLy8gJCAoZG9sbGFyKSBhbmQgXyAodW5kZXJzY29yZSlcbiAgICAgICAgICAoY2ggPj0gMHg0MSAmJiBjaCA8PSAweDVBKSB8fCAgICAgICAgIC8vIEEuLlpcbiAgICAgICAgICAoY2ggPj0gMHg2MSAmJiBjaCA8PSAweDdBKSB8fCAgICAgICAgIC8vIGEuLnpcbiAgICAgICAgICAoY2ggPT09IDB4NUMpIHx8ICAgICAgICAgICAgICAgICAgICAgIC8vIFxcIChiYWNrc2xhc2gpXG4gICAgICAgICAgKChjaCA+PSAweDgwKSAmJiBSZWdleC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gICAgICByZXR1cm4gKGNoID09PSAweDI0KSB8fCAoY2ggPT09IDB4NUYpIHx8ICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICAgICAgICAgIChjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEpIHx8ICAgICAgICAgLy8gQS4uWlxuICAgICAgICAgIChjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EpIHx8ICAgICAgICAgLy8gYS4uelxuICAgICAgICAgIChjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkpIHx8ICAgICAgICAgLy8gMC4uOVxuICAgICAgICAgIChjaCA9PT0gMHg1QykgfHwgICAgICAgICAgICAgICAgICAgICAgLy8gXFwgKGJhY2tzbGFzaClcbiAgICAgICAgICAoKGNoID49IDB4ODApICYmIFJlZ2V4Lk5vbkFzY2lpSWRlbnRpZmllclBhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSkpO1xuICB9XG5cbiAgLy8gNy42LjEuMiBGdXR1cmUgUmVzZXJ2ZWQgV29yZHNcblxuICBmdW5jdGlvbiBpc0Z1dHVyZVJlc2VydmVkV29yZChpZCkge1xuICAgICAgc3dpdGNoIChpZCkge1xuICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgY2FzZSAnZW51bSc6XG4gICAgICBjYXNlICdleHBvcnQnOlxuICAgICAgY2FzZSAnZXh0ZW5kcyc6XG4gICAgICBjYXNlICdpbXBvcnQnOlxuICAgICAgY2FzZSAnc3VwZXInOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQoaWQpIHtcbiAgICAgIHN3aXRjaCAoaWQpIHtcbiAgICAgIGNhc2UgJ2ltcGxlbWVudHMnOlxuICAgICAgY2FzZSAnaW50ZXJmYWNlJzpcbiAgICAgIGNhc2UgJ3BhY2thZ2UnOlxuICAgICAgY2FzZSAncHJpdmF0ZSc6XG4gICAgICBjYXNlICdwcm90ZWN0ZWQnOlxuICAgICAgY2FzZSAncHVibGljJzpcbiAgICAgIGNhc2UgJ3N0YXRpYyc6XG4gICAgICBjYXNlICd5aWVsZCc6XG4gICAgICBjYXNlICdsZXQnOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gIH1cblxuICAvLyA3LjYuMS4xIEtleXdvcmRzXG5cbiAgZnVuY3Rpb24gaXNLZXl3b3JkKGlkKSB7XG4gICAgICBpZiAoc3RyaWN0ICYmIGlzU3RyaWN0TW9kZVJlc2VydmVkV29yZChpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gJ2NvbnN0JyBpcyBzcGVjaWFsaXplZCBhcyBLZXl3b3JkIGluIFY4LlxuICAgICAgLy8gJ3lpZWxkJyBhbmQgJ2xldCcgYXJlIGZvciBjb21wYXRpYmxpdHkgd2l0aCBTcGlkZXJNb25rZXkgYW5kIEVTLm5leHQuXG4gICAgICAvLyBTb21lIG90aGVycyBhcmUgZnJvbSBmdXR1cmUgcmVzZXJ2ZWQgd29yZHMuXG5cbiAgICAgIHN3aXRjaCAoaWQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2lmJykgfHwgKGlkID09PSAnaW4nKSB8fCAoaWQgPT09ICdkbycpO1xuICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICd2YXInKSB8fCAoaWQgPT09ICdmb3InKSB8fCAoaWQgPT09ICduZXcnKSB8fFxuICAgICAgICAgICAgICAoaWQgPT09ICd0cnknKSB8fCAoaWQgPT09ICdsZXQnKTtcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAndGhpcycpIHx8IChpZCA9PT0gJ2Vsc2UnKSB8fCAoaWQgPT09ICdjYXNlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAndm9pZCcpIHx8IChpZCA9PT0gJ3dpdGgnKSB8fCAoaWQgPT09ICdlbnVtJyk7XG4gICAgICBjYXNlIDU6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ3doaWxlJykgfHwgKGlkID09PSAnYnJlYWsnKSB8fCAoaWQgPT09ICdjYXRjaCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ3Rocm93JykgfHwgKGlkID09PSAnY29uc3QnKSB8fCAoaWQgPT09ICd5aWVsZCcpIHx8XG4gICAgICAgICAgICAgIChpZCA9PT0gJ2NsYXNzJykgfHwgKGlkID09PSAnc3VwZXInKTtcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgICByZXR1cm4gKGlkID09PSAncmV0dXJuJykgfHwgKGlkID09PSAndHlwZW9mJykgfHwgKGlkID09PSAnZGVsZXRlJykgfHxcbiAgICAgICAgICAgICAgKGlkID09PSAnc3dpdGNoJykgfHwgKGlkID09PSAnZXhwb3J0JykgfHwgKGlkID09PSAnaW1wb3J0Jyk7XG4gICAgICBjYXNlIDc6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2RlZmF1bHQnKSB8fCAoaWQgPT09ICdmaW5hbGx5JykgfHwgKGlkID09PSAnZXh0ZW5kcycpO1xuICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiAoaWQgPT09ICdmdW5jdGlvbicpIHx8IChpZCA9PT0gJ2NvbnRpbnVlJykgfHwgKGlkID09PSAnZGVidWdnZXInKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgcmV0dXJuIChpZCA9PT0gJ2luc3RhbmNlb2YnKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gICAgICB2YXIgY2gsIHN0YXJ0O1xuXG4gICAgICBzdGFydCA9IChpbmRleCA9PT0gMCk7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcblxuICAgICAgICAgIGlmIChpc1doaXRlU3BhY2UoY2gpKSB7XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICBpZiAoY2ggPT09IDB4MEQgJiYgc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDBBKSB7XG4gICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgbGluZVN0YXJ0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FuSGV4RXNjYXBlKHByZWZpeCkge1xuICAgICAgdmFyIGksIGxlbiwgY2gsIGNvZGUgPSAwO1xuXG4gICAgICBsZW4gPSAocHJlZml4ID09PSAndScpID8gNCA6IDI7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCkge1xuICAgICAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcblxuICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgY29kZSA9IDA7XG5cbiAgICAgIC8vIEF0IGxlYXN0LCBvbmUgaGV4IGRpZ2l0IGlzIHJlcXVpcmVkLlxuICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvZGUgPSBjb2RlICogMTYgKyAnMDEyMzQ1Njc4OWFiY2RlZicuaW5kZXhPZihjaC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvZGUgPiAweDEwRkZGRiB8fCBjaCAhPT0gJ30nKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBVVEYtMTYgRW5jb2RpbmdcbiAgICAgIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgfVxuICAgICAgY3UxID0gKChjb2RlIC0gMHgxMDAwMCkgPj4gMTApICsgMHhEODAwO1xuICAgICAgY3UyID0gKChjb2RlIC0gMHgxMDAwMCkgJiAxMDIzKSArIDB4REMwMDtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGN1MSwgY3UyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEVzY2FwZWRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIGNoLCBpZDtcblxuICAgICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgICAgIGlkID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG5cbiAgICAgIC8vICdcXHUnIChVKzAwNUMsIFUrMDA3NSkgZGVub3RlcyBhbiBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZCA9IGNoO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoIWlzSWRlbnRpZmllclBhcnQoY2gpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgICAgICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgICAgICAgICBpZCA9IGlkLnN1YnN0cigwLCBpZC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSAhPT0gMHg3NSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllclBhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZCArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGNoO1xuXG4gICAgICBzdGFydCA9IGluZGV4Kys7XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4NUMpIHtcbiAgICAgICAgICAgICAgLy8gQmxhY2tzbGFzaCAoVSswMDVDKSBtYXJrcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEVzY2FwZWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0lkZW50aWZpZXJQYXJ0KGNoKSkge1xuICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbklkZW50aWZpZXIoKSB7XG4gICAgICB2YXIgc3RhcnQsIGlkLCB0eXBlO1xuXG4gICAgICBzdGFydCA9IGluZGV4O1xuXG4gICAgICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgaWQgPSAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDVDKSA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIGtleXdvcmQgb3IgbGl0ZXJhbCB3aXRoIG9ubHkgb25lIGNoYXJhY3Rlci5cbiAgICAgIC8vIFRodXMsIGl0IG11c3QgYmUgYW4gaWRlbnRpZmllci5cbiAgICAgIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAoaXNLZXl3b3JkKGlkKSkge1xuICAgICAgICAgIHR5cGUgPSBUb2tlbi5LZXl3b3JkO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLk51bGxMaXRlcmFsO1xuICAgICAgfSBlbHNlIGlmIChpZCA9PT0gJ3RydWUnIHx8IGlkID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgdHlwZSA9IFRva2VuLkJvb2xlYW5MaXRlcmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0eXBlID0gVG9rZW4uSWRlbnRpZmllcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHZhbHVlOiBpZCxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy43IFB1bmN0dWF0b3JzXG5cbiAgZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBpbmRleCxcbiAgICAgICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpLFxuICAgICAgICAgIGNvZGUyLFxuICAgICAgICAgIGNoMSA9IHNvdXJjZVtpbmRleF0sXG4gICAgICAgICAgY2gyLFxuICAgICAgICAgIGNoMyxcbiAgICAgICAgICBjaDQ7XG5cbiAgICAgIHN3aXRjaCAoY29kZSkge1xuXG4gICAgICAvLyBDaGVjayBmb3IgbW9zdCBjb21tb24gc2luZ2xlLWNoYXJhY3RlciBwdW5jdHVhdG9ycy5cbiAgICAgIGNhc2UgMHgyRTogIC8vIC4gZG90XG4gICAgICBjYXNlIDB4Mjg6ICAvLyAoIG9wZW4gYnJhY2tldFxuICAgICAgY2FzZSAweDI5OiAgLy8gKSBjbG9zZSBicmFja2V0XG4gICAgICBjYXNlIDB4M0I6ICAvLyA7IHNlbWljb2xvblxuICAgICAgY2FzZSAweDJDOiAgLy8gLCBjb21tYVxuICAgICAgY2FzZSAweDdCOiAgLy8geyBvcGVuIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4N0Q6ICAvLyB9IGNsb3NlIGN1cmx5IGJyYWNlXG4gICAgICBjYXNlIDB4NUI6ICAvLyBbXG4gICAgICBjYXNlIDB4NUQ6ICAvLyBdXG4gICAgICBjYXNlIDB4M0E6ICAvLyA6XG4gICAgICBjYXNlIDB4M0Y6ICAvLyA/XG4gICAgICBjYXNlIDB4N0U6ICAvLyB+XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICBpZiAoZXh0cmEudG9rZW5pemUpIHtcbiAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDB4MjgpIHtcbiAgICAgICAgICAgICAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gZXh0cmEudG9rZW5zLmxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDdCKSB7XG4gICAgICAgICAgICAgICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IGV4dHJhLnRva2Vucy5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSksXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICAgIC8vICc9JyAoVSswMDNEKSBtYXJrcyBhbiBhc3NpZ25tZW50IG9yIGNvbXBhcmlzb24gb3BlcmF0b3IuXG4gICAgICAgICAgaWYgKGNvZGUyID09PSAweDNEKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDB4MkI6ICAvLyArXG4gICAgICAgICAgICAgIGNhc2UgMHgyRDogIC8vIC1cbiAgICAgICAgICAgICAgY2FzZSAweDJGOiAgLy8gL1xuICAgICAgICAgICAgICBjYXNlIDB4M0M6ICAvLyA8XG4gICAgICAgICAgICAgIGNhc2UgMHgzRTogIC8vID5cbiAgICAgICAgICAgICAgY2FzZSAweDVFOiAgLy8gXlxuICAgICAgICAgICAgICBjYXNlIDB4N0M6ICAvLyB8XG4gICAgICAgICAgICAgIGNhc2UgMHgyNTogIC8vICVcbiAgICAgICAgICAgICAgY2FzZSAweDI2OiAgLy8gJlxuICAgICAgICAgICAgICBjYXNlIDB4MkE6ICAvLyAqXG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlMiksXG4gICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICBjYXNlIDB4MjE6IC8vICFcbiAgICAgICAgICAgICAgY2FzZSAweDNEOiAvLyA9XG4gICAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xuXG4gICAgICAgICAgICAgICAgICAvLyAhPT0gYW5kID09PVxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHgzRCkge1xuICAgICAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3I6ID4+Pj1cblxuICAgICAgY2g0ID0gc291cmNlLnN1YnN0cihpbmRleCwgNCk7XG5cbiAgICAgIGlmIChjaDQgPT09ICc+Pj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoNCxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIDMtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA9PT0gIT09ID4+PiA8PD0gPj49XG5cbiAgICAgIGNoMyA9IGNoNC5zdWJzdHIoMCwgMyk7XG5cbiAgICAgIGlmIChjaDMgPT09ICc+Pj4nIHx8IGNoMyA9PT0gJzw8PScgfHwgY2gzID09PSAnPj49Jykge1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW4uUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IGNoMyxcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyIDItY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiArKyAtLSA8PCA+PiAmJiB8fFxuICAgICAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcblxuICAgICAgaWYgKChjaDEgPT09IGNoMlsxXSAmJiAoJystPD4mfCcuaW5kZXhPZihjaDEpID49IDApKSB8fCBjaDIgPT09ICc9PicpIHtcbiAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlB1bmN0dWF0b3IsXG4gICAgICAgICAgICAgIHZhbHVlOiBjaDIsXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyAxLWNoYXJhY3RlciBwdW5jdHVhdG9yczogPCA+ID0gISArIC0gKiAlICYgfCBeIC9cblxuICAgICAgaWYgKCc8Pj0hKy0qJSZ8Xi8nLmluZGV4T2YoY2gxKSA+PSAwKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBUb2tlbi5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogY2gxLFxuICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICB9XG5cbiAgLy8gNy44LjMgTnVtZXJpYyBMaXRlcmFsc1xuXG4gIGZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gICAgICB2YXIgbnVtYmVyID0gJyc7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmICghaXNIZXhEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bWJlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFRva2VuLk51bWVyaWNMaXRlcmFsLFxuICAgICAgICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpIHtcbiAgICAgIHZhciBudW1iZXIgPSAnMCcgKyBzb3VyY2VbaW5kZXgrK107XG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWlzT2N0YWxEaWdpdChzb3VyY2VbaW5kZXhdKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkgfHwgaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgJ0lMTEVHQUwnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBUb2tlbi5OdW1lcmljTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogcGFyc2VJbnQobnVtYmVyLCA4KSxcbiAgICAgICAgICBvY3RhbDogdHJ1ZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nhbk51bWVyaWNMaXRlcmFsKCkge1xuICAgICAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuXG4gICAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgICBhc3NlcnQoaXNEZWNpbWFsRGlnaXQoY2guY2hhckNvZGVBdCgwKSkgfHwgKGNoID09PSAnLicpLFxuICAgICAgICAgICdOdW1lcmljIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgZGVjaW1hbCBkaWdpdCBvciBhIGRlY2ltYWwgcG9pbnQnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgIG51bWJlciA9ICcnO1xuICAgICAgaWYgKGNoICE9PSAnLicpIHtcbiAgICAgICAgICBudW1iZXIgPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuXG4gICAgICAgICAgLy8gSGV4IG51bWJlciBzdGFydHMgd2l0aCAnMHgnLlxuICAgICAgICAgIC8vIE9jdGFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcuXG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2NhbkhleExpdGVyYWwoc3RhcnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2Nhbk9jdGFsTGl0ZXJhbChzdGFydCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBkZWNpbWFsIG51bWJlciBzdGFydHMgd2l0aCAnMCcgc3VjaCBhcyAnMDknIGlzIGlsbGVnYWwuXG4gICAgICAgICAgICAgIGlmIChjaCAmJiBpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgIG51bWJlciArPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpc0RlY2ltYWxEaWdpdChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgICAgICAgICAgICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCAnSUxMRUdBTCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uTnVtZXJpY0xpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQobnVtYmVyKSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICBlbmQ6IGluZGV4XG4gICAgICB9O1xuICB9XG5cbiAgLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbiAgZnVuY3Rpb24gc2NhblN0cmluZ0xpdGVyYWwoKSB7XG4gICAgICB2YXIgc3RyID0gJycsIHF1b3RlLCBzdGFydCwgY2gsIGNvZGUsIHVuZXNjYXBlZCwgcmVzdG9yZSwgb2N0YWwgPSBmYWxzZSwgc3RhcnRMaW5lTnVtYmVyLCBzdGFydExpbmVTdGFydDtcbiAgICAgIHN0YXJ0TGluZU51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydExpbmVTdGFydCA9IGxpbmVTdGFydDtcblxuICAgICAgcXVvdGUgPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgYXNzZXJ0KChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicpLFxuICAgICAgICAgICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcblxuICAgICAgc3RhcnQgPSBpbmRleDtcbiAgICAgICsraW5kZXg7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuXG4gICAgICAgICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgICAgICAgICBxdW90ZSA9ICcnO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICAgICAgICAgIGlmICghY2ggfHwgIWlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpbmRleF0gPT09ICd7Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gc2NhblVuaWNvZGVDb2RlUG9pbnRFc2NhcGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVuZXNjYXBlZCA9IHNjYW5IZXhFc2NhcGUoY2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5lc2NhcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gdW5lc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSByZXN0b3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHQnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnYic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGInO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXHgwQic7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2N0YWxEaWdpdChjaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9ICcwMTIzNDU2NycuaW5kZXhPZihjaCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gXFwwIGlzIG5vdCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAzIGRpZ2l0cyBhcmUgb25seSBhbGxvd2VkIHdoZW4gc3RyaW5nIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2l0aCAwLCAxLCAyLCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluZGV4T2YoY2gpID49IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPCBsZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGUgKiA4ICsgJzAxMjM0NTY3Jy5pbmRleE9mKHNvdXJjZVtpbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICsrbGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxpbmVTdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChxdW90ZSAhPT0gJycpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogVG9rZW4uU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICB2YWx1ZTogc3RyLFxuICAgICAgICAgIG9jdGFsOiBvY3RhbCxcbiAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICBzdGFydExpbmVTdGFydDogc3RhcnRMaW5lU3RhcnQsXG4gICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRlc3RSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICAgIHZhciB0bXAgPSBwYXR0ZXJuLFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoZmxhZ3MuaW5kZXhPZigndScpID49IDApIHtcbiAgICAgICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBjb2RlIHBvaW50XG4gICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlIHdpdGggYSBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uXG4gICAgICAgICAgLy8gcmVndWxhciBleHByZXNzaW9ucyB0aGF0IGFyZSBvbmx5IHZhbGlkIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlXG4gICAgICAgICAgLy8gYC91YCBmbGFnLlxuICAgICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgICAgLy8gbmVnYXRpdmVzIGluIHVubGlrZWx5IHNjZW5hcmlvcy4gRm9yIGV4YW1wbGUsIGBbXFx1ezYxfS1iXWAgaXMgYVxuICAgICAgICAgIC8vIHBlcmZlY3RseSB2YWxpZCBwYXR0ZXJuIHRoYXQgaXMgZXF1aXZhbGVudCB0byBgW2EtYl1gLCBidXQgaXRcbiAgICAgICAgICAvLyB3b3VsZCBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgICB0bXAgPSB0bXBcbiAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgZnVuY3Rpb24gKCQwLCAkMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KCQxLCAxNikgPD0gMHgxMEZGRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3gnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZXMuSW52YWxpZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2csICd4Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCBkZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAodG1wKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5JbnZhbGlkUmVnRXhwKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgICAgIC8vIGBudWxsYCBpbiBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXRcbiAgICAgIC8vIHVzZXMuXG4gICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cEJvZHkoKSB7XG4gICAgICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG5cbiAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgIGFzc2VydChjaCA9PT0gJy8nLCAnUmVndWxhciBleHByZXNzaW9uIGxpdGVyYWwgbXVzdCBzdGFydCB3aXRoIGEgc2xhc2gnKTtcbiAgICAgIHN0ciA9IHNvdXJjZVtpbmRleCsrXTtcblxuICAgICAgY2xhc3NNYXJrZXIgPSBmYWxzZTtcbiAgICAgIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgICAgICAgICAgLy8gRUNNQS0yNjIgNy44LjVcbiAgICAgICAgICAgICAgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlcy5VbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2ggPT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgdGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdGVybWluYXRlZCkge1xuICAgICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VzLlVudGVybWluYXRlZFJlZ0V4cCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEV4Y2x1ZGUgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXG4gICAgICBib2R5ID0gc3RyLnN1YnN0cigxLCBzdHIubGVuZ3RoIC0gMik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiBib2R5LFxuICAgICAgICAgIGxpdGVyYWw6IHN0clxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYW5SZWdFeHBGbGFncygpIHtcbiAgICAgIHZhciBjaCwgc3RyLCBmbGFncywgcmVzdG9yZTtcblxuICAgICAgc3RyID0gJyc7XG4gICAgICBmbGFncyA9ICcnO1xuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xcXFwnICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICAgICAgICByZXN0b3JlID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICBjaCA9IHNjYW5IZXhFc2NhcGUoJ3UnKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaCkge1xuICAgICAgICAgICAgICAgICAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3RyICs9ICdcXFxcdSc7IHJlc3RvcmUgPCBpbmRleDsgKytyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBzb3VyY2VbcmVzdG9yZV07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHJlc3RvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xuICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHUnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnO1xuICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sICdJTExFR0FMJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbGFncyArPSBjaDtcbiAgICAgICAgICAgICAgc3RyICs9IGNoO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogZmxhZ3MsXG4gICAgICAgICAgbGl0ZXJhbDogc3RyXG4gICAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhblJlZ0V4cCgpIHtcbiAgICAgIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuXG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIHN0YXJ0ID0gaW5kZXg7XG5cbiAgICAgIGJvZHkgPSBzY2FuUmVnRXhwQm9keSgpO1xuICAgICAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgICAgIHZhbHVlID0gdGVzdFJlZ0V4cChib2R5LnZhbHVlLCBmbGFncy52YWx1ZSk7XG5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLlJlZ3VsYXJFeHByZXNzaW9uLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBib2R5LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLnZhbHVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGxpbmVTdGFydDogbGluZVN0YXJ0LFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpdGVyYWw6IGJvZHkubGl0ZXJhbCArIGZsYWdzLmxpdGVyYWwsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHJlZ2V4OiB7XG4gICAgICAgICAgICAgIHBhdHRlcm46IGJvZHkudmFsdWUsXG4gICAgICAgICAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0UmVnZXgoKSB7XG4gICAgICB2YXIgcG9zLCBsb2MsIHJlZ2V4LCB0b2tlbjtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsb2MgPSB7XG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlZ2V4ID0gc2NhblJlZ0V4cCgpO1xuXG4gICAgICBsb2MuZW5kID0ge1xuICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgY29sdW1uOiBpbmRleCAtIGxpbmVTdGFydFxuICAgICAgfTtcblxuICAgICAgaWYgKCFleHRyYS50b2tlbml6ZSkge1xuICAgICAgICAgIC8vIFBvcCB0aGUgcHJldmlvdXMgdG9rZW4sIHdoaWNoIGlzIGxpa2VseSAnLycgb3IgJy89J1xuICAgICAgICAgIGlmIChleHRyYS50b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0b2tlbiA9IGV4dHJhLnRva2Vuc1tleHRyYS50b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGlmICh0b2tlbi5yYW5nZVswXSA9PT0gcG9zICYmIHRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnZhbHVlID09PSAnLycgfHwgdG9rZW4udmFsdWUgPT09ICcvPScpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnMucG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdSZWd1bGFyRXhwcmVzc2lvbicsXG4gICAgICAgICAgICAgIHZhbHVlOiByZWdleC5saXRlcmFsLFxuICAgICAgICAgICAgICByZWdleDogcmVnZXgucmVnZXgsXG4gICAgICAgICAgICAgIHJhbmdlOiBbcG9zLCBpbmRleF0sXG4gICAgICAgICAgICAgIGxvYzogbG9jXG4gICAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWdleDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgICAgIHJldHVybiB0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCB8fFxuICAgICAgICAgIHRva2VuLnR5cGUgPT09IFRva2VuLkJvb2xlYW5MaXRlcmFsIHx8XG4gICAgICAgICAgdG9rZW4udHlwZSA9PT0gVG9rZW4uTnVsbExpdGVyYWw7XG4gIH1cblxuICBmdW5jdGlvbiBhZHZhbmNlU2xhc2goKSB7XG4gICAgICB2YXIgcHJldlRva2VuLFxuICAgICAgICAgIGNoZWNrVG9rZW47XG4gICAgICAvLyBVc2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG4gICAgICBwcmV2VG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEudG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFwcmV2VG9rZW4pIHtcbiAgICAgICAgICAvLyBOb3RoaW5nIGJlZm9yZSB0aGF0OiBpdCBjYW5ub3QgYmUgYSBkaXZpc2lvbi5cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdQdW5jdHVhdG9yJykge1xuICAgICAgICAgIGlmIChwcmV2VG9rZW4udmFsdWUgPT09ICddJykge1xuICAgICAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gJyknKSB7XG4gICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlblBhcmVuVG9rZW4gLSAxXTtcbiAgICAgICAgICAgICAgaWYgKGNoZWNrVG9rZW4gJiZcbiAgICAgICAgICAgICAgICAgICAgICBjaGVja1Rva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJlxuICAgICAgICAgICAgICAgICAgICAgIChjaGVja1Rva2VuLnZhbHVlID09PSAnaWYnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4udmFsdWUgPT09ICd3aGlsZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ2ZvcicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tUb2tlbi52YWx1ZSA9PT0gJ3dpdGgnKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RSZWdleCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJldlRva2VuLnZhbHVlID09PSAnfScpIHtcbiAgICAgICAgICAgICAgLy8gRGl2aWRpbmcgYSBmdW5jdGlvbiBieSBhbnl0aGluZyBtYWtlcyBsaXR0bGUgc2Vuc2UsXG4gICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICBpZiAoZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gM10gJiZcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSAzXS50eXBlID09PSAnS2V5d29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFub255bW91cyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA0XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhLnRva2Vuc1tleHRyYS5vcGVuQ3VybHlUb2tlbiAtIDRdICYmXG4gICAgICAgICAgICAgICAgICAgICAgZXh0cmEudG9rZW5zW2V4dHJhLm9wZW5DdXJseVRva2VuIC0gNF0udHlwZSA9PT0gJ0tleXdvcmQnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBOYW1lZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW4gPSBleHRyYS50b2tlbnNbZXh0cmEub3BlbkN1cmx5VG9rZW4gLSA1XTtcbiAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29sbGVjdFJlZ2V4KCk7XG4gICAgICB9XG4gICAgICBpZiAocHJldlRva2VuLnR5cGUgPT09ICdLZXl3b3JkJyAmJiBwcmV2VG9rZW4udmFsdWUgIT09ICd0aGlzJykge1xuICAgICAgICAgIHJldHVybiBjb2xsZWN0UmVnZXgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgICAgIHZhciBjaDtcblxuICAgICAgc2tpcENvbW1lbnQoKTtcblxuICAgICAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuLkVPRixcbiAgICAgICAgICAgICAgbGluZU51bWJlcjogbGluZU51bWJlcixcbiAgICAgICAgICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICAgICAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgICAgICAgICAgZW5kOiBpbmRleFxuICAgICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICAgICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFZlcnkgY29tbW9uOiAoIGFuZCApIGFuZCA7XG4gICAgICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICAgICAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RyaW5nIGxpdGVyYWwgc3RhcnRzIHdpdGggc2luZ2xlIHF1b3RlIChVKzAwMjcpIG9yIGRvdWJsZSBxdW90ZSAoVSswMDIyKS5cbiAgICAgIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgICAgICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICAgICAgfVxuXG5cbiAgICAgIC8vIERvdCAoLikgVSswMDJFIGNhbiBhbHNvIHN0YXJ0IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLCBoZW5jZSB0aGUgbmVlZFxuICAgICAgLy8gdG8gY2hlY2sgdGhlIG5leHQgY2hhcmFjdGVyLlxuICAgICAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgICAgICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzY2FuTnVtZXJpY0xpdGVyYWwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICAgICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNsYXNoICgvKSBVKzAwMkYgY2FuIGFsc28gc3RhcnQgYSByZWdleC5cbiAgICAgIGlmIChleHRyYS50b2tlbml6ZSAmJiBjaCA9PT0gMHgyRikge1xuICAgICAgICAgIHJldHVybiBhZHZhbmNlU2xhc2goKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VG9rZW4oKSB7XG4gICAgICB2YXIgbG9jLCB0b2tlbiwgdmFsdWUsIGVudHJ5O1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgbG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgIGxpbmU6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogaW5kZXggLSBsaW5lU3RhcnRcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0b2tlbiA9IGFkdmFuY2UoKTtcbiAgICAgIGxvYy5lbmQgPSB7XG4gICAgICAgICAgbGluZTogbGluZU51bWJlcixcbiAgICAgICAgICBjb2x1bW46IGluZGV4IC0gbGluZVN0YXJ0XG4gICAgICB9O1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgdmFsdWUgPSBzb3VyY2Uuc2xpY2UodG9rZW4uc3RhcnQsIHRva2VuLmVuZCk7XG4gICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuTmFtZVt0b2tlbi50eXBlXSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICByYW5nZTogW3Rva2VuLnN0YXJ0LCB0b2tlbi5lbmRdLFxuICAgICAgICAgICAgICBsb2M6IGxvY1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKHRva2VuLnJlZ2V4KSB7XG4gICAgICAgICAgICAgIGVudHJ5LnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogdG9rZW4ucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiB0b2tlbi5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHRyYS50b2tlbnMucHVzaChlbnRyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxleCgpIHtcbiAgICAgIHZhciB0b2tlbjtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBpbmRleCA9IHRva2VuLmVuZDtcbiAgICAgIGxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgbGluZVN0YXJ0ID0gdG9rZW4ubGluZVN0YXJ0O1xuXG4gICAgICBsb29rYWhlYWQgPSAodHlwZW9mIGV4dHJhLnRva2VucyAhPT0gJ3VuZGVmaW5lZCcpID8gY29sbGVjdFRva2VuKCkgOiBhZHZhbmNlKCk7XG5cbiAgICAgIGluZGV4ID0gdG9rZW4uZW5kO1xuICAgICAgbGluZU51bWJlciA9IHRva2VuLmxpbmVOdW1iZXI7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbi5saW5lU3RhcnQ7XG5cbiAgICAgIHJldHVybiB0b2tlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZWsoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydDtcblxuICAgICAgcG9zID0gaW5kZXg7XG4gICAgICBsaW5lID0gbGluZU51bWJlcjtcbiAgICAgIHN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgbG9va2FoZWFkID0gKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSA/IGNvbGxlY3RUb2tlbigpIDogYWR2YW5jZSgpO1xuICAgICAgaW5kZXggPSBwb3M7XG4gICAgICBsaW5lTnVtYmVyID0gbGluZTtcbiAgICAgIGxpbmVTdGFydCA9IHN0YXJ0O1xuICB9XG5cbiAgZnVuY3Rpb24gUG9zaXRpb24oKSB7XG4gICAgICB0aGlzLmxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgdGhpcy5jb2x1bW4gPSBpbmRleCAtIGxpbmVTdGFydDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNvdXJjZUxvY2F0aW9uKCkge1xuICAgICAgdGhpcy5zdGFydCA9IG5ldyBQb3NpdGlvbigpO1xuICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKSB7XG4gICAgICBpZiAoc3RhcnRUb2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgbGluZTogc3RhcnRUb2tlbi5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4uc3RhcnRMaW5lU3RhcnRcbiAgICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICBsaW5lOiBzdGFydFRva2VuLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgIGNvbHVtbjogc3RhcnRUb2tlbi5zdGFydCAtIHN0YXJ0VG9rZW4ubGluZVN0YXJ0XG4gICAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW5kID0gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIE5vZGUoKSB7XG4gICAgICAvLyBTa2lwIGNvbW1lbnQuXG4gICAgICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCkge1xuICAgICAgICAgIGxpbmVOdW1iZXIgPSBsb29rYWhlYWQuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5zdGFydExpbmVTdGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGluZU51bWJlciA9IGxvb2thaGVhZC5saW5lTnVtYmVyO1xuICAgICAgICAgIGxpbmVTdGFydCA9IGxvb2thaGVhZC5saW5lU3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICB0aGlzLnJhbmdlID0gW2luZGV4LCAwXTtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYS5sb2MpIHtcbiAgICAgICAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbigpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pIHtcbiAgICAgIGlmIChleHRyYS5yYW5nZSkge1xuICAgICAgICAgIHRoaXMucmFuZ2UgPSBbc3RhcnRUb2tlbi5zdGFydCwgMF07XG4gICAgICB9XG4gICAgICBpZiAoZXh0cmEubG9jKSB7XG4gICAgICAgICAgdGhpcy5sb2MgPSBuZXcgV3JhcHBpbmdTb3VyY2VMb2NhdGlvbihzdGFydFRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIFdyYXBwaW5nTm9kZS5wcm90b3R5cGUgPSBOb2RlLnByb3RvdHlwZSA9IHtcblxuICAgICAgZmluaXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGV4dHJhLnJhbmdlKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFuZ2VbMV0gPSBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0aGlzLmxvYy5lbmQgPSBuZXcgUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgaWYgKGV4dHJhLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sb2Muc291cmNlID0gZXh0cmEuc291cmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZmluaXNoQXJyYXlFeHByZXNzaW9uOiBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXJyYXlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQXNzaWdubWVudEV4cHJlc3Npb246IGZ1bmN0aW9uIChvcGVyYXRvciwgbGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQXNzaWdubWVudEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hCaW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnfHwnIHx8IG9wZXJhdG9yID09PSAnJiYnKSA/IFN5bnRheC5Mb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheC5CaW5hcnlFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uIChjYWxsZWUsIGFyZ3MpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ2FsbEV4cHJlc3Npb247XG4gICAgICAgICAgdGhpcy5jYWxsZWUgPSBjYWxsZWU7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb246IGZ1bmN0aW9uICh0ZXN0LCBjb25zZXF1ZW50LCBhbHRlcm5hdGUpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMudGVzdCA9IHRlc3Q7XG4gICAgICAgICAgdGhpcy5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICAgICAgICB0aGlzLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoRXhwcmVzc2lvblN0YXRlbWVudDogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudDtcbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5JZGVudGlmaWVyO1xuICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaExpdGVyYWw6IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5MaXRlcmFsO1xuICAgICAgICAgIHRoaXMudmFsdWUgPSB0b2tlbi52YWx1ZTtcbiAgICAgICAgICB0aGlzLnJhdyA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICAgICAgICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucmF3ID09ICcvLycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhdyA9ICcvKD86KS8nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaE1lbWJlckV4cHJlc3Npb246IGZ1bmN0aW9uIChhY2Nlc3Nvciwgb2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5NZW1iZXJFeHByZXNzaW9uO1xuICAgICAgICAgIHRoaXMuY29tcHV0ZWQgPSBhY2Nlc3NvciA9PT0gJ1snO1xuICAgICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoT2JqZWN0RXhwcmVzc2lvbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB0aGlzLnR5cGUgPSBTeW50YXguT2JqZWN0RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xuICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuXG4gICAgICBmaW5pc2hQcm9ncmFtOiBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9ncmFtO1xuICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG5cbiAgICAgIGZpbmlzaFByb3BlcnR5OiBmdW5jdGlvbiAoa2luZCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMudHlwZSA9IFN5bnRheC5Qcm9wZXJ0eTtcbiAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcblxuICAgICAgZmluaXNoVW5hcnlFeHByZXNzaW9uOiBmdW5jdGlvbiAob3BlcmF0b3IsIGFyZ3VtZW50KSB7XG4gICAgICAgICAgdGhpcy50eXBlID0gKG9wZXJhdG9yID09PSAnKysnIHx8IG9wZXJhdG9yID09PSAnLS0nKSA/IFN5bnRheC5VcGRhdGVFeHByZXNzaW9uIDogU3ludGF4LlVuYXJ5RXhwcmVzc2lvbjtcbiAgICAgICAgICB0aGlzLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgICAgdGhpcy5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGEgbGluZSB0ZXJtaW5hdG9yIGJlZm9yZSB0aGUgbmV4dCB0b2tlbi5cblxuICBmdW5jdGlvbiBwZWVrTGluZVRlcm1pbmF0b3IoKSB7XG4gICAgICB2YXIgcG9zLCBsaW5lLCBzdGFydCwgZm91bmQ7XG5cbiAgICAgIHBvcyA9IGluZGV4O1xuICAgICAgbGluZSA9IGxpbmVOdW1iZXI7XG4gICAgICBzdGFydCA9IGxpbmVTdGFydDtcbiAgICAgIHNraXBDb21tZW50KCk7XG4gICAgICBmb3VuZCA9IGxpbmVOdW1iZXIgIT09IGxpbmU7XG4gICAgICBpbmRleCA9IHBvcztcbiAgICAgIGxpbmVOdW1iZXIgPSBsaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvblxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3IodG9rZW4sIG1lc3NhZ2VGb3JtYXQpIHtcbiAgICAgIHZhciBlcnJvcixcbiAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgICBtc2cgPSBtZXNzYWdlRm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgIC8lKFxcZCkvZyxcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKHdob2xlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuXG4gICAgICBpZiAodHlwZW9mIHRva2VuLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIHRva2VuLmxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSB0b2tlbi5saW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IHRva2VuLnN0YXJ0IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0xpbmUgJyArIGxpbmVOdW1iZXIgKyAnOiAnICsgbXNnKTtcbiAgICAgICAgICBlcnJvci5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIGVycm9yLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgIGVycm9yLmNvbHVtbiA9IGluZGV4IC0gbGluZVN0YXJ0ICsgMTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IuZGVzY3JpcHRpb24gPSBtc2c7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRocm93RXJyb3JUb2xlcmFudCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgICAgdGhyb3dFcnJvci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgZXh0cmEuZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuXG4gIC8vIFRocm93IGFuIGV4Y2VwdGlvbiBiZWNhdXNlIG9mIHRoZSB0b2tlbi5cblxuICBmdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkRU9TKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLk51bWVyaWNMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZE51bWJlcik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5TdHJpbmdMaXRlcmFsKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFN0cmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbi50eXBlID09PSBUb2tlbi5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZElkZW50aWZpZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIGlmIChpc0Z1dHVyZVJlc2VydmVkV29yZCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFJlc2VydmVkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBpc1N0cmljdE1vZGVSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRocm93RXJyb3JUb2xlcmFudCh0b2tlbiwgTWVzc2FnZXMuU3RyaWN0UmVzZXJ2ZWRXb3JkKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlcy5VbmV4cGVjdGVkVG9rZW4sIHRva2VuLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuICAgICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZXMuVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG4gIH1cblxuICAvLyBFeHBlY3QgdGhlIG5leHQgdG9rZW4gdG8gbWF0Y2ggdGhlIHNwZWNpZmllZCBwdW5jdHVhdG9yLlxuICAvLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuICBmdW5jdGlvbiBleHBlY3QodmFsdWUpIHtcbiAgICAgIHZhciB0b2tlbiA9IGxleCgpO1xuICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBleHBlY3RUb2xlcmFudFxuICAgKiBAZGVzY3JpcHRpb24gUXVpZXRseSBleHBlY3QgdGhlIGdpdmVuIHRva2VuIHZhbHVlIHdoZW4gaW4gdG9sZXJhbnQgbW9kZSwgb3RoZXJ3aXNlIGRlbGVnYXRlc1xuICAgKiB0byA8Y29kZT5leHBlY3QodmFsdWUpPC9jb2RlPlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHdlIGFyZSBleHBlY3RpbmcgdGhlIGxvb2thaGVhZCB0b2tlbiB0byBoYXZlXG4gICAqIEBzaW5jZSAyLjBcbiAgICovXG4gIGZ1bmN0aW9uIGV4cGVjdFRvbGVyYW50KHZhbHVlKSB7XG4gICAgICBpZiAoZXh0cmEuZXJyb3JzKSB7XG4gICAgICAgICAgdmFyIHRva2VuID0gbG9va2FoZWFkO1xuICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSBUb2tlbi5QdW5jdHVhdG9yICYmIHRva2VuLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQodG9rZW4sIE1lc3NhZ2VzLlVuZXhwZWN0ZWRUb2tlbiwgdG9rZW4udmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIC8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG4gIC8vIElmIG5vdCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuXG4gIGZ1bmN0aW9uIGV4cGVjdEtleXdvcmQoa2V5d29yZCkge1xuICAgICAgdmFyIHRva2VuID0gbGV4KCk7XG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uS2V5d29yZCB8fCB0b2tlbi52YWx1ZSAhPT0ga2V5d29yZCkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuICBmdW5jdGlvbiBtYXRjaCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbi5QdW5jdHVhdG9yICYmIGxvb2thaGVhZC52YWx1ZSA9PT0gdmFsdWU7XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQga2V5d29yZFxuXG4gIGZ1bmN0aW9uIG1hdGNoS2V5d29yZChrZXl3b3JkKSB7XG4gICAgICByZXR1cm4gbG9va2FoZWFkLnR5cGUgPT09IFRva2VuLktleXdvcmQgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZVNlbWljb2xvbigpIHtcbiAgICAgIHZhciBsaW5lO1xuXG4gICAgICAvLyBDYXRjaCB0aGUgdmVyeSBjb21tb24gY2FzZSBmaXJzdDogaW1tZWRpYXRlbHkgYSBzZW1pY29sb24gKFUrMDAzQikuXG4gICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpID09PSAweDNCIHx8IG1hdGNoKCc7JykpIHtcbiAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxpbmUgPSBsaW5lTnVtYmVyO1xuICAgICAgc2tpcENvbW1lbnQoKTtcbiAgICAgIGlmIChsaW5lTnVtYmVyICE9PSBsaW5lKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLkVPRiAmJiAhbWF0Y2goJ30nKSkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZChsb29rYWhlYWQpO1xuICAgICAgfVxuICB9XG5cbiAgLy8gUmV0dXJuIHRydWUgaWYgcHJvdmlkZWQgZXhwcmVzc2lvbiBpcyBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uXG5cbiAgZnVuY3Rpb24gaXNMZWZ0SGFuZFNpZGUoZXhwcikge1xuICAgICAgcmV0dXJuIGV4cHIudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHwgZXhwci50eXBlID09PSBTeW50YXguTWVtYmVyRXhwcmVzc2lvbjtcbiAgfVxuXG4gIC8vIDExLjEuNCBBcnJheSBJbml0aWFsaXNlclxuXG4gIGZ1bmN0aW9uIHBhcnNlQXJyYXlJbml0aWFsaXNlcigpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgZXhwZWN0KCdbJyk7XG5cbiAgICAgIHdoaWxlICghbWF0Y2goJ10nKSkge1xuICAgICAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgICAgIGxleCgpO1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpKTtcblxuICAgICAgICAgICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgICAgICAgICAgIGV4cGVjdCgnLCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXgoKTtcblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKTtcbiAgfVxuXG4gIC8vIDExLjEuNSBPYmplY3QgSW5pdGlhbGlzZXJcblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBmcm9tIHBhcnNlT2JqZWN0UHJvcGVydHkoKSwgd2hlcmVcbiAgICAgIC8vIEVPRiBhbmQgUHVuY3R1YXRvciB0b2tlbnMgYXJlIGFscmVhZHkgZmlsdGVyZWQgb3V0LlxuXG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uU3RyaW5nTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbi5OdW1lcmljTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChzdHJpY3QgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHRva2VuLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hMaXRlcmFsKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGUuZmluaXNoSWRlbnRpZmllcih0b2tlbi52YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5KCkge1xuICAgICAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZSwgcGFyYW0sIG5vZGUgPSBuZXcgTm9kZSgpO1xuXG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuLklkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZCA9IHBhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgICAgICBleHBlY3QoJzonKTtcbiAgICAgICAgICB2YWx1ZSA9IHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW4uRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG4gICAgICAgICAgcmV0dXJuIG5vZGUuZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlT2JqZWN0SW5pdGlhbGlzZXIoKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtdLCB0b2tlbiwgcHJvcGVydHksIG5hbWUsIGtleSwga2luZCwgbWFwID0ge30sIHRvU3RyaW5nID0gU3RyaW5nLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgZXhwZWN0KCd7Jyk7XG5cbiAgICAgIHdoaWxlICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eSgpO1xuXG4gICAgICAgICAgaWYgKHByb3BlcnR5LmtleS50eXBlID09PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICBuYW1lID0gcHJvcGVydHkua2V5Lm5hbWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZSA9IHRvU3RyaW5nKHByb3BlcnR5LmtleS52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtpbmQgPSAocHJvcGVydHkua2luZCA9PT0gJ2luaXQnKSA/IFByb3BlcnR5S2luZC5EYXRhIDogKHByb3BlcnR5LmtpbmQgPT09ICdnZXQnKSA/IFByb3BlcnR5S2luZC5HZXQgOiBQcm9wZXJ0eUtpbmQuU2V0O1xuXG4gICAgICAgICAga2V5ID0gJyQnICsgbmFtZTtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwga2V5KSkge1xuICAgICAgICAgICAgICBpZiAobWFwW2tleV0gPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmIGtpbmQgPT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5TdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtpbmQgIT09IFByb3BlcnR5S2luZC5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckRhdGFQcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gUHJvcGVydHlLaW5kLkRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoe30sIE1lc3NhZ2VzLkFjY2Vzc29yRGF0YVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwW2tleV0gJiBraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvclRvbGVyYW50KHt9LCBNZXNzYWdlcy5BY2Nlc3NvckdldFNldCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWFwW2tleV0gfD0ga2luZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXBba2V5XSA9IGtpbmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcblxuICAgICAgICAgIGlmICghbWF0Y2goJ30nKSkge1xuICAgICAgICAgICAgICBleHBlY3RUb2xlcmFudCgnLCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0KCd9Jyk7XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG4gIH1cblxuICAvLyAxMS4xLjYgVGhlIEdyb3VwaW5nIE9wZXJhdG9yXG5cbiAgZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwcjtcblxuICAgICAgZXhwZWN0KCcoJyk7XG5cbiAgICAgICsrc3RhdGUucGFyZW50aGVzaXNDb3VudDtcblxuICAgICAgZXhwciA9IHBhcnNlRXhwcmVzc2lvbigpO1xuXG4gICAgICBleHBlY3QoJyknKTtcblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuXG4gIC8vIDExLjEgUHJpbWFyeSBFeHByZXNzaW9uc1xuXG4gIHZhciBsZWdhbEtleXdvcmRzID0ge1wiaWZcIjoxLCBcInRoaXNcIjoxfTtcblxuICBmdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIHR5cGUsIHRva2VuLCBleHByLCBub2RlO1xuXG4gICAgICBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUdyb3VwRXhwcmVzc2lvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2goJ1snKSkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUFycmF5SW5pdGlhbGlzZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gbG9va2FoZWFkLnR5cGU7XG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLklkZW50aWZpZXIgfHwgbGVnYWxLZXl3b3Jkc1tsb29rYWhlYWQudmFsdWVdKSB7XG4gICAgICAgICAgZXhwciA9IG5vZGUuZmluaXNoSWRlbnRpZmllcihsZXgoKS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuLlN0cmluZ0xpdGVyYWwgfHwgdHlwZSA9PT0gVG9rZW4uTnVtZXJpY0xpdGVyYWwpIHtcbiAgICAgICAgICBpZiAoc3RyaWN0ICYmIGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQobG9va2FoZWFkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHByID0gbm9kZS5maW5pc2hMaXRlcmFsKGxleCgpKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uQm9vbGVhbkxpdGVyYWwpIHtcbiAgICAgICAgICB0b2tlbiA9IGxleCgpO1xuICAgICAgICAgIHRva2VuLnZhbHVlID0gKHRva2VuLnZhbHVlID09PSAndHJ1ZScpO1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbi5OdWxsTGl0ZXJhbCkge1xuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4udmFsdWUgPSBudWxsO1xuICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwodG9rZW4pO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLycpIHx8IG1hdGNoKCcvPScpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBleHRyYS50b2tlbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwoY29sbGVjdFJlZ2V4KCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4cHIgPSBub2RlLmZpbmlzaExpdGVyYWwoc2NhblJlZ0V4cCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGVlaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobGV4KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuICBmdW5jdGlvbiBwYXJzZUFyZ3VtZW50cygpIHtcbiAgICAgIHZhciBhcmdzID0gW107XG5cbiAgICAgIGV4cGVjdCgnKCcpO1xuXG4gICAgICBpZiAoIW1hdGNoKCcpJykpIHtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJncy5wdXNoKHBhcnNlQXNzaWdubWVudEV4cHJlc3Npb24oKSk7XG4gICAgICAgICAgICAgIGlmIChtYXRjaCgnKScpKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBleHBlY3RUb2xlcmFudCgnLCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXhwZWN0KCcpJyk7XG5cbiAgICAgIHJldHVybiBhcmdzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICAgICAgdmFyIHRva2VuLCBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgdG9rZW4gPSBsZXgoKTtcblxuICAgICAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgICAgICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlLmZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpIHtcbiAgICAgIGV4cGVjdCgnLicpO1xuXG4gICAgICByZXR1cm4gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUNvbXB1dGVkTWVtYmVyKCkge1xuICAgICAgdmFyIGV4cHI7XG5cbiAgICAgIGV4cGVjdCgnWycpO1xuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG5cbiAgICAgIGV4cGVjdCgnXScpO1xuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgICAgIHZhciBleHByLCBhcmdzLCBwcm9wZXJ0eSwgc3RhcnRUb2tlbiwgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcblxuICAgICAgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcbiAgICAgIHN0YXRlLmFsbG93SW4gPSB0cnVlO1xuICAgICAgZXhwciA9IHBhcnNlUHJpbWFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2goJygnKSkge1xuICAgICAgICAgICAgICBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQ2FsbEV4cHJlc3Npb24oZXhwciwgYXJncyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnWycpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCdbJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMZWZ0SGFuZFNpZGVFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHByb3BlcnR5LCBzdGFydFRva2VuO1xuICAgICAgYXNzZXJ0KHN0YXRlLmFsbG93SW4sICdjYWxsZWUgb2YgbmV3IGV4cHJlc3Npb24gYWx3YXlzIGFsbG93IGluIGtleXdvcmQuJyk7XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuXG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwYXJzZUNvbXB1dGVkTWVtYmVyKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKHN0YXJ0VG9rZW4pLmZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaCgnLicpKSB7XG4gICAgICAgICAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hNZW1iZXJFeHByZXNzaW9uKCcuJywgZXhwciwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMyBQb3N0Zml4IEV4cHJlc3Npb25zXG5cbiAgZnVuY3Rpb24gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBleHByLCB0b2tlbiwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpO1xuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICBpZiAoKG1hdGNoKCcrKycpIHx8IG1hdGNoKCctLScpKSAmJiAhcGVla0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlVW5hcnlFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIHRva2VuLCBleHByLCBzdGFydFRva2VuO1xuXG4gICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnR5cGUgIT09IFRva2VuLktleXdvcmQpIHtcbiAgICAgICAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgICAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgdG9rZW4gPSBsZXgoKTtcbiAgICAgICAgICBleHByID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcbiAgICAgICAgICBleHByID0gbmV3IFdyYXBwaW5nTm9kZShzdGFydFRva2VuKS5maW5pc2hVbmFyeUV4cHJlc3Npb24odG9rZW4udmFsdWUsIGV4cHIpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaEtleXdvcmQoJ2RlbGV0ZScpIHx8IG1hdGNoS2V5d29yZCgndm9pZCcpIHx8IG1hdGNoS2V5d29yZCgndHlwZW9mJykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cHIgPSBwYXJzZVBvc3RmaXhFeHByZXNzaW9uKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgYWxsb3dJbikge1xuICAgICAgdmFyIHByZWMgPSAwO1xuXG4gICAgICBpZiAodG9rZW4udHlwZSAhPT0gVG9rZW4uUHVuY3R1YXRvciAmJiB0b2tlbi50eXBlICE9PSBUb2tlbi5LZXl3b3JkKSB7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodG9rZW4udmFsdWUpIHtcbiAgICAgIGNhc2UgJ3x8JzpcbiAgICAgICAgICBwcmVjID0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnJiYnOlxuICAgICAgICAgIHByZWMgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd8JzpcbiAgICAgICAgICBwcmVjID0gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgcHJlYyA9IDQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgIHByZWMgPSA1O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICc9PSc6XG4gICAgICBjYXNlICchPSc6XG4gICAgICBjYXNlICc9PT0nOlxuICAgICAgY2FzZSAnIT09JzpcbiAgICAgICAgICBwcmVjID0gNjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPCc6XG4gICAgICBjYXNlICc+JzpcbiAgICAgIGNhc2UgJzw9JzpcbiAgICAgIGNhc2UgJz49JzpcbiAgICAgIGNhc2UgJ2luc3RhbmNlb2YnOlxuICAgICAgICAgIHByZWMgPSA3O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbic6XG4gICAgICAgICAgcHJlYyA9IGFsbG93SW4gPyA3IDogMDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnPDwnOlxuICAgICAgY2FzZSAnPj4nOlxuICAgICAgY2FzZSAnPj4+JzpcbiAgICAgICAgICBwcmVjID0gODtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICctJzpcbiAgICAgICAgICBwcmVjID0gOTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcvJzpcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgIHByZWMgPSAxMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZWM7XG4gIH1cblxuICAvLyAxMS41IE11bHRpcGxpY2F0aXZlIE9wZXJhdG9yc1xuICAvLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuICAvLyAxMS43IEJpdHdpc2UgU2hpZnQgT3BlcmF0b3JzXG4gIC8vIDExLjggUmVsYXRpb25hbCBPcGVyYXRvcnNcbiAgLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbiAgLy8gMTEuMTAgQmluYXJ5IEJpdHdpc2UgT3BlcmF0b3JzXG4gIC8vIDExLjExIEJpbmFyeSBMb2dpY2FsIE9wZXJhdG9yc1xuXG4gIGZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgICAgIHZhciBtYXJrZXIsIG1hcmtlcnMsIGV4cHIsIHRva2VuLCBwcmVjLCBzdGFjaywgcmlnaHQsIG9wZXJhdG9yLCBsZWZ0LCBpO1xuXG4gICAgICBtYXJrZXIgPSBsb29rYWhlYWQ7XG4gICAgICBsZWZ0ID0gcGFyc2VVbmFyeUV4cHJlc3Npb24oKTtcblxuICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbiwgc3RhdGUuYWxsb3dJbik7XG4gICAgICBpZiAocHJlYyA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBsZWZ0O1xuICAgICAgfVxuICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICBsZXgoKTtcblxuICAgICAgbWFya2VycyA9IFttYXJrZXIsIGxvb2thaGVhZF07XG4gICAgICByaWdodCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIHN0YWNrID0gW2xlZnQsIHRva2VuLCByaWdodF07XG5cbiAgICAgIHdoaWxlICgocHJlYyA9IGJpbmFyeVByZWNlZGVuY2UobG9va2FoZWFkLCBzdGF0ZS5hbGxvd0luKSkgPiAwKSB7XG5cbiAgICAgICAgICAvLyBSZWR1Y2U6IG1ha2UgYSBiaW5hcnkgZXhwcmVzc2lvbiBmcm9tIHRoZSB0aHJlZSB0b3Btb3N0IGVudHJpZXMuXG4gICAgICAgICAgd2hpbGUgKChzdGFjay5sZW5ndGggPiAyKSAmJiAocHJlYyA8PSBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wcmVjKSkge1xuICAgICAgICAgICAgICByaWdodCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgICAgICAgICBsZWZ0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgIG1hcmtlcnMucG9wKCk7XG4gICAgICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnNbbWFya2Vycy5sZW5ndGggLSAxXSkuZmluaXNoQmluYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNoaWZ0LlxuICAgICAgICAgIHRva2VuID0gbGV4KCk7XG4gICAgICAgICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgICAgICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChleHByKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWwgcmVkdWNlIHRvIGNsZWFuLXVwIHRoZSBzdGFjay5cbiAgICAgIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgICAgZXhwciA9IHN0YWNrW2ldO1xuICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgIHdoaWxlIChpID4gMSkge1xuICAgICAgICAgIGV4cHIgPSBuZXcgV3JhcHBpbmdOb2RlKG1hcmtlcnMucG9wKCkpLmZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgICAgICAgIGkgLT0gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHI7XG4gIH1cblxuICAvLyAxMS4xMiBDb25kaXRpb25hbCBPcGVyYXRvclxuXG4gIGZ1bmN0aW9uIHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIGV4cHIsIHByZXZpb3VzQWxsb3dJbiwgY29uc2VxdWVudCwgYWx0ZXJuYXRlLCBzdGFydFRva2VuO1xuXG4gICAgICBzdGFydFRva2VuID0gbG9va2FoZWFkO1xuXG4gICAgICBleHByID0gcGFyc2VCaW5hcnlFeHByZXNzaW9uKCk7XG5cbiAgICAgIGlmIChtYXRjaCgnPycpKSB7XG4gICAgICAgICAgbGV4KCk7XG4gICAgICAgICAgcHJldmlvdXNBbGxvd0luID0gc3RhdGUuYWxsb3dJbjtcbiAgICAgICAgICBzdGF0ZS5hbGxvd0luID0gdHJ1ZTtcbiAgICAgICAgICBjb25zZXF1ZW50ID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuICAgICAgICAgIHN0YXRlLmFsbG93SW4gPSBwcmV2aW91c0FsbG93SW47XG4gICAgICAgICAgZXhwZWN0KCc6Jyk7XG4gICAgICAgICAgYWx0ZXJuYXRlID0gcGFyc2VBc3NpZ25tZW50RXhwcmVzc2lvbigpO1xuXG4gICAgICAgICAgZXhwciA9IG5ldyBXcmFwcGluZ05vZGUoc3RhcnRUb2tlbikuZmluaXNoQ29uZGl0aW9uYWxFeHByZXNzaW9uKGV4cHIsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTMgQXNzaWdubWVudCBPcGVyYXRvcnNcblxuICBmdW5jdGlvbiBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCkge1xuICAgICAgdmFyIG9sZFBhcmVudGhlc2lzQ291bnQsIHRva2VuLCBleHByLCByaWdodCwgbGlzdCwgc3RhcnRUb2tlbjtcblxuICAgICAgb2xkUGFyZW50aGVzaXNDb3VudCA9IHN0YXRlLnBhcmVudGhlc2lzQ291bnQ7XG5cbiAgICAgIHN0YXJ0VG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICB0b2tlbiA9IGxvb2thaGVhZDtcblxuICAgICAgZXhwciA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCk7XG5cbiAgICAgIHJldHVybiBleHByO1xuICB9XG5cbiAgLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb24oKSB7XG4gICAgICB2YXIgZXhwciwgc3RhcnRUb2tlbiA9IGxvb2thaGVhZCwgZXhwcmVzc2lvbnM7XG5cbiAgICAgIGV4cHIgPSBwYXJzZUFzc2lnbm1lbnRFeHByZXNzaW9uKCk7XG5cbiAgICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzYWJsZWQuXCIpOyAvLyBubyBzZXF1ZW5jZSBleHByZXNzaW9uc1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhwcjtcbiAgfVxuXG4gIC8vIDEyLjQgRXhwcmVzc2lvbiBTdGF0ZW1lbnRcblxuICBmdW5jdGlvbiBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkge1xuICAgICAgdmFyIGV4cHIgPSBwYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIGNvbnN1bWVTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiBub2RlLmZpbmlzaEV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcik7XG4gIH1cblxuICAvLyAxMiBTdGF0ZW1lbnRzXG5cbiAgZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgICB2YXIgdHlwZSA9IGxvb2thaGVhZC50eXBlLFxuICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgbGFiZWxlZEJvZHksXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIG5vZGU7XG5cbiAgICAgIGlmICh0eXBlID09PSBUb2tlbi5FT0YpIHtcbiAgICAgICAgICB0aHJvd1VuZXhwZWN0ZWQobG9va2FoZWFkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSAneycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGJsb2NrIHN0YXRlbWVudFxuICAgICAgfVxuXG4gICAgICBub2RlID0gbmV3IE5vZGUoKTtcblxuICAgICAgaWYgKHR5cGUgPT09IFRva2VuLlB1bmN0dWF0b3IpIHtcbiAgICAgICAgICBzd2l0Y2ggKGxvb2thaGVhZC52YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJzsnOlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXNhYmxlZC5cIik7IC8vIGVtcHR5IHN0YXRlbWVudFxuICAgICAgICAgIGNhc2UgJygnOlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUpO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTsgLy8ga2V5d29yZFxuICAgICAgfVxuXG4gICAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBjb25zdW1lU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hFeHByZXNzaW9uU3RhdGVtZW50KGV4cHIpO1xuICB9XG5cbiAgLy8gMTQgUHJvZ3JhbVxuXG4gIGZ1bmN0aW9uIHBhcnNlU291cmNlRWxlbWVudCgpIHtcbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSA9PT0gVG9rZW4uS2V5d29yZCkge1xuICAgICAgICAgIHN3aXRjaCAobG9va2FoZWFkLnZhbHVlKSB7XG4gICAgICAgICAgY2FzZSAnY29uc3QnOlxuICAgICAgICAgIGNhc2UgJ2xldCc6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc2FibGVkLlwiKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gcGFyc2VTdGF0ZW1lbnQoKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlU3RhdGVtZW50KCk7XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZUVsZW1lbnRzKCkge1xuICAgICAgdmFyIHNvdXJjZUVsZW1lbnQsIHNvdXJjZUVsZW1lbnRzID0gW10sIHRva2VuLCBkaXJlY3RpdmUsIGZpcnN0UmVzdHJpY3RlZDtcblxuICAgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdG9rZW4gPSBsb29rYWhlYWQ7XG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09IFRva2VuLlN0cmluZ0xpdGVyYWwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc291cmNlRWxlbWVudCA9IHBhcnNlU291cmNlRWxlbWVudCgpO1xuICAgICAgICAgIHNvdXJjZUVsZW1lbnRzLnB1c2goc291cmNlRWxlbWVudCk7XG4gICAgICAgICAgaWYgKHNvdXJjZUVsZW1lbnQuZXhwcmVzc2lvbi50eXBlICE9PSBTeW50YXguTGl0ZXJhbCkge1xuICAgICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBkaXJlY3RpdmVcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpcmVjdGl2ZSA9IHNvdXJjZS5zbGljZSh0b2tlbi5zdGFydCArIDEsIHRva2VuLmVuZCAtIDEpO1xuICAgICAgICAgIGlmIChkaXJlY3RpdmUgPT09ICd1c2Ugc3RyaWN0Jykge1xuICAgICAgICAgICAgICBzdHJpY3QgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoZmlyc3RSZXN0cmljdGVkKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yVG9sZXJhbnQoZmlyc3RSZXN0cmljdGVkLCBNZXNzYWdlcy5TdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCFmaXJzdFJlc3RyaWN0ZWQgJiYgdG9rZW4ub2N0YWwpIHtcbiAgICAgICAgICAgICAgICAgIGZpcnN0UmVzdHJpY3RlZCA9IHRva2VuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBzb3VyY2VFbGVtZW50ID0gcGFyc2VTb3VyY2VFbGVtZW50KCk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2VFbGVtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlRWxlbWVudHMucHVzaChzb3VyY2VFbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3VyY2VFbGVtZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSgpIHtcbiAgICAgIHZhciBib2R5LCBub2RlO1xuXG4gICAgICBza2lwQ29tbWVudCgpO1xuICAgICAgcGVlaygpO1xuICAgICAgbm9kZSA9IG5ldyBOb2RlKCk7XG4gICAgICBzdHJpY3QgPSB0cnVlOyAvLyBhc3N1bWUgc3RyaWN0XG5cbiAgICAgIGJvZHkgPSBwYXJzZVNvdXJjZUVsZW1lbnRzKCk7XG4gICAgICByZXR1cm4gbm9kZS5maW5pc2hQcm9ncmFtKGJvZHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyVG9rZW5Mb2NhdGlvbigpIHtcbiAgICAgIHZhciBpLCBlbnRyeSwgdG9rZW4sIHRva2VucyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXh0cmEudG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZW50cnkgPSBleHRyYS50b2tlbnNbaV07XG4gICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IGVudHJ5LnR5cGUsXG4gICAgICAgICAgICAgIHZhbHVlOiBlbnRyeS52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGVudHJ5LnJlZ2V4KSB7XG4gICAgICAgICAgICAgIHRva2VuLnJlZ2V4ID0ge1xuICAgICAgICAgICAgICAgICAgcGF0dGVybjogZW50cnkucmVnZXgucGF0dGVybixcbiAgICAgICAgICAgICAgICAgIGZsYWdzOiBlbnRyeS5yZWdleC5mbGFnc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXh0cmEucmFuZ2UpIHtcbiAgICAgICAgICAgICAgdG9rZW4ucmFuZ2UgPSBlbnRyeS5yYW5nZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dHJhLmxvYykge1xuICAgICAgICAgICAgICB0b2tlbi5sb2MgPSBlbnRyeS5sb2M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgIH1cblxuICAgICAgZXh0cmEudG9rZW5zID0gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9rZW5pemUoY29kZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHRvU3RyaW5nLFxuICAgICAgICAgIHRva2VucztcblxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgaW5GdW5jdGlvbkJvZHk6IGZhbHNlLFxuICAgICAgICAgIGluSXRlcmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBpblN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgbGFzdENvbW1lbnRTdGFydDogLTFcbiAgICAgIH07XG5cbiAgICAgIGV4dHJhID0ge307XG5cbiAgICAgIC8vIE9wdGlvbnMgbWF0Y2hpbmcuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gT2YgY291cnNlIHdlIGNvbGxlY3QgdG9rZW5zIGhlcmUuXG4gICAgICBvcHRpb25zLnRva2VucyA9IHRydWU7XG4gICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgIGV4dHJhLnRva2VuaXplID0gdHJ1ZTtcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgdHdvIGZpZWxkcyBhcmUgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgdGhlIFJlZ2V4IHRva2Vucy5cbiAgICAgIGV4dHJhLm9wZW5QYXJlblRva2VuID0gLTE7XG4gICAgICBleHRyYS5vcGVuQ3VybHlUb2tlbiA9IC0xO1xuXG4gICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgZXh0cmEubG9jID0gKHR5cGVvZiBvcHRpb25zLmxvYyA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLmxvYztcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgIGV4dHJhLmVycm9ycyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICAgIHBlZWsoKTtcbiAgICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgPT09IFRva2VuLkVPRikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxleCgpO1xuICAgICAgICAgIHdoaWxlIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW4uRU9GKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBsZXgoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAobGV4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChleHRyYS5lcnJvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICBleHRyYS5lcnJvcnMucHVzaChsZXhFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0byBicmVhayBvbiB0aGUgZmlyc3QgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbGV4RXJyb3I7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgdG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEuZXJyb3JzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICB0b2tlbnMuZXJyb3JzID0gZXh0cmEuZXJyb3JzO1xuICAgICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBleHRyYSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRva2VucztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlKGNvZGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwcm9ncmFtLCB0b1N0cmluZztcblxuICAgICAgdG9TdHJpbmcgPSBTdHJpbmc7XG4gICAgICBpZiAodHlwZW9mIGNvZGUgIT09ICdzdHJpbmcnICYmICEoY29kZSBpbnN0YW5jZW9mIFN0cmluZykpIHtcbiAgICAgICAgICBjb2RlID0gdG9TdHJpbmcoY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHNvdXJjZSA9IGNvZGU7XG4gICAgICBpbmRleCA9IDA7XG4gICAgICBsaW5lTnVtYmVyID0gKHNvdXJjZS5sZW5ndGggPiAwKSA/IDEgOiAwO1xuICAgICAgbGluZVN0YXJ0ID0gMDtcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICBsb29rYWhlYWQgPSBudWxsO1xuICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgYWxsb3dJbjogdHJ1ZSxcbiAgICAgICAgICBsYWJlbFNldDoge30sXG4gICAgICAgICAgcGFyZW50aGVzaXNDb3VudDogMCxcbiAgICAgICAgICBpbkZ1bmN0aW9uQm9keTogZmFsc2UsXG4gICAgICAgICAgaW5JdGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGluU3dpdGNoOiBmYWxzZSxcbiAgICAgICAgICBsYXN0Q29tbWVudFN0YXJ0OiAtMVxuICAgICAgfTtcblxuICAgICAgZXh0cmEgPSB7fTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBleHRyYS5yYW5nZSA9ICh0eXBlb2Ygb3B0aW9ucy5yYW5nZSA9PT0gJ2Jvb2xlYW4nKSAmJiBvcHRpb25zLnJhbmdlO1xuICAgICAgICAgIGV4dHJhLmxvYyA9ICh0eXBlb2Ygb3B0aW9ucy5sb2MgPT09ICdib29sZWFuJykgJiYgb3B0aW9ucy5sb2M7XG5cbiAgICAgICAgICBpZiAoZXh0cmEubG9jICYmIG9wdGlvbnMuc291cmNlICE9PSBudWxsICYmIG9wdGlvbnMuc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZXh0cmEuc291cmNlID0gdG9TdHJpbmcob3B0aW9ucy5zb3VyY2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50b2tlbnMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnRva2Vucykge1xuICAgICAgICAgICAgICBleHRyYS50b2tlbnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRvbGVyYW50ID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy50b2xlcmFudCkge1xuICAgICAgICAgICAgICBleHRyYS5lcnJvcnMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvZ3JhbSA9IHBhcnNlUHJvZ3JhbSgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXh0cmEudG9rZW5zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBmaWx0ZXJUb2tlbkxvY2F0aW9uKCk7XG4gICAgICAgICAgICAgIHByb2dyYW0udG9rZW5zID0gZXh0cmEudG9rZW5zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGV4dHJhLmVycm9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgcHJvZ3JhbS5lcnJvcnMgPSBleHRyYS5lcnJvcnM7XG4gICAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4dHJhID0ge307XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogdG9rZW5pemUsXG4gICAgcGFyc2U6IHBhcnNlXG4gIH07XG5cbn0pKCk7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGF4cyA9IHJlcXVpcmUoJy4uL3NjZW5lL2F4aXMnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi91dGlsL2NvbmZpZycpO1xuXG52YXIgT1JJRU5UID0ge1xuICBcInhcIjogICAgICBcImJvdHRvbVwiLFxuICBcInlcIjogICAgICBcImxlZnRcIixcbiAgXCJ0b3BcIjogICAgXCJ0b3BcIixcbiAgXCJib3R0b21cIjogXCJib3R0b21cIixcbiAgXCJsZWZ0XCI6ICAgXCJsZWZ0XCIsXG4gIFwicmlnaHRcIjogIFwicmlnaHRcIlxufTtcblxuZnVuY3Rpb24gYXhlcyhtb2RlbCwgc3BlYywgYXhlcywgZ3JvdXApIHtcbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oZGVmLCBpbmRleCkge1xuICAgIGF4ZXNbaW5kZXhdID0gYXhlc1tpbmRleF0gfHwgYXhzKG1vZGVsKTtcbiAgICBheGlzKGRlZiwgaW5kZXgsIGF4ZXNbaW5kZXhdLCBncm91cCk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gYXhpcyhkZWYsIGluZGV4LCBheGlzLCBncm91cCkge1xuICAvLyBheGlzIHNjYWxlXG4gIGlmIChkZWYuc2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGF4aXMuc2NhbGUoZ3JvdXAuc2NhbGUoZGVmLnNjYWxlKSk7XG4gIH1cblxuICAvLyBheGlzIG9yaWVudGF0aW9uXG4gIGF4aXMub3JpZW50KGRlZi5vcmllbnQgfHwgT1JJRU5UW2RlZi50eXBlXSk7XG4gIC8vIGF4aXMgb2Zmc2V0XG4gIGF4aXMub2Zmc2V0KGRlZi5vZmZzZXQgfHwgMCk7XG4gIC8vIGF4aXMgbGF5ZXJcbiAgYXhpcy5sYXllcihkZWYubGF5ZXIgfHwgXCJmcm9udFwiKTtcbiAgLy8gYXhpcyBncmlkIGxpbmVzXG4gIGF4aXMuZ3JpZChkZWYuZ3JpZCB8fCBmYWxzZSk7XG4gIC8vIGF4aXMgdGl0bGVcbiAgYXhpcy50aXRsZShkZWYudGl0bGUgfHwgbnVsbCk7XG4gIC8vIGF4aXMgdGl0bGUgb2Zmc2V0XG4gIGF4aXMudGl0bGVPZmZzZXQoZGVmLnRpdGxlT2Zmc2V0ICE9IG51bGxcbiAgICA/IGRlZi50aXRsZU9mZnNldCA6IGNvbmZpZy5heGlzLnRpdGxlT2Zmc2V0KTtcbiAgLy8gYXhpcyB2YWx1ZXNcbiAgYXhpcy50aWNrVmFsdWVzKGRlZi52YWx1ZXMgfHwgbnVsbCk7XG4gIC8vIGF4aXMgbGFiZWwgZm9ybWF0dGluZ1xuICBheGlzLnRpY2tGb3JtYXQoZGVmLmZvcm1hdCB8fCBudWxsKTtcbiAgLy8gYXhpcyB0aWNrIHN1YmRpdmlzaW9uXG4gIGF4aXMudGlja1N1YmRpdmlkZShkZWYuc3ViZGl2aWRlIHx8IDApO1xuICAvLyBheGlzIHRpY2sgcGFkZGluZ1xuICBheGlzLnRpY2tQYWRkaW5nKGRlZi50aWNrUGFkZGluZyB8fCBjb25maWcuYXhpcy5wYWRkaW5nKTtcblxuICAvLyBheGlzIHRpY2sgc2l6ZShzKVxuICB2YXIgc2l6ZSA9IFtdO1xuICBpZiAoZGVmLnRpY2tTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8MzsgKytpKSBzaXplLnB1c2goZGVmLnRpY2tTaXplKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHMgPSBjb25maWcuYXhpcy50aWNrU2l6ZTtcbiAgICBzaXplID0gW3RzLCB0cywgdHNdO1xuICB9XG4gIGlmIChkZWYudGlja1NpemVNYWpvciAhPSBudWxsKSBzaXplWzBdID0gZGVmLnRpY2tTaXplTWFqb3I7XG4gIGlmIChkZWYudGlja1NpemVNaW5vciAhPSBudWxsKSBzaXplWzFdID0gZGVmLnRpY2tTaXplTWlub3I7XG4gIGlmIChkZWYudGlja1NpemVFbmQgICAhPSBudWxsKSBzaXplWzJdID0gZGVmLnRpY2tTaXplRW5kO1xuICBpZiAoc2l6ZS5sZW5ndGgpIHtcbiAgICBheGlzLnRpY2tTaXplLmFwcGx5KGF4aXMsIHNpemUpO1xuICB9XG5cbiAgLy8gdGljayBhcmd1bWVudHNcbiAgaWYgKGRlZi50aWNrcyAhPSBudWxsKSB7XG4gICAgdmFyIHRpY2tzID0gZGwuaXNBcnJheShkZWYudGlja3MpID8gZGVmLnRpY2tzIDogW2RlZi50aWNrc107XG4gICAgYXhpcy50aWNrcy5hcHBseShheGlzLCB0aWNrcyk7XG4gIH0gZWxzZSB7XG4gICAgYXhpcy50aWNrcyhjb25maWcuYXhpcy50aWNrcyk7XG4gIH1cblxuICAvLyBzdHlsZSBwcm9wZXJ0aWVzXG4gIHZhciBwID0gZGVmLnByb3BlcnRpZXM7XG4gIGlmIChwICYmIHAudGlja3MpIHtcbiAgICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMocC5tYWpvclRpY2tzXG4gICAgICA/IGRsLmV4dGVuZCh7fSwgcC50aWNrcywgcC5tYWpvclRpY2tzKSA6IHAudGlja3MpO1xuICAgIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyhwLm1pbm9yVGlja3NcbiAgICAgID8gZGwuZXh0ZW5kKHt9LCBwLnRpY2tzLCBwLm1pbm9yVGlja3MpIDogcC50aWNrcyk7XG4gIH0gZWxzZSB7XG4gICAgYXhpcy5tYWpvclRpY2tQcm9wZXJ0aWVzKHAgJiYgcC5tYWpvclRpY2tzIHx8IHt9KTtcbiAgICBheGlzLm1pbm9yVGlja1Byb3BlcnRpZXMocCAmJiBwLm1pbm9yVGlja3MgfHwge30pO1xuICB9XG4gIGF4aXMudGlja0xhYmVsUHJvcGVydGllcyhwICYmIHAubGFiZWxzIHx8IHt9KTtcbiAgYXhpcy50aXRsZVByb3BlcnRpZXMocCAmJiBwLnRpdGxlIHx8IHt9KTtcbiAgYXhpcy5ncmlkTGluZVByb3BlcnRpZXMocCAmJiBwLmdyaWQgfHwge30pO1xuICBheGlzLmRvbWFpblByb3BlcnRpZXMocCAmJiBwLmF4aXMgfHwge30pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGF4ZXM7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgcGFyc2VUcmFuc2Zvcm1zID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1zJyksXG4gICAgcGFyc2VNb2RpZnkgPSByZXF1aXJlKCcuL21vZGlmeScpO1xuXG52YXIgcGFyc2VEYXRhID0gZnVuY3Rpb24obW9kZWwsIHNwZWMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZnVuY3Rpb24gbG9hZGVkKGQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBkbC5lcnJvcihcIkxPQURJTkcgRkFJTEVEOiBcIiArIGQudXJsICsgXCIgXCIgKyBlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC5kYXRhKGQubmFtZSkudmFsdWVzKGRsLnJlYWQoZGF0YSwgZC5mb3JtYXQpKTtcbiAgICAgIH1cbiAgICAgIGlmICgtLWNvdW50ID09PSAwKSBjYWxsYmFjaygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb2Nlc3MgZWFjaCBkYXRhIHNldCBkZWZpbml0aW9uXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICBpZiAoZC51cmwpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiBkLnVybH0sIGNvbmZpZy5sb2FkKSwgbG9hZGVkKGQpKTtcbiAgICB9XG4gICAgcGFyc2VEYXRhLmRhdGFzb3VyY2UobW9kZWwsIGQpO1xuICB9KTtcblxuICBpZiAoY291bnQgPT09IDApIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEpO1xuICByZXR1cm4gc3BlYztcbn07XG5cbnBhcnNlRGF0YS5kYXRhc291cmNlID0gZnVuY3Rpb24obW9kZWwsIGQpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IChkLnRyYW5zZm9ybXx8W10pLm1hcChmdW5jdGlvbih0KSB7IHJldHVybiBwYXJzZVRyYW5zZm9ybXMobW9kZWwsIHQpIH0pLFxuICAgICAgbW9kID0gKGQubW9kaWZ5fHxbXSkubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTW9kaWZ5KG1vZGVsLCBtLCBkKSB9KSxcbiAgICAgIGRzID0gbW9kZWwuZGF0YShkLm5hbWUsIG1vZC5jb25jYXQodHJhbnNmb3JtKSk7XG5cbiAgaWYgKGQudmFsdWVzKSB7XG4gICAgZHMudmFsdWVzKGRsLnJlYWQoZC52YWx1ZXMsIGQuZm9ybWF0KSk7XG4gIH0gZWxzZSBpZiAoZC5zb3VyY2UpIHtcbiAgICBkcy5zb3VyY2UoZC5zb3VyY2UpXG4gICAgICAucmV2aXNlcyhkcy5yZXZpc2VzKCkpIC8vIElmIG5ldyBkcyByZXZpc2VzLCB0aGVuIGl0J3Mgb3JpZ2luIG11c3QgcmV2aXNlIHRvby5cbiAgICAgIC5hZGRMaXN0ZW5lcihkcyk7ICAvLyBEZXJpdmVkIGRzIHdpbGwgYmUgcHVsc2VkIGJ5IGl0cyBzcmMgcmF0aGVyIHRoYW4gdGhlIG1vZGVsLlxuICAgIG1vZGVsLnJlbW92ZUxpc3RlbmVyKGRzLnBpcGVsaW5lKClbMF0pOyBcbiAgfVxuXG4gIHJldHVybiBkczsgICAgXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlRGF0YTtcbiIsIi8qXG4gKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICpcbiAqIGh0dHA6Ly9wZWdqcy5tYWpkYS5jei9cbiAqL1xuXG5mdW5jdGlvbiBwZWckc3ViY2xhc3MoY2hpbGQsIHBhcmVudCkge1xuICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpO1xufVxuXG5mdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlO1xuICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7XG4gIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgdGhpcy5vZmZzZXQgICA9IG9mZnNldDtcbiAgdGhpcy5saW5lICAgICA9IGxpbmU7XG4gIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgdGhpcy5uYW1lICAgICA9IFwiU3ludGF4RXJyb3JcIjtcbn1cblxucGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSxcblxuICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0geyBzdGFydDogcGVnJHBhcnNlc3RhcnQgfSxcbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiAgPSBwZWckcGFyc2VzdGFydCxcblxuICAgICAgcGVnJGMwID0gcGVnJEZBSUxFRCxcbiAgICAgIHBlZyRjMSA9IFwiLFwiLFxuICAgICAgcGVnJGMyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLFxcXCJcIiB9LFxuICAgICAgcGVnJGMzID0gZnVuY3Rpb24obywgbSkgeyByZXR1cm4gW29dLmNvbmNhdChtKSB9LFxuICAgICAgcGVnJGM0ID0gZnVuY3Rpb24obykgeyByZXR1cm4gW29dIH0sXG4gICAgICBwZWckYzUgPSBcIltcIixcbiAgICAgIHBlZyRjNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgIHBlZyRjNyA9IFwiXVwiLFxuICAgICAgcGVnJGM4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXVxcXCJcIiB9LFxuICAgICAgcGVnJGM5ID0gXCI+XCIsXG4gICAgICBwZWckYzEwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPlxcXCJcIiB9LFxuICAgICAgcGVnJGMxMSA9IGZ1bmN0aW9uKGYxLCBmMiwgbykgeyByZXR1cm4ge3N0YXJ0OiBmMSwgZW5kOiBmMiwgbWlkZGxlOiBvfX0sXG4gICAgICBwZWckYzEyID0gW10sXG4gICAgICBwZWckYzEzID0gZnVuY3Rpb24ocywgZikgeyByZXR1cm4gKHMuZmlsdGVycyA9IGYpLCBzIH0sXG4gICAgICBwZWckYzE0ID0gZnVuY3Rpb24ocykgeyByZXR1cm4gcyB9LFxuICAgICAgcGVnJGMxNSA9IG51bGwsXG4gICAgICBwZWckYzE2ID0gZnVuY3Rpb24odCwgZSkgeyByZXR1cm4geyBldmVudDogZSwgdGFyZ2V0OiB0IH0gfSxcbiAgICAgIHBlZyRjMTcgPSAvXls6YS16QS16MC05X1xcLV0vLFxuICAgICAgcGVnJGMxOCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbOmEtekEtejAtOV9cXFxcLV1cIiwgZGVzY3JpcHRpb246IFwiWzphLXpBLXowLTlfXFxcXC1dXCIgfSxcbiAgICAgIHBlZyRjMTkgPSBmdW5jdGlvbihzKSB7IHJldHVybiB7IHNpZ25hbDogcy5qb2luKFwiXCIpIH19LFxuICAgICAgcGVnJGMyMCA9IFwiKFwiLFxuICAgICAgcGVnJGMyMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIihcIiwgZGVzY3JpcHRpb246IFwiXFxcIihcXFwiXCIgfSxcbiAgICAgIHBlZyRjMjIgPSBcIilcIixcbiAgICAgIHBlZyRjMjMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIpXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIpXFxcIlwiIH0sXG4gICAgICBwZWckYzI0ID0gZnVuY3Rpb24obSkgeyByZXR1cm4geyBzdHJlYW06IG0gfX0sXG4gICAgICBwZWckYzI1ID0gXCIuXCIsXG4gICAgICBwZWckYzI2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLlxcXCJcIiB9LFxuICAgICAgcGVnJGMyNyA9IFwiOlwiLFxuICAgICAgcGVnJGMyOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgIHBlZyRjMjkgPSBmdW5jdGlvbihjKSB7IHJldHVybiB7IHR5cGU6J2NsYXNzJywgdmFsdWU6IGMgfSB9LFxuICAgICAgcGVnJGMzMCA9IFwiI1wiLFxuICAgICAgcGVnJGMzMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiNcIiwgZGVzY3JpcHRpb246IFwiXFxcIiNcXFwiXCIgfSxcbiAgICAgIHBlZyRjMzIgPSBmdW5jdGlvbihpZCkgeyByZXR1cm4geyB0eXBlOidpZCcsIHZhbHVlOiBpZCB9IH0sXG4gICAgICBwZWckYzMzID0gXCJtb3VzZWRvd25cIixcbiAgICAgIHBlZyRjMzQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZWRvd25cIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlZG93blxcXCJcIiB9LFxuICAgICAgcGVnJGMzNSA9IFwibW91c2V1cFwiLFxuICAgICAgcGVnJGMzNiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNldXBcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNldXBcXFwiXCIgfSxcbiAgICAgIHBlZyRjMzcgPSBcImNsaWNrXCIsXG4gICAgICBwZWckYzM4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiY2xpY2tcIiwgZGVzY3JpcHRpb246IFwiXFxcImNsaWNrXFxcIlwiIH0sXG4gICAgICBwZWckYzM5ID0gXCJkYmxjbGlja1wiLFxuICAgICAgcGVnJGM0MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImRibGNsaWNrXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJkYmxjbGlja1xcXCJcIiB9LFxuICAgICAgcGVnJGM0MSA9IFwid2hlZWxcIixcbiAgICAgIHBlZyRjNDIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ3aGVlbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwid2hlZWxcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDMgPSBcImtleWRvd25cIixcbiAgICAgIHBlZyRjNDQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXlkb3duXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXlkb3duXFxcIlwiIH0sXG4gICAgICBwZWckYzQ1ID0gXCJrZXlwcmVzc1wiLFxuICAgICAgcGVnJGM0NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImtleXByZXNzXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJrZXlwcmVzc1xcXCJcIiB9LFxuICAgICAgcGVnJGM0NyA9IFwia2V5dXBcIixcbiAgICAgIHBlZyRjNDggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJrZXl1cFwiLCBkZXNjcmlwdGlvbjogXCJcXFwia2V5dXBcXFwiXCIgfSxcbiAgICAgIHBlZyRjNDkgPSBcIm1vdXNld2hlZWxcIixcbiAgICAgIHBlZyRjNTAgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZXdoZWVsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJtb3VzZXdoZWVsXFxcIlwiIH0sXG4gICAgICBwZWckYzUxID0gXCJtb3VzZW1vdmVcIixcbiAgICAgIHBlZyRjNTIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW1vdmVcIiwgZGVzY3JpcHRpb246IFwiXFxcIm1vdXNlbW92ZVxcXCJcIiB9LFxuICAgICAgcGVnJGM1MyA9IFwibW91c2VvdXRcIixcbiAgICAgIHBlZyRjNTQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJtb3VzZW91dFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VvdXRcXFwiXCIgfSxcbiAgICAgIHBlZyRjNTUgPSBcIm1vdXNlb3ZlclwiLFxuICAgICAgcGVnJGM1NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm1vdXNlb3ZlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VvdmVyXFxcIlwiIH0sXG4gICAgICBwZWckYzU3ID0gXCJtb3VzZWVudGVyXCIsXG4gICAgICBwZWckYzU4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibW91c2VlbnRlclwiLCBkZXNjcmlwdGlvbjogXCJcXFwibW91c2VlbnRlclxcXCJcIiB9LFxuICAgICAgcGVnJGM1OSA9IFwidG91Y2hzdGFydFwiLFxuICAgICAgcGVnJGM2MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNoc3RhcnRcIiwgZGVzY3JpcHRpb246IFwiXFxcInRvdWNoc3RhcnRcXFwiXCIgfSxcbiAgICAgIHBlZyRjNjEgPSBcInRvdWNobW92ZVwiLFxuICAgICAgcGVnJGM2MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNobW92ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidG91Y2htb3ZlXFxcIlwiIH0sXG4gICAgICBwZWckYzYzID0gXCJ0b3VjaGVuZFwiLFxuICAgICAgcGVnJGM2NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInRvdWNoZW5kXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ0b3VjaGVuZFxcXCJcIiB9LFxuICAgICAgcGVnJGM2NSA9IGZ1bmN0aW9uKGZpZWxkKSB7IHJldHVybiBmaWVsZCAgfSxcbiAgICAgIHBlZyRjNjYgPSAvXlsnXCJhLXpBLVowLTlfLj48PSEgXFx0XFwtXS8sXG4gICAgICBwZWckYzY3ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsnXFxcImEtekEtWjAtOV8uPjw9ISBcXFxcdFxcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbJ1xcXCJhLXpBLVowLTlfLj48PSEgXFxcXHRcXFxcLV1cIiB9LFxuICAgICAgcGVnJGM2OCA9IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYuam9pbihcIlwiKSB9LFxuICAgICAgcGVnJGM2OSA9IC9eWyBcXHRcXHJcXG5dLyxcbiAgICAgIHBlZyRjNzAgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyBcXFxcdFxcXFxyXFxcXG5dXCIsIGRlc2NyaXB0aW9uOiBcIlsgXFxcXHRcXFxcclxcXFxuXVwiIH0sXG5cbiAgICAgIHBlZyRjdXJyUG9zICAgICAgICAgID0gMCxcbiAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgIHBlZyRjYWNoZWRQb3MgICAgICAgID0gMCxcbiAgICAgIHBlZyRjYWNoZWRQb3NEZXRhaWxzID0geyBsaW5lOiAxLCBjb2x1bW46IDEsIHNlZW5DUjogZmFsc2UgfSxcbiAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgIHBlZyRtYXhGYWlsRXhwZWN0ZWQgID0gW10sXG4gICAgICBwZWckc2lsZW50RmFpbHMgICAgICA9IDAsXG5cbiAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykge1xuICAgIGlmICghKG9wdGlvbnMuc3RhcnRSdWxlIGluIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgfVxuXG4gICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uc1tvcHRpb25zLnN0YXJ0UnVsZV07XG4gIH1cblxuICBmdW5jdGlvbiB0ZXh0KCkge1xuICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHJlcG9ydGVkUG9zLCBwZWckY3VyclBvcyk7XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXQoKSB7XG4gICAgcmV0dXJuIHBlZyRyZXBvcnRlZFBvcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGxpbmUoKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmxpbmU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2x1bW4oKSB7XG4gICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmNvbHVtbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGVjdGVkKGRlc2NyaXB0aW9uKSB7XG4gICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKFxuICAgICAgbnVsbCxcbiAgICAgIFt7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uIH1dLFxuICAgICAgcGVnJHJlcG9ydGVkUG9zXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHtcbiAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgIHZhciBwLCBjaDtcblxuICAgICAgZm9yIChwID0gc3RhcnRQb3M7IHAgPCBlbmRQb3M7IHArKykge1xuICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgaWYgKGNoID09PSBcIlxcblwiKSB7XG4gICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfVxuICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcclwiIHx8IGNoID09PSBcIlxcdTIwMjhcIiB8fCBjaCA9PT0gXCJcXHUyMDI5XCIpIHtcbiAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7XG4gICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7XG4gICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgIGlmIChwZWckY2FjaGVkUG9zID4gcG9zKSB7XG4gICAgICAgIHBlZyRjYWNoZWRQb3MgPSAwO1xuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBhZHZhbmNlKHBlZyRjYWNoZWRQb3NEZXRhaWxzLCBwZWckY2FjaGVkUG9zLCBwb3MpO1xuICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICB9XG5cbiAgICByZXR1cm4gcGVnJGNhY2hlZFBvc0RldGFpbHM7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkge1xuICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgIHBlZyRtYXhGYWlsUG9zID0gcGVnJGN1cnJQb3M7XG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkID0gW107XG4gICAgfVxuXG4gICAgcGVnJG1heEZhaWxFeHBlY3RlZC5wdXNoKGV4cGVjdGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7XG4gICAgICB2YXIgaSA9IDE7XG5cbiAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBpZiAoYS5kZXNjcmlwdGlvbiA8IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChleHBlY3RlZFtpIC0gMV0gPT09IGV4cGVjdGVkW2ldKSB7XG4gICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpIHtcbiAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGhleChjaCkgeyByZXR1cm4gY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTsgfVxuXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgIC5yZXBsYWNlKC9cIi9nLCAgICAnXFxcXFwiJylcbiAgICAgICAgICAucmVwbGFjZSgvXFx4MDgvZywgJ1xcXFxiJylcbiAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAucmVwbGFjZSgvXFxuL2csICAgJ1xcXFxuJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxmL2csICAgJ1xcXFxmJylcbiAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRVxceDBGXS9nLCBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx4MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MTAtXFx4MUZcXHg4MC1cXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxceCcgICsgaGV4KGNoKTsgfSlcbiAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MTA4MC1cXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHUnICArIGhleChjaCk7IH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgIGV4cGVjdGVkRGVzYywgZm91bmREZXNjLCBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXhwZWN0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuXG4gICAgICBleHBlY3RlZERlc2MgPSBleHBlY3RlZC5sZW5ndGggPiAxXG4gICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICArIFwiIG9yIFwiXG4gICAgICAgICAgICArIGV4cGVjdGVkRGVzY3NbZXhwZWN0ZWQubGVuZ3RoIC0gMV1cbiAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFwiXFxcIlwiICsgc3RyaW5nRXNjYXBlKGZvdW5kKSArIFwiXFxcIlwiIDogXCJlbmQgb2YgaW5wdXRcIjtcblxuICAgICAgcmV0dXJuIFwiRXhwZWN0ZWQgXCIgKyBleHBlY3RlZERlc2MgKyBcIiBidXQgXCIgKyBmb3VuZERlc2MgKyBcIiBmb3VuZC5cIjtcbiAgICB9XG5cbiAgICB2YXIgcG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpLFxuICAgICAgICBmb3VuZCAgICAgID0gcG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBvcykgOiBudWxsO1xuXG4gICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBtZXNzYWdlICE9PSBudWxsID8gbWVzc2FnZSA6IGJ1aWxkTWVzc2FnZShleHBlY3RlZCwgZm91bmQpLFxuICAgICAgZXhwZWN0ZWQsXG4gICAgICBmb3VuZCxcbiAgICAgIHBvcyxcbiAgICAgIHBvc0RldGFpbHMubGluZSxcbiAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZXN0YXJ0KCkge1xuICAgIHZhciBzMDtcblxuICAgIHMwID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VtZXJnZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIHMxID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczMgPSBwZWckYzE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlbWVyZ2VkKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMzKHMxLCBzNSk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW9yZGVyZWQoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VvcmRlcmVkKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4LCBzOSwgczEwLCBzMTEsIHMxMiwgczEzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICBzMSA9IHBlZyRjNTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2KTsgfVxuICAgIH1cbiAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMyID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRjMTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VmaWx0ZXJlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VzZXAoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzOCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckYzc7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgpOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHM5ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczEwID0gcGVnJHBhcnNlc2VwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMxMCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckYzk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMTEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTApOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczExICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMxMiA9IHBlZyRwYXJzZXNlcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczEyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczEzID0gcGVnJHBhcnNlb3JkZXJlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMTMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzExKHMzLCBzNywgczEzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRwYXJzZWZpbHRlcmVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlZmlsdGVyZWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBzMSA9IHBlZyRwYXJzZXN0cmVhbSgpO1xuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBbXTtcbiAgICAgIHMzID0gcGVnJHBhcnNlZmlsdGVyKCk7XG4gICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VmaWx0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczIgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxMyhzMSwgczIpO1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VzdHJlYW0oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzE0KHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyZWFtKCkge1xuICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBwZWckcGFyc2VjbGFzcygpO1xuICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczEgPSBwZWckcGFyc2VpZCgpO1xuICAgIH1cbiAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMxID0gcGVnJGMxNTtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZWV2ZW50VHlwZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTYoczEsIHMyKTtcbiAgICAgICAgczAgPSBzMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBpZiAocGVnJGMxNy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzE4KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIGlmIChwZWckYzE3LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTkoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgICAgczEgPSBwZWckYzIwO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZW1lcmdlZCgpO1xuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRjMjI7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzI0KHMyKTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VjbGFzcygpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgIHMxID0gcGVnJGMyNTtcbiAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNik7IH1cbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBzMiA9IHBlZyRwYXJzZXZhbHVlKCk7XG4gICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICAgIHMzID0gcGVnJGMyNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMjgpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzI5KHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgczAgPSBwZWckYzA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMwO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVnJHBhcnNlaWQoKSB7XG4gICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgczAgPSBwZWckY3VyclBvcztcbiAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM1KSB7XG4gICAgICBzMSA9IHBlZyRjMzA7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzEpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjMjc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMzMihzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgIHMwID0gcGVnJGMwO1xuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWV2ZW50VHlwZSgpIHtcbiAgICB2YXIgczA7XG5cbiAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA5KSA9PT0gcGVnJGMzMykge1xuICAgICAgczAgPSBwZWckYzMzO1xuICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICB9IGVsc2Uge1xuICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM0KTsgfVxuICAgIH1cbiAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzM1KSB7XG4gICAgICAgIHMwID0gcGVnJGMzNTtcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzM3KSB7XG4gICAgICAgICAgczAgPSBwZWckYzM3O1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGMzOSkge1xuICAgICAgICAgICAgczAgPSBwZWckYzM5O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQwKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQxKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGM0MTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQyKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDcpID09PSBwZWckYzQzKSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzQzO1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0NCk7IH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM0NSkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzQ1O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ2KTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDUpID09PSBwZWckYzQ3KSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0NztcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ4KTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM0OSkge1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGM0OTtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUwKTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzUxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA5O1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTIpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOCkgPT09IHBlZyRjNTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzUzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTQpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgOSkgPT09IHBlZyRjNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU2KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEwKSA9PT0gcGVnJGM1Nykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU3O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1OCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMCkgPT09IHBlZyRjNTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzU5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYwKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDkpID09PSBwZWckYzYxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Mik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA4KSA9PT0gcGVnJGM2Mykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzYzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY0KTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlZyRwYXJzZWZpbHRlcigpIHtcbiAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgIHMxID0gcGVnJGM1O1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYpOyB9XG4gICAgfVxuICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgczIgPSBwZWckcGFyc2V2YWx1ZSgpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICBzMyA9IHBlZyRjNztcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNjUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICBzMCA9IHBlZyRjMDtcbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2V2YWx1ZSgpIHtcbiAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgczEgPSBbXTtcbiAgICBpZiAocGVnJGM2Ni50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICBwZWckY3VyclBvcysrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjcpOyB9XG4gICAgfVxuICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBpZiAocGVnJGM2Ni50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2Nyk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzMSA9IHBlZyRjMDtcbiAgICB9XG4gICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgIHMxID0gcGVnJGM2OChzMSk7XG4gICAgfVxuICAgIHMwID0gczE7XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBmdW5jdGlvbiBwZWckcGFyc2VzZXAoKSB7XG4gICAgdmFyIHMwLCBzMTtcblxuICAgIHMwID0gW107XG4gICAgaWYgKHBlZyRjNjkudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcwKTsgfVxuICAgIH1cbiAgICB3aGlsZSAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgIHMwLnB1c2goczEpO1xuICAgICAgaWYgKHBlZyRjNjkudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MCk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gczA7XG4gIH1cblxuICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiBwZWckcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgIH1cblxuICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihudWxsLCBwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgcGFyc2U6ICAgICAgIHBhcnNlXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBleHByZXNzaW9uID0gcmVxdWlyZSgnLi4vZXhwcmVzc2lvbicpO1xuXG52YXIgZXhwciA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHBhcnNlID0gZXhwcmVzc2lvbi5wYXJzZTtcbiAgdmFyIGNvZGVnZW4gPSBleHByZXNzaW9uLmNvZGUoe1xuICAgIGlkV2hpdGVMaXN0OiBbJ2QnLCAnZScsICdpJywgJ3AnLCAnc2cnXVxuICB9KTtcblxuICByZXR1cm4gZnVuY3Rpb24oZXhwcikgeyAgICBcbiAgICB2YXIgdmFsdWUgPSBjb2RlZ2VuKHBhcnNlKGV4cHIpKTtcbiAgICB2YWx1ZS5mbiA9IEZ1bmN0aW9uKCdkJywgJ2UnLCAnaScsICdwJywgJ3NnJyxcbiAgICAgICdcInVzZSBzdHJpY3RcIjsgcmV0dXJuICgnICsgdmFsdWUuZm4gKyAnKTsnKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59KSgpO1xuXG5leHByLmV2YWwgPSBmdW5jdGlvbihncmFwaCwgZm4sIGQsIGUsIGksIHAsIHNnKSB7XG4gIHNnID0gZ3JhcGguc2lnbmFsVmFsdWVzKGRsLmFycmF5KHNnKSk7XG4gIHJldHVybiBmbi5jYWxsKG51bGwsIGQsIGUsIGksIHAsIHNnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUludGVyYWN0b3JzKG1vZGVsLCBzcGVjLCBkZWZGYWN0b3J5KSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBzZyA9IHt9LCBwZCA9IHt9LCBtayA9IHt9LFxuICAgICAgc2lnbmFscyA9IFtdLCBwcmVkaWNhdGVzID0gW107XG5cbiAgZnVuY3Rpb24gbG9hZGVkKGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBkbC5lcnJvcihcIkxPQURJTkcgRkFJTEVEOiBcIiArIGkudXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkZWYgPSBkbC5pc09iamVjdChkYXRhKSA/IGRhdGEgOiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICBpbnRlcmFjdG9yKGkubmFtZSwgZGVmKTtcbiAgICAgIH1cbiAgICAgIGlmICgtLWNvdW50ID09IDApIGluamVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyYWN0b3IobmFtZSwgZGVmKSB7XG4gICAgc2cgPSB7fSwgcGQgPSB7fTtcbiAgICBpZiAoZGVmLnNpZ25hbHMpICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBuc1NpZ25hbHMobmFtZSwgZGVmLnNpZ25hbHMpKTtcbiAgICBpZiAoZGVmLnByZWRpY2F0ZXMpIHByZWRpY2F0ZXMucHVzaC5hcHBseShwcmVkaWNhdGVzLCBuc1ByZWRpY2F0ZXMobmFtZSwgZGVmLnByZWRpY2F0ZXMpKTtcbiAgICBuc01hcmtzKG5hbWUsIGRlZi5tYXJrcyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3QoKSB7XG4gICAgaWYgKGRsLmtleXMobWspLmxlbmd0aCA+IDApIGluamVjdE1hcmtzKHNwZWMubWFya3MpO1xuICAgIHNwZWMuc2lnbmFscyA9IGRsLmFycmF5KHNwZWMuc2lnbmFscyk7XG4gICAgc3BlYy5wcmVkaWNhdGVzID0gZGwuYXJyYXkoc3BlYy5wcmVkaWNhdGVzKTtcbiAgICBzcGVjLnNpZ25hbHMudW5zaGlmdC5hcHBseShzcGVjLnNpZ25hbHMsIHNpZ25hbHMpO1xuICAgIHNwZWMucHJlZGljYXRlcy51bnNoaWZ0LmFwcGx5KHNwZWMucHJlZGljYXRlcywgcHJlZGljYXRlcyk7XG4gICAgZGVmRmFjdG9yeSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0TWFya3MobWFya3MpIHtcbiAgICB2YXIgbSwgciwgaSwgbGVuO1xuICAgIG1hcmtzID0gZGwuYXJyYXkobWFya3MpO1xuXG4gICAgZm9yKGkgPSAwLCBsZW4gPSBtYXJrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbSA9IG1hcmtzW2ldO1xuICAgICAgaWYgKHIgPSBta1ttLnR5cGVdKSB7XG4gICAgICAgIG1hcmtzW2ldID0gZGwuZHVwbGljYXRlKHIpO1xuICAgICAgICBpZiAobS5mcm9tKSBtYXJrc1tpXS5mcm9tID0gbS5mcm9tO1xuICAgICAgICBpZiAobS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgW0MuRU5URVIsIEMuVVBEQVRFLCBDLkVYSVRdLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgbWFya3NbaV0ucHJvcGVydGllc1twXSA9IGRsLmV4dGVuZChyLnByb3BlcnRpZXNbcF0sIG0ucHJvcGVydGllc1twXSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobS5tYXJrcykgeyAgLy8gVE9ETyBob3cgdG8gb3ZlcnJpZGUgcHJvcGVydGllcyBvZiBuZXN0ZWQgbWFya3M/XG4gICAgICAgIGluamVjdE1hcmtzKG0ubWFya3MpO1xuICAgICAgfVxuICAgIH0gICAgXG4gIH1cblxuICBmdW5jdGlvbiBucyhuLCBzKSB7IFxuICAgIGlmIChkbC5pc1N0cmluZyhzKSkge1xuICAgICAgcmV0dXJuIHMgKyBcIl9cIiArIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIGRsLmtleXMocykuZm9yRWFjaChmdW5jdGlvbih4KSB7IFxuICAgICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKCdcXFxcYicreCsnXFxcXGInLCBcImdcIik7XG4gICAgICAgIG4gPSBuLnJlcGxhY2UocmVnZXgsIHNbeF0pIFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuc1NpZ25hbHMobmFtZSwgc2lnbmFscykge1xuICAgIHNpZ25hbHMgPSBkbC5hcnJheShzaWduYWxzKTtcbiAgICAvLyBUd28gcGFzc2VzIHRvIG5zIGFsbCBzaWduYWxzLCBhbmQgdGhlbiBvdmVyd3JpdGUgdGhlaXIgZGVmaW5pdGlvbnNcbiAgICAvLyBpbiBjYXNlIHNpZ25hbCBvcmRlciBpcyBpbXBvcnRhbnQuXG4gICAgc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgcy5uYW1lID0gc2dbcy5uYW1lXSA9IG5zKHMubmFtZSwgbmFtZSk7IH0pO1xuICAgIHNpZ25hbHMuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgICAocy5zdHJlYW1zIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdC50eXBlID0gbnModC50eXBlLCBzZyk7XG4gICAgICAgIHQuZXhwciA9IG5zKHQuZXhwciwgc2cpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpZ25hbHM7XG4gIH1cblxuICBmdW5jdGlvbiBuc1ByZWRpY2F0ZXMobmFtZSwgcHJlZGljYXRlcykge1xuICAgIHByZWRpY2F0ZXMgPSBkbC5hcnJheShwcmVkaWNhdGVzKTtcbiAgICBwcmVkaWNhdGVzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgcC5uYW1lID0gcGRbcC5uYW1lXSA9IG5zKHAubmFtZSwgbmFtZSk7XG5cbiAgICAgIFtwLm9wZXJhbmRzLCBwLnJhbmdlXS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgKHggfHwgW10pLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgICAgICAgIGlmIChvLnNpZ25hbCkgby5zaWduYWwgPSBucyhvLnNpZ25hbCwgc2cpO1xuICAgICAgICAgIGVsc2UgaWYgKG8ucHJlZGljYXRlKSBuc09wZXJhbmQobyk7XG4gICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgIH0pOyAgXG4gICAgcmV0dXJuIHByZWRpY2F0ZXM7IFxuICB9XG5cbiAgZnVuY3Rpb24gbnNPcGVyYW5kKG8pIHtcbiAgICBvLnByZWRpY2F0ZSA9IHBkW28ucHJlZGljYXRlXTtcbiAgICBkbC5rZXlzKG8uaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGkgPSBvLmlucHV0W2tdO1xuICAgICAgaWYgKGkuc2lnbmFsKSBpLnNpZ25hbCA9IG5zKGkuc2lnbmFsLCBzZyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBuc01hcmtzKG5hbWUsIG1hcmtzKSB7XG4gICAgKG1hcmtzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKG0pIHsgXG4gICAgICBuc1Byb3BlcnRpZXMobS5wcm9wZXJ0aWVzLmVudGVyKTtcbiAgICAgIG5zUHJvcGVydGllcyhtLnByb3BlcnRpZXMudXBkYXRlKTtcbiAgICAgIG5zUHJvcGVydGllcyhtLnByb3BlcnRpZXMuZXhpdCk7XG4gICAgICBta1tucyhtLm5hbWUsIG5hbWUpXSA9IG07IFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbnNQcm9wZXJ0aWVzKHByb3BzZXQpIHtcbiAgICBkbC5rZXlzKHByb3BzZXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHAgPSBwcm9wc2V0W2tdO1xuICAgICAgaWYgKHAuc2lnbmFsKSBwLnNpZ25hbCA9IG5zKHAuc2lnbmFsLCBzZyk7XG4gICAgICBlbHNlIGlmIChwLnJ1bGUpIHtcbiAgICAgICAgcC5ydWxlLmZvckVhY2goZnVuY3Rpb24ocikgeyBcbiAgICAgICAgICBpZiAoci5zaWduYWwpIHIuc2lnbmFsID0gbnMoci5zaWduYWwsIHNnKTtcbiAgICAgICAgICBpZiAoci5wcmVkaWNhdGUpIG5zT3BlcmFuZChyKTsgXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgKHNwZWMuaW50ZXJhY3RvcnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIGlmIChpLnVybCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICAgIGRsLmxvYWQoZGwuZXh0ZW5kKHt1cmw6IGkudXJsfSwgY29uZmlnLmxvYWQpLCBsb2FkZWQoaSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGNvdW50ID09PSAwKSBzZXRUaW1lb3V0KGluamVjdCwgMSk7XG4gIHJldHVybiBzcGVjO1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBwYXJzZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuL3Byb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZU1hcmsobW9kZWwsIG1hcmspIHtcbiAgdmFyIHByb3BzID0gbWFyay5wcm9wZXJ0aWVzLFxuICAgICAgZ3JvdXAgPSBtYXJrLm1hcmtzO1xuXG4gIC8vIHBhcnNlIG1hcmsgcHJvcGVydHkgZGVmaW5pdGlvbnNcbiAgZGwua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcHJvcHNba10gPSBwYXJzZVByb3BlcnRpZXMobW9kZWwsIG1hcmsudHlwZSwgcHJvcHNba10pO1xuICB9KTtcblxuICAvLyBwYXJzZSBkZWxheSBmdW5jdGlvblxuICBpZiAobWFyay5kZWxheSkge1xuICAgIG1hcmsuZGVsYXkgPSBwYXJzZVByb3BlcnRpZXMobW9kZWwsIG1hcmsudHlwZSwge2RlbGF5OiBtYXJrLmRlbGF5fSk7XG4gIH1cblxuICAvLyByZWN1cnNlIGlmIGdyb3VwIHR5cGVcbiAgaWYgKGdyb3VwKSB7XG4gICAgbWFyay5tYXJrcyA9IGdyb3VwLm1hcChmdW5jdGlvbihnKSB7IHJldHVybiBwYXJzZU1hcmsobW9kZWwsIGcpOyB9KTtcbiAgfVxuICAgIFxuICByZXR1cm4gbWFyaztcbn07IiwidmFyIHBhcnNlTWFyayA9IHJlcXVpcmUoJy4vbWFyaycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZGVsLCBzcGVjLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cFwiLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBzY2FsZXM6IHNwZWMuc2NhbGVzIHx8IFtdLFxuICAgIGF4ZXM6IHNwZWMuYXhlcyB8fCBbXSxcbiAgICAvLyBsZWdlbmRzOiBzcGVjLmxlZ2VuZHMgfHwgW10sXG4gICAgbWFya3M6IChzcGVjLm1hcmtzIHx8IFtdKS5tYXAoZnVuY3Rpb24obSkgeyByZXR1cm4gcGFyc2VNYXJrKG1vZGVsLCBtKTsgfSlcbiAgfTtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIE5vZGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Ob2RlJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgZmlsdGVyID0gZnVuY3Rpb24oZmllbGQsIHZhbHVlLCBzcmMsIGRlc3QpIHtcbiAgZm9yKHZhciBpID0gc3JjLmxlbmd0aC0xOyBpID49IDA7IC0taSkge1xuICAgIGlmKHNyY1tpXVtmaWVsZF0gPT0gdmFsdWUpXG4gICAgICBkZXN0LnB1c2guYXBwbHkoZGVzdCwgc3JjLnNwbGljZShpLCAxKSk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VNb2RpZnkobW9kZWwsIGRlZiwgZHMpIHtcbiAgdmFyIGdyYXBoID0gbW9kZWwuZ3JhcGgsXG4gICAgICBzaWduYWwgPSBkZWYuc2lnbmFsID8gZGwuZmllbGQoZGVmLnNpZ25hbCkgOiBudWxsLCBcbiAgICAgIHNpZ25hbE5hbWUgPSBzaWduYWwgPyBzaWduYWxbMF0gOiBudWxsLFxuICAgICAgcHJlZGljYXRlID0gZGVmLnByZWRpY2F0ZSA/IG1vZGVsLnByZWRpY2F0ZShkZWYucHJlZGljYXRlKSA6IG51bGwsXG4gICAgICByZWV2YWwgPSAocHJlZGljYXRlID09PSBudWxsKSxcbiAgICAgIG5vZGUgPSBuZXcgTm9kZShncmFwaCk7XG5cbiAgbm9kZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYocHJlZGljYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGIgPSB7fTtcbiAgICAgIChwcmVkaWNhdGUuZGF0YXx8W10pLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkYltkXSA9IG1vZGVsLmRhdGEoZCkudmFsdWVzKCk7IH0pO1xuXG4gICAgICAvLyBUT0RPOiBpbnB1dFxuICAgICAgcmVldmFsID0gcHJlZGljYXRlKHt9LCBkYiwgZ3JhcGguc2lnbmFsVmFsdWVzKHByZWRpY2F0ZS5zaWduYWxzfHxbXSksIG1vZGVsLl9wcmVkaWNhdGVzKTtcbiAgICB9XG5cbiAgICBkZWJ1ZyhpbnB1dCwgW2RlZi50eXBlK1wiaW5nXCIsIHJlZXZhbF0pO1xuICAgIGlmKCFyZWV2YWwpIHJldHVybiBpbnB1dDtcblxuICAgIHZhciBkYXR1bSA9IHt9LCBcbiAgICAgICAgdmFsdWUgPSBzaWduYWwgPyBncmFwaC5zaWduYWxSZWYoZGVmLnNpZ25hbCkgOiBudWxsLFxuICAgICAgICBkID0gbW9kZWwuZGF0YShkcy5uYW1lKSxcbiAgICAgICAgcHJldiA9IGQucmV2aXNlcygpID8gbnVsbCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdCA9IG51bGw7XG5cbiAgICBkYXR1bVtkZWYuZmllbGRdID0gdmFsdWU7XG5cbiAgICAvLyBXZSBoYXZlIHRvIG1vZGlmeSBkcy5fZGF0YSBzbyB0aGF0IHN1YnNlcXVlbnQgcHVsc2VzIGNvbnRhaW5cbiAgICAvLyBvdXIgZHluYW1pYyBkYXRhLiBXL28gbW9kaWZ5aW5nIGRzLl9kYXRhLCBvbmx5IHRoZSBvdXRwdXRcbiAgICAvLyBjb2xsZWN0b3Igd2lsbCBjb250YWluIGR5bmFtaWMgdHVwbGVzLiBcbiAgICBpZihkZWYudHlwZSA9PSBDLkFERCkge1xuICAgICAgdCA9IHR1cGxlLmluZ2VzdChkYXR1bSwgcHJldik7XG4gICAgICBpbnB1dC5hZGQucHVzaCh0KTtcbiAgICAgIGQuX2RhdGEucHVzaCh0KTtcbiAgICB9IGVsc2UgaWYoZGVmLnR5cGUgPT0gQy5SRU1PVkUpIHtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5hZGQsIGlucHV0LnJlbSk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQubW9kLCBpbnB1dC5yZW0pO1xuICAgICAgZC5fZGF0YSA9IGQuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHhbZGVmLmZpZWxkXSAhPT0gdmFsdWUgfSk7XG4gICAgfSBlbHNlIGlmKGRlZi50eXBlID09IEMuVE9HR0xFKSB7XG4gICAgICB2YXIgYWRkID0gW10sIHJlbSA9IFtdO1xuICAgICAgZmlsdGVyKGRlZi5maWVsZCwgdmFsdWUsIGlucHV0LnJlbSwgYWRkKTtcbiAgICAgIGZpbHRlcihkZWYuZmllbGQsIHZhbHVlLCBpbnB1dC5hZGQsIHJlbSk7XG4gICAgICBmaWx0ZXIoZGVmLmZpZWxkLCB2YWx1ZSwgaW5wdXQubW9kLCByZW0pO1xuICAgICAgaWYoYWRkLmxlbmd0aCA9PSAwICYmIHJlbS5sZW5ndGggPT0gMCkgYWRkLnB1c2godHVwbGUuaW5nZXN0KGRhdHVtKSk7XG5cbiAgICAgIGlucHV0LmFkZC5wdXNoLmFwcGx5KGlucHV0LmFkZCwgYWRkKTtcbiAgICAgIGQuX2RhdGEucHVzaC5hcHBseShkLl9kYXRhLCBhZGQpO1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCByZW0pO1xuICAgICAgZC5fZGF0YSA9IGQuX2RhdGEuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHJlbS5pbmRleE9mKHgpID09PSAtMSB9KTtcbiAgICB9IGVsc2UgaWYoZGVmLnR5cGUgPT0gQy5DTEVBUikge1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCBpbnB1dC5hZGQpO1xuICAgICAgaW5wdXQucmVtLnB1c2guYXBwbHkoaW5wdXQucmVtLCBpbnB1dC5tb2QpO1xuICAgICAgaW5wdXQuYWRkID0gW107XG4gICAgICBpbnB1dC5tb2QgPSBbXTtcbiAgICAgIGQuX2RhdGEgID0gW107XG4gICAgfSBcblxuICAgIGlucHV0LmZpZWxkc1tkZWYuZmllbGRdID0gMTtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH07XG5cbiAgaWYoc2lnbmFsTmFtZSkgbm9kZS5kZXBlbmRlbmN5KEMuU0lHTkFMUywgc2lnbmFsTmFtZSk7XG4gIGlmKHByZWRpY2F0ZSkgIG5vZGUuZGVwZW5kZW5jeShDLlNJR05BTFMsIHByZWRpY2F0ZS5zaWduYWxzKTtcbiAgXG4gIHJldHVybiBub2RlO1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVBhZGRpbmcocGFkKSB7XG4gIGlmIChwYWQgPT0gbnVsbCkgcmV0dXJuIFwiYXV0b1wiO1xuICBlbHNlIGlmIChkbC5pc1N0cmluZyhwYWQpKSByZXR1cm4gcGFkPT09XCJzdHJpY3RcIiA/IFwic3RyaWN0XCIgOiBcImF1dG9cIjtcbiAgZWxzZSBpZiAoZGwuaXNPYmplY3QocGFkKSkgcmV0dXJuIHBhZDtcbiAgdmFyIHAgPSBkbC5pc051bWJlcihwYWQpID8gcGFkIDogMjA7XG4gIHJldHVybiB7dG9wOnAsIGxlZnQ6cCwgcmlnaHQ6cCwgYm90dG9tOnB9O1xufSIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVByZWRpY2F0ZShtb2RlbCwgc3BlYykge1xuICB2YXIgdHlwZXMgPSB7XG4gICAgJz0nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAgICc9PSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnIT0nOiBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJz4nOiAgcGFyc2VDb21wYXJhdG9yLFxuICAgICc+PSc6IHBhcnNlQ29tcGFyYXRvcixcbiAgICAnPCc6ICBwYXJzZUNvbXBhcmF0b3IsXG4gICAgJzw9JzogcGFyc2VDb21wYXJhdG9yLFxuICAgICdhbmQnOiBwYXJzZUxvZ2ljYWwsXG4gICAgJyYmJzogIHBhcnNlTG9naWNhbCxcbiAgICAnb3InOiAgcGFyc2VMb2dpY2FsLFxuICAgICd8fCc6ICBwYXJzZUxvZ2ljYWwsXG4gICAgJ2luJzogcGFyc2VJblxuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlU2lnbmFsKHNpZ25hbCwgc2lnbmFscykge1xuICAgIHZhciBzID0gZGwuZmllbGQoc2lnbmFsKSxcbiAgICAgICAgY29kZSA9IFwic2lnbmFsc1tcIitzLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIjtcbiAgICBzaWduYWxzW3Muc2hpZnQoKV0gPSAxO1xuICAgIHJldHVybiBjb2RlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHBhcnNlT3BlcmFuZHMob3BlcmFuZHMpIHtcbiAgICB2YXIgZGVjbCA9IFtdLCBkZWZzID0gW10sXG4gICAgICAgIHNpZ25hbHMgPSB7fSwgZGIgPSB7fTtcblxuICAgIGRsLmFycmF5KG9wZXJhbmRzKS5mb3JFYWNoKGZ1bmN0aW9uKG8sIGkpIHtcbiAgICAgIHZhciBzaWduYWwsIG5hbWUgPSBcIm9cIitpLCBkZWYgPSBcIlwiO1xuICAgICAgXG4gICAgICBpZihvLnZhbHVlICE9PSB1bmRlZmluZWQpIGRlZiA9IGRsLnN0cihvLnZhbHVlKTtcbiAgICAgIGVsc2UgaWYoby5hcmcpICAgIGRlZiA9IFwiYXJnc1tcIitkbC5zdHIoby5hcmcpK1wiXVwiO1xuICAgICAgZWxzZSBpZihvLnNpZ25hbCkgZGVmID0gcGFyc2VTaWduYWwoby5zaWduYWwsIHNpZ25hbHMpO1xuICAgICAgZWxzZSBpZihvLnByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgcHJlZCA9IG1vZGVsLnByZWRpY2F0ZShvLnByZWRpY2F0ZSk7XG4gICAgICAgIHByZWQuc2lnbmFscy5mb3JFYWNoKGZ1bmN0aW9uKHMpIHsgc2lnbmFsc1tzXSA9IDE7IH0pO1xuICAgICAgICBwcmVkLmRhdGEuZm9yRWFjaChmdW5jdGlvbihkKSB7IGRiW2RdID0gMSB9KTtcblxuICAgICAgICBkbC5rZXlzKG8uaW5wdXQpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICAgIHZhciBpID0gby5pbnB1dFtrXSwgc2lnbmFsO1xuICAgICAgICAgIGRlZiArPSBcImFyZ3NbXCIrZGwuc3RyKGspK1wiXSA9IFwiO1xuICAgICAgICAgIGlmKGkuc2lnbmFsKSAgIGRlZiArPSBwYXJzZVNpZ25hbChpLnNpZ25hbCwgc2lnbmFscyk7XG4gICAgICAgICAgZWxzZSBpZihpLmFyZykgZGVmICs9IFwiYXJnc1tcIitkbC5zdHIoaS5hcmcpK1wiXVwiO1xuICAgICAgICAgIGRlZis9XCIsIFwiO1xuICAgICAgICB9KTtcblxuICAgICAgICBkZWYrPSBcInByZWRpY2F0ZXNbXCIrZGwuc3RyKG8ucHJlZGljYXRlKStcIl0oYXJncywgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpXCI7XG4gICAgICB9XG5cbiAgICAgIGRlY2wucHVzaChuYW1lKTtcbiAgICAgIGRlZnMucHVzaChuYW1lK1wiPShcIitkZWYrXCIpXCIpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGU6IFwidmFyIFwiICsgZGVjbC5qb2luKFwiLCBcIikgKyBcIjtcXG5cIiArIGRlZnMuam9pbihcIjtcXG5cIikgKyBcIjtcXG5cIixcbiAgICAgIHNpZ25hbHM6IGRsLmtleXMoc2lnbmFscyksXG4gICAgICBkYXRhOiBkbC5rZXlzKGRiKVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUNvbXBhcmF0b3Ioc3BlYykge1xuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKHNwZWMub3BlcmFuZHMpO1xuICAgIGlmKHNwZWMudHlwZSA9PSAnPScpIHNwZWMudHlwZSA9ICc9PSc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIFtcIm8wXCIsIFwibzFcIl0uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICAgIGRhdGE6IG9wcy5kYXRhXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUxvZ2ljYWwoc3BlYykge1xuICAgIHZhciBvcHMgPSBwYXJzZU9wZXJhbmRzKHNwZWMub3BlcmFuZHMpLFxuICAgICAgICBvID0gW10sIGkgPSAwLCBsZW4gPSBzcGVjLm9wZXJhbmRzLmxlbmd0aDtcblxuICAgIHdoaWxlKG8ucHVzaChcIm9cIitpKyspPGxlbik7XG4gICAgaWYoc3BlYy50eXBlID09ICdhbmQnKSBzcGVjLnR5cGUgPSAnJiYnO1xuICAgIGVsc2UgaWYoc3BlYy50eXBlID09ICdvcicpIHNwZWMudHlwZSA9ICd8fCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogb3BzLmNvZGUgKyBcInJldHVybiBcIiArIG8uam9pbihzcGVjLnR5cGUpICsgXCI7XCIsXG4gICAgICBzaWduYWxzOiBvcHMuc2lnbmFscyxcbiAgICAgIGRhdGE6IG9wcy5kYXRhXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUluKHNwZWMpIHtcbiAgICB2YXIgbyA9IFtzcGVjLml0ZW1dO1xuICAgIGlmKHNwZWMucmFuZ2UpIG8ucHVzaC5hcHBseShvLCBzcGVjLnJhbmdlKTtcbiAgICBpZihzcGVjLnNjYWxlKSBvLnB1c2goc3BlYy5zY2FsZSk7XG5cbiAgICB2YXIgb3BzID0gcGFyc2VPcGVyYW5kcyhvKSxcbiAgICAgICAgY29kZSA9IG9wcy5jb2RlO1xuXG4gICAgaWYoc3BlYy5kYXRhKSB7XG4gICAgICB2YXIgZmllbGQgPSBkbC5maWVsZChzcGVjLmZpZWxkKS5tYXAoZGwuc3RyKTtcbiAgICAgIGNvZGUgKz0gXCJ2YXIgd2hlcmUgPSBmdW5jdGlvbihkKSB7IHJldHVybiBkW1wiK2ZpZWxkLmpvaW4oXCJdW1wiKStcIl0gPT0gbzAgfTtcXG5cIjtcbiAgICAgIGNvZGUgKz0gXCJyZXR1cm4gZGJbXCIrZGwuc3RyKHNwZWMuZGF0YSkrXCJdLmZpbHRlcih3aGVyZSkubGVuZ3RoID4gMDtcIjtcbiAgICB9IGVsc2UgaWYoc3BlYy5yYW5nZSkge1xuICAgICAgLy8gVE9ETzogaW5jbHVzaXZlL2V4Y2x1c2l2ZSByYW5nZT9cbiAgICAgIC8vIFRPRE86IGludmVydGluZyBvcmRpbmFsIHNjYWxlc1xuICAgICAgaWYoc3BlYy5zY2FsZSkgY29kZSArPSBcIm8xID0gbzMobzEpO1xcbm8yID0gbzMobzIpO1xcblwiO1xuICAgICAgY29kZSArPSBcInJldHVybiBvMSA8IG8yID8gbzEgPD0gbzAgJiYgbzAgPD0gbzIgOiBvMiA8PSBvMCAmJiBvMCA8PSBvMVwiO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiBjb2RlLCBcbiAgICAgIHNpZ25hbHM6IG9wcy5zaWduYWxzLCBcbiAgICAgIGRhdGE6IG9wcy5kYXRhLmNvbmNhdChzcGVjLmRhdGEgPyBbc3BlYy5kYXRhXSA6IFtdKVxuICAgIH07XG4gIH07XG5cbiAgKHNwZWMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIHZhciBwYXJzZSA9IHR5cGVzW3MudHlwZV0ocyk7XG4gICAgdmFyIHByZWQgPSBGdW5jdGlvbihcImFyZ3NcIiwgXCJkYlwiLCBcInNpZ25hbHNcIiwgXCJwcmVkaWNhdGVzXCIsIHBhcnNlLmNvZGUpO1xuICAgIHByZWQuc2lnbmFscyA9IHBhcnNlLnNpZ25hbHM7XG4gICAgcHJlZC5kYXRhID0gcGFyc2UuZGF0YTtcbiAgICBtb2RlbC5wcmVkaWNhdGUocy5uYW1lLCBwcmVkKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyk7XG5cbmZ1bmN0aW9uIGNvbXBpbGUobW9kZWwsIG1hcmssIHNwZWMpIHtcbiAgdmFyIGNvZGUgPSBcIlwiLFxuICAgICAgbmFtZXMgPSBkbC5rZXlzKHNwZWMpLFxuICAgICAgaSwgbGVuLCBuYW1lLCByZWYsIHZhcnMgPSB7fSwgXG4gICAgICBkZXBzID0ge1xuICAgICAgICBzaWduYWxzOiB7fSxcbiAgICAgICAgc2NhbGVzOiB7fSxcbiAgICAgICAgZGF0YToge31cbiAgICAgIH07XG4gICAgICBcbiAgY29kZSArPSBcInZhciBvID0gdHJhbnMgPyB7fSA6IGl0ZW07XFxuXCJcbiAgXG4gIGZvciAoaT0wLCBsZW49bmFtZXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgcmVmID0gc3BlY1tuYW1lID0gbmFtZXNbaV1dO1xuICAgIGNvZGUgKz0gKGkgPiAwKSA/IFwiXFxuICBcIiA6IFwiICBcIjtcbiAgICBpZihyZWYucnVsZSkge1xuICAgICAgcmVmID0gcnVsZShtb2RlbCwgbmFtZSwgcmVmLnJ1bGUpO1xuICAgICAgY29kZSArPSBcIlxcbiAgXCIgKyByZWYuY29kZVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYgPSB2YWx1ZVJlZihuYW1lLCByZWYpO1xuICAgICAgY29kZSArPSBcInRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1wiO1xuICAgIH1cblxuICAgIHZhcnNbbmFtZV0gPSB0cnVlO1xuICAgIFsnc2lnbmFscycsICdzY2FsZXMnLCAnZGF0YSddLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgaWYocmVmW3BdICE9IG51bGwpIGRsLmFycmF5KHJlZltwXSkuZm9yRWFjaChmdW5jdGlvbihrKSB7IGRlcHNbcF1ba10gPSAxIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHZhcnMueDIpIHtcbiAgICBpZiAodmFycy54KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby54ID4gby54MikgeyBcIlxuICAgICAgICAgICAgKyBcInZhciB0ID0gby54O1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd4Jywgby54Mik7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3gyJywgdCk7IFwiXG4gICAgICAgICAgICArIFwifTtcIjtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAnd2lkdGgnLCAoby54MiAtIG8ueCkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy53aWR0aCkge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd4JywgKG8ueDIgLSBvLndpZHRoKSk7XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneCcsIG8ueDIpO1wiXG4gICAgfVxuICB9XG5cbiAgaWYgKHZhcnMueTIpIHtcbiAgICBpZiAodmFycy55KSB7XG4gICAgICBjb2RlICs9IFwiXFxuICBpZiAoby55ID4gby55MikgeyBcIlxuICAgICAgICAgICAgKyBcInZhciB0ID0gby55O1wiXG4gICAgICAgICAgICArIFwidGhpcy50cGwuc2V0KG8sICd5Jywgby55Mik7XCJcbiAgICAgICAgICAgICsgXCJ0aGlzLnRwbC5zZXQobywgJ3kyJywgdCk7XCJcbiAgICAgICAgICAgICsgXCJ9O1wiO1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICdoZWlnaHQnLCAoby55MiAtIG8ueSkpO1wiO1xuICAgIH0gZWxzZSBpZiAodmFycy5oZWlnaHQpIHtcbiAgICAgIGNvZGUgKz0gXCJcXG4gIHRoaXMudHBsLnNldChvLCAneScsIChvLnkyIC0gby5oZWlnaHQpKTtcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIlxcbiAgdGhpcy50cGwuc2V0KG8sICd5Jywgby55Mik7XCJcbiAgICB9XG4gIH1cbiAgXG4gIGlmIChoYXNQYXRoKG1hcmssIHZhcnMpKSBjb2RlICs9IFwiXFxuICBpdGVtLnRvdWNoKCk7XCI7XG4gIGNvZGUgKz0gXCJcXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XCI7XG5cbiAgdHJ5IHtcbiAgICB2YXIgZW5jb2RlciA9IEZ1bmN0aW9uKFwiaXRlbVwiLCBcImdyb3VwXCIsIFwidHJhbnNcIiwgXCJkYlwiLCBcbiAgICAgIFwic2lnbmFsc1wiLCBcInByZWRpY2F0ZXNcIiwgY29kZSk7XG4gICAgZW5jb2Rlci50cGwgID0gdHVwbGU7XG4gICAgZW5jb2Rlci51dGlsID0gZGw7XG4gICAgZW5jb2Rlci5kMyAgID0gZDM7IC8vIEZvciBjb2xvciBzcGFjZXNcbiAgICByZXR1cm4ge1xuICAgICAgZW5jb2RlOiBlbmNvZGVyLFxuICAgICAgc2lnbmFsczogZGwua2V5cyhkZXBzLnNpZ25hbHMpLFxuICAgICAgc2NhbGVzOiBkbC5rZXlzKGRlcHMuc2NhbGVzKSxcbiAgICAgIGRhdGE6IGRsLmtleXMoZGVwcy5kYXRhKVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRsLmVycm9yKGUpO1xuICAgIGRsLmxvZyhjb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXRoKG1hcmssIHZhcnMpIHtcbiAgcmV0dXJuIHZhcnMucGF0aCB8fFxuICAgICgobWFyaz09PVwiYXJlYVwiIHx8IG1hcms9PT1cImxpbmVcIikgJiZcbiAgICAgICh2YXJzLnggfHwgdmFycy54MiB8fCB2YXJzLndpZHRoIHx8XG4gICAgICAgdmFycy55IHx8IHZhcnMueTIgfHwgdmFycy5oZWlnaHQgfHxcbiAgICAgICB2YXJzLnRlbnNpb24gfHwgdmFycy5pbnRlcnBvbGF0ZSkpO1xufVxuXG52YXIgR1JPVVBfVkFSUyA9IHtcbiAgXCJ3aWR0aFwiOiAxLFxuICBcImhlaWdodFwiOiAxLFxuICBcIm1hcmsuZ3JvdXAud2lkdGhcIjogMSxcbiAgXCJtYXJrLmdyb3VwLmhlaWdodFwiOiAxXG59O1xuXG5mdW5jdGlvbiBydWxlKG1vZGVsLCBuYW1lLCBydWxlcykge1xuICB2YXIgc2lnbmFscyA9IFtdLCBzY2FsZXMgPSBbXSwgZGIgPSBbXSxcbiAgICAgIGlucHV0cyA9IFtdLCBjb2RlID0gXCJcIjtcblxuICAocnVsZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHIsIGkpIHtcbiAgICB2YXIgcHJlZE5hbWUgPSByLnByZWRpY2F0ZSxcbiAgICAgICAgcHJlZCA9IG1vZGVsLnByZWRpY2F0ZShwcmVkTmFtZSksXG4gICAgICAgIGlucHV0ID0gW10sIGFyZ3MgPSBuYW1lK1wiX2FyZ1wiK2ksXG4gICAgICAgIHJlZjtcblxuICAgIGRsLmtleXMoci5pbnB1dCkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgcmVmID0gdmFsdWVSZWYoaSwgci5pbnB1dFtrXSk7XG4gICAgICBpbnB1dC5wdXNoKGRsLnN0cihrKStcIjogXCIrcmVmLnZhbCk7XG4gICAgICBpZihyZWYuc2lnbmFscykgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIGRsLmFycmF5KHJlZi5zaWduYWxzKSk7XG4gICAgICBpZihyZWYuc2NhbGVzKSAgc2NhbGVzLnB1c2guYXBwbHkoc2NhbGVzLCBkbC5hcnJheShyZWYuc2NhbGVzKSk7XG4gICAgfSk7XG5cbiAgICByZWYgPSB2YWx1ZVJlZihuYW1lLCByKTtcbiAgICBpZihyZWYuc2lnbmFscykgc2lnbmFscy5wdXNoLmFwcGx5KHNpZ25hbHMsIGRsLmFycmF5KHJlZi5zaWduYWxzKSk7XG4gICAgaWYocmVmLnNjYWxlcykgIHNjYWxlcy5wdXNoLmFwcGx5KHNjYWxlcywgZGwuYXJyYXkocmVmLnNjYWxlcykpO1xuXG4gICAgaWYocHJlZE5hbWUpIHtcbiAgICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBwcmVkLnNpZ25hbHMpO1xuICAgICAgZGIucHVzaC5hcHBseShkYiwgcHJlZC5kYXRhKTtcbiAgICAgIGlucHV0cy5wdXNoKGFyZ3MrXCIgPSB7XCIraW5wdXQuam9pbignLCAnKStcIn1cIik7XG4gICAgICBjb2RlICs9IFwiaWYocHJlZGljYXRlc1tcIitkbC5zdHIocHJlZE5hbWUpK1wiXShcIithcmdzK1wiLCBkYiwgc2lnbmFscywgcHJlZGljYXRlcykpIHtcXG5cIiArXG4gICAgICAgIFwiICAgIHRoaXMudHBsLnNldChvLCBcIitkbC5zdHIobmFtZSkrXCIsIFwiK3JlZi52YWwrXCIpO1xcblwiO1xuICAgICAgY29kZSArPSBydWxlc1tpKzFdID8gXCIgIH0gZWxzZSBcIiA6IFwiICB9XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJ7XFxuXCIgKyBcbiAgICAgICAgXCIgICAgdGhpcy50cGwuc2V0KG8sIFwiK2RsLnN0cihuYW1lKStcIiwgXCIrcmVmLnZhbCtcIik7XFxuXCIrXG4gICAgICAgIFwiICB9XCI7XG4gICAgfVxuICB9KTtcblxuICBjb2RlID0gXCJ2YXIgXCIgKyBpbnB1dHMuam9pbihcIixcXG4gICAgICBcIikgKyBcIjtcXG4gIFwiICsgY29kZTtcbiAgcmV0dXJuIHtjb2RlOiBjb2RlLCBzaWduYWxzOiBzaWduYWxzLCBzY2FsZXM6IHNjYWxlcywgZGF0YTogZGJ9O1xufVxuXG5mdW5jdGlvbiB2YWx1ZVJlZihuYW1lLCByZWYpIHtcbiAgaWYgKHJlZiA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgdmFyIGlzQ29sb3IgPSBuYW1lPT09XCJmaWxsXCIgfHwgbmFtZT09PVwic3Ryb2tlXCI7XG4gIHZhciBzaWduYWxzID0gW107XG5cbiAgaWYgKGlzQ29sb3IpIHtcbiAgICBpZiAocmVmLmMpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcImhjbFwiLCByZWYuaCwgcmVmLmMsIHJlZi5sKTtcbiAgICB9IGVsc2UgaWYgKHJlZi5oIHx8IHJlZi5zKSB7XG4gICAgICByZXR1cm4gY29sb3JSZWYoXCJoc2xcIiwgcmVmLmgsIHJlZi5zLCByZWYubCk7XG4gICAgfSBlbHNlIGlmIChyZWYubCB8fCByZWYuYSkge1xuICAgICAgcmV0dXJuIGNvbG9yUmVmKFwibGFiXCIsIHJlZi5sLCByZWYuYSwgcmVmLmIpO1xuICAgIH0gZWxzZSBpZiAocmVmLnIgfHwgcmVmLmcgfHwgcmVmLmIpIHtcbiAgICAgIHJldHVybiBjb2xvclJlZihcInJnYlwiLCByZWYuciwgcmVmLmcsIHJlZi5iKTtcbiAgICB9XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHZhbHVlXG4gIHZhciB2YWwgPSBudWxsLCBzaWduYWxSZWYgPSBudWxsO1xuICBpZiAocmVmLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YWwgPSBkbC5zdHIocmVmLnZhbHVlKTtcbiAgfVxuXG4gIGlmIChyZWYuc2lnbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBzaWduYWxSZWYgPSBkbC5maWVsZChyZWYuc2lnbmFsKTtcbiAgICB2YWwgPSBcInNpZ25hbHNbXCIrc2lnbmFsUmVmLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIjsgXG4gICAgc2lnbmFscy5wdXNoKHNpZ25hbFJlZi5zaGlmdCgpKTtcbiAgfVxuXG4gIC8vIGdldCBmaWVsZCByZWZlcmVuY2UgZm9yIGVuY2xvc2luZyBncm91cFxuICBpZiAocmVmLmdyb3VwICE9IG51bGwpIHtcbiAgICB2YXIgZ3JwID0gXCJncm91cC5kYXR1bVwiO1xuICAgIGlmIChkbC5pc1N0cmluZyhyZWYuZ3JvdXApKSB7XG4gICAgICBncnAgPSBHUk9VUF9WQVJTW3JlZi5ncm91cF1cbiAgICAgICAgPyBcImdyb3VwLlwiICsgcmVmLmdyb3VwXG4gICAgICAgIDogXCJncm91cC5kYXR1bVtcIitkbC5maWVsZChyZWYuZ3JvdXApLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1cIjtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgZGF0YSBmaWVsZCB2YWx1ZVxuICBpZiAocmVmLmZpZWxkICE9IG51bGwpIHtcbiAgICBpZiAoZGwuaXNTdHJpbmcocmVmLmZpZWxkKSkge1xuICAgICAgdmFsID0gXCJpdGVtLmRhdHVtW1wiK2RsLmZpZWxkKHJlZi5maWVsZCkubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiO1xuICAgICAgaWYgKHJlZi5ncm91cCAhPSBudWxsKSB7IHZhbCA9IFwidGhpcy51dGlsLmFjY2Vzc29yKFwiK3ZhbCtcIikoXCIrZ3JwK1wiKVwiOyB9XG4gICAgfSBlbHNlIGlmKHJlZi5maWVsZC5zaWduYWwpIHtcbiAgICAgIHNpZ25hbFJlZiA9IGRsLmZpZWxkKHJlZi5maWVsZC5zaWduYWwpO1xuICAgICAgdmFsID0gXCJpdGVtLmRhdHVtW3NpZ25hbHNbXCIrc2lnbmFsUmVmLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKStcIl1dXCI7XG4gICAgICBpZiAocmVmLmdyb3VwICE9IG51bGwpIHsgdmFsID0gXCJ0aGlzLnV0aWwuYWNjZXNzb3IoXCIrdmFsK1wiKShcIitncnArXCIpXCI7IH1cbiAgICAgIHNpZ25hbHMucHVzaChzaWduYWxSZWYuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IFwidGhpcy51dGlsLmFjY2Vzc29yKGdyb3VwLmRhdHVtW1wiXG4gICAgICAgICAgKyBkbC5maWVsZChyZWYuZmllbGQuZ3JvdXApLm1hcChkbC5zdHIpLmpvaW4oXCJdW1wiKVxuICAgICAgICAgICsgXCJdKShpdGVtLmRhdHVtKVwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyZWYuZ3JvdXAgIT0gbnVsbCkge1xuICAgIHZhbCA9IGdycDtcbiAgfVxuXG4gIGlmIChyZWYuc2NhbGUgIT0gbnVsbCkge1xuICAgIHZhciBzY2FsZSA9IG51bGw7XG4gICAgaWYoZGwuaXNTdHJpbmcocmVmLnNjYWxlKSkge1xuICAgICAgc2NhbGUgPSBkbC5zdHIocmVmLnNjYWxlKTtcbiAgICB9IGVsc2UgaWYocmVmLnNjYWxlLnNpZ25hbCkge1xuICAgICAgc2lnbmFsUmVmID0gZGwuZmllbGQocmVmLnNjYWxlLnNpZ25hbCk7XG4gICAgICBzY2FsZSA9IFwic2lnbmFsc1tcIitzaWduYWxSZWYubWFwKGRsLnN0cikuam9pbihcIl1bXCIpK1wiXVwiO1xuICAgICAgc2lnbmFscy5wdXNoKHNpZ25hbFJlZi5zaGlmdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSAocmVmLnNjYWxlLmdyb3VwID8gXCJncm91cFwiIDogXCJpdGVtXCIpXG4gICAgICAgICsgXCIuZGF0dW1bXCIgKyBkbC5zdHIocmVmLnNjYWxlLmdyb3VwIHx8IHJlZi5zY2FsZS5maWVsZCkgKyBcIl1cIjtcbiAgICB9XG5cbiAgICBzY2FsZSA9IFwiZ3JvdXAuc2NhbGUoXCIgKyBzY2FsZSArIFwiKVwiO1xuICAgIGlmKHJlZi5pbnZlcnQpIHNjYWxlICs9IFwiLmludmVydFwiOyAgLy8gVE9ETzogb3JkaW5hbCBzY2FsZXNcblxuICAgIC8vIHJ1biB0aHJvdWdoIHNjYWxlIGZ1bmN0aW9uIGlmIHZhbCBzcGVjaWZpZWQuXG4gICAgLy8gaWYgbm8gdmFsLCBzY2FsZSBmdW5jdGlvbiBpcyBwcmVkaWNhdGUgYXJnLlxuICAgIGlmKHZhbCAhPT0gbnVsbCB8fCByZWYuYmFuZCB8fCByZWYubXVsdCB8fCByZWYub2Zmc2V0KSB7XG4gICAgICB2YWwgPSBzY2FsZSArIChyZWYuYmFuZCA/IFwiLnJhbmdlQmFuZCgpXCIgOiBcbiAgICAgICAgXCIoXCIrKHZhbCAhPT0gbnVsbCA/IHZhbCA6IFwiaXRlbS5kYXR1bS5kYXRhXCIpK1wiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gc2NhbGU7XG4gICAgfVxuICB9XG4gIFxuICAvLyBtdWx0aXBseSwgb2Zmc2V0LCByZXR1cm4gdmFsdWVcbiAgdmFsID0gXCIoXCIgKyAocmVmLm11bHQ/KGRsLm51bWJlcihyZWYubXVsdCkrXCIgKiBcIik6XCJcIikgKyB2YWwgKyBcIilcIlxuICAgICsgKHJlZi5vZmZzZXQgPyBcIiArIFwiICsgZGwubnVtYmVyKHJlZi5vZmZzZXQpIDogXCJcIik7XG4gIHJldHVybiB7dmFsOiB2YWwsIHNpZ25hbHM6IHNpZ25hbHMsIHNjYWxlczogcmVmLnNjYWxlfTtcbn1cblxuZnVuY3Rpb24gY29sb3JSZWYodHlwZSwgeCwgeSwgeikge1xuICB2YXIgeHggPSB4ID8gdmFsdWVSZWYoXCJcIiwgeCkgOiBjb25maWcuY29sb3JbdHlwZV1bMF0sXG4gICAgICB5eSA9IHkgPyB2YWx1ZVJlZihcIlwiLCB5KSA6IGNvbmZpZy5jb2xvclt0eXBlXVsxXSxcbiAgICAgIHp6ID0geiA/IHZhbHVlUmVmKFwiXCIsIHopIDogY29uZmlnLmNvbG9yW3R5cGVdWzJdXG4gICAgICBzaWduYWxzID0gW10sIHNjYWxlcyA9IFtdO1xuXG4gIFt4eCwgeXksIHp6XS5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICBpZih2LnNpZ25hbHMpIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCB2LnNpZ25hbHMpO1xuICAgIGlmKHYuc2NhbGVzKSAgc2NhbGVzLnB1c2godi5zY2FsZXMpO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHZhbDogXCIodGhpcy5kMy5cIiArIHR5cGUgKyBcIihcIiArIFt4eC52YWwsIHl5LnZhbCwgenoudmFsXS5qb2luKFwiLFwiKSArICcpICsgXCJcIiknLFxuICAgIHNpZ25hbHM6IHNpZ25hbHMsXG4gICAgc2NhbGVzOiBzY2FsZXNcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlOyIsInZhciBleHByID0gcmVxdWlyZSgnLi9leHByJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VTaWduYWxzKG1vZGVsLCBzcGVjKSB7XG4gIHZhciBncmFwaCA9IG1vZGVsLmdyYXBoO1xuXG4gIC8vIHByb2Nlc3MgZWFjaCBzaWduYWwgZGVmaW5pdGlvblxuICAoc3BlYyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgdmFyIHNpZ25hbCA9IGdyYXBoLnNpZ25hbChzLm5hbWUsIHMuaW5pdCksXG4gICAgICAgIGV4cDtcblxuICAgIGlmKHMuZXhwcikge1xuICAgICAgZXhwID0gZXhwcihzLmV4cHIpO1xuICAgICAgc2lnbmFsLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXhwci5ldmFsKGdyYXBoLCBleHAuZm4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGV4cC5zaWduYWxzKTtcbiAgICAgICAgaWYoc3BlYy5zY2FsZSkgdmFsdWUgPSBtb2RlbC5zY2FsZShzcGVjLCB2YWx1ZSk7XG4gICAgICAgIHNpZ25hbC52YWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlucHV0LnNpZ25hbHNbcy5uYW1lXSA9IDE7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgIH07XG4gICAgICBzaWduYWwuZGVwZW5kZW5jeShDLlNJR05BTFMsIGV4cC5zaWduYWxzKTtcbiAgICAgIGV4cC5zaWduYWxzLmZvckVhY2goZnVuY3Rpb24oZGVwKSB7IGdyYXBoLnNpZ25hbChkZXApLmFkZExpc3RlbmVyKHNpZ25hbCk7IH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBNb2RlbCA9IHJlcXVpcmUoJy4uL2NvcmUvTW9kZWwnKSwgXG4gICAgVmlldyA9IHJlcXVpcmUoJy4uL2NvcmUvVmlldycpLCBcbiAgICBwYXJzZVBhZGRpbmcgPSByZXF1aXJlKCcuLi9wYXJzZS9wYWRkaW5nJyksXG4gICAgcGFyc2VNYXJrcyA9IHJlcXVpcmUoJy4uL3BhcnNlL21hcmtzJyksXG4gICAgcGFyc2VTaWduYWxzID0gcmVxdWlyZSgnLi4vcGFyc2Uvc2lnbmFscycpLFxuICAgIHBhcnNlUHJlZGljYXRlcyA9IHJlcXVpcmUoJy4uL3BhcnNlL3ByZWRpY2F0ZXMnKSxcbiAgICBwYXJzZURhdGEgPSByZXF1aXJlKCcuLi9wYXJzZS9kYXRhJyksXG4gICAgcGFyc2VJbnRlcmFjdG9ycyA9IHJlcXVpcmUoJy4uL3BhcnNlL2ludGVyYWN0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VTcGVjKHNwZWMsIGNhbGxiYWNrLCB2aWV3RmFjdG9yeSkge1xuICAvLyBwcm90ZWN0IGFnYWluc3Qgc3Vic2VxdWVudCBzcGVjIG1vZGlmaWNhdGlvblxuICBzcGVjID0gZGwuZHVwbGljYXRlKHNwZWMpO1xuXG4gIHZpZXdGYWN0b3J5ID0gdmlld0ZhY3RvcnkgfHwgVmlldy5mYWN0b3J5O1xuXG4gIHZhciB3aWR0aCA9IHNwZWMud2lkdGggfHwgNTAwLFxuICAgICAgaGVpZ2h0ID0gc3BlYy5oZWlnaHQgfHwgNTAwLFxuICAgICAgdmlld3BvcnQgPSBzcGVjLnZpZXdwb3J0IHx8IG51bGwsXG4gICAgICBtb2RlbCA9IG5ldyBNb2RlbCgpO1xuXG4gIHBhcnNlSW50ZXJhY3RvcnMobW9kZWwsIHNwZWMsIGZ1bmN0aW9uKCkge1xuICAgIG1vZGVsLmRlZnMoe1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBwYWRkaW5nOiBwYXJzZVBhZGRpbmcoc3BlYy5wYWRkaW5nKSxcbiAgICAgIHNpZ25hbHM6IHBhcnNlU2lnbmFscyhtb2RlbCwgc3BlYy5zaWduYWxzKSxcbiAgICAgIHByZWRpY2F0ZXM6IHBhcnNlUHJlZGljYXRlcyhtb2RlbCwgc3BlYy5wcmVkaWNhdGVzKSxcbiAgICAgIG1hcmtzOiBwYXJzZU1hcmtzKG1vZGVsLCBzcGVjLCB3aWR0aCwgaGVpZ2h0KSxcbiAgICAgIGRhdGE6IHBhcnNlRGF0YShtb2RlbCwgc3BlYy5kYXRhLCBmdW5jdGlvbigpIHsgY2FsbGJhY2sodmlld0ZhY3RvcnkobW9kZWwpKTsgfSlcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIGNoYW5nc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgc2VsZWN0b3IgPSByZXF1aXJlKCcuL2V2ZW50cycpLFxuICAgIGV4cHIgPSByZXF1aXJlKCcuL2V4cHInKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIFNUQVJUID0gXCJzdGFydFwiLCBNSURETEUgPSBcIm1pZGRsZVwiLCBFTkQgPSBcImVuZFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZpZXcpIHtcbiAgdmFyIG1vZGVsID0gdmlldy5tb2RlbCgpLFxuICAgICAgZ3JhcGggPSBtb2RlbC5ncmFwaCxcbiAgICAgIHNwZWMgID0gbW9kZWwuZGVmcygpLnNpZ25hbHMsXG4gICAgICByZWdpc3RlciA9IHt9LCBub2RlcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKGRlZiwgdmFsdWUsIGl0ZW0pIHtcbiAgICBpZighaXRlbSB8fCAhaXRlbS5zY2FsZSkge1xuICAgICAgaXRlbSA9IChpdGVtICYmIGl0ZW0ubWFyaykgPyBpdGVtLm1hcmsuZ3JvdXAgOiBtb2RlbC5zY2VuZSgpLml0ZW1zWzBdO1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IGl0ZW0uc2NhbGUoZGVmLnNjYWxlLnNpZ25hbCB8fCBkZWYuc2NhbGUpO1xuICAgIGlmKCFzY2FsZSkgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiBkZWYuaW52ZXJ0ID8gc2NhbGUuaW52ZXJ0KHZhbHVlKSA6IHNjYWxlKHZhbHVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpZ25hbChzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICB2YXIgbiA9IG5ldyBOb2RlKGdyYXBoKSxcbiAgICAgICAgaXRlbSA9IHNwZWMuaXRlbSA/IGdyYXBoLnNpZ25hbChzcGVjLml0ZW0uc2lnbmFsKSA6IG51bGw7XG4gICAgbi5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICBpZighaW5wdXQuc2lnbmFsc1tzZWxlY3Rvci5zaWduYWxdKSByZXR1cm4gZ3JhcGguZG9Ob3RQcm9wYWdhdGU7XG4gICAgICB2YXIgdmFsID0gZXhwci5ldmFsKGdyYXBoLCBleHAuZm4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIGV4cC5zaWduYWxzKTtcbiAgICAgIGlmKHNwZWMuc2NhbGUpIHZhbCA9IHNjYWxlKHNwZWMsIHZhbCwgaXRlbSA/IGl0ZW0udmFsdWUoKSA6IG51bGwpO1xuICAgICAgc2lnLnZhbHVlKHZhbCk7XG4gICAgICBpbnB1dC5zaWduYWxzW3NpZy5uYW1lKCldID0gMTtcbiAgICAgIGlucHV0LnJlZmxvdyA9IHRydWU7XG4gICAgICByZXR1cm4gaW5wdXQ7ICBcbiAgICB9O1xuICAgIG4uZGVwZW5kZW5jeShDLlNJR05BTFMsIHNlbGVjdG9yLnNpZ25hbCk7XG4gICAgbi5hZGRMaXN0ZW5lcihzaWcpO1xuICAgIGdyYXBoLnNpZ25hbChzZWxlY3Rvci5zaWduYWwpLmFkZExpc3RlbmVyKG4pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGV2ZW50KHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBmaWx0ZXJzID0gc2VsZWN0b3IuZmlsdGVycyB8fCBbXSxcbiAgICAgICAgdGFyZ2V0ID0gc2VsZWN0b3IudGFyZ2V0O1xuXG4gICAgaWYodGFyZ2V0KSBmaWx0ZXJzLnB1c2goXCJpLlwiK3RhcmdldC50eXBlK1wiPT1cIitkbC5zdHIodGFyZ2V0LnZhbHVlKSk7XG5cbiAgICByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0gPSByZWdpc3RlcltzZWxlY3Rvci5ldmVudF0gfHwgW107XG4gICAgcmVnaXN0ZXJbc2VsZWN0b3IuZXZlbnRdLnB1c2goe1xuICAgICAgc2lnbmFsOiBzaWcsXG4gICAgICBleHA6IGV4cCxcbiAgICAgIGZpbHRlcnM6IGZpbHRlcnMubWFwKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGV4cHIoZik7IH0pLFxuICAgICAgc3BlYzogc3BlY1xuICAgIH0pO1xuXG4gICAgbm9kZXNbc2VsZWN0b3IuZXZlbnRdID0gbm9kZXNbc2VsZWN0b3IuZXZlbnRdIHx8IG5ldyBOb2RlKGdyYXBoKTtcbiAgICBub2Rlc1tzZWxlY3Rvci5ldmVudF0uYWRkTGlzdGVuZXIoc2lnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBvcmRlcmVkU3RyZWFtKHNpZywgc2VsZWN0b3IsIGV4cCwgc3BlYykge1xuICAgIHZhciBuYW1lID0gc2lnLm5hbWUoKSwgXG4gICAgICAgIHRydWVGbiA9IGV4cHIoXCJ0cnVlXCIpLFxuICAgICAgICBzID0ge307XG5cbiAgICBzW1NUQVJUXSAgPSBncmFwaC5zaWduYWwobmFtZSArIFNUQVJULCAgZmFsc2UpO1xuICAgIHNbTUlERExFXSA9IGdyYXBoLnNpZ25hbChuYW1lICsgTUlERExFLCBmYWxzZSk7XG4gICAgc1tFTkRdICAgID0gZ3JhcGguc2lnbmFsKG5hbWUgKyBFTkQsICAgIGZhbHNlKTtcblxuICAgIHZhciByb3V0ZXIgPSBuZXcgTm9kZShncmFwaCk7XG4gICAgcm91dGVyLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIGlmKHNbU1RBUlRdLnZhbHVlKCkgPT09IHRydWUgJiYgc1tFTkRdLnZhbHVlKCkgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFRPRE86IEV4cGFuZCBzZWxlY3RvciBzeW50YXggdG8gYWxsb3cgc3RhcnQvZW5kIHNpZ25hbHMgaW50byBzdHJlYW0uXG4gICAgICAgIC8vIFVudGlsIHRoZW4sIHByZXZlbnQgb2xkIG1pZGRsZXMgZW50ZXJpbmcgc3RyZWFtIG9uIG5ldyBzdGFydC5cbiAgICAgICAgaWYoaW5wdXQuc2lnbmFsc1tuYW1lK1NUQVJUXSkgcmV0dXJuIGdyYXBoLmRvTm90UHJvcGFnYXRlO1xuXG4gICAgICAgIHNpZy52YWx1ZShzW01JRERMRV0udmFsdWUoKSk7XG4gICAgICAgIGlucHV0LnNpZ25hbHNbbmFtZV0gPSAxO1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmKHNbRU5EXS52YWx1ZSgpID09PSB0cnVlKSB7XG4gICAgICAgIHNbU1RBUlRdLnZhbHVlKGZhbHNlKTtcbiAgICAgICAgc1tFTkRdLnZhbHVlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyYXBoLmRvTm90UHJvcGFnYXRlO1xuICAgIH07XG4gICAgcm91dGVyLmFkZExpc3RlbmVyKHNpZyk7XG5cbiAgICBbU1RBUlQsIE1JRERMRSwgRU5EXS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciB2YWwgPSAoeCA9PSBNSURETEUpID8gZXhwIDogdHJ1ZUZuLFxuICAgICAgICAgIHNwID0gKHggPT0gTUlERExFKSA/IHNwZWMgOiB7fTtcblxuICAgICAgaWYoc2VsZWN0b3JbeF0uZXZlbnQpIGV2ZW50KHNbeF0sIHNlbGVjdG9yW3hdLCB2YWwsIHNwKTtcbiAgICAgIGVsc2UgaWYoc2VsZWN0b3JbeF0uc2lnbmFsKSBzaWduYWwoc1t4XSwgc2VsZWN0b3JbeF0sIHZhbCwgc3ApO1xuICAgICAgZWxzZSBpZihzZWxlY3Rvclt4XS5zdHJlYW0pIG1lcmdlZFN0cmVhbShzW3hdLCBzZWxlY3Rvclt4XS5zdHJlYW0sIHZhbCwgc3ApO1xuICAgICAgc1t4XS5hZGRMaXN0ZW5lcihyb3V0ZXIpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlZFN0cmVhbShzaWcsIHNlbGVjdG9yLCBleHAsIHNwZWMpIHtcbiAgICBzZWxlY3Rvci5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgIGlmKHMuZXZlbnQpICAgICAgIGV2ZW50KHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zaWduYWwpIHNpZ25hbChzaWcsIHMsIGV4cCwgc3BlYyk7XG4gICAgICBlbHNlIGlmKHMuc3RhcnQpICBvcmRlcmVkU3RyZWFtKHNpZywgcywgZXhwLCBzcGVjKTtcbiAgICAgIGVsc2UgaWYocy5zdHJlYW0pIG1lcmdlZFN0cmVhbShzaWcsIHMuc3RyZWFtLCBleHAsIHNwZWMpO1xuICAgIH0pO1xuICB9O1xuXG4gIChzcGVjIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKHNpZykge1xuICAgIHZhciBzaWduYWwgPSBncmFwaC5zaWduYWwoc2lnLm5hbWUpO1xuICAgIGlmKHNpZy5leHByKSByZXR1cm47ICAvLyBDYW5ub3QgaGF2ZSBhbiBleHByIGFuZCBzdHJlYW0gZGVmaW5pdGlvbi5cblxuICAgIChzaWcuc3RyZWFtcyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHZhciBzZWwgPSBzZWxlY3Rvci5wYXJzZShzdHJlYW0udHlwZSksXG4gICAgICAgICAgZXhwID0gZXhwcihzdHJlYW0uZXhwcik7XG4gICAgICBtZXJnZWRTdHJlYW0oc2lnbmFsLCBzZWwsIGV4cCwgc3RyZWFtKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2UgcmVnaXN0ZXIgdGhlIGV2ZW50IGxpc3RlbmVycyBhbGwgdG9nZXRoZXIgc28gdGhhdCBpZiBtdWx0aXBsZVxuICAvLyBzaWduYWxzIGFyZSByZWdpc3RlcmVkIG9uIHRoZSBzYW1lIGV2ZW50LCB0aGV5IHdpbGwgcmVjZWl2ZSB0aGVcbiAgLy8gbmV3IHZhbHVlIG9uIHRoZSBzYW1lIHB1bHNlLiBcblxuICAvLyBUT0RPOiBGaWx0ZXJzLCB0aW1lIGludGVydmFscywgdGFyZ2V0IHNlbGVjdG9yc1xuICBkbC5rZXlzKHJlZ2lzdGVyKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgaGFuZGxlcnMgPSByZWdpc3RlcltyXSwgXG4gICAgICAgIG5vZGUgPSBub2Rlc1tyXTtcblxuICAgIHZpZXcub24ociwgZnVuY3Rpb24oZXZ0LCBpdGVtKSB7XG4gICAgICB2YXIgY3MgPSBjaGFuZ3NldC5jcmVhdGUobnVsbCwgdHJ1ZSksXG4gICAgICAgICAgcGFkID0gdmlldy5wYWRkaW5nKCksXG4gICAgICAgICAgZmlsdGVyZWQgPSBmYWxzZSxcbiAgICAgICAgICB2YWwsIGgsIGksIG0sIGQ7XG5cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIHRleHQgc2VsZWN0aW9uXG4gICAgICBtID0gZDMubW91c2UoKGQzLmV2ZW50PWV2dCwgdmlldy5fZWwpKTsgLy8gUmVsYXRpdmUgcG9zaXRpb24gd2l0aGluIGNvbnRhaW5lclxuICAgICAgaXRlbSA9IGl0ZW18fHt9O1xuICAgICAgZCA9IGl0ZW0uZGF0dW18fHt9O1xuICAgICAgdmFyIHAgPSB7eDogbVswXSAtIHBhZC5sZWZ0LCB5OiBtWzFdIC0gcGFkLnRvcH07XG5cbiAgICAgIGZvcihpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGggPSBoYW5kbGVyc1tpXTtcbiAgICAgICAgZmlsdGVyZWQgPSBoLmZpbHRlcnMuc29tZShmdW5jdGlvbihmKSB7XG4gICAgICAgICAgcmV0dXJuICFleHByLmV2YWwoZ3JhcGgsIGYuZm4sIGQsIGV2dCwgaXRlbSwgcCwgZi5zaWduYWxzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKGZpbHRlcmVkKSBjb250aW51ZTtcbiAgICAgICAgXG4gICAgICAgIHZhbCA9IGV4cHIuZXZhbChncmFwaCwgaC5leHAuZm4sIGQsIGV2dCwgaXRlbSwgcCwgaC5leHAuc2lnbmFscyk7IFxuICAgICAgICBpZihoLnNwZWMuc2NhbGUpIHZhbCA9IHNjYWxlKGguc3BlYywgdmFsLCBpdGVtKTtcbiAgICAgICAgaC5zaWduYWwudmFsdWUodmFsKTtcbiAgICAgICAgY3Muc2lnbmFsc1toLnNpZ25hbC5uYW1lKCldID0gMTtcbiAgICAgIH1cblxuICAgICAgZ3JhcGgucHJvcGFnYXRlKGNzLCBub2RlKTtcbiAgICB9KTtcbiAgfSlcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIHRyYW5zZm9ybXMgPSByZXF1aXJlKCcuLi90cmFuc2Zvcm1zL2luZGV4Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCBkZWYpIHtcbiAgdmFyIHR4ID0gbmV3IHRyYW5zZm9ybXNbZGVmLnR5cGVdKG1vZGVsLmdyYXBoKTtcbiAgaWYoZGVmLnR5cGUgPT0gJ2ZhY2V0Jykge1xuICAgIHZhciBwaXBlbGluZSA9IChkZWYudHJhbnNmb3JtfHxbXSlcbiAgICAgIC5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gcGFyc2VUcmFuc2Zvcm1zKG1vZGVsLCB0KTsgfSk7XG4gICAgdHgucGlwZWxpbmUocGlwZWxpbmUpO1xuICB9XG5cbiAgLy8gV2Ugd2FudCB0byByZW5hbWUgb3V0cHV0IGZpZWxkcyBiZWZvcmUgc2V0dGluZyBhbnkgb3RoZXIgcHJvcGVydGllcyxcbiAgLy8gYXMgc3Vic2VxdWVudCBwcm9wZXJ0aWVzIG1heSByZXF1aXJlIG91dHB1dCB0byBiZSBzZXQgKGUuZy4gZ3JvdXAgYnkpLlxuICBpZihkZWYub3V0cHV0KSB0eC5vdXRwdXQoZGVmLm91dHB1dCk7XG5cbiAgZGwua2V5cyhkZWYpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIGlmKGsgPT09ICd0eXBlJyB8fCBrID09PSAnb3V0cHV0JykgcmV0dXJuO1xuICAgIGlmKGsgPT09ICd0cmFuc2Zvcm0nICYmIGRlZi50eXBlID09PSAnZmFjZXQnKSByZXR1cm47XG4gICAgKHR4W2tdKS5zZXQodHgsIGRlZltrXSk7XG4gIH0pO1xuXG4gIHJldHVybiB0eDtcbn07IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbnZhciBoYW5kbGVyID0gZnVuY3Rpb24oZWwsIG1vZGVsKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG4gIGlmIChlbCkgdGhpcy5pbml0aWFsaXplKGVsKTtcbiAgaWYgKG1vZGVsKSB0aGlzLm1vZGVsKG1vZGVsKTtcbn07XG5cbnZhciBwcm90b3R5cGUgPSBoYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBkMy5zZWxlY3QoZWwpLm5vZGUoKTtcbiAgdGhpcy5fY2FudmFzID0gZDMuc2VsZWN0KGVsKS5zZWxlY3QoXCJjYW52YXMubWFya3NcIikubm9kZSgpO1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgXG4gIC8vIGFkZCBldmVudCBsaXN0ZW5lcnNcbiAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcywgdGhhdCA9IHRoaXM7XG4gIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIHByb3RvdHlwZVt0eXBlXS5jYWxsKHRoYXQsIGV2dCk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucGFkZGluZyA9IGZ1bmN0aW9uKHBhZCkge1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5tb2RlbCA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5oYW5kbGVycyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaCA9IHRoaXMuX2hhbmRsZXJzO1xuICByZXR1cm4gZGwua2V5cyhoKS5yZWR1Y2UoZnVuY3Rpb24oYSwgaykge1xuICAgIHJldHVybiBoW2tdLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7IHJldHVybiAoYS5wdXNoKHgpLCBhKTsgfSwgYSk7XG4gIH0sIFtdKTtcbn07XG5cbi8vIHNldHVwIGV2ZW50c1xudmFyIGV2ZW50cyA9IFtcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJtb3VzZXVwXCIsXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIndoZWVsXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXByZXNzXCIsXG4gIFwia2V5dXBcIixcbiAgXCJtb3VzZXdoZWVsXCIsXG4gIFwidG91Y2hzdGFydFwiXG5dO1xuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24odHlwZSkge1xuICBwcm90b3R5cGVbdHlwZV0gPSBmdW5jdGlvbihldnQpIHtcbiAgICB0aGlzLmZpcmUodHlwZSwgZXZ0KTtcbiAgfTtcbn0pO1xuZXZlbnRzLnB1c2goXCJtb3VzZW1vdmVcIik7XG5ldmVudHMucHVzaChcIm1vdXNlb3V0XCIpO1xuZXZlbnRzLnB1c2goXCJ0b3VjaG1vdmVcIik7XG5ldmVudHMucHVzaChcInRvdWNoZW5kXCIpO1xuXG5mdW5jdGlvbiBldmVudE5hbWUobmFtZSkge1xuICB2YXIgaSA9IG5hbWUuaW5kZXhPZihcIi5cIik7XG4gIHJldHVybiBpIDwgMCA/IG5hbWUgOiBuYW1lLnNsaWNlKDAsaSk7XG59XG5cbnByb3RvdHlwZS50b3VjaG1vdmUgPSBwcm90b3R5cGUubW91c2Vtb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHZhciBwYWQgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgYiA9IGV2dC50YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICB4ID0gZXZ0LmNsaWVudFggLSBiLmxlZnQsXG4gICAgICB5ID0gZXZ0LmNsaWVudFkgLSBiLnRvcCxcbiAgICAgIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBwID0gdGhpcy5waWNrKHRoaXMuX21vZGVsLnNjZW5lKCksIHgsIHksIHgtcGFkLmxlZnQsIHktcGFkLnRvcCk7XG5cbiAgaWYgKHAgPT09IGEpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW1vdmVcIiwgZXZ0KTtcbiAgICBpZihldnQudHlwZSA9PSBcInRvdWNobW92ZVwiKSB0aGlzLmZpcmUoXCJ0b3VjaG1vdmVcIiwgZXZ0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoYSkge1xuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaGVuZFwiKSB0aGlzLmZpcmUoXCJ0b3VjaGVuZFwiLCBldnQpO1xuICB9XG4gIHRoaXMuX2FjdGl2ZSA9IHA7XG4gIGlmIChwKSB7XG4gICAgdGhpcy5maXJlKFwibW91c2VvdmVyXCIsIGV2dCk7XG4gICAgaWYoZXZ0LnR5cGUgPT0gXCJ0b3VjaHN0YXJ0XCIpIHRoaXMuZmlyZShcInRvdWNoc3RhcnRcIiwgZXZ0KTtcbiAgfVxufTtcblxucHJvdG90eXBlLnRvdWNoZW5kID0gcHJvdG90eXBlLm1vdXNlb3V0ID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLmZpcmUoXCJtb3VzZW91dFwiLCBldnQpO1xuICAgIHRoaXMuZmlyZShcInRvdWNoZW5kXCIsIGV2dCk7XG4gIH1cbiAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbn07XG5cbi8vIHRvIGtlZXAgZmlyZWZveCBoYXBweVxucHJvdG90eXBlLkRPTU1vdXNlU2Nyb2xsID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuZmlyZShcIm1vdXNld2hlZWxcIiwgZXZ0KTtcbn07XG5cbi8vIGZpcmUgYW4gZXZlbnRcbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZXZ0KSB7XG4gIHZhciBhID0gdGhpcy5fYWN0aXZlLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuICBpZiAoaCkge1xuICAgIGZvciAodmFyIGk9MCwgbGVuPWgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBoW2ldLmhhbmRsZXIuY2FsbCh0aGlzLl9vYmosIGV2dCwgYSk7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycztcbiAgaCA9IGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSk7XG4gIGgucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSBoLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbn07XG5cbi8vIGZpbmQgdGhlIHNjZW5lZ3JhcGggaXRlbSBhdCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuLy8geCwgeSAtLSB0aGUgYWJzb2x1dGUgeCwgeSBtb3VzZSBjb29yZGluYXRlcyBvbiB0aGUgY2FudmFzIGVsZW1lbnRcbi8vIGd4LCBneSAtLSB0aGUgcmVsYXRpdmUgY29vcmRpbmF0ZXMgd2l0aGluIHRoZSBjdXJyZW50IGdyb3VwXG5wcm90b3R5cGUucGljayA9IGZ1bmN0aW9uKHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICBwaWNrZXIgPSBtYXJrcy5waWNrW21hcmt0eXBlXTtcbiAgcmV0dXJuIHBpY2tlci5jYWxsKHRoaXMsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVyOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2N0eCA9IG51bGw7XG4gIHRoaXMuX2VsID0gbnVsbDtcbiAgdGhpcy5faW1nbG9hZCA9IDA7XG59O1xuXG52YXIgcHJvdG90eXBlID0gcmVuZGVyZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgXG4gIGlmICghZWwpIHJldHVybiB0aGlzOyAvLyBlYXJseSBleGl0IGlmIG5vIERPTSBlbGVtZW50XG5cbiAgLy8gc2VsZWN0IGNhbnZhcyBlbGVtZW50XG4gIHZhciBjYW52YXMgPSBkMy5zZWxlY3QoZWwpXG4gICAgLnNlbGVjdEFsbChcImNhbnZhcy5tYXJrc1wiKVxuICAgIC5kYXRhKFsxXSk7XG4gIFxuICAvLyBjcmVhdGUgbmV3IGNhbnZhcyBlbGVtZW50IGlmIG5lZWRlZFxuICBjYW52YXMuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJjYW52YXNcIilcbiAgICAuYXR0cihcImNsYXNzXCIsIFwibWFya3NcIik7XG4gIFxuICAvLyByZW1vdmUgZXh0cmFuZW91cyBjYW52YXMgaWYgbmVlZGVkXG4gIGNhbnZhcy5leGl0KCkucmVtb3ZlKCk7XG4gIFxuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICBcbiAgaWYgKHRoaXMuX2VsKSB7XG4gICAgdmFyIGNhbnZhcyA9IGQzLnNlbGVjdCh0aGlzLl9lbCkuc2VsZWN0KFwiY2FudmFzLm1hcmtzXCIpO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBjYW52YXMgYXR0cmlidXRlc1xuICAgIGNhbnZhc1xuICAgICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0KVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgcGFkLnRvcCArIHBhZC5ib3R0b20pO1xuXG4gICAgLy8gZ2V0IHRoZSBjYW52YXMgZ3JhcGhpY3MgY29udGV4dFxuICAgIHZhciBzO1xuICAgIHRoaXMuX2N0eCA9IGNhbnZhcy5ub2RlKCkuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIHRoaXMuX2N0eC5fcmF0aW8gPSAocyA9IHNjYWxlQ2FudmFzKGNhbnZhcy5ub2RlKCksIHRoaXMuX2N0eCkgfHwgMSk7XG4gICAgdGhpcy5fY3R4LnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCBzKnBhZC5sZWZ0LCBzKnBhZC50b3ApO1xuICB9XG4gIFxuICBpbml0aWFsaXplTGluZURhc2godGhpcy5fY3R4KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBzY2FsZUNhbnZhcyhjYW52YXMsIGN0eCkge1xuICAvLyBnZXQgY2FudmFzIHBpeGVsIGRhdGFcbiAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgYmFja2luZ1N0b3JlUmF0aW8gPSAoXG4gICAgICAgIGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGN0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvKSB8fCAxLFxuICAgICAgcmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cbiAgaWYgKGRldmljZVBpeGVsUmF0aW8gIT09IGJhY2tpbmdTdG9yZVJhdGlvKSB7XG4gICAgdmFyIHcgPSBjYW52YXMud2lkdGgsIGggPSBjYW52YXMuaGVpZ2h0O1xuICAgIC8vIHNldCBhY3R1YWwgYW5kIHZpc2libGUgY2FudmFzIHNpemVcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyAqIHJhdGlvKTtcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGggKiByYXRpbyk7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICB9XG4gIHJldHVybiByYXRpbztcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUxpbmVEYXNoKGN0eCkge1xuICBpZiAoY3R4LnZnTGluZURhc2gpIHJldHVybjsgLy8gYWxyZWFkeSBzZXRcblxuICB2YXIgTk9EQVNIID0gW107XG4gIGlmIChjdHguc2V0TGluZURhc2gpIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy5zZXRMaW5lRGFzaChkYXNoIHx8IE5PREFTSCk7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy5saW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgud2Via2l0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICBcdGN0eC52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLndlYmtpdExpbmVEYXNoID0gZGFzaCB8fCBOT0RBU0g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgdGhpcy53ZWJraXRMaW5lRGFzaE9mZnNldCA9IG9mZjsgfTtcbiAgfSBlbHNlIGlmIChjdHgubW96RGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY3R4LnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMubW96RGFzaCA9IGRhc2g7IH07XG4gICAgY3R4LnZnTGluZURhc2hPZmZzZXQgPSBmdW5jdGlvbihvZmYpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgfSBlbHNlIHtcbiAgICBjdHgudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgLyogdW5zdXBwb3J0ZWQgKi8gfTtcbiAgICBjdHgudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyAvKiB1bnN1cHBvcnRlZCAqLyB9O1xuICB9XG59XG5cbnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oY3R4KSB7XG4gIGlmIChjdHgpIHsgdGhpcy5fY3R4ID0gY3R4OyByZXR1cm4gdGhpczsgfVxuICBlbHNlIHJldHVybiB0aGlzLl9jdHg7XG59O1xuXG5wcm90b3R5cGUuZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWw7XG59O1xuXG5wcm90b3R5cGUucGVuZGluZ0ltYWdlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faW1nbG9hZDtcbn07XG5cbmZ1bmN0aW9uIHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgYm91bmRzKSB7XG4gIHZhciBiID0gbmV3IEJvdW5kcyhib3VuZHMpO1xuICB3aGlsZSAoKGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApICE9IG51bGwpIHtcbiAgICBiLnRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xuICB9XG4gIHJldHVybiBiO1xufVxuICBcbmZ1bmN0aW9uIGdldEJvdW5kcyhpdGVtcykge1xuICByZXR1cm4gIWl0ZW1zID8gbnVsbCA6XG4gICAgZGwuYXJyYXkoaXRlbXMpLnJlZHVjZShmdW5jdGlvbihiLCBpdGVtKSB7XG4gICAgICByZXR1cm4gYi51bmlvbih0cmFuc2xhdGVkQm91bmRzKGl0ZW0sIGl0ZW0uYm91bmRzKSlcbiAgICAgICAgICAgICAgLnVuaW9uKHRyYW5zbGF0ZWRCb3VuZHMoaXRlbSwgaXRlbVsnYm91bmRzOnByZXYnXSkpO1xuICAgIH0sIG5ldyBCb3VuZHMoKSk7ICBcbn1cblxuZnVuY3Rpb24gc2V0Qm91bmRzKGcsIGJvdW5kcykge1xuICB2YXIgYmJveCA9IG51bGw7XG4gIGlmIChib3VuZHMpIHtcbiAgICBiYm94ID0gKG5ldyBCb3VuZHMoYm91bmRzKSkucm91bmQoKTtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGcucmVjdChiYm94LngxLCBiYm94LnkxLCBiYm94LndpZHRoKCksIGJib3guaGVpZ2h0KCkpO1xuICAgIGcuY2xpcCgpO1xuICB9XG4gIHJldHVybiBiYm94O1xufVxuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUsIGl0ZW1zKSB7XG4gIHZhciBnID0gdGhpcy5fY3R4LFxuICAgICAgcGFkID0gdGhpcy5fcGFkZGluZyxcbiAgICAgIHcgPSB0aGlzLl93aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0LFxuICAgICAgaCA9IHRoaXMuX2hlaWdodCArIHBhZC50b3AgKyBwYWQuYm90dG9tLFxuICAgICAgYmIgPSBudWxsLCBiYjI7XG5cbiAgLy8gc2V0dXBcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgZy5zYXZlKCk7XG4gIGJiID0gc2V0Qm91bmRzKGcsIGdldEJvdW5kcyhpdGVtcykpO1xuICBnLmNsZWFyUmVjdCgtcGFkLmxlZnQsIC1wYWQudG9wLCB3LCBoKTtcblxuICAvLyByZW5kZXJcbiAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYik7XG5cbiAgLy8gcmVuZGVyIGFnYWluIHRvIGhhbmRsZSBwb3NzaWJsZSBib3VuZHMgY2hhbmdlXG4gIGlmIChpdGVtcykge1xuICAgIGcucmVzdG9yZSgpO1xuICAgIGcuc2F2ZSgpO1xuICAgIGJiMiA9IHNldEJvdW5kcyhnLCBnZXRCb3VuZHMoaXRlbXMpKTtcbiAgICBpZiAoIWJiLmVuY2xvc2VzKGJiMikpIHtcbiAgICAgIGcuY2xlYXJSZWN0KC1wYWQubGVmdCwgLXBhZC50b3AsIHcsIGgpO1xuICAgICAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiYjIpO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gdGFrZWRvd25cbiAgZy5yZXN0b3JlKCk7XG4gIHRoaXMuX3NjZW5lID0gbnVsbDtcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBtYXJrdHlwZSA9IHNjZW5lLm1hcmt0eXBlLFxuICAgICAgcmVuZGVyZXIgPSBtYXJrcy5kcmF3W21hcmt0eXBlXTtcbiAgcmVuZGVyZXIuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xufTtcblxucHJvdG90eXBlLnJlbmRlckFzeW5jID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgLy8gVE9ETyBtYWtlIHNhZmUgZm9yIG11bHRpcGxlIHNjZW5lIHJlbmRlcmluZz9cbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgaWYgKHJlbmRlcmVyLl9hc3luY19pZCkge1xuICAgIGNsZWFyVGltZW91dChyZW5kZXJlci5fYXN5bmNfaWQpO1xuICB9XG4gIHJlbmRlcmVyLl9hc3luY19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lKTtcbiAgICBkZWxldGUgcmVuZGVyZXIuX2FzeW5jX2lkO1xuICB9LCA1MCk7XG59O1xuXG5wcm90b3R5cGUubG9hZEltYWdlID0gZnVuY3Rpb24odXJpKSB7XG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBzY2VuZSA9IHJlbmRlcmVyLl9zY2VuZSxcbiAgICAgIGltYWdlID0gbnVsbCwgdXJsO1xuXG4gIHJlbmRlcmVyLl9pbWdsb2FkICs9IDE7XG4gIGlmIChkbC5pc05vZGUpIHtcbiAgICBpbWFnZSA9IG5ldyAoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuY2FudmFzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5jYW52YXMgOiBudWxsKS5JbWFnZSkoKTtcbiAgICBkbC5sb2FkKGRsLmV4dGVuZCh7dXJsOiB1cml9LCBjb25maWcubG9hZCksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikgeyBkbC5lcnJvcihlcnIpOyByZXR1cm47IH1cbiAgICAgIGltYWdlLnNyYyA9IGRhdGE7XG4gICAgICBpbWFnZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgcmVuZGVyZXIuX2ltZ2xvYWQgLT0gMTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIHVybCA9IGNvbmZpZy5iYXNlVVJMICsgdXJpO1xuICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaW1hZ2UubG9hZGVkID0gdHJ1ZTtcbiAgICAgIHJlbmRlcmVyLl9pbWdsb2FkIC09IDE7XG4gICAgICByZW5kZXJlci5yZW5kZXJBc3luYyhzY2VuZSk7XG4gICAgfTtcbiAgICBpbWFnZS5zcmMgPSB1cmw7XG4gIH1cblxuICByZXR1cm4gaW1hZ2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9IYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1JlbmRlcmVyJylcbn07IiwidmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvQm91bmRzJyksXG4gICAgYm91bmRzQ2FsYyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvYm91bmRzJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBwYXRoID0gcmVxdWlyZSgnLi9wYXRoJyk7XG5cbnZhciBwYXJzZVBhdGggPSBwYXRoLnBhcnNlLFxuICAgIHJlbmRlclBhdGggPSBwYXRoLnJlbmRlcixcbiAgICBoYWxmcGkgPSBNYXRoLlBJIC8gMixcbiAgICBzcXJ0MyA9IE1hdGguc3FydCgzKSxcbiAgICB0YW4zMCA9IE1hdGgudGFuKDMwICogTWF0aC5QSSAvIDE4MCksXG4gICAgdG1wQm91bmRzID0gbmV3IEJvdW5kcygpO1xuXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgcmV0dXJuIChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250IHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG59XG5cbi8vIHBhdGggZ2VuZXJhdG9yc1xuXG5mdW5jdGlvbiBhcmNQYXRoKGcsIG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBNYXRoLlBJLzIsXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gTWF0aC5QSS8yO1xuICBnLmJlZ2luUGF0aCgpO1xuICBpZiAoaXIgPT09IDApIGcubW92ZVRvKHgsIHkpO1xuICBlbHNlIGcuYXJjKHgsIHksIGlyLCBzYSwgZWEsIDApO1xuICBnLmFyYyh4LCB5LCBvciwgZWEsIHNhLCAxKTtcbiAgZy5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gYXJlYVBhdGgoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIG0gPSBvLm1hcmssXG4gICAgICBwID0gbS5wYXRoQ2FjaGUgfHwgKG0ucGF0aENhY2hlID0gcGFyc2VQYXRoKHBhdGguYXJlYShpdGVtcykpKTtcbiAgcmVuZGVyUGF0aChnLCBwKTtcbn1cblxuZnVuY3Rpb24gbGluZVBhdGgoZywgaXRlbXMpIHtcbiAgdmFyIG8gPSBpdGVtc1swXSxcbiAgICAgIG0gPSBvLm1hcmssXG4gICAgICBwID0gbS5wYXRoQ2FjaGUgfHwgKG0ucGF0aENhY2hlID0gcGFyc2VQYXRoKHBhdGgubGluZShpdGVtcykpKTtcbiAgcmVuZGVyUGF0aChnLCBwKTtcbn1cblxuZnVuY3Rpb24gcGF0aFBhdGgoZywgbykge1xuICBpZiAoby5wYXRoID09IG51bGwpIHJldHVybjtcbiAgdmFyIHAgPSBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZVBhdGgoby5wYXRoKSk7XG4gIHJldHVybiByZW5kZXJQYXRoKGcsIHAsIG8ueCwgby55KTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sUGF0aChnLCBvKSB7XG4gIGcuYmVnaW5QYXRoKCk7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54LCB5ID0gby55LCByLCB0LCByeCwgcnk7XG5cbiAgaWYgKG8uc2hhcGUgPT0gbnVsbCB8fCBvLnNoYXBlID09PSBcImNpcmNsZVwiKSB7XG4gICAgciA9IE1hdGguc3FydChzaXplL01hdGguUEkpO1xuICAgIGcuYXJjKHgsIHksIHIsIDAsIDIqTWF0aC5QSSwgMCk7XG4gICAgZy5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG8uc2hhcGUpIHtcbiAgICBjYXNlIFwiY3Jvc3NcIjpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBnLm1vdmVUbyh4LXQsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4LXQsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJkaWFtb25kXCI6XG4gICAgICByeSA9IE1hdGguc3FydChzaXplIC8gKDIgKiB0YW4zMCkpO1xuICAgICAgcnggPSByeSAqIHRhbjMwO1xuICAgICAgZy5tb3ZlVG8oeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5KTtcbiAgICAgIGcubGluZVRvKHgsIHkrcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgIHQgPSBNYXRoLnNxcnQoc2l6ZSk7XG4gICAgICByID0gdCAvIDI7XG4gICAgICBnLnJlY3QoeC1yLCB5LXIsIHQsIHQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGUtZG93blwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBnLm1vdmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeS1yeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS11cFwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBnLm1vdmVUbyh4LCB5LXJ5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHkrcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeStyeSk7XG4gIH1cbiAgZy5jbG9zZVBhdGgoKTtcbn1cblxuZnVuY3Rpb24gbGluZVN0cm9rZShnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgbHcgPSBvLnN0cm9rZVdpZHRoLFxuICAgICAgbGMgPSBvLnN0cm9rZUNhcDtcbiAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgZy5saW5lQ2FwICAgPSBsYyAhPSBudWxsID8gbGMgOiBjb25maWcucmVuZGVyLmxpbmVDYXA7XG4gIGxpbmVQYXRoKGcsIGl0ZW1zKTtcbn1cblxuZnVuY3Rpb24gcnVsZVN0cm9rZShnLCBvKSB7XG4gIHZhciB4MSA9IG8ueCB8fCAwLFxuICAgICAgeTEgPSBvLnkgfHwgMCxcbiAgICAgIHgyID0gby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgICAgeTIgPSBvLnkyICE9IG51bGwgPyBvLnkyIDogeTEsXG4gICAgICBsdyA9IG8uc3Ryb2tlV2lkdGgsXG4gICAgICBsYyA9IG8uc3Ryb2tlQ2FwO1xuXG4gIGcubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gIGcubGluZUNhcCAgID0gbGMgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICBnLmJlZ2luUGF0aCgpO1xuICBnLm1vdmVUbyh4MSwgeTEpO1xuICBnLmxpbmVUbyh4MiwgeTIpO1xufVxuXG4vLyBkcmF3aW5nIGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBkcmF3UGF0aE9uZShwYXRoLCBnLCBvLCBpdGVtcykge1xuICB2YXIgZmlsbCA9IG8uZmlsbCwgc3Ryb2tlID0gby5zdHJva2UsIG9wYWMsIGxjLCBsdztcblxuICBwYXRoKGcsIGl0ZW1zKTtcblxuICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICBpZiAob3BhYyA9PSAwIHx8ICFmaWxsICYmICFzdHJva2UpIHJldHVybjtcblxuICBpZiAoZmlsbCkge1xuICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gICAgZy5maWxsU3R5bGUgPSBjb2xvcihnLCBvLCBmaWxsKTtcbiAgICBnLmZpbGwoKTtcbiAgfVxuXG4gIGlmIChzdHJva2UpIHtcbiAgICBsdyA9IChsdyA9IG8uc3Ryb2tlV2lkdGgpICE9IG51bGwgPyBsdyA6IGNvbmZpZy5yZW5kZXIubGluZVdpZHRoO1xuICAgIGlmIChsdyA+IDApIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKGcsIG8sIHN0cm9rZSk7XG4gICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgICBnLnZnTGluZURhc2hPZmZzZXQoby5zdHJva2VEYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgZy5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1BhdGhBbGwocGF0aCwgZywgc2NlbmUsIGJvdW5kcykge1xuICB2YXIgaSwgbGVuLCBpdGVtO1xuICBmb3IgKGk9MCwgbGVuPXNjZW5lLml0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBzY2VuZS5pdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG4gICAgZHJhd1BhdGhPbmUocGF0aCwgZywgaXRlbSwgaXRlbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd1JlY3QoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIGZpbGwsIHN0cm9rZSwgb3BhYywgbGMsIGx3LCB4LCB5LCB3LCBoO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICB4ID0gby54IHx8IDA7XG4gICAgeSA9IG8ueSB8fCAwO1xuICAgIHcgPSBvLndpZHRoIHx8IDA7XG4gICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09IDApIGNvbnRpbnVlO1xuXG4gICAgaWYgKGZpbGwgPSBvLmZpbGwpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gICAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIGZpbGwpO1xuICAgICAgZy5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlID0gby5zdHJva2UpIHtcbiAgICAgIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogY29uZmlnLnJlbmRlci5saW5lV2lkdGg7XG4gICAgICBpZiAobHcgPiAwKSB7XG4gICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uc3Ryb2tlT3BhY2l0eT09bnVsbCA/IDEgOiBvLnN0cm9rZU9wYWNpdHkpO1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gY29sb3IoZywgbywgc3Ryb2tlKTtcbiAgICAgICAgZy5saW5lV2lkdGggPSBsdztcbiAgICAgICAgZy5saW5lQ2FwID0gKGxjID0gby5zdHJva2VDYXApICE9IG51bGwgPyBsYyA6IGNvbmZpZy5yZW5kZXIubGluZUNhcDtcbiAgICAgICAgZy52Z0xpbmVEYXNoKG8uc3Ryb2tlRGFzaCB8fCBudWxsKTtcbiAgICAgICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICAgICAgZy5zdHJva2VSZWN0KHgsIHksIHcsIGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3UnVsZShnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgc3Ryb2tlLCBvcGFjLCBsYywgbHcsIHgxLCB5MSwgeDIsIHkyO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICB4MSA9IG8ueCB8fCAwO1xuICAgIHkxID0gby55IHx8IDA7XG4gICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDE7XG4gICAgeTIgPSBvLnkyICE9IG51bGwgPyBvLnkyIDogeTE7XG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09IDApIGNvbnRpbnVlO1xuICAgIFxuICAgIGlmIChzdHJva2UgPSBvLnN0cm9rZSkge1xuICAgICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiBjb25maWcucmVuZGVyLmxpbmVXaWR0aDtcbiAgICAgIGlmIChsdyA+IDApIHtcbiAgICAgICAgZy5nbG9iYWxBbHBoYSA9IG9wYWMgKiAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gICAgICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBzdHJva2UpO1xuICAgICAgICBnLmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogY29uZmlnLnJlbmRlci5saW5lQ2FwO1xuICAgICAgICBnLnZnTGluZURhc2goby5zdHJva2VEYXNoIHx8IG51bGwpO1xuICAgICAgICBnLnZnTGluZURhc2hPZmZzZXQoby5zdHJva2VEYXNoT2Zmc2V0IHx8IDApO1xuICAgICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgICBnLm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICBnLmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3SW1hZ2UoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcywgbztcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgaWYgKCEoby5pbWFnZSAmJiBvLmltYWdlLnVybCA9PT0gby51cmwpKSB7XG4gICAgICBvLmltYWdlID0gcmVuZGVyZXIubG9hZEltYWdlKG8udXJsKTtcbiAgICAgIG8uaW1hZ2UudXJsID0gby51cmw7XG4gICAgfVxuXG4gICAgdmFyIHgsIHksIHcsIGgsIG9wYWM7XG4gICAgdyA9IG8ud2lkdGggfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS53aWR0aCkgfHwgMDtcbiAgICBoID0gby5oZWlnaHQgfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS5oZWlnaHQpIHx8IDA7XG4gICAgeCA9IChvLnh8fDApIC0gKG8uYWxpZ24gPT09IFwiY2VudGVyXCJcbiAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSk7XG4gICAgeSA9IChvLnl8fDApIC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpO1xuXG4gICAgaWYgKG8uaW1hZ2UubG9hZGVkKSB7XG4gICAgICBnLmdsb2JhbEFscGhhID0gKG9wYWMgPSBvLm9wYWNpdHkpICE9IG51bGwgPyBvcGFjIDogMTtcbiAgICAgIGcuZHJhd0ltYWdlKG8uaW1hZ2UsIHgsIHksIHcsIGgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgZmlsbCwgc3Ryb2tlLCBvcGFjLCBsdywgeCwgeSwgciwgdDtcblxuICBmb3IgKHZhciBpPTAsIGxlbj1pdGVtcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBvID0gaXRlbXNbaV07XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoby5ib3VuZHMpKVxuICAgICAgY29udGludWU7IC8vIGJvdW5kcyBjaGVja1xuXG4gICAgZy5mb250ID0gZm9udFN0cmluZyhvKTtcbiAgICBnLnRleHRBbGlnbiA9IG8uYWxpZ24gfHwgXCJsZWZ0XCI7XG4gICAgZy50ZXh0QmFzZWxpbmUgPSBvLmJhc2VsaW5lIHx8IFwiYWxwaGFiZXRpY1wiO1xuXG4gICAgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgICBpZiAob3BhYyA9PSAwKSBjb250aW51ZTtcblxuICAgIHggPSBvLnggfHwgMDtcbiAgICB5ID0gby55IHx8IDA7XG4gICAgaWYgKHIgPSBvLnJhZGl1cykge1xuICAgICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgICAgeCArPSByICogTWF0aC5jb3ModCk7XG4gICAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgICB9XG5cbiAgICBpZiAoby5hbmdsZSkge1xuICAgICAgZy5zYXZlKCk7XG4gICAgICBnLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIGcucm90YXRlKG8uYW5nbGUgKiBNYXRoLlBJLzE4MCk7XG4gICAgICB4ID0gby5keCB8fCAwO1xuICAgICAgeSA9IG8uZHkgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSAoby5keCB8fCAwKTtcbiAgICAgIHkgKz0gKG8uZHkgfHwgMCk7XG4gICAgfVxuXG4gICAgaWYgKGZpbGwgPSBvLmZpbGwpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjICogKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gICAgICBnLmZpbGxTdHlsZSA9IGNvbG9yKGcsIG8sIGZpbGwpO1xuICAgICAgZy5maWxsVGV4dChvLnRleHQsIHgsIHkpO1xuICAgIH1cblxuICAgIGlmIChzdHJva2UgPSBvLnN0cm9rZSkge1xuICAgICAgbHcgPSAobHcgPSBvLnN0cm9rZVdpZHRoKSAhPSBudWxsID8gbHcgOiAxO1xuICAgICAgaWYgKGx3ID4gMCkge1xuICAgICAgICBnLmdsb2JhbEFscGhhID0gb3BhYyAqIChvLnN0cm9rZU9wYWNpdHk9PW51bGwgPyAxIDogby5zdHJva2VPcGFjaXR5KTtcbiAgICAgICAgZy5zdHJva2VTdHlsZSA9IGNvbG9yKG8sIHN0cm9rZSk7XG4gICAgICAgIGcubGluZVdpZHRoID0gbHc7XG4gICAgICAgIGcuc3Ryb2tlVGV4dChvLnRleHQsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvLmFuZ2xlKSBnLnJlc3RvcmUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3QWxsKHBhdGhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihnLCBzY2VuZSwgYm91bmRzKSB7XG4gICAgZHJhd1BhdGhBbGwocGF0aEZ1bmMsIGcsIHNjZW5lLCBib3VuZHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdPbmUocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmIChib3VuZHMgJiYgIWJvdW5kcy5pbnRlcnNlY3RzKHNjZW5lLml0ZW1zWzBdLmJvdW5kcykpXG4gICAgICByZXR1cm47IC8vIGJvdW5kcyBjaGVja1xuICAgIGRyYXdQYXRoT25lKHBhdGhGdW5jLCBnLCBzY2VuZS5pdGVtc1swXSwgc2NlbmUuaXRlbXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdHcm91cChnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLCBncm91cCwgYXhlcywgbGVnZW5kcyxcbiAgICAgIHJlbmRlcmVyID0gdGhpcywgZ3gsIGd5LCBnYiwgaSwgbiwgaiwgbTtcblxuICBkcmF3UmVjdChnLCBzY2VuZSwgYm91bmRzKTtcblxuICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZ3JvdXAgPSBpdGVtc1tpXTtcbiAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IFtdO1xuICAgIGxlZ2VuZHMgPSBncm91cC5sZWdlbmRJdGVtcyB8fCBbXTtcbiAgICBneCA9IGdyb3VwLnggfHwgMDtcbiAgICBneSA9IGdyb3VwLnkgfHwgMDtcblxuICAgIC8vIHJlbmRlciBncm91cCBjb250ZW50c1xuICAgIGcuc2F2ZSgpO1xuICAgIGcudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgaWYgKGdyb3VwLmNsaXApIHtcbiAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICBnLnJlY3QoMCwgMCwgZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICAgICAgZy5jbGlwKCk7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuICAgIFxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyID09PSBcImJhY2tcIikge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWdyb3VwLml0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgZ3JvdXAuaXRlbXNbal0sIGJvdW5kcyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyICE9PSBcImJhY2tcIikge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgcmVuZGVyZXIuZHJhdyhnLCBsZWdlbmRzW2pdLCBib3VuZHMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgZy5yZXN0b3JlKCk7XG4gIH0gICAgXG59XG5cbmZ1bmN0aW9uIGNvbG9yKGcsIG8sIHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUuaWQpXG4gICAgPyBncmFkaWVudChnLCB2YWx1ZSwgby5ib3VuZHMpXG4gICAgOiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gZ3JhZGllbnQoZywgcCwgYikge1xuICB2YXIgdyA9IGIud2lkdGgoKSxcbiAgICAgIGggPSBiLmhlaWdodCgpLFxuICAgICAgeDEgPSBiLngxICsgcC54MSAqIHcsXG4gICAgICB5MSA9IGIueTEgKyBwLnkxICogaCxcbiAgICAgIHgyID0gYi54MSArIHAueDIgKiB3LFxuICAgICAgeTIgPSBiLnkxICsgcC55MiAqIGgsXG4gICAgICBncmFkID0gZy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5MiksXG4gICAgICBzdG9wID0gcC5zdG9wcyxcbiAgICAgIGksIG47XG5cbiAgZm9yIChpPTAsIG49c3RvcC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgZ3JhZC5hZGRDb2xvclN0b3Aoc3RvcFtpXS5vZmZzZXQsIHN0b3BbaV0uY29sb3IpO1xuICB9XG4gIHJldHVybiBncmFkO1xufVxuXG4vLyBoaXQgdGVzdGluZ1xuXG5mdW5jdGlvbiBwaWNrR3JvdXAoZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoc2NlbmUuaXRlbXMubGVuZ3RoID09PSAwIHx8XG4gICAgICBzY2VuZS5ib3VuZHMgJiYgIXNjZW5lLmJvdW5kcy5jb250YWlucyhneCwgZ3kpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLCBzdWJzY2VuZSwgZ3JvdXAsIGhpdCwgZHgsIGR5LFxuICAgICAgaGFuZGxlciA9IHRoaXMsIGksIGo7XG5cbiAgZm9yIChpPWl0ZW1zLmxlbmd0aDsgLS1pPj0wOykge1xuICAgIGdyb3VwID0gaXRlbXNbaV07XG4gICAgZHggPSBncm91cC54IHx8IDA7XG4gICAgZHkgPSBncm91cC55IHx8IDA7XG5cbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZShkeCwgZHkpO1xuICAgIGZvciAoaj1ncm91cC5pdGVtcy5sZW5ndGg7IC0taiA+PSAwOykge1xuICAgICAgc3Vic2NlbmUgPSBncm91cC5pdGVtc1tqXTtcbiAgICAgIGlmIChzdWJzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIGNvbnRpbnVlO1xuICAgICAgaGl0ID0gaGFuZGxlci5waWNrKHN1YnNjZW5lLCB4LCB5LCBneC1keCwgZ3ktZHkpO1xuICAgICAgaWYgKGhpdCkge1xuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIGhpdDtcbiAgICAgIH1cbiAgICB9XG4gICAgZy5yZXN0b3JlKCk7XG4gIH1cblxuICByZXR1cm4gc2NlbmUuaW50ZXJhY3RpdmVcbiAgICA/IHBpY2tBbGwoaGl0VGVzdHMuZ3JvdXAsIGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpXG4gICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGlja0FsbCh0ZXN0LCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmICghc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHZhciBvLCBiLCBpO1xuXG4gIGlmIChnLl9yYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5fcmF0aW87XG4gICAgeSAqPSBnLl9yYXRpbztcbiAgfVxuXG4gIGZvciAoaT1zY2VuZS5pdGVtcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgIG8gPSBzY2VuZS5pdGVtc1tpXTsgYiA9IG8uYm91bmRzO1xuICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgaWYgKChiICYmICFiLmNvbnRhaW5zKGd4LCBneSkpIHx8ICFiKSBjb250aW51ZTtcbiAgICAvLyBpZiBpbiBib3VuZGluZyBib3gsIHBlcmZvcm0gbW9yZSBjYXJlZnVsIHRlc3RcbiAgICBpZiAodGVzdChnLCBvLCB4LCB5LCBneCwgZ3kpKSByZXR1cm4gbztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHBpY2tBcmVhKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBiLCBpLCBkaSwgZGQsIG9kLCBkeCwgZHk7XG5cbiAgYiA9IGl0ZW1zWzBdLmJvdW5kcztcbiAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZy5fcmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcuX3JhdGlvO1xuICAgIHkgKj0gZy5fcmF0aW87XG4gIH1cbiAgaWYgKCFoaXRUZXN0cy5hcmVhKGcsIGl0ZW1zLCB4LCB5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlbXNbMF07XG59XG5cbmZ1bmN0aW9uIHBpY2tMaW5lKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBiLCBpLCBkaSwgZGQsIG9kLCBkeCwgZHk7XG5cbiAgYiA9IGl0ZW1zWzBdLmJvdW5kcztcbiAgaWYgKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZy5fcmF0aW8gIT09IDEpIHtcbiAgICB4ICo9IGcuX3JhdGlvO1xuICAgIHkgKj0gZy5fcmF0aW87XG4gIH1cbiAgaWYgKCFoaXRUZXN0cy5saW5lKGcsIGl0ZW1zLCB4LCB5KSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXRlbXNbMF07XG59XG5cbmZ1bmN0aW9uIHBpY2sodGVzdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICByZXR1cm4gcGlja0FsbCh0ZXN0LCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGV4dEhpdChnLCBvLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKCFvLmZvbnRTaXplKSByZXR1cm4gZmFsc2U7XG4gIGlmICghby5hbmdsZSkgcmV0dXJuIHRydWU7IC8vIGJvdW5kcyBzdWZmaWNpZW50IGlmIG5vIHJvdGF0aW9uXG5cbiAgdmFyIGIgPSBib3VuZHNDYWxjLnRleHQobywgdG1wQm91bmRzLCB0cnVlKSxcbiAgICAgIGEgPSAtby5hbmdsZSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBjb3MgPSBNYXRoLmNvcyhhKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGEpLFxuICAgICAgeCA9IG8ueCxcbiAgICAgIHkgPSBvLnksXG4gICAgICBweCA9IGNvcypneCAtIHNpbipneSArICh4IC0geCpjb3MgKyB5KnNpbiksXG4gICAgICBweSA9IHNpbipneCArIGNvcypneSArICh5IC0geCpzaW4gLSB5KmNvcyk7XG5cbiAgcmV0dXJuIGIuY29udGFpbnMocHgsIHB5KTtcbn1cblxudmFyIGhpdFRlc3RzID0ge1xuICB0ZXh0OiAgIHRleHRIaXQsXG4gIHJlY3Q6ICAgZnVuY3Rpb24oZyxvLHgseSkgeyByZXR1cm4gdHJ1ZTsgfSwgLy8gYm91bmRzIHRlc3QgaXMgc3VmZmljaWVudFxuICBpbWFnZTogIGZ1bmN0aW9uKGcsbyx4LHkpIHsgcmV0dXJuIHRydWU7IH0sIC8vIGJvdW5kcyB0ZXN0IGlzIHN1ZmZpY2llbnRcbiAgZ3JvdXA6ICBmdW5jdGlvbihnLG8seCx5KSB7IHJldHVybiBvLmZpbGwgfHwgby5zdHJva2U7IH0sXG4gIHJ1bGU6ICAgZnVuY3Rpb24oZyxvLHgseSkge1xuICAgICAgICAgICAgaWYgKCFnLmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcnVsZVN0cm9rZShnLG8pOyByZXR1cm4gZy5pc1BvaW50SW5TdHJva2UoeCx5KTtcbiAgICAgICAgICB9LFxuICBsaW5lOiAgIGZ1bmN0aW9uKGcscyx4LHkpIHtcbiAgICAgICAgICAgIGlmICghZy5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxpbmVTdHJva2UoZyxzKTsgcmV0dXJuIGcuaXNQb2ludEluU3Ryb2tlKHgseSk7XG4gICAgICAgICAgfSxcbiAgYXJjOiAgICBmdW5jdGlvbihnLG8seCx5KSB7IGFyY1BhdGgoZyxvKTsgIHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfSxcbiAgYXJlYTogICBmdW5jdGlvbihnLHMseCx5KSB7IGFyZWFQYXRoKGcscyk7IHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfSxcbiAgcGF0aDogICBmdW5jdGlvbihnLG8seCx5KSB7IHBhdGhQYXRoKGcsbyk7IHJldHVybiBnLmlzUG9pbnRJblBhdGgoeCx5KTsgfSxcbiAgc3ltYm9sOiBmdW5jdGlvbihnLG8seCx5KSB7IHN5bWJvbFBhdGgoZyxvKTsgcmV0dXJuIGcuaXNQb2ludEluUGF0aCh4LHkpOyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzoge1xuICAgIGdyb3VwOiAgIGRyYXdHcm91cCxcbiAgICBhcmVhOiAgICBkcmF3T25lKGFyZWFQYXRoKSxcbiAgICBsaW5lOiAgICBkcmF3T25lKGxpbmVQYXRoKSxcbiAgICBhcmM6ICAgICBkcmF3QWxsKGFyY1BhdGgpLFxuICAgIHBhdGg6ICAgIGRyYXdBbGwocGF0aFBhdGgpLFxuICAgIHN5bWJvbDogIGRyYXdBbGwoc3ltYm9sUGF0aCksXG4gICAgcmVjdDogICAgZHJhd1JlY3QsXG4gICAgcnVsZTogICAgZHJhd1J1bGUsXG4gICAgdGV4dDogICAgZHJhd1RleHQsXG4gICAgaW1hZ2U6ICAgZHJhd0ltYWdlLFxuICAgIGRyYXdPbmU6IGRyYXdPbmUsIC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICAgIGRyYXdBbGw6IGRyYXdBbGwgIC8vIGV4cG9zZSBmb3IgZXh0ZW5zaWJpbGl0eVxuICB9LFxuICBwaWNrOiB7XG4gICAgZ3JvdXA6ICAgcGlja0dyb3VwLFxuICAgIGFyZWE6ICAgIHBpY2tBcmVhLFxuICAgIGxpbmU6ICAgIHBpY2tMaW5lLFxuICAgIGFyYzogICAgIHBpY2soaGl0VGVzdHMuYXJjKSxcbiAgICBwYXRoOiAgICBwaWNrKGhpdFRlc3RzLnBhdGgpLFxuICAgIHN5bWJvbDogIHBpY2soaGl0VGVzdHMuc3ltYm9sKSxcbiAgICByZWN0OiAgICBwaWNrKGhpdFRlc3RzLnJlY3QpLFxuICAgIHJ1bGU6ICAgIHBpY2soaGl0VGVzdHMucnVsZSksXG4gICAgdGV4dDogICAgcGljayhoaXRUZXN0cy50ZXh0KSxcbiAgICBpbWFnZTogICBwaWNrKGhpdFRlc3RzLmltYWdlKSxcbiAgICBwaWNrQWxsOiBwaWNrQWxsICAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgfVxufTsiLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi9jb3JlL0JvdW5kcycpO1xuXG4vLyBQYXRoIHBhcnNpbmcgYW5kIHJlbmRlcmluZyBjb2RlIHRha2VuIGZyb20gZmFicmljLmpzIC0tIFRoYW5rcyFcbnZhciBjbWRMZW5ndGggPSB7IG06MiwgbDoyLCBoOjEsIHY6MSwgYzo2LCBzOjQsIHE6NCwgdDoyLCBhOjcgfSxcbiAgICByZSA9IFsvKFtNTEhWQ1NRVEFabWxodmNzcXRhel0pL2csIC8jIyMvLCAvKFxcZCktL2csIC9cXHN8LHwjIyMvXTtcblxuZnVuY3Rpb24gcGFyc2UocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBjdXJyZW50UGF0aCxcbiAgICAgIGNodW5rcyxcbiAgICAgIHBhcnNlZDtcblxuICAvLyBGaXJzdCwgYnJlYWsgcGF0aCBpbnRvIGNvbW1hbmQgc2VxdWVuY2VcbiAgcGF0aCA9IHBhdGguc2xpY2UoKS5yZXBsYWNlKHJlWzBdLCAnIyMjJDEnKS5zcGxpdChyZVsxXSkuc2xpY2UoMSk7XG5cbiAgLy8gTmV4dCwgcGFyc2UgZWFjaCBjb21tYW5kIGluIHR1cm5cbiAgZm9yICh2YXIgaT0wLCBqLCBjaHVua3NQYXJzZWQsIGxlbj1wYXRoLmxlbmd0aDsgaTxsZW47IGkrKykge1xuICAgIGN1cnJlbnRQYXRoID0gcGF0aFtpXTtcbiAgICBjaHVua3MgPSBjdXJyZW50UGF0aC5zbGljZSgxKS50cmltKCkucmVwbGFjZShyZVsyXSwnJDEjIyMtJykuc3BsaXQocmVbM10pO1xuICAgIGNodW5rc1BhcnNlZCA9IFtjdXJyZW50UGF0aC5jaGFyQXQoMCldO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSBjaHVua3MubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICBwYXJzZWQgPSBwYXJzZUZsb2F0KGNodW5rc1tqXSk7XG4gICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgY2h1bmtzUGFyc2VkLnB1c2gocGFyc2VkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tbWFuZCA9IGNodW5rc1BhcnNlZFswXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBjb21tYW5kTGVuZ3RoID0gY21kTGVuZ3RoW2NvbW1hbmRdO1xuXG4gICAgaWYgKGNodW5rc1BhcnNlZC5sZW5ndGggLSAxID4gY29tbWFuZExlbmd0aCkge1xuICAgICAgZm9yICh2YXIgayA9IDEsIGtsZW4gPSBjaHVua3NQYXJzZWQubGVuZ3RoOyBrIDwga2xlbjsgayArPSBjb21tYW5kTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFsgY2h1bmtzUGFyc2VkWzBdIF0uY29uY2F0KGNodW5rc1BhcnNlZC5zbGljZShrLCBrICsgY29tbWFuZExlbmd0aCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChjaHVua3NQYXJzZWQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRyYXdBcmMoZywgeCwgeSwgY29vcmRzLCBib3VuZHMsIGwsIHQpIHtcbiAgdmFyIHJ4ID0gY29vcmRzWzBdO1xuICB2YXIgcnkgPSBjb29yZHNbMV07XG4gIHZhciByb3QgPSBjb29yZHNbMl07XG4gIHZhciBsYXJnZSA9IGNvb3Jkc1szXTtcbiAgdmFyIHN3ZWVwID0gY29vcmRzWzRdO1xuICB2YXIgZXggPSBjb29yZHNbNV07XG4gIHZhciBleSA9IGNvb3Jkc1s2XTtcbiAgdmFyIHNlZ3MgPSBhcmNUb1NlZ21lbnRzKGV4LCBleSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdCwgeCwgeSk7XG4gIGZvciAodmFyIGk9MDsgaTxzZWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJleiA9IHNlZ21lbnRUb0Jlemllci5hcHBseShudWxsLCBzZWdzW2ldKTtcbiAgICBnLmJlemllckN1cnZlVG8uYXBwbHkoZywgYmV6KTtcbiAgICBib3VuZHMuYWRkKGJlelswXS1sLCBiZXpbMV0tdCk7XG4gICAgYm91bmRzLmFkZChiZXpbMl0tbCwgYmV6WzNdLXQpO1xuICAgIGJvdW5kcy5hZGQoYmV6WzRdLWwsIGJlels1XS10KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZEFyYyh4LCB5LCBjb29yZHMsIGJvdW5kcykge1xuICB2YXIgcnggPSBjb29yZHNbMF07XG4gIHZhciByeSA9IGNvb3Jkc1sxXTtcbiAgdmFyIHJvdCA9IGNvb3Jkc1syXTtcbiAgdmFyIGxhcmdlID0gY29vcmRzWzNdO1xuICB2YXIgc3dlZXAgPSBjb29yZHNbNF07XG4gIHZhciBleCA9IGNvb3Jkc1s1XTtcbiAgdmFyIGV5ID0gY29vcmRzWzZdO1xuICB2YXIgc2VncyA9IGFyY1RvU2VnbWVudHMoZXgsIGV5LCByeCwgcnksIGxhcmdlLCBzd2VlcCwgcm90LCB4LCB5KTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZ3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYmV6ID0gc2VnbWVudFRvQmV6aWVyLmFwcGx5KG51bGwsIHNlZ3NbaV0pO1xuICAgIGJvdW5kcy5hZGQoYmV6WzBdLCBiZXpbMV0pO1xuICAgIGJvdW5kcy5hZGQoYmV6WzJdLCBiZXpbM10pO1xuICAgIGJvdW5kcy5hZGQoYmV6WzRdLCBiZXpbNV0pO1xuICB9XG59XG5cbnZhciBhcmNUb1NlZ21lbnRzQ2FjaGUgPSB7IH0sXG4gICAgc2VnbWVudFRvQmV6aWVyQ2FjaGUgPSB7IH0sXG4gICAgam9pbiA9IEFycmF5LnByb3RvdHlwZS5qb2luLFxuICAgIGFyZ3NTdHI7XG5cbi8vIENvcGllZCBmcm9tIElua3NjYXBlIHN2Z3RvcGRmLCB0aGFua3MhXG5mdW5jdGlvbiBhcmNUb1NlZ21lbnRzKHgsIHksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYLCBveCwgb3kpIHtcbiAgYXJnc1N0ciA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJdKSB7XG4gICAgcmV0dXJuIGFyY1RvU2VnbWVudHNDYWNoZVthcmdzU3RyXTtcbiAgfVxuXG4gIHZhciB0aCA9IHJvdGF0ZVggKiAoTWF0aC5QSS8xODApO1xuICB2YXIgc2luX3RoID0gTWF0aC5zaW4odGgpO1xuICB2YXIgY29zX3RoID0gTWF0aC5jb3ModGgpO1xuICByeCA9IE1hdGguYWJzKHJ4KTtcbiAgcnkgPSBNYXRoLmFicyhyeSk7XG4gIHZhciBweCA9IGNvc190aCAqIChveCAtIHgpICogMC41ICsgc2luX3RoICogKG95IC0geSkgKiAwLjU7XG4gIHZhciBweSA9IGNvc190aCAqIChveSAtIHkpICogMC41IC0gc2luX3RoICogKG94IC0geCkgKiAwLjU7XG4gIHZhciBwbCA9IChweCpweCkgLyAocngqcngpICsgKHB5KnB5KSAvIChyeSpyeSk7XG4gIGlmIChwbCA+IDEpIHtcbiAgICBwbCA9IE1hdGguc3FydChwbCk7XG4gICAgcnggKj0gcGw7XG4gICAgcnkgKj0gcGw7XG4gIH1cblxuICB2YXIgYTAwID0gY29zX3RoIC8gcng7XG4gIHZhciBhMDEgPSBzaW5fdGggLyByeDtcbiAgdmFyIGExMCA9ICgtc2luX3RoKSAvIHJ5O1xuICB2YXIgYTExID0gKGNvc190aCkgLyByeTtcbiAgdmFyIHgwID0gYTAwICogb3ggKyBhMDEgKiBveTtcbiAgdmFyIHkwID0gYTEwICogb3ggKyBhMTEgKiBveTtcbiAgdmFyIHgxID0gYTAwICogeCArIGEwMSAqIHk7XG4gIHZhciB5MSA9IGExMCAqIHggKyBhMTEgKiB5O1xuXG4gIHZhciBkID0gKHgxLXgwKSAqICh4MS14MCkgKyAoeTEteTApICogKHkxLXkwKTtcbiAgdmFyIHNmYWN0b3Jfc3EgPSAxIC8gZCAtIDAuMjU7XG4gIGlmIChzZmFjdG9yX3NxIDwgMCkgc2ZhY3Rvcl9zcSA9IDA7XG4gIHZhciBzZmFjdG9yID0gTWF0aC5zcXJ0KHNmYWN0b3Jfc3EpO1xuICBpZiAoc3dlZXAgPT0gbGFyZ2UpIHNmYWN0b3IgPSAtc2ZhY3RvcjtcbiAgdmFyIHhjID0gMC41ICogKHgwICsgeDEpIC0gc2ZhY3RvciAqICh5MS15MCk7XG4gIHZhciB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEteDApO1xuXG4gIHZhciB0aDAgPSBNYXRoLmF0YW4yKHkwLXljLCB4MC14Yyk7XG4gIHZhciB0aDEgPSBNYXRoLmF0YW4yKHkxLXljLCB4MS14Yyk7XG5cbiAgdmFyIHRoX2FyYyA9IHRoMS10aDA7XG4gIGlmICh0aF9hcmMgPCAwICYmIHN3ZWVwID09IDEpe1xuICAgIHRoX2FyYyArPSAyKk1hdGguUEk7XG4gIH0gZWxzZSBpZiAodGhfYXJjID4gMCAmJiBzd2VlcCA9PSAwKSB7XG4gICAgdGhfYXJjIC09IDIgKiBNYXRoLlBJO1xuICB9XG5cbiAgdmFyIHNlZ21lbnRzID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoX2FyYyAvIChNYXRoLlBJICogMC41ICsgMC4wMDEpKSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZ21lbnRzOyBpKyspIHtcbiAgICB2YXIgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ21lbnRzO1xuICAgIHZhciB0aDMgPSB0aDAgKyAoaSsxKSAqIHRoX2FyYyAvIHNlZ21lbnRzO1xuICAgIHJlc3VsdFtpXSA9IFt4YywgeWMsIHRoMiwgdGgzLCByeCwgcnksIHNpbl90aCwgY29zX3RoXTtcbiAgfVxuXG4gIHJldHVybiAoYXJjVG9TZWdtZW50c0NhY2hlW2FyZ3NTdHJdID0gcmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gc2VnbWVudFRvQmV6aWVyKGN4LCBjeSwgdGgwLCB0aDEsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGgpIHtcbiAgYXJnc1N0ciA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cl0pIHtcbiAgICByZXR1cm4gc2VnbWVudFRvQmV6aWVyQ2FjaGVbYXJnc1N0cl07XG4gIH1cblxuICB2YXIgYTAwID0gY29zX3RoICogcng7XG4gIHZhciBhMDEgPSAtc2luX3RoICogcnk7XG4gIHZhciBhMTAgPSBzaW5fdGggKiByeDtcbiAgdmFyIGExMSA9IGNvc190aCAqIHJ5O1xuXG4gIHZhciBjb3NfdGgwID0gTWF0aC5jb3ModGgwKTtcbiAgdmFyIHNpbl90aDAgPSBNYXRoLnNpbih0aDApO1xuICB2YXIgY29zX3RoMSA9IE1hdGguY29zKHRoMSk7XG4gIHZhciBzaW5fdGgxID0gTWF0aC5zaW4odGgxKTtcblxuICB2YXIgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICB2YXIgc2luX3RoX2gyID0gTWF0aC5zaW4odGhfaGFsZiAqIDAuNSk7XG4gIHZhciB0ID0gKDgvMykgKiBzaW5fdGhfaDIgKiBzaW5fdGhfaDIgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgdmFyIHgxID0gY3ggKyBjb3NfdGgwIC0gdCAqIHNpbl90aDA7XG4gIHZhciB5MSA9IGN5ICsgc2luX3RoMCArIHQgKiBjb3NfdGgwO1xuICB2YXIgeDMgPSBjeCArIGNvc190aDE7XG4gIHZhciB5MyA9IGN5ICsgc2luX3RoMTtcbiAgdmFyIHgyID0geDMgKyB0ICogc2luX3RoMTtcbiAgdmFyIHkyID0geTMgLSB0ICogY29zX3RoMTtcblxuICByZXR1cm4gKHNlZ21lbnRUb0JlemllckNhY2hlW2FyZ3NTdHJdID0gW1xuICAgIGEwMCAqIHgxICsgYTAxICogeTEsICBhMTAgKiB4MSArIGExMSAqIHkxLFxuICAgIGEwMCAqIHgyICsgYTAxICogeTIsICBhMTAgKiB4MiArIGExMSAqIHkyLFxuICAgIGEwMCAqIHgzICsgYTAxICogeTMsICBhMTAgKiB4MyArIGExMSAqIHkzXG4gIF0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXIoZywgcGF0aCwgbCwgdCkge1xuICB2YXIgY3VycmVudCwgLy8gY3VycmVudCBpbnN0cnVjdGlvblxuICAgICAgcHJldmlvdXMgPSBudWxsLFxuICAgICAgeCA9IDAsIC8vIGN1cnJlbnQgeFxuICAgICAgeSA9IDAsIC8vIGN1cnJlbnQgeVxuICAgICAgY29udHJvbFggPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeFxuICAgICAgY29udHJvbFkgPSAwLCAvLyBjdXJyZW50IGNvbnRyb2wgcG9pbnQgeVxuICAgICAgdGVtcFgsXG4gICAgICB0ZW1wWSxcbiAgICAgIHRlbXBDb250cm9sWCxcbiAgICAgIHRlbXBDb250cm9sWSxcbiAgICAgIGJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbiAgaWYgKGwgPT0gdW5kZWZpbmVkKSBsID0gMDtcbiAgaWYgKHQgPT0gdW5kZWZpbmVkKSB0ID0gMDtcblxuICBnLmJlZ2luUGF0aCgpO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPXBhdGgubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgY3VycmVudCA9IHBhdGhbaV07XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnRbMF0pIHsgLy8gZmlyc3QgbGV0dGVyXG5cbiAgICAgIGNhc2UgJ2wnOiAvLyBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTCc6IC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaCc6IC8vIGhvcml6b250YWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB4ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdIJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndic6IC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVic6IC8vIHZlcmljYWwgbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB5ID0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ20nOiAvLyBtb3ZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgeSArPSBjdXJyZW50WzJdO1xuICAgICAgICBnLm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnTSc6IC8vIG1vdmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBnLm1vdmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYyc6IC8vIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbNV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICB4ICsgY3VycmVudFsxXSArIGwsIC8vIHgxXG4gICAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LCAvLyB5MVxuICAgICAgICAgIGNvbnRyb2xYICsgbCwgLy8geDJcbiAgICAgICAgICBjb250cm9sWSArIHQsIC8vIHkyXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICBib3VuZHMuYWRkKHggKyBjdXJyZW50WzFdLCB5ICsgY3VycmVudFsyXSk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0MnOiAvLyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFs1XTtcbiAgICAgICAgeSA9IGN1cnJlbnRbNl07XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzRdO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB4ICsgbCxcbiAgICAgICAgICB5ICsgdFxuICAgICAgICApO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuXG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIqeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIqeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLmJlemllckN1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGN1cnJlbnRbMV0sIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gXCIuLi4gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcG9pbnQuXCJcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG5cbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndCc6IC8vIHNob3J0aGFuZCBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFsyXTtcblxuICAgICAgICBpZiAocHJldmlvdXNbMF0ubWF0Y2goL1tRcVR0XS8pID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJldmlvdXMgY29tbWFuZCBvciBpZiB0aGUgcHJldmlvdXMgY29tbWFuZCB3YXMgbm90IGEgUSwgcSwgVCBvciB0LFxuICAgICAgICAgIC8vIGFzc3VtZSB0aGUgY29udHJvbCBwb2ludCBpcyBjb2luY2lkZW50IHdpdGggdGhlIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgICBjb250cm9sWCA9IHg7XG4gICAgICAgICAgY29udHJvbFkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAndCcpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgdFxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSB0ZW1wQ29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIHRlbXBDb250cm9sWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c1swXSA9PT0gJ3EnKSB7XG4gICAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHMgZm9yIHFcbiAgICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICB9XG5cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuXG4gICAgICAgIGcucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHRlbXBYICsgbCxcbiAgICAgICAgICB0ZW1wWSArIHRcbiAgICAgICAgKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY29udHJvbFggKyBsLFxuICAgICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgeCArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgIF0sIGJvdW5kcywgbCwgdCk7XG4gICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGRyYXdBcmMoZywgeCArIGwsIHkgKyB0LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0gKyBsLFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB0XG4gICAgICAgIF0sIGJvdW5kcywgbCwgdCk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcy50cmFuc2xhdGUobCwgdCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kcyhwYXRoLCBib3VuZHMpIHtcbiAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFk7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgYm91bmRzLmFkZCh4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgYm91bmRzLmFkZCh4ICsgY3VycmVudFsxXSwgeSArIGN1cnJlbnRbMl0pO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdDJzogLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHgsIHkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQoeCArIGN1cnJlbnRbMV0sIHkgKyBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuXG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdTJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIqeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIqeSAtIGNvbnRyb2xZO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYm91bmRzLmFkZChjdXJyZW50WzFdLCBjdXJyZW50WzJdKTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIFwiLi4uIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvaW50LlwiXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUSc6IC8vIHF1YWRyYXRpY0N1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHRlbXBYID0gY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzRdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFsyXTtcbiAgICAgICAgYm91bmRzLmFkZChjb250cm9sWCwgY29udHJvbFkpO1xuICAgICAgICBib3VuZHMuYWRkKHRlbXBYLCB0ZW1wWSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG5cbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJvdW5kcy5hZGQoY29udHJvbFgsIGNvbnRyb2xZKTtcbiAgICAgICAgYm91bmRzLmFkZCh0ZW1wWCwgdGVtcFkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBib3VuZHMuYWRkKGNvbnRyb2xYLCBjb250cm9sWSk7XG4gICAgICAgIGJvdW5kcy5hZGQodGVtcFgsIHRlbXBZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBib3VuZEFyYyh4LCB5LCBbXG4gICAgICAgICAgY3VycmVudFsxXSxcbiAgICAgICAgICBjdXJyZW50WzJdLFxuICAgICAgICAgIGN1cnJlbnRbM10sXG4gICAgICAgICAgY3VycmVudFs0XSxcbiAgICAgICAgICBjdXJyZW50WzVdLFxuICAgICAgICAgIGN1cnJlbnRbNl0gKyB4LFxuICAgICAgICAgIGN1cnJlbnRbN10gKyB5XG4gICAgICAgIF0sIGJvdW5kcyk7XG4gICAgICAgIHggKz0gY3VycmVudFs2XTtcbiAgICAgICAgeSArPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGJvdW5kQXJjKHgsIHksIFtcbiAgICAgICAgICBjdXJyZW50WzFdLFxuICAgICAgICAgIGN1cnJlbnRbMl0sXG4gICAgICAgICAgY3VycmVudFszXSxcbiAgICAgICAgICBjdXJyZW50WzRdLFxuICAgICAgICAgIGN1cnJlbnRbNV0sXG4gICAgICAgICAgY3VycmVudFs2XSxcbiAgICAgICAgICBjdXJyZW50WzddXG4gICAgICAgIF0sIGJvdW5kcyk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3onOlxuICAgICAgY2FzZSAnWic6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gYXJlYShpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdO1xuICB2YXIgYXJlYSA9IGQzLnN2Zy5hcmVhKClcbiAgICAueChmdW5jdGlvbihkKSB7IHJldHVybiBkLng7IH0pXG4gICAgLnkxKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQueTsgfSlcbiAgICAueTAoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55ICsgZC5oZWlnaHQ7IH0pO1xuICBpZiAoby5pbnRlcnBvbGF0ZSkgYXJlYS5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlKTtcbiAgaWYgKG8udGVuc2lvbiAhPSBudWxsKSBhcmVhLnRlbnNpb24oby50ZW5zaW9uKTtcbiAgcmV0dXJuIGFyZWEoaXRlbXMpO1xufVxuXG5mdW5jdGlvbiBsaW5lKGl0ZW1zKSB7XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIHZhciBsaW5lID0gZDMuc3ZnLmxpbmUoKVxuICAgLngoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC54OyB9KVxuICAgLnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC55OyB9KTtcbiAgaWYgKG8uaW50ZXJwb2xhdGUpIGxpbmUuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSk7XG4gIGlmIChvLnRlbnNpb24gIT0gbnVsbCkgbGluZS50ZW5zaW9uKG8udGVuc2lvbik7XG4gIHJldHVybiBsaW5lKGl0ZW1zKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiAgcGFyc2UsXG4gIHJlbmRlcjogcmVuZGVyLFxuICBib3VuZHM6IGJvdW5kcyxcbiAgYXJlYTogICBhcmVhLFxuICBsaW5lOiAgIGxpbmVcbn07IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKSxcbiAgICBTVkdCdWlsZGVyID0gcmVxdWlyZSgnLi9zdmcnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2J1aWxkZXIgPSBudWxsO1xufTtcblxudmFyIHByb3RvdHlwZSA9IHJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX2J1aWxkZXIgPSBuZXcgU1ZHQnVpbGRlcigpO1xuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn1cblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZCkge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQgfHwge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgdGhpcy5fYXV0b3BhZCA9IGRsLmlzU3RyaW5nKHRoaXMuX3BhZGRpbmcpID8gMSA6IDA7XG5cbiAgdmFyIHcgPSB0aGlzLl93aWR0aCwgaCA9IHRoaXMuX2hlaWdodCwgcGFkID0gdGhpcy5fcGFkZGluZztcbiAgXG4gIC8vIChyZS0pY29uZmlndXJlIGJ1aWxkZXIgc2l6ZVxuICB0aGlzLl9idWlsZGVyLmluaXRpYWxpemUobnVsbCwgdywgaCwgcGFkKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgLy8gaGVhZGxlc3MgYWx3YXlzIGRyYXdzIHRoZSBlbnRpcmUgc2NlbmUsIGlnbm9yaW5nIGl0ZW1zXG4gIHRoaXMuX2J1aWxkZXIucmVuZGVyKHNjZW5lKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc3ZnID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9idWlsZGVyLnN2ZygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSByZW5kZXJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBSZW5kZXJlcjogcmVxdWlyZSgnLi9SZW5kZXJlcicpXG59O1xuIiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKTtcblxudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2dpZCA9IDA7IC8vIGdyb3VwIGlkIGNvdW50ZXIgZm9yIGQzIGRvbSBjb21wYXRcbiAgdGhpcy5fdGV4dCA9IHtcbiAgICBoZWFkOiBcIlwiLFxuICAgIHJvb3Q6IFwiXCIsXG4gICAgZm9vdDogXCJcIixcbiAgICBkZWZzOiBcIlwiLFxuICAgIGJvZHk6IFwiXCJcbiAgfTtcbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59O1xuXG5mdW5jdGlvbiBvcGVuKHRhZywgYXR0ciwgcmF3KSB7XG4gIHZhciBzID0gXCI8XCIgKyB0YWc7XG4gIGlmIChhdHRyKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGF0dHIpIHtcbiAgICAgIHZhciB2YWwgPSBhdHRyW2tleV07XG4gICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgcyArPSBcIiBcIiArIGtleSArICc9XCInICsgdmFsICsgJ1wiJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJhdykgcyArPSBcIiBcIiArIHJhdztcbiAgcmV0dXJuIHMgKyBcIj5cIjtcbn1cblxuZnVuY3Rpb24gY2xvc2UodGFnKSB7XG4gIHJldHVybiBcIjwvXCIgKyB0YWcgKyBcIj5cIjtcbn1cblxudmFyIHByb3RvdHlwZSA9IHJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgdywgaCwgcGFkKSB7XG4gIHZhciB0ID0gdGhpcy5fdGV4dDtcblxuICB0LmhlYWQgPSBvcGVuKCdzdmcnLCB7XG4gICAgXCJjbGFzc1wiOiAnbWFya3MnLFxuICAgIHdpZHRoOiB3ICsgcGFkLmxlZnQgKyBwYWQucmlnaHQsXG4gICAgaGVpZ2h0OiBoICsgcGFkLnRvcCArIHBhZC5ib3R0b20sXG4gIH0sIGNvbmZpZy5zdmdOYW1lc3BhY2UpO1xuXG4gIHQucm9vdCA9IG9wZW4oJ2cnLCB7XG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKCcgKyBwYWQubGVmdCArICcsJyArIHBhZC50b3AgKyAnKSdcbiAgfSk7XG5cbiAgdC5mb290ID0gY2xvc2UoJ2cnKSArIGNsb3NlKCdzdmcnKTtcbn07XG5cbnByb3RvdHlwZS5zdmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHQgPSB0aGlzLl90ZXh0O1xuICByZXR1cm4gdC5oZWFkICsgdC5kZWZzICsgdC5yb290ICsgdC5ib2R5ICsgdC5mb290O1xufTtcblxucHJvdG90eXBlLmJ1aWxkRGVmcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYWxsID0gdGhpcy5fZGVmcyxcbiAgICAgIGRncmFkID0gZGwua2V5cyhhbGwuZ3JhZGllbnQpLFxuICAgICAgZGNsaXAgPSBkbC5rZXlzKGFsbC5jbGlwcGluZyksXG4gICAgICBkZWZzID0gXCJcIiwgZ3JhZCwgY2xpcCwgaSwgajtcblxuICBmb3IgKGk9MDsgaTxkZ3JhZC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBpZCA9IGRncmFkW2ldLFxuICAgICAgICBkZWYgPSBhbGwuZ3JhZGllbnRbaWRdLFxuICAgICAgICBzdG9wcyA9IGRlZi5zdG9wcztcblxuICAgIGRlZnMgKz0gb3BlbihcImxpbmVhckdyYWRpZW50XCIsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHgxOiBkZWYueDEsXG4gICAgICB4MjogZGVmLngyLFxuICAgICAgeTE6IGRlZi55MSxcbiAgICAgIHkyOiBkZWYueTJcbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGo9MDsgajxzdG9wcy5sZW5ndGg7ICsraikge1xuICAgICAgZGVmcyArPSBvcGVuKFwic3RvcFwiLCB7XG4gICAgICAgIG9mZnNldDogc3RvcHNbal0ub2Zmc2V0LFxuICAgICAgICBcInN0b3AtY29sb3JcIjogc3RvcHNbal0uY29sb3JcbiAgICAgIH0pICsgY2xvc2UoXCJzdG9wXCIpO1xuICAgIH1cbiAgICBcbiAgICBkZWZzICs9IGNsb3NlKFwibGluZWFyR3JhZGllbnRcIik7XG4gIH1cbiAgXG4gIGZvciAoaT0wOyBpPGRjbGlwLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGlkID0gZGNsaXBbaV0sXG4gICAgICAgIGRlZiA9IGFsbC5jbGlwcGluZ1tpZF07XG5cbiAgICBkZWZzICs9IG9wZW4oXCJjbGlwUGF0aFwiLCB7aWQ6IGlkfSk7XG5cbiAgICBkZWZzICs9IG9wZW4oXCJyZWN0XCIsIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGRlZi53aWR0aCxcbiAgICAgIGhlaWdodDogZGVmLmhlaWdodFxuICAgIH0pICsgY2xvc2UoXCJyZWN0XCIpO1xuXG4gICAgZGVmcyArPSBjbG9zZShcImNsaXBQYXRoXCIpO1xuICB9XG4gIFxuICBpZiAoZGVmcy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIG9wZW4oXCJkZWZzXCIpICsgZGVmcyArIGNsb3NlKFwiZGVmc1wiKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJcIlxuICB9XG4gIHJldHVybiBkZWZzO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHRoaXMuX2dpZCA9IDA7IC8vIHJlc2V0IHRoZSBncm91cCBjb3VudGVyXG4gIHRoaXMuX3RleHQuYm9keSA9IHRoaXMuZHJhdyhzY2VuZSk7XG4gIHRoaXMuX3RleHQuZGVmcyA9IHRoaXMuYnVpbGREZWZzKCk7XG59O1xuXG5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBtZXRhID0gTUFSS1Nbc2NlbmUubWFya3R5cGVdO1xuICBpZiAoIW1ldGEpIHtcbiAgICByZXR1cm47IC8vIG5vIGtub3duIG1hcmt0eXBlIChlLmcuLCBhbiBpbnRlcmFjdG9yKVxuICB9XG4gIHZhciB0YWcgID0gbWV0YVswXSxcbiAgICAgIGF0dHIgPSBtZXRhWzFdLFxuICAgICAgbmVzdCA9IG1ldGFbMl0gfHwgZmFsc2UsXG4gICAgICBkYXRhID0gbmVzdCA/IFtzY2VuZS5pdGVtc10gOiBzY2VuZS5pdGVtcyxcbiAgICAgIGRlZnMgPSB0aGlzLl9kZWZzLFxuICAgICAgc3ZnID0gXCJcIiwgaSwgc3R5O1xuXG4gIHZhciBjbHMgPSBjc3NDbGFzcyhzY2VuZS5kZWYpO1xuXG4gIC8vIHN0eWxlIGxpdGVyYWxzIHRvIGV4YWN0bHkgbWF0Y2ggdGhlIGQzIGRvbVxuICB2YXIgc3R5bCA9IG51bGw7XG4gIGlmIChjbHMgPT09ICd0eXBlLXJ1bGUnIHx8IGNscyA9PT0gJ3R5cGUtcGF0aCcpXG4gICAgc3R5bCA9ICdzdHlsZT1cInBvaW50ZXItZXZlbnRzOiBub25lO1wiJztcbiAgZWxzZSBpZiAoY2xzICE9PSAndHlwZS1ncm91cCcpXG4gICAgc3R5bCA9ICdzdHlsZT1cIlwiJztcblxuICBzdmcgKz0gb3BlbignZycsIHtcbiAgICAnaWQnOiAnZycgKyArK3RoaXMuX2dpZCwgLy8gZDMgZG9tIGNvbXBhdFxuICAgICdjbGFzcyc6IGNzc0NsYXNzKHNjZW5lLmRlZilcbiAgfSwgc3R5bCk7XG5cbiAgZm9yIChpPTA7IGk8ZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBzdHkgPSB0YWcgPT09ICdnJyA/IG51bGwgOiBzdHlsZShkYXRhW2ldLCB0YWcsIGRlZnMpO1xuICAgIHN2ZyArPSBvcGVuKHRhZywgYXR0cihkYXRhW2ldLCBkZWZzKSwgc3R5KTtcbiAgICBpZiAodGFnID09PSAndGV4dCcpIHN2ZyArPSBlc2NhcGVfdGV4dChkYXRhW2ldLnRleHQpO1xuICAgIGlmICh0YWcgPT09ICdnJykgc3ZnICs9IHRoaXMuZHJhd0dyb3VwKGRhdGFbaV0pO1xuICAgIHN2ZyArPSBjbG9zZSh0YWcpO1xuICB9XG5cbiAgcmV0dXJuIHN2ZyArIGNsb3NlKCdnJyk7XG59O1xuXG5mdW5jdGlvbiBlc2NhcGVfdGV4dChzKSB7XG4gIHMgPSAocyA9PSBudWxsID8gXCJcIiA6IFN0cmluZyhzKSk7XG4gIHJldHVybiBzLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlX2ZvbnQocykge1xuICByZXR1cm4gU3RyaW5nKHMpLnJlcGxhY2UoL1xcXCIvZywgXCInXCIpO1xufVxuXG52YXIgTUFSS1MgPSB7XG4gIGdyb3VwOiAgWydnJywgZ3JvdXBdLFxuICBhcmVhOiAgIFsncGF0aCcsIGFyZWEsIHRydWVdLFxuICBsaW5lOiAgIFsncGF0aCcsIGxpbmUsIHRydWVdLFxuICBhcmM6ICAgIFsncGF0aCcsIGFyY10sXG4gIHBhdGg6ICAgWydwYXRoJywgcGF0aF0sXG4gIHN5bWJvbDogWydwYXRoJywgc3ltYm9sXSxcbiAgcmVjdDogICBbJ3JlY3QnLCByZWN0XSxcbiAgcnVsZTogICBbJ2xpbmUnLCBydWxlXSxcbiAgdGV4dDogICBbJ3RleHQnLCB0ZXh0XSxcbiAgaW1hZ2U6ICBbJ2ltYWdlJywgaW1hZ2VdXG59O1xuXG5wcm90b3R5cGUuZHJhd0dyb3VwID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIHN2ZyA9IFwiXCIsXG4gICAgICBheGVzID0gc2NlbmUuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGxlZ2VuZHMgPSBzY2VuZS5sZWdlbmRJdGVtcyB8fCBbXSxcbiAgICAgIGksIGosIG07XG5cbiAgc3ZnICs9IGdyb3VwX2JnKHNjZW5lKTtcblxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgPT09IFwiYmFja1wiKSB7XG4gICAgICBzdmcgKz0gdGhpcy5kcmF3KGF4ZXNbal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgc3ZnICs9IHRoaXMuZHJhdyhpdGVtc1tqXSk7XG4gIH1cbiAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyICE9PSBcImJhY2tcIikge1xuICAgICAgc3ZnICs9IHRoaXMuZHJhdyhheGVzW2pdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChqPTAsIG09bGVnZW5kcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgc3ZnICs9IHRoaXMuZHJhdyhsZWdlbmRzW2pdKTtcbiAgfVxuXG4gIHJldHVybiBzdmc7XG59O1xuXG4vLy9cblxuZnVuY3Rpb24gZ3JvdXBfYmcobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAwO1xuXG4gIHZhciBzdHlsID0gby5tYXJrLmludGVyYWN0aXZlID09PSBmYWxzZSA/XG4gICAgJ3N0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCInIDogXG4gICAgJ3N0eWxlPVwiXCInO1xuXG4gIHJldHVybiBvcGVuKCdyZWN0Jywge1xuICAgICdjbGFzcyc6ICdiYWNrZ3JvdW5kJ1xuICB9LCBzdHlsKSArIGNsb3NlKCdyZWN0Jyk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKG8sIGRlZnMpIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGF0dHIgPSB7dHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCJ9O1xuXG4gIGlmIChvLmNsaXApIHtcbiAgICB2YXIgYyA9IHt3aWR0aDogby53aWR0aCB8fCAwLCBoZWlnaHQ6IG8uaGVpZ2h0IHx8IDB9LFxuICAgICAgICBpZCA9IG8uY2xpcF9pZCB8fCAoby5jbGlwX2lkID0gXCJjbGlwXCIgKyBjbGlwX2lkKyspO1xuICAgIGRlZnMuY2xpcHBpbmdbaWRdID0gYztcbiAgICBhdHRyW1wiY2xpcC1wYXRoXCJdID0gXCJ1cmwoI1wiK2lkK1wiKVwiO1xuICB9XG5cbiAgcmV0dXJuIGF0dHI7XG59XG5cbmZ1bmN0aW9uIGFyYyhvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIsXG4gICAgZDogYXJjX3BhdGgobylcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXJlYShpdGVtcykge1xuICBpZiAoIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgcGF0aCA9IG8ub3JpZW50ID09PSBcImhvcml6b250YWxcIiA/IGFyZWFfcGF0aF9oIDogYXJlYV9wYXRoX3Y7XG4gIHBhdGhcbiAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCBcImxpbmVhclwiKVxuICAgIC50ZW5zaW9uKG8udGVuc2lvbiA9PSBudWxsID8gMC43IDogby50ZW5zaW9uKTtcbiAgcmV0dXJuIHtkOiBwYXRoKGl0ZW1zKX07XG59XG5cbmZ1bmN0aW9uIGxpbmUoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgbGluZV9wYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHJldHVybiB7ZDogbGluZV9wYXRoKGl0ZW1zKX07XG59XG5cbmZ1bmN0aW9uIHBhdGgobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiLFxuICAgIGQ6IG8ucGF0aFxuICB9O1xufVxuXG5mdW5jdGlvbiByZWN0KG8pIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBvLnggfHwgMCxcbiAgICB5OiBvLnkgfHwgMCxcbiAgICB3aWR0aDogby53aWR0aCB8fCAwLFxuICAgIGhlaWdodDogby5oZWlnaHQgfHwgMFxuICB9O1xufVxuXG5mdW5jdGlvbiBydWxlKG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwO1xuICByZXR1cm4ge1xuICAgIHgxOiB4MSxcbiAgICB5MTogeTEsXG4gICAgeDI6IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSxcbiAgICB5Mjogby55MiAhPSBudWxsID8gby55MiA6IHkxXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN5bWJvbChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHJldHVybiB7XG4gICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIsXG4gICAgZDogc3ltYm9sX3BhdGgobylcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW1hZ2Uobykge1xuICB2YXIgdyA9IG8ud2lkdGggfHwgKG8uaW1hZ2UgJiYgby5pbWFnZS53aWR0aCkgfHwgMCxcbiAgICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMCxcbiAgICAgIHggPSBvLnggLSAoby5hbGlnbiA9PT0gXCJjZW50ZXJcIlxuICAgICAgICA/IHcvMiA6IChvLmFsaWduID09PSBcInJpZ2h0XCIgPyB3IDogMCkpLFxuICAgICAgeSA9IG8ueSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICAgID8gaC8yIDogKG8uYmFzZWxpbmUgPT09IFwiYm90dG9tXCIgPyBoIDogMCkpLFxuICAgICAgdXJsID0gY29uZmlnLmJhc2VVUkwgKyBvLnVybDtcbiAgXG4gIHJldHVybiB7XG4gICAgXCJ4bGluazpocmVmXCI6IHVybCxcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgd2lkdGg6IHcsXG4gICAgaGVpZ2h0OiBoXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHQobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgZHggPSBvLmR4IHx8IDAsXG4gICAgICBkeSA9IG8uZHkgfHwgMCxcbiAgICAgIGEgPSBvLmFuZ2xlIHx8IDAsXG4gICAgICByID0gby5yYWRpdXMgfHwgMCxcbiAgICAgIGFsaWduID0gdGV4dEFsaWduW28uYWxpZ24gfHwgXCJsZWZ0XCJdLFxuICAgICAgYmFzZSA9IG8uYmFzZWxpbmU9PT1cInRvcFwiID8gXCIuOWVtXCJcbiAgICAgICAgICAgOiBvLmJhc2VsaW5lPT09XCJtaWRkbGVcIiA/IFwiLjM1ZW1cIiA6IDA7XG5cbiAgaWYgKHIpIHtcbiAgICB2YXIgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4ICsgZHgsXG4gICAgeTogeSArIGR5LFxuICAgICd0ZXh0LWFuY2hvcic6IGFsaWduLFxuICAgIHRyYW5zZm9ybTogYSA/IFwicm90YXRlKFwiK2ErXCIgXCIreCtcIixcIit5K1wiKVwiIDogbnVsbCxcbiAgICBkeTogYmFzZSA/IGJhc2UgOiBudWxsXG4gIH07XG59XG5cbi8vL1xuXG5mdW5jdGlvbiBjc3NDbGFzcyhkZWYpIHtcbiAgdmFyIGNscyA9IFwidHlwZS1cIiArIGRlZi50eXBlO1xuICBpZiAoZGVmLm5hbWUpIGNscyArPSBcIiBcIiArIGRlZi5uYW1lO1xuICByZXR1cm4gY2xzO1xufVxuXG5mdW5jdGlvbiB4KG8pICAgICB7IHJldHVybiBvLnggfHwgMDsgfVxuZnVuY3Rpb24geShvKSAgICAgeyByZXR1cm4gby55IHx8IDA7IH1cbmZ1bmN0aW9uIHh3KG8pICAgIHsgcmV0dXJuIG8ueCArIG8ud2lkdGggfHwgMDsgfVxuZnVuY3Rpb24geWgobykgICAgeyByZXR1cm4gby55ICsgby5oZWlnaHQgfHwgMDsgfVxuZnVuY3Rpb24ga2V5KG8pICAgeyByZXR1cm4gby5rZXk7IH1cbmZ1bmN0aW9uIHNpemUobykgIHsgcmV0dXJuIG8uc2l6ZT09bnVsbCA/IDEwMCA6IG8uc2l6ZTsgfVxuZnVuY3Rpb24gc2hhcGUobykgeyByZXR1cm4gby5zaGFwZSB8fCBcImNpcmNsZVwiOyB9XG5cbnZhciBhcmNfcGF0aCAgICA9IGQzLnN2Zy5hcmMoKSxcbiAgICBhcmVhX3BhdGhfdiA9IGQzLnN2Zy5hcmVhKCkueCh4KS55MSh5KS55MCh5aCksXG4gICAgYXJlYV9wYXRoX2ggPSBkMy5zdmcuYXJlYSgpLnkoeSkueDAoeHcpLngxKHgpLFxuICAgIGxpbmVfcGF0aCAgID0gZDMuc3ZnLmxpbmUoKS54KHgpLnkoeSksXG4gICAgc3ltYm9sX3BhdGggPSBkMy5zdmcuc3ltYm9sKCkudHlwZShzaGFwZSkuc2l6ZShzaXplKTtcblxudmFyIG1hcmtfaWQgPSAwLFxuICAgIGNsaXBfaWQgPSAwO1xuXG52YXIgdGV4dEFsaWduID0ge1xuICBcImxlZnRcIjogICBcInN0YXJ0XCIsXG4gIFwiY2VudGVyXCI6IFwibWlkZGxlXCIsXG4gIFwicmlnaHRcIjogIFwiZW5kXCJcbn07XG5cbnZhciBzdHlsZXMgPSB7XG4gIFwiZmlsbFwiOiAgICAgICAgICAgICBcImZpbGxcIixcbiAgXCJmaWxsT3BhY2l0eVwiOiAgICAgIFwiZmlsbC1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlXCI6ICAgICAgICAgICBcInN0cm9rZVwiLFxuICBcInN0cm9rZVdpZHRoXCI6ICAgICAgXCJzdHJva2Utd2lkdGhcIixcbiAgXCJzdHJva2VPcGFjaXR5XCI6ICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgXCJzdHJva2VDYXBcIjogICAgICAgIFwic3Ryb2tlLWxpbmVjYXBcIixcbiAgXCJzdHJva2VEYXNoXCI6ICAgICAgIFwic3Ryb2tlLWRhc2hhcnJheVwiLFxuICBcInN0cm9rZURhc2hPZmZzZXRcIjogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICBcIm9wYWNpdHlcIjogICAgICAgICAgXCJvcGFjaXR5XCJcbn07XG5cbnZhciBzdHlsZVByb3BzID0gZGwua2V5cyhzdHlsZXMpO1xuXG5mdW5jdGlvbiBzdHlsZShkLCB0YWcsIGRlZnMpIHtcbiAgdmFyIGksIG4sIHByb3AsIG5hbWUsIHZhbHVlLFxuICAgICAgbyA9IGQubWFyayA/IGQgOiBkLmxlbmd0aCA/IGRbMF0gOiBudWxsO1xuICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHMgPSBcIlwiO1xuXG4gIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgIHMgKz0gJ2ZvbnQ6ICcgKyBmb250U3RyaW5nKG8pICsgJzsnO1xuICB9XG4gIFxuICBmb3IgKGk9MCwgbj1zdHlsZVByb3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBwcm9wID0gc3R5bGVQcm9wc1tpXTtcbiAgICBuYW1lID0gc3R5bGVzW3Byb3BdO1xuICAgIHZhbHVlID0gb1twcm9wXTtcblxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJmaWxsXCIpIHMgKz0gJ2ZpbGw6IG5vbmU7JztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlLmlkKSB7XG4gICAgICAgIC8vIGVuc3VyZSBkZWZpbml0aW9uIGlzIGluY2x1ZGVkXG4gICAgICAgIGRlZnMuZ3JhZGllbnRbdmFsdWUuaWRdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gXCJ1cmwoXCIgKyB3aW5kb3cubG9jYXRpb24uaHJlZiArIFwiI1wiICsgdmFsdWUuaWQgKyBcIilcIjtcbiAgICAgIH1cbiAgICAgIHMgKz0gKHMubGVuZ3RoID8gJyAnIDogJycpICsgbmFtZSArICc6ICcgKyB2YWx1ZSArICc7J1xuICAgIH1cbiAgfVxuICBcbiAgLy8gbm90IHRoYXQgd2UgZG9uJ3QgZXhjbHVkZSBibGFuayBzdHlsZXMgZm9yIGQzIGRvbSBjb21wYXRcbiAgcmV0dXJuICdzdHlsZT1cIicrcysnXCInO1xufVxuXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgdmFyIGYgPSAoby5mb250U3R5bGUgPyBvLmZvbnRTdHlsZSArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRWYXJpYW50ID8gby5mb250VmFyaWFudCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRXZWlnaHQgPyBvLmZvbnRXZWlnaHQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250U2l6ZSAhPSBudWxsID8gby5mb250U2l6ZSA6IGNvbmZpZy5yZW5kZXIuZm9udFNpemUpICsgXCJweCBcIlxuICAgICsgKG8uZm9udCAmJiBlc2NhcGVfZm9udChvLmZvbnQpIHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG4gIHJldHVybiBmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbmRlcmVyO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpO1xuXG52YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGVsLCBtb2RlbCkge1xuICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICBpZiAoZWwpIHRoaXMuaW5pdGlhbGl6ZShlbCk7XG4gIGlmIChtb2RlbCkgdGhpcy5tb2RlbChtb2RlbCk7XG59O1xuXG5mdW5jdGlvbiBzdmdIYW5kbGVyKGhhbmRsZXIpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgIGl0ZW0gPSB0YXJnZXQuX19kYXRhX187XG5cbiAgICBpZiAoaXRlbSkgaXRlbSA9IGl0ZW0ubWFyayA/IGl0ZW0gOiBpdGVtWzBdO1xuICAgIGhhbmRsZXIuY2FsbCh0aGF0Ll9vYmosIGV2dCwgaXRlbSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV2ZW50TmFtZShuYW1lKSB7XG4gIHZhciBpID0gbmFtZS5pbmRleE9mKFwiLlwiKTtcbiAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCxpKTtcbn1cblxudmFyIHByb3RvdHlwZSA9IGhhbmRsZXIucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCBwYWQsIG9iaikge1xuICB0aGlzLl9lbCA9IGQzLnNlbGVjdChlbCkubm9kZSgpO1xuICB0aGlzLl9zdmcgPSBkMy5zZWxlY3QoZWwpLnNlbGVjdChcInN2Zy5tYXJrc1wiKS5ub2RlKCk7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHRoaXMuX29iaiA9IG9iaiB8fCBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLm1vZGVsID0gZnVuY3Rpb24obW9kZWwpIHtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fbW9kZWw7XG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoID0gdGhpcy5faGFuZGxlcnM7XG4gIHJldHVybiBkbC5rZXlzKGgpLnJlZHVjZShmdW5jdGlvbihhLCBrKSB7XG4gICAgcmV0dXJuIGhba10ucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHsgcmV0dXJuIChhLnB1c2goeCksIGEpOyB9LCBhKTtcbiAgfSwgW10pO1xufTtcblxuLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSBldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICBkb20gPSBkMy5zZWxlY3QodGhpcy5fc3ZnKS5ub2RlKCk7XG4gICAgICBcbiAgdmFyIHggPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgIHN2Zzogc3ZnSGFuZGxlci5jYWxsKHRoaXMsIGhhbmRsZXIpXG4gIH07XG4gIGggPSBoW25hbWVdIHx8IChoW25hbWVdID0gW10pO1xuICBoLnB1c2goeCk7XG5cbiAgZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgeC5zdmcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IGV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXSxcbiAgICAgIGRvbSA9IGQzLnNlbGVjdCh0aGlzLl9zdmcpLm5vZGUoKTtcbiAgaWYgKCFoKSByZXR1cm47XG4gIGZvciAodmFyIGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICBkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoW2ldLnN2Zyk7XG4gICAgICBoLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhbmRsZXI7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zdmcgPSBudWxsO1xuICB0aGlzLl9jdHggPSBudWxsO1xuICB0aGlzLl9lbCA9IG51bGw7XG4gIHRoaXMuX2RlZnMgPSB7XG4gICAgZ3JhZGllbnQ6IHt9LFxuICAgIGNsaXBwaW5nOiB7fVxuICB9O1xufTtcblxudmFyIHByb3RvdHlwZSA9IHJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkKSB7XG4gIHRoaXMuX2VsID0gZWw7XG5cbiAgLy8gcmVtb3ZlIGFueSBleGlzdGluZyBzdmcgZWxlbWVudFxuICBkMy5zZWxlY3QoZWwpLnNlbGVjdChcInN2Zy5tYXJrc1wiKS5yZW1vdmUoKTtcblxuICAvLyBjcmVhdGUgc3ZnIGVsZW1lbnQgYW5kIGluaXRpYWxpemUgYXR0cmlidXRlc1xuICB0aGlzLl9zdmcgPSBkMy5zZWxlY3QoZWwpXG4gICAgLmFwcGVuZChcInN2Z1wiKVxuICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJtYXJrc1wiKTtcbiAgXG4gIC8vIHNldCB0aGUgc3ZnIHJvb3QgZ3JvdXBcbiAgdGhpcy5fY3R4ID0gdGhpcy5fc3ZnLmFwcGVuZChcImdcIik7XG4gIFxuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWQpIHtcbiAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICB0aGlzLl9wYWRkaW5nID0gcGFkO1xuICBcbiAgdGhpcy5fc3ZnXG4gICAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZC5sZWZ0ICsgcGFkLnJpZ2h0KVxuICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCArIHBhZC50b3AgKyBwYWQuYm90dG9tKTtcbiAgICBcbiAgdGhpcy5fY3R4XG4gICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIrcGFkLmxlZnQrXCIsXCIrcGFkLnRvcCtcIilcIik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY3R4O1xufTtcblxucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsO1xufTtcblxucHJvdG90eXBlLnVwZGF0ZURlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgIGFsbCA9IHRoaXMuX2RlZnMsXG4gICAgICBkZ3JhZCA9IGRsLmtleXMoYWxsLmdyYWRpZW50KSxcbiAgICAgIGRjbGlwID0gZGwua2V5cyhhbGwuY2xpcHBpbmcpLFxuICAgICAgZGVmcyA9IHN2Zy5zZWxlY3QoXCJkZWZzXCIpLCBncmFkLCBjbGlwO1xuXG4gIC8vIGdldCBvciBjcmVhdGUgc3ZnIGRlZnMgYmxvY2tcbiAgaWYgKGRncmFkLmxlbmd0aD09PTAgJiYgZGNsaXAubGVuZ3RoPT0wKSB7IGRlZnMucmVtb3ZlKCk7IHJldHVybjsgfVxuICBpZiAoZGVmcy5lbXB0eSgpKSBkZWZzID0gc3ZnLmluc2VydChcImRlZnNcIiwgXCI6Zmlyc3QtY2hpbGRcIik7XG4gIFxuICBncmFkID0gZGVmcy5zZWxlY3RBbGwoXCJsaW5lYXJHcmFkaWVudFwiKS5kYXRhKGRncmFkLCBkbC5pZGVudGl0eSk7XG4gIGdyYWQuZW50ZXIoKS5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKS5hdHRyKFwiaWRcIiwgZGwuaWRlbnRpdHkpO1xuICBncmFkLmV4aXQoKS5yZW1vdmUoKTtcbiAgZ3JhZC5lYWNoKGZ1bmN0aW9uKGlkKSB7XG4gICAgdmFyIGRlZiA9IGFsbC5ncmFkaWVudFtpZF0sXG4gICAgICAgIGdyZCA9IGQzLnNlbGVjdCh0aGlzKTtcblxuICAgIC8vIHNldCBncmFkaWVudCBjb29yZGluYXRlc1xuICAgIGdyZC5hdHRyKHt4MTogZGVmLngxLCB4MjogZGVmLngyLCB5MTogZGVmLnkxLCB5MjogZGVmLnkyfSk7XG5cbiAgICAvLyBzZXQgZ3JhZGllbnQgc3RvcHNcbiAgICBzdG9wID0gZ3JkLnNlbGVjdEFsbChcInN0b3BcIikuZGF0YShkZWYuc3RvcHMpO1xuICAgIHN0b3AuZW50ZXIoKS5hcHBlbmQoXCJzdG9wXCIpO1xuICAgIHN0b3AuZXhpdCgpLnJlbW92ZSgpO1xuICAgIHN0b3AuYXR0cihcIm9mZnNldFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLm9mZnNldDsgfSlcbiAgICAgICAgLmF0dHIoXCJzdG9wLWNvbG9yXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuY29sb3I7IH0pO1xuICB9KTtcbiAgXG4gIGNsaXAgPSBkZWZzLnNlbGVjdEFsbChcImNsaXBQYXRoXCIpLmRhdGEoZGNsaXAsIGRsLmlkZW50aXR5KTtcbiAgY2xpcC5lbnRlcigpLmFwcGVuZChcImNsaXBQYXRoXCIpLmF0dHIoXCJpZFwiLCBkbC5pZGVudGl0eSk7XG4gIGNsaXAuZXhpdCgpLnJlbW92ZSgpO1xuICBjbGlwLmVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZGVmID0gYWxsLmNsaXBwaW5nW2lkXSxcbiAgICAgICAgY3IgPSBkMy5zZWxlY3QodGhpcykuc2VsZWN0QWxsKFwicmVjdFwiKS5kYXRhKFsxXSk7XG4gICAgY3IuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpO1xuICAgIGNyLmF0dHIoXCJ4XCIsIDApXG4gICAgICAuYXR0cihcInlcIiwgMClcbiAgICAgIC5hdHRyKFwid2lkdGhcIiwgZGVmLndpZHRoKVxuICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgZGVmLmhlaWdodCk7XG4gIH0pO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lLCBpdGVtcykge1xuICBtYXJrcy5jdXJyZW50ID0gdGhpcztcblxuICBpZiAoaXRlbXMpIHtcbiAgICB0aGlzLnJlbmRlckl0ZW1zKGRsLmFycmF5KGl0ZW1zKSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kcmF3KHRoaXMuX2N0eCwgc2NlbmUsIC0xKTtcbiAgfVxuICB0aGlzLnVwZGF0ZURlZnMoKTtcblxuIGRlbGV0ZSBtYXJrcy5jdXJyZW50O1xufTtcblxucHJvdG90eXBlLnJlbmRlckl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcbiAgdmFyIGl0ZW0sIG5vZGUsIHR5cGUsIG5lc3QsIGksIG47XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBub2RlID0gaXRlbS5fc3ZnO1xuICAgIHR5cGUgPSBpdGVtLm1hcmsubWFya3R5cGU7XG5cbiAgICBpdGVtID0gbWFya3MubmVzdGVkW3R5cGVdID8gaXRlbS5tYXJrLml0ZW1zIDogaXRlbTtcbiAgICBtYXJrcy51cGRhdGVbdHlwZV0uY2FsbChub2RlLCBpdGVtKTtcbiAgICBtYXJrcy5zdHlsZS5jYWxsKG5vZGUsIGl0ZW0pO1xuICB9XG59XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgaW5kZXgpIHtcbiAgdmFyIG1hcmt0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICByZW5kZXJlciA9IG1hcmtzLmRyYXdbbWFya3R5cGVdO1xuICByZW5kZXJlci5jYWxsKHRoaXMsIGN0eCwgc2NlbmUsIGluZGV4KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcmVuZGVyZXI7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpO1xuXG5mdW5jdGlvbiB4KG8pICAgICB7IHJldHVybiBvLnggfHwgMDsgfVxuZnVuY3Rpb24geShvKSAgICAgeyByZXR1cm4gby55IHx8IDA7IH1cbmZ1bmN0aW9uIHloKG8pICAgIHsgcmV0dXJuIG8ueSArIG8uaGVpZ2h0IHx8IDA7IH1cbmZ1bmN0aW9uIGtleShvKSAgIHsgcmV0dXJuIG8ua2V5OyB9XG5mdW5jdGlvbiBzaXplKG8pICB7IHJldHVybiBvLnNpemU9PW51bGwgPyAxMDAgOiBvLnNpemU7IH1cbmZ1bmN0aW9uIHNoYXBlKG8pIHsgcmV0dXJuIG8uc2hhcGUgfHwgXCJjaXJjbGVcIjsgfVxuICAgIFxudmFyIGFyY19wYXRoICAgID0gZDMuc3ZnLmFyYygpLFxuICAgIGFyZWFfcGF0aCAgID0gZDMuc3ZnLmFyZWEoKS54KHgpLnkxKHkpLnkwKHloKSxcbiAgICBsaW5lX3BhdGggICA9IGQzLnN2Zy5saW5lKCkueCh4KS55KHkpLFxuICAgIHN5bWJvbF9wYXRoID0gZDMuc3ZnLnN5bWJvbCgpLnR5cGUoc2hhcGUpLnNpemUoc2l6ZSk7XG5cbnZhciBtYXJrX2lkID0gMCxcbiAgICBjbGlwX2lkID0gMDtcblxudmFyIHRleHRBbGlnbiA9IHtcbiAgXCJsZWZ0XCI6ICAgXCJzdGFydFwiLFxuICBcImNlbnRlclwiOiBcIm1pZGRsZVwiLFxuICBcInJpZ2h0XCI6ICBcImVuZFwiXG59O1xuXG52YXIgc3R5bGVzID0ge1xuICBcImZpbGxcIjogICAgICAgICAgICAgXCJmaWxsXCIsXG4gIFwiZmlsbE9wYWNpdHlcIjogICAgICBcImZpbGwtb3BhY2l0eVwiLFxuICBcInN0cm9rZVwiOiAgICAgICAgICAgXCJzdHJva2VcIixcbiAgXCJzdHJva2VXaWR0aFwiOiAgICAgIFwic3Ryb2tlLXdpZHRoXCIsXG4gIFwic3Ryb2tlT3BhY2l0eVwiOiAgICBcInN0cm9rZS1vcGFjaXR5XCIsXG4gIFwic3Ryb2tlQ2FwXCI6ICAgICAgICBcInN0cm9rZS1saW5lY2FwXCIsXG4gIFwic3Ryb2tlRGFzaFwiOiAgICAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgXCJzdHJva2VEYXNoT2Zmc2V0XCI6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgXCJvcGFjaXR5XCI6ICAgICAgICAgIFwib3BhY2l0eVwiXG59O1xudmFyIHN0eWxlUHJvcHMgPSBkbC5rZXlzKHN0eWxlcyk7XG5cbmZ1bmN0aW9uIHN0eWxlKGQpIHtcbiAgdmFyIGksIG4sIHByb3AsIG5hbWUsIHZhbHVlLFxuICAgICAgbyA9IGQubWFyayA/IGQgOiBkLmxlbmd0aCA/IGRbMF0gOiBudWxsO1xuICBpZiAobyA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gIGZvciAoaT0wLCBuPXN0eWxlUHJvcHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHByb3AgPSBzdHlsZVByb3BzW2ldO1xuICAgIG5hbWUgPSBzdHlsZXNbcHJvcF07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSBcImZpbGxcIikgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCBcIm5vbmVcIiwgbnVsbCk7XG4gICAgICBlbHNlIHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5pZCkge1xuICAgICAgICAvLyBlbnN1cmUgZGVmaW5pdGlvbiBpcyBpbmNsdWRlZFxuICAgICAgICBtYXJrcy5jdXJyZW50Ll9kZWZzLmdyYWRpZW50W3ZhbHVlLmlkXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IFwidXJsKCNcIiArIHZhbHVlLmlkICsgXCIpXCI7XG4gICAgICB9XG4gICAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlK1wiXCIsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcmMobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgYXJjX3BhdGgobykpO1xufVxuXG5mdW5jdGlvbiBhcmVhKGl0ZW1zKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIHZhciBvID0gaXRlbXNbMF07XG4gIGFyZWFfcGF0aFxuICAgIC5pbnRlcnBvbGF0ZShvLmludGVycG9sYXRlIHx8IFwibGluZWFyXCIpXG4gICAgLnRlbnNpb24oby50ZW5zaW9uID09IG51bGwgPyAwLjcgOiBvLnRlbnNpb24pO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgYXJlYV9wYXRoKGl0ZW1zKSk7XG59XG5cbmZ1bmN0aW9uIGxpbmUoaXRlbXMpIHtcbiAgaWYgKCFpdGVtcy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIG8gPSBpdGVtc1swXTtcbiAgbGluZV9wYXRoXG4gICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgXCJsaW5lYXJcIilcbiAgICAudGVuc2lvbihvLnRlbnNpb24gPT0gbnVsbCA/IDAuNyA6IG8udGVuc2lvbik7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiZFwiLCBsaW5lX3BhdGgoaXRlbXMpKTtcbn1cblxuZnVuY3Rpb24gcGF0aChvKSB7XG4gIHZhciB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiK3grXCIsXCIreStcIilcIik7XG4gIGlmIChvLnBhdGggIT0gbnVsbCkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkXCIsIG8ucGF0aCk7XG59XG5cbmZ1bmN0aW9uIHJlY3Qobykge1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInhcIiwgby54IHx8IDApO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInlcIiwgby55IHx8IDApO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIG8ud2lkdGggfHwgMCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIG8uaGVpZ2h0IHx8IDApO1xufVxuXG5mdW5jdGlvbiBydWxlKG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIngxXCIsIHgxKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCB5MSk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieDJcIiwgby54MiAhPSBudWxsID8gby54MiA6IHgxKTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5MlwiLCBvLnkyICE9IG51bGwgPyBvLnkyIDogeTEpO1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIit4K1wiLFwiK3krXCIpXCIpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImRcIiwgc3ltYm9sX3BhdGgobykpO1xufVxuXG5mdW5jdGlvbiBpbWFnZShvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLndpZHRoKSB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IChvLmltYWdlICYmIG8uaW1hZ2UuaGVpZ2h0KSB8fCAwLFxuICAgICAgeCA9IG8ueCAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICAgID8gdy8yIDogKG8uYWxpZ24gPT09IFwicmlnaHRcIiA/IHcgOiAwKSksXG4gICAgICB5ID0gby55IC0gKG8uYmFzZWxpbmUgPT09IFwibWlkZGxlXCJcbiAgICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSksXG4gICAgICB1cmwgPSBjb25maWcuYmFzZVVSTCArIG8udXJsO1xuICBcbiAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJocmVmXCIsIHVybCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieFwiLCB4KTtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHcpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoKTtcbn1cbiAgXG5mdW5jdGlvbiBmb250U3RyaW5nKG8pIHtcbiAgcmV0dXJuIChvLmZvbnRTdHlsZSA/IG8uZm9udFN0eWxlICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFZhcmlhbnQgPyBvLmZvbnRWYXJpYW50ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFdlaWdodCA/IG8uZm9udFdlaWdodCArIFwiIFwiIDogXCJcIilcbiAgICArIChvLmZvbnRTaXplICE9IG51bGwgPyBvLmZvbnRTaXplIDogY29uZmlnLnJlbmRlci5mb250U2l6ZSkgKyBcInB4IFwiXG4gICAgKyAoby5mb250IHx8IGNvbmZpZy5yZW5kZXIuZm9udCk7XG59XG5cbmZ1bmN0aW9uIHRleHQobykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgZHggPSBvLmR4IHx8IDAsXG4gICAgICBkeSA9IG8uZHkgfHwgMCxcbiAgICAgIGEgPSBvLmFuZ2xlIHx8IDAsXG4gICAgICByID0gby5yYWRpdXMgfHwgMCxcbiAgICAgIGFsaWduID0gdGV4dEFsaWduW28uYWxpZ24gfHwgXCJsZWZ0XCJdLFxuICAgICAgYmFzZSA9IG8uYmFzZWxpbmU9PT1cInRvcFwiID8gXCIuOWVtXCJcbiAgICAgICAgICAgOiBvLmJhc2VsaW5lPT09XCJtaWRkbGVcIiA/IFwiLjM1ZW1cIiA6IDA7XG5cbiAgaWYgKHIpIHtcbiAgICB2YXIgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHggKyBkeCk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwieVwiLCB5ICsgZHkpO1xuICB0aGlzLnNldEF0dHJpYnV0ZShcInRleHQtYW5jaG9yXCIsIGFsaWduKTtcbiAgXG4gIGlmIChhKSB0aGlzLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBcInJvdGF0ZShcIithK1wiIFwiK3grXCIsXCIreStcIilcIik7XG4gIGVsc2UgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gIFxuICBpZiAoYmFzZSkgdGhpcy5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBiYXNlKTtcbiAgZWxzZSB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcImR5XCIpO1xuICBcbiAgdGhpcy50ZXh0Q29udGVudCA9IG8udGV4dDtcbiAgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShcImZvbnRcIiwgZm9udFN0cmluZyhvKSwgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMDtcbiAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIreCtcIixcIit5K1wiKVwiKTtcblxuICBpZiAoby5jbGlwKSB7XG4gICAgdmFyIGMgPSB7d2lkdGg6IG8ud2lkdGggfHwgMCwgaGVpZ2h0OiBvLmhlaWdodCB8fCAwfSxcbiAgICAgICAgaWQgPSBvLmNsaXBfaWQgfHwgKG8uY2xpcF9pZCA9IFwiY2xpcFwiICsgY2xpcF9pZCsrKTtcbiAgICBtYXJrcy5jdXJyZW50Ll9kZWZzLmNsaXBwaW5nW2lkXSA9IGM7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoI1wiK2lkK1wiKVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBncm91cF9iZyhvKSB7XG4gIHZhciB3ID0gby53aWR0aCB8fCAwLFxuICAgICAgaCA9IG8uaGVpZ2h0IHx8IDA7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdyk7XG4gIHRoaXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGgpO1xufVxuXG5mdW5jdGlvbiBjc3NDbGFzcyhkZWYpIHtcbiAgdmFyIGNscyA9IFwidHlwZS1cIiArIGRlZi50eXBlO1xuICBpZiAoZGVmLm5hbWUpIGNscyArPSBcIiBcIiArIGRlZi5uYW1lO1xuICByZXR1cm4gY2xzO1xufVxuXG5mdW5jdGlvbiBkcmF3KHRhZywgYXR0ciwgbmVzdCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgc2NlbmUsIGluZGV4KSB7XG4gICAgZHJhd01hcmsoZywgc2NlbmUsIGluZGV4LCBcIm1hcmtfXCIsIHRhZywgYXR0ciwgbmVzdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdNYXJrKGcsIHNjZW5lLCBpbmRleCwgcHJlZml4LCB0YWcsIGF0dHIsIG5lc3QpIHtcbiAgdmFyIGRhdGEgPSBuZXN0ID8gW3NjZW5lLml0ZW1zXSA6IHNjZW5lLml0ZW1zLFxuICAgICAgZXZ0cyA9IHNjZW5lLmludGVyYWN0aXZlPT09ZmFsc2UgPyBcIm5vbmVcIiA6IG51bGwsXG4gICAgICBncnBzID0gZy5ub2RlKCkuY2hpbGROb2RlcyxcbiAgICAgIG5vdEcgPSAodGFnICE9PSBcImdcIiksXG4gICAgICBwID0gKHAgPSBncnBzW2luZGV4KzFdKSAvLyArMSB0byBza2lwIGdyb3VwIGJhY2tncm91bmQgcmVjdFxuICAgICAgICA/IGQzLnNlbGVjdChwKVxuICAgICAgICA6IGcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAuYXR0cihcImlkXCIsIFwiZ1wiKygrK21hcmtfaWQpKVxuICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIGNzc0NsYXNzKHNjZW5lLmRlZikpO1xuXG4gIHZhciBpZCA9IHAuYXR0cihcImlkXCIpLFxuICAgICAgcyA9IFwiI1wiICsgaWQgKyBcIiA+IFwiICsgdGFnLFxuICAgICAgbSA9IHAuc2VsZWN0QWxsKHMpLmRhdGEoZGF0YSksXG4gICAgICBlID0gbS5lbnRlcigpLmFwcGVuZCh0YWcpO1xuXG4gIGlmIChub3RHKSB7XG4gICAgcC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIGV2dHMpO1xuICAgIGUuZWFjaChmdW5jdGlvbihkKSB7XG4gICAgICBpZiAoZC5tYXJrKSBkLl9zdmcgPSB0aGlzO1xuICAgICAgZWxzZSBpZiAoZC5sZW5ndGgpIGRbMF0uX3N2ZyA9IHRoaXM7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZS5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJjbGFzc1wiLFwiYmFja2dyb3VuZFwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsZXZ0cyk7XG4gIH1cbiAgXG4gIG0uZXhpdCgpLnJlbW92ZSgpO1xuICBtLmVhY2goYXR0cik7XG4gIGlmIChub3RHKSBtLmVhY2goc3R5bGUpO1xuICBlbHNlIHAuc2VsZWN0QWxsKHMrXCIgPiByZWN0LmJhY2tncm91bmRcIikuZWFjaChncm91cF9iZykuZWFjaChzdHlsZSk7XG4gIFxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZHJhd0dyb3VwKGcsIHNjZW5lLCBpbmRleCwgcHJlZml4KSB7ICAgIFxuICB2YXIgcCA9IGRyYXdNYXJrKGcsIHNjZW5lLCBpbmRleCwgcHJlZml4IHx8IFwiZ3JvdXBfXCIsIFwiZ1wiLCBncm91cCksXG4gICAgICBjID0gcC5ub2RlKCkuY2hpbGROb2RlcywgbiA9IGMubGVuZ3RoLCBpLCBqLCBtO1xuICBcbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgdmFyIGl0ZW1zID0gY1tpXS5fX2RhdGFfXy5pdGVtcyxcbiAgICAgICAgbGVnZW5kcyA9IGNbaV0uX19kYXRhX18ubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICAgIGF4ZXMgPSBjW2ldLl9fZGF0YV9fLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgICAgc2VsID0gZDMuc2VsZWN0KGNbaV0pLFxuICAgICAgICBpZHggPSAwO1xuXG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBpZiAoYXhlc1tqXS5kZWYubGF5ZXIgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGRyYXdHcm91cC5jYWxsKHRoaXMsIHNlbCwgYXhlc1tqXSwgaWR4KyssIFwiYXhpc19cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHRoaXMuZHJhdyhzZWwsIGl0ZW1zW2pdLCBpZHgrKyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0uZGVmLmxheWVyICE9PSBcImJhY2tcIikge1xuICAgICAgICBkcmF3R3JvdXAuY2FsbCh0aGlzLCBzZWwsIGF4ZXNbal0sIGlkeCsrLCBcImF4aXNfXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGRyYXdHcm91cC5jYWxsKHRoaXMsIHNlbCwgbGVnZW5kc1tqXSwgaWR4KyssIFwibGVnZW5kX1wiKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIG1hcmtzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVwZGF0ZToge1xuICAgIGdyb3VwOiAgIHJlY3QsXG4gICAgYXJlYTogICAgYXJlYSxcbiAgICBsaW5lOiAgICBsaW5lLFxuICAgIGFyYzogICAgIGFyYyxcbiAgICBwYXRoOiAgICBwYXRoLFxuICAgIHN5bWJvbDogIHN5bWJvbCxcbiAgICByZWN0OiAgICByZWN0LFxuICAgIHJ1bGU6ICAgIHJ1bGUsXG4gICAgdGV4dDogICAgdGV4dCxcbiAgICBpbWFnZTogICBpbWFnZVxuICB9LFxuICBuZXN0ZWQ6IHtcbiAgICBcImFyZWFcIjogdHJ1ZSxcbiAgICBcImxpbmVcIjogdHJ1ZVxuICB9LFxuICBzdHlsZTogc3R5bGUsXG4gIGRyYXc6IHtcbiAgICBncm91cDogICBkcmF3R3JvdXAsXG4gICAgYXJlYTogICAgZHJhdyhcInBhdGhcIiwgYXJlYSwgdHJ1ZSksXG4gICAgbGluZTogICAgZHJhdyhcInBhdGhcIiwgbGluZSwgdHJ1ZSksXG4gICAgYXJjOiAgICAgZHJhdyhcInBhdGhcIiwgYXJjKSxcbiAgICBwYXRoOiAgICBkcmF3KFwicGF0aFwiLCBwYXRoKSxcbiAgICBzeW1ib2w6ICBkcmF3KFwicGF0aFwiLCBzeW1ib2wpLFxuICAgIHJlY3Q6ICAgIGRyYXcoXCJyZWN0XCIsIHJlY3QpLFxuICAgIHJ1bGU6ICAgIGRyYXcoXCJsaW5lXCIsIHJ1bGUpLFxuICAgIHRleHQ6ICAgIGRyYXcoXCJ0ZXh0XCIsIHRleHQpLFxuICAgIGltYWdlOiAgIGRyYXcoXCJpbWFnZVwiLCBpbWFnZSksXG4gICAgZHJhdzogICAgZHJhdyAvLyBleHBvc2UgZm9yIGV4dGVuc2liaWxpdHlcbiAgfSxcbiAgY3VycmVudDogbnVsbFxufTsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBib3VuZHMgPSByZXF1aXJlKCcuLi91dGlsL2JvdW5kcycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBCb3VuZGVyKG1vZGVsLCBtYXJrKSB7XG4gIHRoaXMuX21hcmsgPSBtYXJrO1xuICByZXR1cm4gTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIG1vZGVsLmdyYXBoKS5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChCb3VuZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJib3VuZHNcIiwgdGhpcy5fbWFyay5tYXJrdHlwZV0pO1xuXG4gIGJvdW5kcy5tYXJrKHRoaXMuX21hcmspO1xuICBpZiAodGhpcy5fbWFyay5tYXJrdHlwZSA9PT0gQy5HUk9VUCkgXG4gICAgYm91bmRzLm1hcmsodGhpcy5fbWFyaywgbnVsbCwgZmFsc2UpO1xuXG4gIGlucHV0LnJlZmxvdyA9IHRydWU7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBFbmNvZGVyICA9IHJlcXVpcmUoJy4vRW5jb2RlcicpLFxuICAgIEJvdW5kZXIgID0gcmVxdWlyZSgnLi9Cb3VuZGVyJyksXG4gICAgSXRlbSAgPSByZXF1aXJlKCcuL0l0ZW0nKSxcbiAgICBwYXJzZURhdGEgPSByZXF1aXJlKCcuLi9wYXJzZS9kYXRhJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBCdWlsZGVyKCkgeyAgICBcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBwcm90byA9IChCdWlsZGVyLnByb3RvdHlwZSA9IG5ldyBOb2RlKCkpO1xuXG5wcm90by5pbml0ID0gZnVuY3Rpb24obW9kZWwsIGRlZiwgbWFyaywgcGFyZW50LCBwYXJlbnRfaWQsIGluaGVyaXRGcm9tKSB7XG4gIE5vZGUucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBtb2RlbC5ncmFwaClcbiAgICAucm91dGVyKHRydWUpXG4gICAgLmNvbGxlY3Rvcih0cnVlKTtcblxuICB0aGlzLl9tb2RlbCA9IG1vZGVsO1xuICB0aGlzLl9kZWYgICA9IGRlZjtcbiAgdGhpcy5fbWFyayAgPSBtYXJrO1xuICB0aGlzLl9mcm9tICA9IChkZWYuZnJvbSA/IGRlZi5mcm9tLmRhdGEgOiBudWxsKSB8fCBpbmhlcml0RnJvbTtcbiAgdGhpcy5fZHMgICAgPSBkbC5pc1N0cmluZyh0aGlzLl9mcm9tKSA/IG1vZGVsLmRhdGEodGhpcy5fZnJvbSkgOiBudWxsO1xuICB0aGlzLl9tYXAgICA9IHt9O1xuXG4gIHRoaXMuX3JldmlzZXMgPSBmYWxzZTsgIC8vIFNob3VsZCBzY2VuZWdyYXBoIGl0ZW1zIHRyYWNrIF9wcmV2P1xuXG4gIG1hcmsuZGVmID0gZGVmO1xuICBtYXJrLm1hcmt0eXBlID0gZGVmLnR5cGU7XG4gIG1hcmsuaW50ZXJhY3RpdmUgPSAhKGRlZi5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpO1xuICBtYXJrLml0ZW1zID0gW107XG5cbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9wYXJlbnRfaWQgPSBwYXJlbnRfaWQ7XG5cbiAgaWYoZGVmLmZyb20gJiYgKGRlZi5mcm9tLm1hcmsgfHwgZGVmLmZyb20udHJhbnNmb3JtIHx8IGRlZi5mcm9tLm1vZGlmeSkpIHtcbiAgICBpbmxpbmVEcy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgLy8gTm9uLWdyb3VwIG1hcmsgYnVpbGRlcnMgYXJlIHN1cGVyIG5vZGVzLiBFbmNvZGVyIGFuZCBCb3VuZGVyIHJlbWFpbiBcbiAgLy8gc2VwYXJhdGUgb3BlcmF0b3JzIGJ1dCBhcmUgZW1iZWRkZWQgYW5kIGNhbGxlZCBieSBCdWlsZGVyLmV2YWx1YXRlLlxuICB0aGlzLl9pc1N1cGVyID0gKHRoaXMuX2RlZi50eXBlICE9PSBDLkdST1VQKTsgXG4gIHRoaXMuX2VuY29kZXIgPSBuZXcgRW5jb2Rlcih0aGlzLl9tb2RlbCwgdGhpcy5fbWFyayk7XG4gIHRoaXMuX2JvdW5kZXIgPSBuZXcgQm91bmRlcih0aGlzLl9tb2RlbCwgdGhpcy5fbWFyayk7XG5cbiAgaWYodGhpcy5fZHMpIHsgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuREFUQSwgdGhpcy5fZnJvbSk7IH1cblxuICAvLyBTaW5jZSBCdWlsZGVycyBhcmUgc3VwZXIgbm9kZXMsIGNvcHkgb3ZlciBlbmNvZGVyIGRlcGVuZGVuY2llc1xuICAvLyAoYm91bmRlciBoYXMgbm8gcmVnaXN0ZXJlZCBkZXBlbmRlbmNpZXMpLlxuICB0aGlzLmRlcGVuZGVuY3koQy5EQVRBLCB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5EQVRBKSk7XG4gIHRoaXMuZGVwZW5kZW5jeShDLlNDQUxFUywgdGhpcy5fZW5jb2Rlci5kZXBlbmRlbmN5KEMuU0NBTEVTKSk7XG4gIHRoaXMuZGVwZW5kZW5jeShDLlNJR05BTFMsIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNJR05BTFMpKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnJldmlzZXMgPSBmdW5jdGlvbihwKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmV2aXNlcztcblxuICAvLyBJZiB3ZSd2ZSBub3QgbmVlZGVkIHByZXYgaW4gdGhlIHBhc3QsIGJ1dCBhIG5ldyBpbmxpbmUgZHMgbmVlZHMgaXQgbm93XG4gIC8vIGVuc3VyZSBleGlzdGluZyBpdGVtcyBoYXZlIHByZXYgc2V0LlxuICBpZighdGhpcy5fcmV2aXNlcyAmJiBwKSB7XG4gICAgdGhpcy5faXRlbXMuZm9yRWFjaChmdW5jdGlvbihkKSB7IGlmKGQuX3ByZXYgPT09IHVuZGVmaW5lZCkgZC5fcHJldiA9IEMuU0VOVElORUw7IH0pO1xuICB9XG5cbiAgdGhpcy5fcmV2aXNlcyA9IHRoaXMuX3JldmlzZXMgfHwgcDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBSZWFjdGl2ZSBnZW9tZXRyeSBhbmQgbWFyay1sZXZlbCB0cmFuc2Zvcm1hdGlvbnMgYXJlIGhhbmRsZWQgaGVyZSBcbi8vIGJlY2F1c2UgdGhleSBuZWVkIHRoZWlyIGdyb3VwJ3MgZGF0YS1qb2luZWQgY29udGV4dC4gXG5mdW5jdGlvbiBpbmxpbmVEcygpIHtcbiAgdmFyIGZyb20gPSB0aGlzLl9kZWYuZnJvbSxcbiAgICAgIGdlb20gPSBmcm9tLm1hcmssXG4gICAgICBzcmMsIG5hbWUsIHNwZWMsIHNpYmxpbmcsIG91dHB1dDtcblxuICBpZihnZW9tKSB7XG4gICAgbmFtZSA9IFtcInZnXCIsIHRoaXMuX3BhcmVudF9pZCwgZ2VvbV0uam9pbihcIl9cIik7XG4gICAgc3BlYyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0cmFuc2Zvcm06IGZyb20udHJhbnNmb3JtLCBcbiAgICAgIG1vZGlmeTogZnJvbS5tb2RpZnlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNyYyA9IHRoaXMuX21vZGVsLmRhdGEodGhpcy5fZnJvbSk7XG4gICAgbmFtZSA9IFtcInZnXCIsIHRoaXMuX2Zyb20sIHRoaXMuX2RlZi50eXBlLCBzcmMubGlzdGVuZXJzKHRydWUpLmxlbmd0aF0uam9pbihcIl9cIik7XG4gICAgc3BlYyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzb3VyY2U6IHRoaXMuX2Zyb20sXG4gICAgICB0cmFuc2Zvcm06IGZyb20udHJhbnNmb3JtLFxuICAgICAgbW9kaWZ5OiBmcm9tLm1vZGlmeVxuICAgIH07XG4gIH1cblxuICB0aGlzLl9mcm9tID0gbmFtZTtcbiAgdGhpcy5fZHMgPSBwYXJzZURhdGEuZGF0YXNvdXJjZSh0aGlzLl9tb2RlbCwgc3BlYyk7XG4gIHZhciByZXZpc2VzID0gdGhpcy5fZHMucmV2aXNlcygpO1xuXG4gIGlmKGdlb20pIHtcbiAgICBzaWJsaW5nID0gdGhpcy5zaWJsaW5nKGdlb20pLnJldmlzZXMocmV2aXNlcyk7XG4gICAgaWYoc2libGluZy5faXNTdXBlcikgc2libGluZy5hZGRMaXN0ZW5lcih0aGlzLl9kcy5saXN0ZW5lcigpKTtcbiAgICBlbHNlIHNpYmxpbmcuX2JvdW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fZHMubGlzdGVuZXIoKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSBhIG5ldyBkYXRhc291cmNlIGJ1dCBpdCBpcyBlbXB0eSBhc1xuICAgIC8vIHRoZSBwcm9wYWdhdGlvbiBjeWNsZSBoYXMgYWxyZWFkeSBjcm9zc2VkIHRoZSBkYXRhc291cmNlcy4gXG4gICAgLy8gU28sIHdlIHJlcHVsc2UganVzdCB0aGlzIGRhdGFzb3VyY2UuIFRoaXMgc2hvdWxkIGJlIHNhZmVcbiAgICAvLyBhcyB0aGUgZHMgaXNuJ3QgY29ubmVjdGVkIHRvIHRoZSBzY2VuZWdyYXBoIHlldC5cbiAgICBcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fZHMuc291cmNlKCkucmV2aXNlcyhyZXZpc2VzKS5sYXN0KCk7XG4gICAgICAgIGlucHV0ICA9IGNoYW5nZXNldC5jcmVhdGUob3V0cHV0KTtcblxuICAgIGlucHV0LmFkZCA9IG91dHB1dC5hZGQ7XG4gICAgaW5wdXQubW9kID0gb3V0cHV0Lm1vZDtcbiAgICBpbnB1dC5yZW0gPSBvdXRwdXQucmVtO1xuICAgIGlucHV0LnN0YW1wID0gbnVsbDtcbiAgICB0aGlzLl9ncmFwaC5wcm9wYWdhdGUoaW5wdXQsIHRoaXMuX2RzLmxpc3RlbmVyKCkpO1xuICB9XG59XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpc107XG59O1xuXG5wcm90by5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcblxuICB0aGlzLl9tb2RlbC5ncmFwaC5jb25uZWN0KHRoaXMucGlwZWxpbmUoKSk7XG4gIHRoaXMuX2VuY29kZXIuZGVwZW5kZW5jeShDLlNDQUxFUykuZm9yRWFjaChmdW5jdGlvbihzKSB7XG4gICAgYnVpbGRlci5fcGFyZW50LnNjYWxlKHMpLmFkZExpc3RlbmVyKGJ1aWxkZXIpO1xuICB9KTtcblxuICBpZih0aGlzLl9wYXJlbnQpIHtcbiAgICBpZih0aGlzLl9pc1N1cGVyKSB0aGlzLmFkZExpc3RlbmVyKHRoaXMuX3BhcmVudC5fY29sbGVjdG9yKTtcbiAgICBlbHNlIHRoaXMuX2JvdW5kZXIuYWRkTGlzdGVuZXIodGhpcy5fcGFyZW50Ll9jb2xsZWN0b3IpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWlsZGVyID0gdGhpcztcbiAgaWYoIXRoaXMuX2xpc3RlbmVycy5sZW5ndGgpIHJldHVybiB0aGlzO1xuXG4gIE5vZGUucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbiAgdGhpcy5fbW9kZWwuZ3JhcGguZGlzY29ubmVjdCh0aGlzLnBpcGVsaW5lKCkpO1xuICB0aGlzLl9lbmNvZGVyLmRlcGVuZGVuY3koQy5TQ0FMRVMpLmZvckVhY2goZnVuY3Rpb24ocykge1xuICAgIGJ1aWxkZXIuX3BhcmVudC5zY2FsZShzKS5yZW1vdmVMaXN0ZW5lcihidWlsZGVyKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uc2libGluZyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIHRoaXMuX3BhcmVudC5jaGlsZChuYW1lLCB0aGlzLl9wYXJlbnRfaWQpO1xufTtcblxucHJvdG8uZXZhbHVhdGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiYnVpbGRpbmdcIiwgdGhpcy5fZnJvbSwgdGhpcy5fZGVmLnR5cGVdKTtcblxuICB2YXIgb3V0cHV0LCBmdWxsVXBkYXRlLCBmY3MsIGRhdGE7XG5cbiAgaWYodGhpcy5fZHMpIHtcbiAgICBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KTtcblxuICAgIC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGFueSBlbmNvZGVyIGRlcGVuZGVuY2llcyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAvLyBIb3dldmVyLCB0aGUgZW5jb2RlcidzIGRhdGEgc291cmNlIHdpbGwgbGlrZWx5IGJlIHVwZGF0ZWQsIGFuZCBzaG91bGRuJ3RcbiAgICAvLyB0cmlnZ2VyIGFsbCBpdGVtcyB0byBtb2QuXG4gICAgZGF0YSA9IGRsLmR1cGxpY2F0ZShvdXRwdXQuZGF0YSk7XG4gICAgZGVsZXRlIG91dHB1dC5kYXRhW3RoaXMuX2RzLm5hbWUoKV07XG4gICAgZnVsbFVwZGF0ZSA9IHRoaXMuX2VuY29kZXIucmVldmFsdWF0ZShvdXRwdXQpO1xuICAgIG91dHB1dC5kYXRhID0gZGF0YTtcblxuICAgIC8vIElmIGEgc2NhbGUgb3Igc2lnbmFsIGluIHRoZSB1cGRhdGUgcHJvcHNldCBoYXMgYmVlbiB1cGRhdGVkLCBcbiAgICAvLyBzZW5kIGZvcndhcmQgYWxsIGl0ZW1zIGZvciByZWVuY29kaW5nIGlmIHdlIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICBpZihmdWxsVXBkYXRlKSBvdXRwdXQubW9kID0gdGhpcy5fbWFyay5pdGVtcy5zbGljZSgpO1xuXG4gICAgZmNzID0gdGhpcy5fZHMubGFzdCgpO1xuICAgIGlmKCFmY3MpIHtcbiAgICAgIG91dHB1dC5yZWZsb3cgPSB0cnVlXG4gICAgfSBlbHNlIGlmKGZjcy5zdGFtcCA+IHRoaXMuX3N0YW1wKSB7XG4gICAgICBvdXRwdXQgPSBqb2luRGF0YXNvdXJjZS5jYWxsKHRoaXMsIGZjcywgdGhpcy5fZHMudmFsdWVzKCksIGZ1bGxVcGRhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmdWxsVXBkYXRlID0gdGhpcy5fZW5jb2Rlci5yZWV2YWx1YXRlKGlucHV0KTtcbiAgICBkYXRhID0gZGwuaXNGdW5jdGlvbih0aGlzLl9kZWYuZnJvbSkgPyB0aGlzLl9kZWYuZnJvbSgpIDogW0MuU0VOVElORUxdO1xuICAgIG91dHB1dCA9IGpvaW5WYWx1ZXMuY2FsbCh0aGlzLCBpbnB1dCwgZGF0YSwgZnVsbFVwZGF0ZSk7XG4gIH1cblxuICBvdXRwdXQgPSB0aGlzLl9ncmFwaC5ldmFsdWF0ZShvdXRwdXQsIHRoaXMuX2VuY29kZXIpO1xuICByZXR1cm4gdGhpcy5faXNTdXBlciA/IHRoaXMuX2dyYXBoLmV2YWx1YXRlKG91dHB1dCwgdGhpcy5fYm91bmRlcikgOiBvdXRwdXQ7XG59O1xuXG5mdW5jdGlvbiBuZXdJdGVtKCkge1xuICB2YXIgcHJldiA9IHRoaXMuX3JldmlzZXMgPyBudWxsIDogdW5kZWZpbmVkLFxuICAgICAgaXRlbSA9IHR1cGxlLmluZ2VzdChuZXcgSXRlbSh0aGlzLl9tYXJrKSwgcHJldik7XG5cbiAgLy8gRm9yIHRoZSByb290IG5vZGUncyBpdGVtXG4gIGlmKHRoaXMuX2RlZi53aWR0aCkgIHR1cGxlLnNldChpdGVtLCBcIndpZHRoXCIsICB0aGlzLl9kZWYud2lkdGgpO1xuICBpZih0aGlzLl9kZWYuaGVpZ2h0KSB0dXBsZS5zZXQoaXRlbSwgXCJoZWlnaHRcIiwgdGhpcy5fZGVmLmhlaWdodCk7XG4gIHJldHVybiBpdGVtO1xufTtcblxuZnVuY3Rpb24gam9pbihkYXRhLCBrZXlmLCBuZXh0LCBvdXRwdXQsIHByZXYsIG1vZCkge1xuICB2YXIgaSwga2V5LCBsZW4sIGl0ZW0sIGRhdHVtLCBlbnRlcjtcblxuICBmb3IoaT0wLCBsZW49ZGF0YS5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBkYXR1bSA9IGRhdGFbaV07XG4gICAgaXRlbSAgPSBrZXlmID8gdGhpcy5fbWFwW2tleSA9IGtleWYoZGF0dW0pXSA6IHByZXZbaV07XG4gICAgZW50ZXIgPSBpdGVtID8gZmFsc2UgOiAoaXRlbSA9IG5ld0l0ZW0uY2FsbCh0aGlzKSwgdHJ1ZSk7XG4gICAgaXRlbS5zdGF0dXMgPSBlbnRlciA/IEMuRU5URVIgOiBDLlVQREFURTtcbiAgICBpdGVtLmRhdHVtID0gZGF0dW07XG4gICAgdHVwbGUuc2V0KGl0ZW0sIFwia2V5XCIsIGtleSk7XG4gICAgdGhpcy5fbWFwW2tleV0gPSBpdGVtO1xuICAgIG5leHQucHVzaChpdGVtKTtcbiAgICBpZihlbnRlcikgb3V0cHV0LmFkZC5wdXNoKGl0ZW0pO1xuICAgIGVsc2UgaWYoIW1vZCB8fCAobW9kICYmIG1vZFtkYXR1bS5faWRdKSkgb3V0cHV0Lm1vZC5wdXNoKGl0ZW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGpvaW5EYXRhc291cmNlKGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKSB7XG4gIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIGtleWYgPSBrZXlGdW5jdGlvbih0aGlzLl9kZWYua2V5IHx8IFwiX2lkXCIpLFxuICAgICAgYWRkID0gaW5wdXQuYWRkLCBcbiAgICAgIG1vZCA9IGlucHV0Lm1vZCwgXG4gICAgICByZW0gPSBpbnB1dC5yZW0sXG4gICAgICBuZXh0ID0gW10sXG4gICAgICBpLCBrZXksIGxlbiwgaXRlbSwgZGF0dW0sIGVudGVyO1xuXG4gIC8vIEJ1aWxkIHJlbXMgZmlyc3QsIGFuZCBwdXQgdGhlbSBhdCB0aGUgaGVhZCBvZiB0aGUgbmV4dCBpdGVtc1xuICAvLyBUaGVuIGJ1aWxkIHRoZSByZXN0IG9mIHRoZSBkYXRhIHZhbHVlcyAod2hpY2ggd29uJ3QgY29udGFpbiByZW0pLlxuICAvLyBUaGlzIHdpbGwgcHJlc2VydmUgdGhlIHNvcnQgb3JkZXIgd2l0aG91dCBuZWVkaW5nIGFueXRoaW5nIGV4dHJhLlxuXG4gIGZvcihpPTAsIGxlbj1yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHRoaXMuX21hcFtrZXkgPSBrZXlmKHJlbVtpXSldO1xuICAgIGl0ZW0uc3RhdHVzID0gQy5FWElUO1xuICAgIG5leHQucHVzaChpdGVtKTtcbiAgICBvdXRwdXQucmVtLnB1c2goaXRlbSk7XG4gICAgdGhpcy5fbWFwW2tleV0gPSBudWxsO1xuICB9XG5cbiAgam9pbi5jYWxsKHRoaXMsIGRhdGEsIGtleWYsIG5leHQsIG91dHB1dCwgbnVsbCwgdHVwbGUuaWRNYXAoZnVsbFVwZGF0ZSA/IGRhdGEgOiBtb2QpKTtcblxuICByZXR1cm4gKHRoaXMuX21hcmsuaXRlbXMgPSBuZXh0LCBvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBqb2luVmFsdWVzKGlucHV0LCBkYXRhLCBmdWxsVXBkYXRlKSB7XG4gIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIGtleWYgPSBrZXlGdW5jdGlvbih0aGlzLl9kZWYua2V5KSxcbiAgICAgIHByZXYgPSB0aGlzLl9tYXJrLml0ZW1zIHx8IFtdLFxuICAgICAgbmV4dCA9IFtdLFxuICAgICAgaSwga2V5LCBsZW4sIGl0ZW0sIGRhdHVtLCBlbnRlcjtcblxuICBmb3IgKGk9MCwgbGVuPXByZXYubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHByZXZbaV07XG4gICAgaXRlbS5zdGF0dXMgPSBDLkVYSVQ7XG4gICAgaWYgKGtleWYpIHRoaXMuX21hcFtpdGVtLmtleV0gPSBpdGVtO1xuICB9XG4gIFxuICBqb2luLmNhbGwodGhpcywgZGF0YSwga2V5ZiwgbmV4dCwgb3V0cHV0LCBwcmV2LCBmdWxsVXBkYXRlID8gdHVwbGUuaWRNYXAoZGF0YSkgOiBudWxsKTtcblxuICBmb3IgKGk9MCwgbGVuPXByZXYubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHByZXZbaV07XG4gICAgaWYgKGl0ZW0uc3RhdHVzID09PSBDLkVYSVQpIHtcbiAgICAgIHR1cGxlLnNldChpdGVtLCBcImtleVwiLCBrZXlmID8gaXRlbS5rZXkgOiB0aGlzLl9pdGVtcy5sZW5ndGgpO1xuICAgICAgbmV4dC5zcGxpY2UoMCwgMCwgaXRlbSk7ICAvLyBLZWVwIGl0ZW0gYXJvdW5kIGZvciBcImV4aXRcIiB0cmFuc2l0aW9uLlxuICAgICAgb3V0cHV0LnJlbS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuICh0aGlzLl9tYXJrLml0ZW1zID0gbmV4dCwgb3V0cHV0KTtcbn07XG5cbmZ1bmN0aW9uIGtleUZ1bmN0aW9uKGtleSkge1xuICBpZiAoa2V5ID09IG51bGwpIHJldHVybiBudWxsO1xuICB2YXIgZiA9IGRsLmFycmF5KGtleSkubWFwKGRsLmFjY2Vzc29yKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICBmb3IgKHZhciBzPVwiXCIsIGk9MCwgbj1mLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmIChpPjApIHMgKz0gXCJ8XCI7XG4gICAgICBzICs9IFN0cmluZyhmW2ldKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVpbGRlcjsiLCJ2YXIgTm9kZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L05vZGUnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSxcbiAgICBFTVBUWSA9IHt9O1xuXG5mdW5jdGlvbiBFbmNvZGVyKG1vZGVsLCBtYXJrKSB7XG4gIHZhciBwcm9wcyA9IG1hcmsuZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICB1cGRhdGUgPSBwcm9wcy51cGRhdGU7XG5cbiAgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIG1vZGVsLmdyYXBoKVxuXG4gIHRoaXMuX21vZGVsID0gbW9kZWw7XG4gIHRoaXMuX21hcmsgID0gbWFyaztcblxuICBpZih1cGRhdGUpIHtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5EQVRBLCB1cGRhdGUuZGF0YSk7XG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuU0NBTEVTLCB1cGRhdGUuc2NhbGVzKTtcbiAgICB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTLCB1cGRhdGUuc2lnbmFscyk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEVuY29kZXIucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImVuY29kaW5nXCIsIHRoaXMuX21hcmsuZGVmLnR5cGVdKTtcbiAgdmFyIGl0ZW1zID0gdGhpcy5fbWFyay5pdGVtcyxcbiAgICAgIHByb3BzID0gdGhpcy5fbWFyay5kZWYucHJvcGVydGllcyB8fCB7fSxcbiAgICAgIGVudGVyICA9IHByb3BzLmVudGVyLFxuICAgICAgdXBkYXRlID0gcHJvcHMudXBkYXRlLFxuICAgICAgZXhpdCAgID0gcHJvcHMuZXhpdCxcbiAgICAgIGksIGxlbiwgaXRlbTtcblxuICAvLyBJdGVtcyBtYXJrZWQgZm9yIHJlbW92YWwgYXJlIGF0IHRoZSBoZWFkIG9mIGl0ZW1zLiBQcm9jZXNzIHRoZW0gZmlyc3QuXG4gIGZvcihpPTAsIGxlbj1pbnB1dC5yZW0ubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IGlucHV0LnJlbVtpXTtcbiAgICBpZih1cGRhdGUpIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMpO1xuICAgIGlmKGV4aXQpICAgZW5jb2RlLmNhbGwodGhpcywgZXhpdCwgICBpdGVtLCBpbnB1dC50cmFucyk7IFxuICAgIGlmKGlucHV0LnRyYW5zICYmICFleGl0KSBpbnB1dC50cmFucy5pbnRlcnBvbGF0ZShpdGVtLCBFTVBUWSk7XG4gICAgZWxzZSBpZighaW5wdXQudHJhbnMpIGl0ZW0ucmVtb3ZlKCk7XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGl0ZW0gPSBpbnB1dC5hZGRbaV07XG4gICAgaWYoZW50ZXIpICBlbmNvZGUuY2FsbCh0aGlzLCBlbnRlciwgIGl0ZW0sIGlucHV0LnRyYW5zKTtcbiAgICBpZih1cGRhdGUpIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMpO1xuICAgIGl0ZW0uc3RhdHVzID0gQy5VUERBVEU7XG4gIH1cblxuICBpZih1cGRhdGUpIHtcbiAgICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGlucHV0Lm1vZFtpXTtcbiAgICAgIGVuY29kZS5jYWxsKHRoaXMsIHVwZGF0ZSwgaXRlbSwgaW5wdXQudHJhbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmZ1bmN0aW9uIGVuY29kZShwcm9wLCBpdGVtLCB0cmFucywgc3RhbXApIHtcbiAgdmFyIG1vZGVsID0gdGhpcy5fbW9kZWwsXG4gICAgICBlbmMgPSBwcm9wLmVuY29kZSxcbiAgICAgIHNnID0gdGhpcy5fZ3JhcGguc2lnbmFsVmFsdWVzKHByb3Auc2lnbmFsc3x8W10pLFxuICAgICAgZGIgPSAocHJvcC5kYXRhfHxbXSkucmVkdWNlKGZ1bmN0aW9uKGRiLCBkcykgeyBcbiAgICAgICAgcmV0dXJuIGRiW2RzXSA9IG1vZGVsLmRhdGEoZHMpLnZhbHVlcygpLCBkYjtcbiAgICAgIH0sIHt9KTtcblxuICBlbmMuY2FsbChlbmMsIGl0ZW0sIGl0ZW0ubWFyay5ncm91cHx8aXRlbSwgdHJhbnMsIGRiLCBzZywgbW9kZWwucHJlZGljYXRlcygpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbmNvZGVyOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIEJ1aWxkZXIgPSByZXF1aXJlKCcuL0J1aWxkZXInKSxcbiAgICBTY2FsZSA9IHJlcXVpcmUoJy4vU2NhbGUnKSxcbiAgICBwYXJzZUF4ZXMgPSByZXF1aXJlKCcuLi9wYXJzZS9heGVzJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIEdyb3VwQnVpbGRlcigpIHtcbiAgdGhpcy5fY2hpbGRyZW4gPSB7fTtcbiAgdGhpcy5fc2NhbGVyID0gbnVsbDtcbiAgdGhpcy5fcmVjdXJzb3IgPSBudWxsO1xuXG4gIHRoaXMuX3NjYWxlcyA9IHt9O1xuICB0aGlzLnNjYWxlID0gc2NhbGUuYmluZCh0aGlzKTtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHcm91cEJ1aWxkZXIucHJvdG90eXBlID0gbmV3IEJ1aWxkZXIoKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihtb2RlbCwgZGVmLCBtYXJrLCBwYXJlbnQsIHBhcmVudF9pZCwgaW5oZXJpdEZyb20pIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuXG4gIHRoaXMuX3NjYWxlciA9IG5ldyBOb2RlKG1vZGVsLmdyYXBoKTtcblxuICAoZGVmLnNjYWxlc3x8W10pLmZvckVhY2goZnVuY3Rpb24ocykgeyBcbiAgICBzID0gYnVpbGRlci5zY2FsZShzLm5hbWUsIG5ldyBTY2FsZShtb2RlbCwgcywgYnVpbGRlcikpO1xuICAgIGJ1aWxkZXIuX3NjYWxlci5hZGRMaXN0ZW5lcihzKTsgIC8vIFNjYWxlcyBzaG91bGQgYmUgY29tcHV0ZWQgYWZ0ZXIgZ3JvdXAgaXMgZW5jb2RlZFxuICB9KTtcblxuICB0aGlzLl9yZWN1cnNvciA9IG5ldyBOb2RlKG1vZGVsLmdyYXBoKTtcbiAgdGhpcy5fcmVjdXJzb3IuZXZhbHVhdGUgPSByZWN1cnNlLmJpbmQodGhpcyk7XG5cbiAgdmFyIHNjYWxlcyA9IChkZWYuYXhlc3x8W10pLnJlZHVjZShmdW5jdGlvbihhY2MsIHgpIHtcbiAgICByZXR1cm4gKGFjY1t4LnNjYWxlXSA9IDEsIGFjYyk7XG4gIH0sIHt9KTtcbiAgdGhpcy5fcmVjdXJzb3IuZGVwZW5kZW5jeShDLlNDQUxFUywgZGwua2V5cyhzY2FsZXMpKTtcblxuICAvLyBXZSBvbmx5IG5lZWQgYSBjb2xsZWN0b3IgZm9yIHVwLXByb3BhZ2F0aW9uIG9mIGJvdW5kcyBjYWxjdWxhdGlvbixcbiAgLy8gc28gb25seSBHcm91cEJ1aWxkZXJzLCBhbmQgbm90IHJlZ3VsYXIgQnVpbGRlcnMsIGhhdmUgY29sbGVjdG9ycy5cbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3Rvcihtb2RlbC5ncmFwaCk7XG5cbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IEJ1aWxkZXIucHJvdG90eXBlLmV2YWx1YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICBidWlsZGVyID0gdGhpcztcblxuICBvdXRwdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oZ3JvdXApIHsgYnVpbGRHcm91cC5jYWxsKGJ1aWxkZXIsIG91dHB1dCwgZ3JvdXApOyB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdGhpcywgdGhpcy5fc2NhbGVyLCB0aGlzLl9yZWN1cnNvciwgdGhpcy5fY29sbGVjdG9yLCB0aGlzLl9ib3VuZGVyXTtcbn07XG5cbnByb3RvLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGJ1aWxkZXIgPSB0aGlzO1xuICBkbC5rZXlzKGJ1aWxkZXIuX2NoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uKGdyb3VwX2lkKSB7XG4gICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXBfaWRdLmZvckVhY2goZnVuY3Rpb24oYykge1xuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7XG4gICAgfSlcbiAgfSk7XG5cbiAgYnVpbGRlci5fY2hpbGRyZW4gPSB7fTtcbiAgcmV0dXJuIEJ1aWxkZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QuY2FsbCh0aGlzKTtcbn07XG5cbnByb3RvLmNoaWxkID0gZnVuY3Rpb24obmFtZSwgZ3JvdXBfaWQpIHtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bZ3JvdXBfaWRdLFxuICAgICAgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCxcbiAgICAgIGNoaWxkO1xuXG4gIGZvcig7IGk8bGVuOyArK2kpIHtcbiAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmKGNoaWxkLnR5cGUgPT0gQy5NQVJLICYmIGNoaWxkLmJ1aWxkZXIuX2RlZi5uYW1lID09IG5hbWUpIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkLmJ1aWxkZXI7XG59O1xuXG5mdW5jdGlvbiByZWN1cnNlKGlucHV0KSB7XG4gIHZhciBidWlsZGVyID0gdGhpcyxcbiAgICAgIGhhc01hcmtzID0gdGhpcy5fZGVmLm1hcmtzICYmIHRoaXMuX2RlZi5tYXJrcy5sZW5ndGggPiAwLFxuICAgICAgaGFzQXhlcyA9IHRoaXMuX2RlZi5heGVzICYmIHRoaXMuX2RlZi5heGVzLmxlbmd0aCA+IDAsXG4gICAgICBpLCBsZW4sIGdyb3VwLCBwaXBlbGluZSwgZGVmLCBpbmxpbmUgPSBmYWxzZTtcblxuICBmb3IoaT0wLCBsZW49aW5wdXQuYWRkLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGlmKGhhc01hcmtzKSBidWlsZE1hcmtzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgICBpZihoYXNBeGVzKSAgYnVpbGRBeGVzLmNhbGwodGhpcywgaW5wdXQsIGdyb3VwKTtcbiAgfVxuXG4gIC8vIFdpcmUgdXAgbmV3IGNoaWxkcmVuIGJ1aWxkZXJzIGluIHJldmVyc2UgdG8gbWluaW1pemUgZ3JhcGggcmV3cml0ZXMuXG4gIGZvciAoaT1pbnB1dC5hZGQubGVuZ3RoLTE7IGk+PTA7IC0taSkge1xuICAgIGdyb3VwID0gaW5wdXQuYWRkW2ldO1xuICAgIGZvciAoaj10aGlzLl9jaGlsZHJlbltncm91cC5faWRdLmxlbmd0aC0xOyBqPj0wOyAtLWopIHtcbiAgICAgIGMgPSB0aGlzLl9jaGlsZHJlbltncm91cC5faWRdW2pdO1xuICAgICAgYy5idWlsZGVyLmNvbm5lY3QoKTtcbiAgICAgIHBpcGVsaW5lID0gYy5idWlsZGVyLnBpcGVsaW5lKCk7XG4gICAgICBkZWYgPSBjLmJ1aWxkZXIuX2RlZjtcblxuICAgICAgLy8gVGhpcyBuZXcgY2hpbGQgbmVlZHMgdG8gYmUgYnVpbHQgZHVyaW5nIHRoaXMgcHJvcGFnYXRpb24gY3ljbGUuXG4gICAgICAvLyBXZSBjb3VsZCBhZGQgaXRzIGJ1aWxkZXIgYXMgYSBsaXN0ZW5lciBvZmYgdGhlIF9yZWN1cnNvciBub2RlLCBcbiAgICAgIC8vIGJ1dCB0cnkgdG8gaW5saW5lIGl0IGlmIHdlIGNhbiB0byBtaW5pbWl6ZSBncmFwaCBkaXNwYXRjaGVzLlxuICAgICAgaW5saW5lID0gKGRlZi50eXBlICE9PSBDLkdST1VQKTtcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAodGhpcy5fbW9kZWwuZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQpOyBcbiAgICAgIGlubGluZSA9IGlubGluZSAmJiAocGlwZWxpbmVbcGlwZWxpbmUubGVuZ3RoLTFdLmxpc3RlbmVycygpLmxlbmd0aCA9PSAxKTsgLy8gUmVhY3RpdmUgZ2VvbVxuICAgICAgYy5pbmxpbmUgPSBpbmxpbmU7XG5cbiAgICAgIGlmKGlubGluZSkgYy5idWlsZGVyLmV2YWx1YXRlKGlucHV0KTtcbiAgICAgIGVsc2UgdGhpcy5fcmVjdXJzb3IuYWRkTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICB9XG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQubW9kLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQubW9kW2ldO1xuICAgIC8vIFJlbW92ZSB0ZW1wb3JhcnkgY29ubmVjdGlvbiBmb3IgbWFya3MgdGhhdCBkcmF3IGZyb20gYSBzb3VyY2VcbiAgICBpZihoYXNNYXJrcykge1xuICAgICAgYnVpbGRlci5fY2hpbGRyZW5bZ3JvdXAuX2lkXS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgaWYoYy50eXBlID09IEMuTUFSSyAmJiAhYy5pbmxpbmUgJiYgYnVpbGRlci5fbW9kZWwuZGF0YShjLmZyb20pICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGF4ZXMgZGF0YSBkZWZzXG4gICAgaWYoaGFzQXhlcykge1xuICAgICAgcGFyc2VBeGVzKGJ1aWxkZXIuX21vZGVsLCBidWlsZGVyLl9kZWYuYXhlcywgZ3JvdXAuYXhlcywgZ3JvdXApO1xuICAgICAgZ3JvdXAuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHsgYS5kZWYoKSB9KTtcbiAgICB9ICAgICAgXG4gIH1cblxuICBmb3IoaT0wLCBsZW49aW5wdXQucmVtLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGdyb3VwID0gaW5wdXQucmVtW2ldO1xuICAgIC8vIEZvciBkZWxldGVkIGdyb3VwcywgZGlzY29ubmVjdCB0aGVpciBjaGlsZHJlblxuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0uZm9yRWFjaChmdW5jdGlvbihjKSB7IFxuICAgICAgYnVpbGRlci5fcmVjdXJzb3IucmVtb3ZlTGlzdGVuZXIoYy5idWlsZGVyKTtcbiAgICAgIGMuYnVpbGRlci5kaXNjb25uZWN0KCk7IFxuICAgIH0pO1xuICAgIGRlbGV0ZSBidWlsZGVyLl9jaGlsZHJlbltncm91cC5faWRdO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0O1xufTtcblxuZnVuY3Rpb24gc2NhbGUobmFtZSwgc2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gdGhpcztcbiAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgcmV0dXJuIChncm91cC5fc2NhbGVzW25hbWVdID0gc2NhbGUsIHNjYWxlKTtcbiAgd2hpbGUoc2NhbGUgPT0gbnVsbCkge1xuICAgIHNjYWxlID0gZ3JvdXAuX3NjYWxlc1tuYW1lXTtcbiAgICBncm91cCA9IGdyb3VwLm1hcmsgPyBncm91cC5tYXJrLmdyb3VwIDogZ3JvdXAuX3BhcmVudDtcbiAgICBpZighZ3JvdXApIGJyZWFrO1xuICB9XG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRHcm91cChpbnB1dCwgZ3JvdXApIHtcbiAgZGVidWcoaW5wdXQsIFtcImJ1aWxkaW5nIGdyb3VwXCIsIGdyb3VwLl9pZF0pO1xuXG4gIGdyb3VwLl9zY2FsZXMgPSBncm91cC5fc2NhbGVzIHx8IHt9OyAgICBcbiAgZ3JvdXAuc2NhbGUgID0gc2NhbGUuYmluZChncm91cCk7XG5cbiAgZ3JvdXAuaXRlbXMgPSBncm91cC5pdGVtcyB8fCBbXTtcbiAgdGhpcy5fY2hpbGRyZW5bZ3JvdXAuX2lkXSA9IHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0gfHwgW107XG5cbiAgZ3JvdXAuYXhlcyA9IGdyb3VwLmF4ZXMgfHwgW107XG4gIGdyb3VwLmF4aXNJdGVtcyA9IGdyb3VwLmF4aXNJdGVtcyB8fCBbXTtcbn1cblxuZnVuY3Rpb24gYnVpbGRNYXJrcyhpbnB1dCwgZ3JvdXApIHtcbiAgZGVidWcoaW5wdXQsIFtcImJ1aWxkaW5nIG1hcmtzXCIsIGdyb3VwLl9pZF0pO1xuICB2YXIgbWFya3MgPSB0aGlzLl9kZWYubWFya3MsXG4gICAgICBsaXN0ZW5lcnMgPSBbXSxcbiAgICAgIG1hcmssIGZyb20sIGluaGVyaXQsIGksIGxlbiwgbSwgYjtcblxuICBmb3IoaT0wLCBsZW49bWFya3MubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgbWFyayA9IG1hcmtzW2ldO1xuICAgIGZyb20gPSBtYXJrLmZyb20gfHwge307XG4gICAgaW5oZXJpdCA9IFwidmdfXCIrZ3JvdXAuZGF0dW0uX2lkO1xuICAgIGdyb3VwLml0ZW1zW2ldID0ge2dyb3VwOiBncm91cH07XG4gICAgYiA9IChtYXJrLnR5cGUgPT09IEMuR1JPVVApID8gbmV3IEdyb3VwQnVpbGRlcigpIDogbmV3IEJ1aWxkZXIoKTtcbiAgICBiLmluaXQodGhpcy5fbW9kZWwsIG1hcmssIGdyb3VwLml0ZW1zW2ldLCB0aGlzLCBncm91cC5faWQsIGluaGVyaXQpO1xuICAgIHRoaXMuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IFxuICAgICAgYnVpbGRlcjogYiwgXG4gICAgICBmcm9tOiBmcm9tLmRhdGEgfHwgKGZyb20ubWFyayA/IChcInZnX1wiICsgZ3JvdXAuX2lkICsgXCJfXCIgKyBmcm9tLm1hcmspIDogaW5oZXJpdCksIFxuICAgICAgdHlwZTogQy5NQVJLIFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkQXhlcyhpbnB1dCwgZ3JvdXApIHtcbiAgdmFyIGF4ZXMgPSBncm91cC5heGVzLFxuICAgICAgYXhpc0l0ZW1zID0gZ3JvdXAuYXhpc0l0ZW1zLFxuICAgICAgYnVpbGRlciA9IHRoaXM7XG5cbiAgcGFyc2VBeGVzKHRoaXMuX21vZGVsLCB0aGlzLl9kZWYuYXhlcywgYXhlcywgZ3JvdXApO1xuICBheGVzLmZvckVhY2goZnVuY3Rpb24oYSwgaSkge1xuICAgIHZhciBzY2FsZSA9IGJ1aWxkZXIuX2RlZi5heGVzW2ldLnNjYWxlLFxuICAgICAgICBkZWYgPSBhLmRlZigpLFxuICAgICAgICBiID0gbnVsbDtcblxuICAgIGF4aXNJdGVtc1tpXSA9IHtncm91cDogZ3JvdXAsIGF4aXNEZWY6IGRlZn07XG4gICAgYiA9IChkZWYudHlwZSA9PT0gQy5HUk9VUCkgPyBuZXcgR3JvdXBCdWlsZGVyKCkgOiBuZXcgQnVpbGRlcigpO1xuICAgIGIuaW5pdChidWlsZGVyLl9tb2RlbCwgZGVmLCBheGlzSXRlbXNbaV0sIGJ1aWxkZXIpXG4gICAgICAuZGVwZW5kZW5jeShDLlNDQUxFUywgc2NhbGUpO1xuICAgIGJ1aWxkZXIuX2NoaWxkcmVuW2dyb3VwLl9pZF0ucHVzaCh7IGJ1aWxkZXI6IGIsIHR5cGU6IEMuQVhJUywgc2NhbGU6IHNjYWxlIH0pO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ1aWxkZXI7IiwiZnVuY3Rpb24gSXRlbShtYXJrKSB7XG4gIHRoaXMubWFyayA9IG1hcms7XG59XG5cbnZhciBwcm90b3R5cGUgPSBJdGVtLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmhhc1Byb3BlcnR5U2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgcHJvcHMgPSB0aGlzLm1hcmsuZGVmLnByb3BlcnRpZXM7XG4gIHJldHVybiBwcm9wcyAmJiBwcm9wc1tuYW1lXSAhPSBudWxsO1xufTtcblxucHJvdG90eXBlLmNvdXNpbiA9IGZ1bmN0aW9uKG9mZnNldCwgaW5kZXgpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBncm91cCA9IG1hcmsuZ3JvdXAsXG4gICAgICBpaWR4ID0gaW5kZXg9PW51bGwgPyBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgOiBpbmRleCxcbiAgICAgIG1pZHggPSBncm91cC5pdGVtcy5pbmRleE9mKG1hcmspICsgb2Zmc2V0O1xuICByZXR1cm4gZ3JvdXAuaXRlbXNbbWlkeF0uaXRlbXNbaWlkeF07XG59O1xuXG5wcm90b3R5cGUuc2libGluZyA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IC0xO1xuICB2YXIgbWFyayA9IHRoaXMubWFyayxcbiAgICAgIGlpZHggPSBtYXJrLml0ZW1zLmluZGV4T2YodGhpcykgKyBvZmZzZXQ7XG4gIHJldHVybiBtYXJrLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaXRlbSA9IHRoaXMsXG4gICAgICBsaXN0ID0gaXRlbS5tYXJrLml0ZW1zLFxuICAgICAgaSA9IGxpc3QuaW5kZXhPZihpdGVtKTtcbiAgaWYgKGkgPj0gMCkgKGk9PT1saXN0Lmxlbmd0aC0xKSA/IGxpc3QucG9wKCkgOiBsaXN0LnNwbGljZShpLCAxKTtcbiAgcmV0dXJuIGl0ZW07XG59O1xuXG5wcm90b3R5cGUudG91Y2ggPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGF0aENhY2hlKSB0aGlzLnBhdGhDYWNoZSA9IG51bGw7XG4gIGlmICh0aGlzLm1hcmsucGF0aENhY2hlKSB0aGlzLm1hcmsucGF0aENhY2hlID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIEFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4uL3RyYW5zZm9ybXMvQWdncmVnYXRlJyksXG4gICAgY2hhbmdlc2V0ID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvY2hhbmdlc2V0JyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyksXG4gICAgY29uZmlnID0gcmVxdWlyZSgnLi4vdXRpbC9jb25maWcnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxudmFyIEdST1VQX1BST1BFUlRZID0ge3dpZHRoOiAxLCBoZWlnaHQ6IDF9O1xuXG5mdW5jdGlvbiBTY2FsZShtb2RlbCwgZGVmLCBwYXJlbnQpIHtcbiAgdGhpcy5fbW9kZWwgICA9IG1vZGVsO1xuICB0aGlzLl9kZWYgICAgID0gZGVmO1xuICB0aGlzLl9wYXJlbnQgID0gcGFyZW50O1xuICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgbW9kZWwuZ3JhcGgpO1xufVxuXG52YXIgcHJvdG8gPSAoU2NhbGUucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmV2YWx1YXRlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgZm4gPSBmdW5jdGlvbihncm91cCkgeyBzY2FsZS5jYWxsKHNlbGYsIGdyb3VwKTsgfTtcblxuICB0aGlzLl91cGRhdGVkID0gZmFsc2U7XG4gIGlucHV0LmFkZC5mb3JFYWNoKGZuKTtcbiAgaW5wdXQubW9kLmZvckVhY2goZm4pO1xuXG4gIC8vIFNjYWxlcyBhcmUgYXQgdGhlIGVuZCBvZiBhbiBlbmNvZGluZyBwaXBlbGluZSwgc28gdGhleSBzaG91bGQgZm9yd2FyZCBhXG4gIC8vIHJlZmxvdyBwdWxzZS4gVGh1cywgaWYgbXVsdGlwbGUgc2NhbGVzIHVwZGF0ZSBpbiB0aGUgcGFyZW50IGdyb3VwLCB3ZSBkb24ndFxuICAvLyByZWV2YWx1YXRlIGNoaWxkIG1hcmtzIG11bHRpcGxlIHRpbWVzLiBcbiAgaWYgKHRoaXMuX3VwZGF0ZWQpIGlucHV0LnNjYWxlc1t0aGlzLl9kZWYubmFtZV0gPSAxO1xuICByZXR1cm4gY2hhbmdlc2V0LmNyZWF0ZShpbnB1dCwgdHJ1ZSk7XG59O1xuXG4vLyBBbGwgb2YgYSBzY2FsZSdzIGRlcGVuZGVuY2llcyBhcmUgcmVnaXN0ZXJlZCBkdXJpbmcgcHJvcGFnYXRpb24gYXMgd2UgcGFyc2Vcbi8vIGRhdGFSZWZzLiBTbyBhIHNjYWxlIG11c3QgYmUgcmVzcG9uc2libGUgZm9yIGNvbm5lY3RpbmcgaXRzZWxmIHRvIGRlcGVuZGVudHMuXG5wcm90by5kZXBlbmRlbmN5ID0gZnVuY3Rpb24odHlwZSwgZGVwcykge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAyKSB7XG4gICAgZGVwcyA9IGRsLmFycmF5KGRlcHMpO1xuICAgIGZvcih2YXIgaT0wLCBsZW49ZGVwcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2dyYXBoW3R5cGUgPT0gQy5EQVRBID8gQy5EQVRBIDogQy5TSUdOQUxdKGRlcHNbaV0pXG4gICAgICAgIC5hZGRMaXN0ZW5lcih0aGlzLl9wYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBOb2RlLnByb3RvdHlwZS5kZXBlbmRlbmN5LmNhbGwodGhpcywgdHlwZSwgZGVwcyk7XG59O1xuXG5mdW5jdGlvbiBzY2FsZShncm91cCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX2RlZi5uYW1lLFxuICAgICAgcHJldiA9IG5hbWUgKyBcIjpwcmV2XCIsXG4gICAgICBzID0gaW5zdGFuY2UuY2FsbCh0aGlzLCBncm91cC5zY2FsZShuYW1lKSksXG4gICAgICBtID0gcy50eXBlPT09Qy5PUkRJTkFMID8gb3JkaW5hbCA6IHF1YW50aXRhdGl2ZSxcbiAgICAgIHJuZyA9IHJhbmdlLmNhbGwodGhpcywgZ3JvdXApO1xuXG4gIG0uY2FsbCh0aGlzLCBzLCBybmcsIGdyb3VwKTtcblxuICBncm91cC5zY2FsZShuYW1lLCBzKTtcbiAgZ3JvdXAuc2NhbGUocHJldiwgZ3JvdXAuc2NhbGUocHJldikgfHwgcyk7XG5cbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlKHNjYWxlKSB7XG4gIHZhciB0eXBlID0gdGhpcy5fZGVmLnR5cGUgfHwgQy5MSU5FQVI7XG4gIGlmICghc2NhbGUgfHwgdHlwZSAhPT0gc2NhbGUudHlwZSkge1xuICAgIHZhciBjdG9yID0gY29uZmlnLnNjYWxlW3R5cGVdIHx8IGQzLnNjYWxlW3R5cGVdO1xuICAgIGlmICghY3RvcikgZGwuZXJyb3IoXCJVbnJlY29nbml6ZWQgc2NhbGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAoc2NhbGUgPSBjdG9yKCkpLnR5cGUgPSBzY2FsZS50eXBlIHx8IHR5cGU7XG4gICAgc2NhbGUuc2NhbGVOYW1lID0gdGhpcy5fZGVmLm5hbWU7XG4gICAgc2NhbGUuX3ByZXYgPSB7fTtcbiAgfVxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIG9yZGluYWwoc2NhbGUsIHJuZywgZ3JvdXApIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZixcbiAgICAgIHByZXYgPSBzY2FsZS5fcHJldixcbiAgICAgIGRvbWFpbiwgc29ydCwgc3RyLCByZWZzLCBkYXRhRHJpdmVuUmFuZ2UgPSBmYWxzZTtcbiAgXG4gIC8vIHJhbmdlIHByZS1wcm9jZXNzaW5nIGZvciBkYXRhLWRyaXZlbiByYW5nZXNcbiAgaWYgKGRsLmlzT2JqZWN0KGRlZi5yYW5nZSkgJiYgIWRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgIGRhdGFEcml2ZW5SYW5nZSA9IHRydWU7XG4gICAgcm5nID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuUkFOR0UsIGRlZi5yYW5nZSwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuICBcbiAgLy8gZG9tYWluXG4gIGRvbWFpbiA9IGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgaWYgKGRvbWFpbiAmJiAhZGwuZXF1YWwocHJldi5kb21haW4sIGRvbWFpbikpIHtcbiAgICBzY2FsZS5kb21haW4oZG9tYWluKTtcbiAgICBwcmV2LmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgfSBcblxuICAvLyByYW5nZVxuICBpZiAoZGwuZXF1YWwocHJldi5yYW5nZSwgcm5nKSkgcmV0dXJuO1xuXG4gIHN0ciA9IHR5cGVvZiBybmdbMF0gPT09ICdzdHJpbmcnO1xuICBpZiAoc3RyIHx8IHJuZy5sZW5ndGggPiAyIHx8IHJuZy5sZW5ndGg9PT0xIHx8IGRhdGFEcml2ZW5SYW5nZSkge1xuICAgIHNjYWxlLnJhbmdlKHJuZyk7IC8vIGNvbG9yIG9yIHNoYXBlIHZhbHVlc1xuICB9IGVsc2UgaWYgKGRlZi5wb2ludHMpIHtcbiAgICBzY2FsZS5yYW5nZVBvaW50cyhybmcsIGRlZi5wYWRkaW5nfHwwKTtcbiAgfSBlbHNlIGlmIChkZWYucm91bmQgfHwgZGVmLnJvdW5kPT09dW5kZWZpbmVkKSB7XG4gICAgc2NhbGUucmFuZ2VSb3VuZEJhbmRzKHJuZywgZGVmLnBhZGRpbmd8fDApO1xuICB9IGVsc2Uge1xuICAgIHNjYWxlLnJhbmdlQmFuZHMocm5nLCBkZWYucGFkZGluZ3x8MCk7XG4gIH1cblxuICBwcmV2LnJhbmdlID0gcm5nO1xuICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcXVhbnRpdGF0aXZlKHNjYWxlLCBybmcsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBwcmV2ID0gc2NhbGUuX3ByZXYsXG4gICAgICBkb21haW4sIGludGVydmFsO1xuXG4gIC8vIGRvbWFpblxuICBkb21haW4gPSAoZGVmLnR5cGUgPT09IEMuUVVBTlRJTEUpXG4gICAgPyBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4sIGRlZi5kb21haW4sIHNjYWxlLCBncm91cClcbiAgICA6IGRvbWFpbk1pbk1heC5jYWxsKHRoaXMsIHNjYWxlLCBncm91cCk7XG4gIGlmIChkb21haW4gJiYgIWRsLmVxdWFsKHByZXYuZG9tYWluLCBkb21haW4pKSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbik7XG4gICAgcHJldi5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gIH0gXG5cbiAgLy8gcmFuZ2VcbiAgLy8gdmVydGljYWwgc2NhbGVzIHNob3VsZCBmbGlwIGJ5IGRlZmF1bHQsIHNvIHVzZSBYT1IgaGVyZVxuICBpZiAoZGVmLnJhbmdlID09PSBcImhlaWdodFwiKSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICBpZiAoZGwuZXF1YWwocHJldi5yYW5nZSwgcm5nKSkgcmV0dXJuO1xuICBzY2FsZVtkZWYucm91bmQgJiYgc2NhbGUucmFuZ2VSb3VuZCA/IFwicmFuZ2VSb3VuZFwiIDogXCJyYW5nZVwiXShybmcpO1xuICBwcmV2LnJhbmdlID0gcm5nO1xuICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcblxuICAvLyBUT0RPOiBTdXBwb3J0IHNpZ25hbHMgZm9yIHRoZXNlIHByb3BlcnRpZXMuIFVudGlsIHRoZW4sIG9ubHkgZXZhbFxuICAvLyB0aGVtIG9uY2UuXG4gIGlmICh0aGlzLl9zdGFtcCA+IDApIHJldHVybjtcbiAgaWYgKGRlZi5leHBvbmVudCAmJiBkZWYudHlwZT09PUMuUE9XRVIpIHNjYWxlLmV4cG9uZW50KGRlZi5leHBvbmVudCk7XG4gIGlmIChkZWYuY2xhbXApIHNjYWxlLmNsYW1wKHRydWUpO1xuICBpZiAoZGVmLm5pY2UpIHtcbiAgICBpZiAoZGVmLnR5cGUgPT09IEMuVElNRSkge1xuICAgICAgaW50ZXJ2YWwgPSBkMy50aW1lW2RlZi5uaWNlXTtcbiAgICAgIGlmICghaW50ZXJ2YWwpIGRsLmVycm9yKFwiVW5yZWNvZ25pemVkIGludGVydmFsOiBcIiArIGludGVydmFsKTtcbiAgICAgIHNjYWxlLm5pY2UoaW50ZXJ2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZS5uaWNlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGFSZWYod2hpY2gsIGRlZiwgc2NhbGUsIGdyb3VwKSB7XG4gIGlmIChkZWYgPT0gbnVsbCkgeyByZXR1cm4gW107IH1cbiAgaWYgKGRsLmlzQXJyYXkoZGVmKSkgcmV0dXJuIGRlZi5tYXAoc2lnbmFsLmJpbmQodGhpcykpO1xuXG4gIHZhciBzZWxmID0gdGhpcywgZ3JhcGggPSB0aGlzLl9ncmFwaCxcbiAgICAgIHJlZnMgPSBkZWYuZmllbGRzIHx8IGRsLmFycmF5KGRlZiksXG4gICAgICB1bmlxdWVzID0gc2NhbGUudHlwZSA9PT0gQy5PUkRJTkFMIHx8IHNjYWxlLnR5cGUgPT09IEMuUVVBTlRJTEUsXG4gICAgICBjayA9IFwiX1wiK3doaWNoLFxuICAgICAgY2FjaGUgPSBzY2FsZVtja10sXG4gICAgICBjYWNoZUZpZWxkID0ge29wczogW119LCAgLy8gdGhlIGZpZWxkIGFuZCBtZWFzdXJlcyBpbiB0aGUgYWdncmVnYXRvclxuICAgICAgc29ydCA9IGRlZi5zb3J0LFxuICAgICAgaSwgcmxlbiwgaiwgZmxlbiwgciwgZmllbGRzLCBmcm9tLCBkYXRhLCBrZXlzO1xuXG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IHNjYWxlW2NrXSA9IG5ldyBBZ2dyZWdhdGUoZ3JhcGgpO1xuICAgIGNhY2hlRmllbGQub3BzID0gW107XG4gICAgY2FjaGUuc2luZ2xldG9uKHRydWUpO1xuICAgIGlmICh1bmlxdWVzICYmIHNvcnQpIGNhY2hlRmllbGQub3BzLnB1c2goc29ydC5zdGF0KTtcbiAgfVxuXG4gIGZvcihpPTAsIHJsZW49cmVmcy5sZW5ndGg7IGk8cmxlbjsgKytpKSB7XG4gICAgciA9IHJlZnNbaV07XG4gICAgZnJvbSA9IHIuZGF0YSB8fCBcInZnX1wiK2dyb3VwLmRhdHVtLl9pZDtcbiAgICBkYXRhID0gZ3JhcGguZGF0YShmcm9tKVxuICAgICAgLnJldmlzZXModHJ1ZSlcbiAgICAgIC5sYXN0KCk7XG5cbiAgICBpZiAoZGF0YS5zdGFtcCA8PSB0aGlzLl9zdGFtcCkgY29udGludWU7XG5cbiAgICBmaWVsZHMgPSBkbC5hcnJheShyLmZpZWxkKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgaWYgKGYuZ3JvdXApIHJldHVybiBkbC5hY2Nlc3NvcihmLmdyb3VwKShncm91cC5kYXR1bSlcbiAgICAgIHJldHVybiBmOyAvLyBTdHJpbmcgb3Ige1wic2lnbmFsXCJ9XG4gICAgfSk7XG5cbiAgICBpZiAodW5pcXVlcykge1xuICAgICAgY2FjaGVGaWVsZC5uYW1lID0gc29ydCA/IHNvcnQuZmllbGQgOiBcIl9pZFwiO1xuICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKTtcbiAgICAgIGZvciAoaj0wLCBmbGVuPWZpZWxkcy5sZW5ndGg7IGo8ZmxlbjsgKytqKSB7XG4gICAgICAgIGNhY2hlLmdyb3VwX2J5LnNldChjYWNoZSwgZmllbGRzW2pdKVxuICAgICAgICAgIC5ldmFsdWF0ZShkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChqPTAsIGZsZW49ZmllbGRzLmxlbmd0aDsgajxmbGVuOyArK2opIHtcbiAgICAgICAgY2FjaGVGaWVsZC5uYW1lID0gZmllbGRzW2pdO1xuICAgICAgICBjYWNoZUZpZWxkLm9wcyAgPSBbQy5NSU4sIEMuTUFYXTtcbiAgICAgICAgY2FjaGUuZmllbGRzLnNldChjYWNoZSwgW2NhY2hlRmllbGRdKSAvLyBUcmVhdCBhcyBmbGF0IGRhdGFzb3VyY2VcbiAgICAgICAgICAuZXZhbHVhdGUoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5kZXBlbmRlbmN5KEMuREFUQSwgZnJvbSk7XG4gICAgY2FjaGUuZGVwZW5kZW5jeShDLlNJR05BTFMpLmZvckVhY2goZnVuY3Rpb24ocykgeyBzZWxmLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBzKSB9KTtcbiAgfVxuXG4gIGRhdGEgPSBjYWNoZS5kYXRhKCk7XG4gIGlmICh1bmlxdWVzKSB7XG4gICAga2V5cyA9IGRsLmtleXMoZGF0YSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaykgeyByZXR1cm4gZGF0YVtrXSAhPSBudWxsOyB9KTtcblxuICAgIGlmIChzb3J0KSB7XG4gICAgICBzb3J0ID0gc29ydC5vcmRlci5zaWduYWwgPyBncmFwaC5zaWduYWxSZWYoc29ydC5vcmRlci5zaWduYWwpIDogc29ydC5vcmRlcjtcbiAgICAgIHNvcnQgPSAoc29ydCA9PSBDLkRFU0MgPyBcIi1cIiA6IFwiK1wiKSArIFwidHBsLlwiICsgY2FjaGVGaWVsZC5uYW1lO1xuICAgICAgc29ydCA9IGRsLmNvbXBhcmF0b3Ioc29ydCk7XG4gICAgICBrZXlzID0ga2V5cy5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4geyBrZXk6IGssIHRwbDogZGF0YVtrXS50cGwgfX0pXG4gICAgICAgIC5zb3J0KHNvcnQpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaykgeyByZXR1cm4gay5rZXk7IH0pO1xuICAgIC8vIH0gZWxzZSB7ICAvLyBcIkZpcnN0IHNlZW5cIiBvcmRlclxuICAgIC8vICAgc29ydCA9IGRsLmNvbXBhcmF0b3IoXCJ0cGwuX2lkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXlzO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBkYXRhW1wiXCJdOyAvLyBVbnBhY2sgZmxhdCBhZ2dyZWdhdGlvblxuICAgIHJldHVybiAoZGF0YSA9PT0gbnVsbCkgPyBbXSA6IFtkYXRhW0MuU0lOR0xFVE9OXS5taW4sIGRhdGFbQy5TSU5HTEVUT05dLm1heF07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lnbmFsKHYpIHtcbiAgdmFyIHMgPSB2LnNpZ25hbCwgcmVmO1xuICBpZiAoIXMpIHJldHVybiB2O1xuICB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTLCAocmVmID0gZGwuZmllbGQocykpWzBdKTtcbiAgcmV0dXJuIHRoaXMuX2dyYXBoLnNpZ25hbFJlZihyZWYpO1xufVxuXG5mdW5jdGlvbiBkb21haW5NaW5NYXgoc2NhbGUsIGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBkb21haW4gPSBbbnVsbCwgbnVsbF0sIHJlZnMsIHo7XG5cbiAgaWYgKGRlZi5kb21haW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGRvbWFpbiA9ICghZGwuaXNPYmplY3QoZGVmLmRvbWFpbikpID8gZG9tYWluIDpcbiAgICAgIGRhdGFSZWYuY2FsbCh0aGlzLCBDLkRPTUFJTiwgZGVmLmRvbWFpbiwgc2NhbGUsIGdyb3VwKTtcbiAgfVxuXG4gIHogPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgaWYgKGRlZi5kb21haW5NaW4gIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkbC5pc09iamVjdChkZWYuZG9tYWluTWluKSkge1xuICAgICAgaWYgKGRlZi5kb21haW5NaW4uc2lnbmFsKSB7XG4gICAgICAgIGRvbWFpblswXSA9IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5kb21haW5NaW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tYWluWzBdID0gZGF0YVJlZi5jYWxsKHRoaXMsIEMuRE9NQUlOK0MuTUlOLCBkZWYuZG9tYWluTWluLCBzY2FsZSwgZ3JvdXApWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkb21haW5bMF0gPSBkZWYuZG9tYWluTWluO1xuICAgIH1cbiAgfVxuICBpZiAoZGVmLmRvbWFpbk1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRsLmlzT2JqZWN0KGRlZi5kb21haW5NYXgpKSB7XG4gICAgICBpZiAoZGVmLmRvbWFpbk1heC5zaWduYWwpIHtcbiAgICAgICAgZG9tYWluW3pdID0gc2lnbmFsLmNhbGwodGhpcywgZGVmLmRvbWFpbk1heCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb21haW5bel0gPSBkYXRhUmVmLmNhbGwodGhpcywgQy5ET01BSU4rQy5NQVgsIGRlZi5kb21haW5NYXgsIHNjYWxlLCBncm91cClbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbWFpblt6XSA9IGRlZi5kb21haW5NYXg7XG4gICAgfVxuICB9XG4gIGlmIChkZWYudHlwZSAhPT0gQy5MT0cgJiYgZGVmLnR5cGUgIT09IEMuVElNRSAmJiAoZGVmLnplcm8gfHwgZGVmLnplcm89PT11bmRlZmluZWQpKSB7XG4gICAgZG9tYWluWzBdID0gTWF0aC5taW4oMCwgZG9tYWluWzBdKTtcbiAgICBkb21haW5bel0gPSBNYXRoLm1heCgwLCBkb21haW5bel0pO1xuICB9XG4gIHJldHVybiBkb21haW47XG59XG5cbmZ1bmN0aW9uIHJhbmdlKGdyb3VwKSB7XG4gIHZhciBkZWYgPSB0aGlzLl9kZWYsXG4gICAgICBybmcgPSBbbnVsbCwgbnVsbF07XG5cbiAgaWYgKGRlZi5yYW5nZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYucmFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoR1JPVVBfUFJPUEVSVFlbZGVmLnJhbmdlXSkge1xuICAgICAgICBybmcgPSBbMCwgZ3JvdXBbZGVmLnJhbmdlXV07XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdKSB7XG4gICAgICAgIHJuZyA9IGNvbmZpZy5yYW5nZVtkZWYucmFuZ2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGwuZXJyb3IoXCJVbnJlY29naXplZCByYW5nZTogXCIrZGVmLnJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHJuZztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRsLmlzQXJyYXkoZGVmLnJhbmdlKSkge1xuICAgICAgcm5nID0gZGVmLnJhbmdlLm1hcChzaWduYWwuYmluZCh0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChkbC5pc09iamVjdChkZWYucmFuZ2UpKSB7XG4gICAgICByZXR1cm4gbnVsbDsgLy8gZWFybHkgZXhpdFxuICAgIH0gZWxzZSB7XG4gICAgICBybmcgPSBbMCwgZGVmLnJhbmdlXTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nWzBdID0gZGVmLnJhbmdlTWluLnNpZ25hbCA/IHNpZ25hbC5jYWxsKHRoaXMsIGRlZi5yYW5nZU1pbikgOiBkZWYucmFuZ2VNaW47XG4gIH1cbiAgaWYgKGRlZi5yYW5nZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcm5nW3JuZy5sZW5ndGgtMV0gPSBkZWYucmFuZ2VNYXguc2lnbmFsID8gc2lnbmFsLmNhbGwodGhpcywgZGVmLnJhbmdlTWF4KSA6IGRlZi5yYW5nZU1heDtcbiAgfVxuICBcbiAgaWYgKGRlZi5yZXZlcnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmV2ID0gZGVmLnJldmVyc2U7XG4gICAgaWYgKGRsLmlzT2JqZWN0KHJldikpIHtcbiAgICAgIHJldiA9IGRsLmFjY2Vzc29yKHJldi5maWVsZCkoZ3JvdXAuZGF0dW0pO1xuICAgIH1cbiAgICBpZiAocmV2KSBybmcgPSBybmcucmV2ZXJzZSgpO1xuICB9XG4gIFxuICByZXR1cm4gcm5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlOyIsInZhciB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgY2FsY0JvdW5kcyA9IHJlcXVpcmUoJy4uL3V0aWwvYm91bmRzJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIFRyYW5zaXRpb24oZHVyYXRpb24sIGVhc2UpIHtcbiAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDUwMDtcbiAgdGhpcy5lYXNlID0gZWFzZSAmJiBkMy5lYXNlKGVhc2UpIHx8IGQzLmVhc2UoXCJjdWJpYy1pbi1vdXRcIik7XG4gIHRoaXMudXBkYXRlcyA9IHtuZXh0OiBudWxsfTtcbn1cblxudmFyIHByb3RvdHlwZSA9IFRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG52YXIgc2tpcCA9IHtcbiAgXCJ0ZXh0XCI6IDEsXG4gIFwidXJsXCI6ICAxXG59O1xuXG5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihpdGVtLCB2YWx1ZXMsIHN0YW1wKSB7XG4gIHZhciBrZXksIGN1cnIsIG5leHQsIGludGVycCwgbGlzdCA9IG51bGw7XG5cbiAgZm9yIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgY3VyciA9IGl0ZW1ba2V5XTtcbiAgICBuZXh0ID0gdmFsdWVzW2tleV07ICAgICAgXG4gICAgaWYgKGN1cnIgIT09IG5leHQpIHtcbiAgICAgIGlmIChza2lwW2tleV0gfHwgY3VyciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNraXAgaW50ZXJwb2xhdGlvbiBmb3Igc3BlY2lmaWMga2V5cyBvciB1bmRlZmluZWQgc3RhcnQgdmFsdWVzXG4gICAgICAgIHR1cGxlLnNldChpdGVtLCBrZXksIG5leHQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY3VyciA9PT0gXCJudW1iZXJcIiAmJiAhaXNGaW5pdGUoY3VycikpIHtcbiAgICAgICAgLy8gZm9yIE5hTiBvciBpbmZpbml0ZSBudW1lcmljIHZhbHVlcywgc2tpcCB0byBmaW5hbCB2YWx1ZVxuICAgICAgICB0dXBsZS5zZXQoaXRlbSwga2V5LCBuZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBsb29rdXAgaW50ZXJwb2xhdG9yXG4gICAgICAgIGludGVycCA9IGQzLmludGVycG9sYXRlKGN1cnIsIG5leHQpO1xuICAgICAgICBpbnRlcnAucHJvcGVydHkgPSBrZXk7XG4gICAgICAgIChsaXN0IHx8IChsaXN0PVtdKSkucHVzaChpbnRlcnApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsaXN0ID09PSBudWxsICYmIGl0ZW0uc3RhdHVzID09PSBDLkVYSVQpIHtcbiAgICBsaXN0ID0gW107IC8vIGVuc3VyZSBleGl0aW5nIGl0ZW1zIGFyZSBpbmNsdWRlZFxuICB9XG5cbiAgaWYgKGxpc3QgIT0gbnVsbCkge1xuICAgIGxpc3QuaXRlbSA9IGl0ZW07XG4gICAgbGlzdC5lYXNlID0gaXRlbS5tYXJrLmVhc2UgfHwgdGhpcy5lYXNlO1xuICAgIGxpc3QubmV4dCA9IHRoaXMudXBkYXRlcy5uZXh0O1xuICAgIHRoaXMudXBkYXRlcy5uZXh0ID0gbGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciB0ID0gdGhpcywgcHJldiA9IHQudXBkYXRlcywgY3VyciA9IHByZXYubmV4dDtcbiAgZm9yICg7IGN1cnIhPW51bGw7IHByZXY9Y3VyciwgY3Vycj1wcmV2Lm5leHQpIHtcbiAgICBpZiAoY3Vyci5pdGVtLnN0YXR1cyA9PT0gQy5FWElUKSBjdXJyLnJlbW92ZSA9IHRydWU7XG4gIH1cbiAgdC5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICBkMy50aW1lcihmdW5jdGlvbihlbGFwc2VkKSB7IHJldHVybiBzdGVwLmNhbGwodCwgZWxhcHNlZCk7IH0pO1xufTtcblxuZnVuY3Rpb24gc3RlcChlbGFwc2VkKSB7XG4gIHZhciBsaXN0ID0gdGhpcy51cGRhdGVzLCBwcmV2ID0gbGlzdCwgY3VyciA9IHByZXYubmV4dCxcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvbixcbiAgICAgIGl0ZW0sIGRlbGF5LCBmLCBlLCBpLCBuLCBzdG9wID0gdHJ1ZTtcblxuICBmb3IgKDsgY3VyciE9bnVsbDsgcHJldj1jdXJyLCBjdXJyPXByZXYubmV4dCkge1xuICAgIGl0ZW0gPSBjdXJyLml0ZW07XG4gICAgZGVsYXkgPSBpdGVtLmRlbGF5IHx8IDA7XG5cbiAgICBmID0gKGVsYXBzZWQgLSBkZWxheSkgLyBkdXJhdGlvbjtcbiAgICBpZiAoZiA8IDApIHsgc3RvcCA9IGZhbHNlOyBjb250aW51ZTsgfVxuICAgIGlmIChmID4gMSkgZiA9IDE7XG4gICAgZSA9IGN1cnIuZWFzZShmKTtcblxuICAgIGZvciAoaT0wLCBuPWN1cnIubGVuZ3RoOyBpPG47ICsraSkge1xuICAgICAgaXRlbVtjdXJyW2ldLnByb3BlcnR5XSA9IGN1cnJbaV0oZSk7XG4gICAgfVxuICAgIGl0ZW0udG91Y2goKTtcbiAgICBjYWxjQm91bmRzLml0ZW0oaXRlbSk7XG5cbiAgICBpZiAoZiA9PT0gMSkge1xuICAgICAgaWYgKGN1cnIucmVtb3ZlKSBpdGVtLnJlbW92ZSgpO1xuICAgICAgcHJldi5uZXh0ID0gY3Vyci5uZXh0O1xuICAgICAgY3VyciA9IHByZXY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3AgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmNhbGxiYWNrKCk7XG4gIHJldHVybiBzdG9wO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2l0aW9uOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIGNvbmZpZyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uZmlnJyksXG4gICAgdHBsID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBwYXJzZU1hcmsgPSByZXF1aXJlKCcuLi9wYXJzZS9tYXJrJyk7XG5cbmZ1bmN0aW9uIGF4cyhtb2RlbCkge1xuICB2YXIgc2NhbGUsXG4gICAgICBvcmllbnQgPSBjb25maWcuYXhpcy5vcmllbnQsXG4gICAgICBvZmZzZXQgPSAwLFxuICAgICAgdGl0bGVPZmZzZXQgPSBjb25maWcuYXhpcy50aXRsZU9mZnNldCxcbiAgICAgIGF4aXNEZWYgPSB7fSxcbiAgICAgIGxheWVyID0gXCJmcm9udFwiLFxuICAgICAgZ3JpZCA9IGZhbHNlLFxuICAgICAgdGl0bGUgPSBudWxsLFxuICAgICAgdGlja01ham9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja01pbm9yU2l6ZSA9IGNvbmZpZy5heGlzLnRpY2tTaXplLFxuICAgICAgdGlja0VuZFNpemUgPSBjb25maWcuYXhpcy50aWNrU2l6ZSxcbiAgICAgIHRpY2tQYWRkaW5nID0gY29uZmlnLmF4aXMucGFkZGluZyxcbiAgICAgIHRpY2tWYWx1ZXMgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdFN0cmluZyA9IG51bGwsXG4gICAgICB0aWNrRm9ybWF0ID0gbnVsbCxcbiAgICAgIHRpY2tTdWJkaXZpZGUgPSAwLFxuICAgICAgdGlja0FyZ3VtZW50cyA9IFtjb25maWcuYXhpcy50aWNrc10sXG4gICAgICBncmlkTGluZVN0eWxlID0ge30sXG4gICAgICB0aWNrTGFiZWxTdHlsZSA9IHt9LFxuICAgICAgbWFqb3JUaWNrU3R5bGUgPSB7fSxcbiAgICAgIG1pbm9yVGlja1N0eWxlID0ge30sXG4gICAgICB0aXRsZVN0eWxlID0ge30sXG4gICAgICBkb21haW5TdHlsZSA9IHt9LFxuICAgICAgbSA9IHsgLy8gQXhpcyBtYXJrcyBhcyByZWZlcmVuY2VzIGZvciB1cGRhdGVzXG4gICAgICAgIGdyaWRMaW5lczogbnVsbCxcbiAgICAgICAgbWFqb3JUaWNrczogbnVsbCxcbiAgICAgICAgbWlub3JUaWNrczogbnVsbCxcbiAgICAgICAgdGlja0xhYmVsczogbnVsbCxcbiAgICAgICAgZG9tYWluOiBudWxsLFxuICAgICAgICB0aXRsZTogbnVsbFxuICAgICAgfTtcblxuICB2YXIgYXhpcyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGF4aXNEZWYudHlwZSA9IG51bGw7XG4gIH07XG5cbiAgYXhpcy5kZWYgPSBmdW5jdGlvbigpIHtcbiAgICBpZighYXhpc0RlZi50eXBlKSBheGlzX2RlZihzY2FsZSk7XG5cbiAgICAvLyB0aWNrIGZvcm1hdFxuICAgIHRpY2tGb3JtYXQgPSAhdGlja0Zvcm1hdFN0cmluZyA/IG51bGwgOiAoKHNjYWxlLnR5cGUgPT09ICd0aW1lJylcbiAgICAgID8gZDMudGltZS5mb3JtYXQodGlja0Zvcm1hdFN0cmluZylcbiAgICAgIDogZDMuZm9ybWF0KHRpY2tGb3JtYXRTdHJpbmcpKTtcblxuICAgIC8vIGdlbmVyYXRlIGRhdGFcbiAgICAvLyBXZSBkb24ndCBfcmVhbGx5XyBuZWVkIHRvIG1vZGVsIHRoZXNlIGFzIHR1cGxlcyBhcyBubyBmdXJ0aGVyXG4gICAgLy8gZGF0YSB0cmFuc2Zvcm1hdGlvbiBpcyBkb25lLiBTbyB3ZSBvcHRpbWl6ZSBmb3IgYSBoaWdoIGNodXJuIHJhdGUuIFxuICAgIHZhciBpbmplc3QgPSBmdW5jdGlvbihkKSB7IHJldHVybiB7ZGF0YTogZH07IH07XG4gICAgdmFyIG1ham9yID0gdGlja1ZhbHVlcyA9PSBudWxsXG4gICAgICA/IChzY2FsZS50aWNrcyA/IHNjYWxlLnRpY2tzLmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IHNjYWxlLmRvbWFpbigpKVxuICAgICAgOiB0aWNrVmFsdWVzO1xuICAgIHZhciBtaW5vciA9IHZnX2F4aXNTdWJkaXZpZGUoc2NhbGUsIG1ham9yLCB0aWNrU3ViZGl2aWRlKS5tYXAoaW5qZXN0KTtcbiAgICBtYWpvciA9IG1ham9yLm1hcChpbmplc3QpO1xuICAgIHZhciBmbXQgPSB0aWNrRm9ybWF0PT1udWxsID8gKHNjYWxlLnRpY2tGb3JtYXQgPyBzY2FsZS50aWNrRm9ybWF0LmFwcGx5KHNjYWxlLCB0aWNrQXJndW1lbnRzKSA6IFN0cmluZykgOiB0aWNrRm9ybWF0O1xuICAgIG1ham9yLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkLmxhYmVsID0gZm10KGQuZGF0YSk7IH0pO1xuICAgIHZhciB0ZGF0YSA9IHRpdGxlID8gW3RpdGxlXS5tYXAoaW5qZXN0KSA6IFtdO1xuXG4gICAgYXhpc0RlZi5tYXJrc1swXS5mcm9tID0gZnVuY3Rpb24oKSB7IHJldHVybiBncmlkID8gbWFqb3IgOiBbXTsgfTtcbiAgICBheGlzRGVmLm1hcmtzWzFdLmZyb20gPSBmdW5jdGlvbigpIHsgcmV0dXJuIG1ham9yOyB9O1xuICAgIGF4aXNEZWYubWFya3NbMl0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWlub3I7IH07XG4gICAgYXhpc0RlZi5tYXJrc1szXS5mcm9tID0gYXhpc0RlZi5tYXJrc1sxXS5mcm9tO1xuICAgIGF4aXNEZWYubWFya3NbNF0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gWzFdOyB9O1xuICAgIGF4aXNEZWYubWFya3NbNV0uZnJvbSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGRhdGE7IH07XG4gICAgYXhpc0RlZi5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgYXhpc0RlZi5vcmllbnQgPSBvcmllbnQ7XG4gICAgYXhpc0RlZi5sYXllciA9IGxheWVyO1xuICAgIHJldHVybiBheGlzRGVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGF4aXNfZGVmKHNjYWxlKSB7XG4gICAgLy8gc2V0dXAgc2NhbGUgbWFwcGluZ1xuICAgIHZhciBuZXdTY2FsZSwgb2xkU2NhbGUsIHJhbmdlO1xuICAgIGlmIChzY2FsZS50eXBlID09PSBcIm9yZGluYWxcIikge1xuICAgICAgbmV3U2NhbGUgPSB7c2NhbGU6IHNjYWxlLnNjYWxlTmFtZSwgb2Zmc2V0OiAwLjUgKyBzY2FsZS5yYW5nZUJhbmQoKS8yfTtcbiAgICAgIG9sZFNjYWxlID0gbmV3U2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1NjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUsIG9mZnNldDogMC41fTtcbiAgICAgIG9sZFNjYWxlID0ge3NjYWxlOiBzY2FsZS5zY2FsZU5hbWUrXCI6cHJldlwiLCBvZmZzZXQ6IDAuNX07XG4gICAgfVxuICAgIHJhbmdlID0gdmdfYXhpc1NjYWxlUmFuZ2Uoc2NhbGUpO1xuXG4gICAgLy8gc2V0dXAgYXhpcyBtYXJrc1xuICAgIGlmICghbS5ncmlkTGluZXMpICBtLmdyaWRMaW5lcyAgPSB2Z19heGlzVGlja3MoKTtcbiAgICBpZiAoIW0ubWFqb3JUaWNrcykgbS5tYWpvclRpY2tzID0gdmdfYXhpc1RpY2tzKCk7XG4gICAgaWYgKCFtLm1pbm9yVGlja3MpIG0ubWlub3JUaWNrcyA9IHZnX2F4aXNUaWNrcygpO1xuICAgIGlmICghbS50aWNrTGFiZWxzKSBtLnRpY2tMYWJlbHMgPSB2Z19heGlzVGlja0xhYmVscygpO1xuICAgIGlmICghbS5kb21haW4pIG0uZG9tYWluID0gdmdfYXhpc0RvbWFpbigpO1xuICAgIGlmICghbS50aXRsZSkgIG0udGl0bGUgID0gdmdfYXhpc1RpdGxlKCk7XG4gICAgbS5ncmlkTGluZXMucHJvcGVydGllcy5lbnRlci5zdHJva2UgPSB7dmFsdWU6IGNvbmZpZy5heGlzLmdyaWRDb2xvcn07XG5cbiAgICAvLyBleHRlbmQgYXhpcyBtYXJrcyBiYXNlZCBvbiBheGlzIG9yaWVudGF0aW9uXG4gICAgdmdfYXhpc1RpY2tzRXh0ZW5kKG9yaWVudCwgbS5ncmlkTGluZXMsIG9sZFNjYWxlLCBuZXdTY2FsZSwgSW5maW5pdHkpO1xuICAgIHZnX2F4aXNUaWNrc0V4dGVuZChvcmllbnQsIG0ubWFqb3JUaWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCB0aWNrTWFqb3JTaXplKTtcbiAgICB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCBtLm1pbm9yVGlja3MsIG9sZFNjYWxlLCBuZXdTY2FsZSwgdGlja01pbm9yU2l6ZSk7XG4gICAgdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbS50aWNrTGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHRpY2tNYWpvclNpemUsIHRpY2tQYWRkaW5nKTtcblxuICAgIHZnX2F4aXNEb21haW5FeHRlbmQob3JpZW50LCBtLmRvbWFpbiwgcmFuZ2UsIHRpY2tFbmRTaXplKTtcbiAgICB2Z19heGlzVGl0bGVFeHRlbmQob3JpZW50LCBtLnRpdGxlLCByYW5nZSwgdGl0bGVPZmZzZXQpOyAvLyBUT0RPIGdldCBvZmZzZXRcbiAgICBcbiAgICAvLyBhZGQgLyBvdmVycmlkZSBjdXN0b20gc3R5bGUgcHJvcGVydGllc1xuICAgIGRsLmV4dGVuZChtLmdyaWRMaW5lcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgZ3JpZExpbmVTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0ubWFqb3JUaWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwgbWFqb3JUaWNrU3R5bGUpO1xuICAgIGRsLmV4dGVuZChtLm1pbm9yVGlja3MucHJvcGVydGllcy51cGRhdGUsIG1pbm9yVGlja1N0eWxlKTtcbiAgICBkbC5leHRlbmQobS50aWNrTGFiZWxzLnByb3BlcnRpZXMudXBkYXRlLCB0aWNrTGFiZWxTdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0uZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLCBkb21haW5TdHlsZSk7XG4gICAgZGwuZXh0ZW5kKG0udGl0bGUucHJvcGVydGllcy51cGRhdGUsIHRpdGxlU3R5bGUpO1xuXG4gICAgdmFyIG1hcmtzID0gW20uZ3JpZExpbmVzLCBtLm1ham9yVGlja3MsIG0ubWlub3JUaWNrcywgbS50aWNrTGFiZWxzLCBtLmRvbWFpbiwgbS50aXRsZV07XG4gICAgZGwuZXh0ZW5kKGF4aXNEZWYsIHtcbiAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICAgIHByb3BlcnRpZXM6IHsgXG4gICAgICAgIGVudGVyOiB7XG4gICAgICAgICAgZW5jb2RlOiB2Z19heGlzVXBkYXRlLFxuICAgICAgICAgIHNjYWxlczogW3NjYWxlLnNjYWxlTmFtZV0sXG4gICAgICAgICAgc2lnbmFsczogW10sIGRhdGE6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIGVuY29kZTogdmdfYXhpc1VwZGF0ZSxcbiAgICAgICAgICBzY2FsZXM6IFtzY2FsZS5zY2FsZU5hbWVdLFxuICAgICAgICAgIHNpZ25hbHM6IFtdLCBkYXRhOiBbXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBheGlzRGVmLm1hcmtzID0gbWFya3MubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIHBhcnNlTWFyayhtb2RlbCwgbSk7IH0pO1xuICB9O1xuXG4gIGF4aXMuc2NhbGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2NhbGU7XG4gICAgaWYgKHNjYWxlICE9PSB4KSB7IHNjYWxlID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMub3JpZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIG9yaWVudDtcbiAgICBpZiAob3JpZW50ICE9PSB4KSB7XG4gICAgICBvcmllbnQgPSB4IGluIHZnX2F4aXNPcmllbnRzID8geCArIFwiXCIgOiBjb25maWcuYXhpcy5vcmllbnQ7XG4gICAgICByZXNldCgpO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpdGxlO1xuICAgIGlmICh0aXRsZSAhPT0geCkgeyB0aXRsZSA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja0FyZ3VtZW50cztcbiAgICB0aWNrQXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrVmFsdWVzO1xuICAgIHRpY2tWYWx1ZXMgPSB4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja0Zvcm1hdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrRm9ybWF0U3RyaW5nO1xuICAgIGlmICh0aWNrRm9ybWF0U3RyaW5nICE9PSB4KSB7XG4gICAgICB0aWNrRm9ybWF0U3RyaW5nID0geDtcbiAgICAgIHJlc2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aWNrTWFqb3JTaXplO1xuICAgIHZhciBuID0gYXJndW1lbnRzLmxlbmd0aCAtIDEsXG4gICAgICAgIG1ham9yID0gK3gsXG4gICAgICAgIG1pbm9yID0gbiA+IDEgPyAreSA6IHRpY2tNYWpvclNpemUsXG4gICAgICAgIGVuZCAgID0gbiA+IDAgPyArYXJndW1lbnRzW25dIDogdGlja01ham9yU2l6ZTtcblxuICAgIGlmICh0aWNrTWFqb3JTaXplICE9PSBtYWpvciB8fFxuICAgICAgICB0aWNrTWlub3JTaXplICE9PSBtaW5vciB8fFxuICAgICAgICB0aWNrRW5kU2l6ZSAhPT0gZW5kKSB7XG4gICAgICByZXNldCgpO1xuICAgIH1cblxuICAgIHRpY2tNYWpvclNpemUgPSBtYWpvcjtcbiAgICB0aWNrTWlub3JTaXplID0gbWlub3I7XG4gICAgdGlja0VuZFNpemUgPSBlbmQ7XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrU3ViZGl2aWRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tTdWJkaXZpZGU7XG4gICAgdGlja1N1YmRpdmlkZSA9ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuICBcbiAgYXhpcy5vZmZzZXQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGRsLmlzT2JqZWN0KHgpID8geCA6ICt4O1xuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMudGlja1BhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGlja1BhZGRpbmc7XG4gICAgaWYgKHRpY2tQYWRkaW5nICE9PSAreCkgeyB0aWNrUGFkZGluZyA9ICt4OyByZXNldCgpOyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aXRsZU9mZnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZU9mZnNldDtcbiAgICBpZiAodGl0bGVPZmZzZXQgIT09ICt4KSB7IHRpdGxlT2Zmc2V0ID0gK3g7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmxheWVyID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxheWVyO1xuICAgIGlmIChsYXllciAhPT0geCkgeyBsYXllciA9IHg7IHJlc2V0KCk7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLmdyaWQgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JpZDtcbiAgICBpZiAoZ3JpZCAhPT0geCkgeyBncmlkID0geDsgcmVzZXQoKTsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMuZ3JpZExpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyaWRMaW5lU3R5bGU7XG4gICAgaWYgKGdyaWRMaW5lU3R5bGUgIT09IHgpIHsgZ3JpZExpbmVTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLm1ham9yVGlja1Byb3BlcnRpZXMgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gbWFqb3JUaWNrU3R5bGU7XG4gICAgaWYgKG1ham9yVGlja1N0eWxlICE9PSB4KSB7IG1ham9yVGlja1N0eWxlID0geDsgfVxuICAgIHJldHVybiBheGlzO1xuICB9O1xuXG4gIGF4aXMubWlub3JUaWNrUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBtaW5vclRpY2tTdHlsZTtcbiAgICBpZiAobWlub3JUaWNrU3R5bGUgIT09IHgpIHsgbWlub3JUaWNrU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrTGFiZWxQcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRpY2tMYWJlbFN0eWxlO1xuICAgIGlmICh0aWNrTGFiZWxTdHlsZSAhPT0geCkgeyB0aWNrTGFiZWxTdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcblxuICBheGlzLnRpdGxlUHJvcGVydGllcyA9IGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aXRsZVN0eWxlO1xuICAgIGlmICh0aXRsZVN0eWxlICE9PSB4KSB7IHRpdGxlU3R5bGUgPSB4OyB9XG4gICAgcmV0dXJuIGF4aXM7XG4gIH07XG5cbiAgYXhpcy5kb21haW5Qcm9wZXJ0aWVzID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpblN0eWxlO1xuICAgIGlmIChkb21haW5TdHlsZSAhPT0geCkgeyBkb21haW5TdHlsZSA9IHg7IH1cbiAgICByZXR1cm4gYXhpcztcbiAgfTtcbiAgXG4gIGF4aXMucmVzZXQgPSBmdW5jdGlvbigpIHsgcmVzZXQoKTsgfTtcblxuICByZXR1cm4gYXhpcztcbn07XG5cbnZhciB2Z19heGlzT3JpZW50cyA9IHt0b3A6IDEsIHJpZ2h0OiAxLCBib3R0b206IDEsIGxlZnQ6IDF9O1xuXG5mdW5jdGlvbiB2Z19heGlzU3ViZGl2aWRlKHNjYWxlLCB0aWNrcywgbSkge1xuICBzdWJ0aWNrcyA9IFtdO1xuICBpZiAobSAmJiB0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgdmFyIGV4dGVudCA9IHZnX2F4aXNTY2FsZUV4dGVudChzY2FsZS5kb21haW4oKSksXG4gICAgICAgIHN1YnRpY2tzLFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSB0aWNrcy5sZW5ndGgsXG4gICAgICAgIGQgPSAodGlja3NbMV0gLSB0aWNrc1swXSkgLyArK20sXG4gICAgICAgIGosXG4gICAgICAgIHY7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGZvciAoaiA9IG07IC0taiA+IDA7KSB7XG4gICAgICAgIGlmICgodiA9ICt0aWNrc1tpXSAtIGogKiBkKSA+PSBleHRlbnRbMF0pIHtcbiAgICAgICAgICBzdWJ0aWNrcy5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoLS1pLCBqID0gMDsgKytqIDwgbSAmJiAodiA9ICt0aWNrc1tpXSArIGogKiBkKSA8IGV4dGVudFsxXTspIHtcbiAgICAgIHN1YnRpY2tzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWJ0aWNrcztcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1NjYWxlRXh0ZW50KGRvbWFpbikge1xuICB2YXIgc3RhcnQgPSBkb21haW5bMF0sIHN0b3AgPSBkb21haW5bZG9tYWluLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNTY2FsZVJhbmdlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZS5yYW5nZUV4dGVudFxuICAgID8gc2NhbGUucmFuZ2VFeHRlbnQoKVxuICAgIDogdmdfYXhpc1NjYWxlRXh0ZW50KHNjYWxlLnJhbmdlKCkpO1xufVxuXG52YXIgdmdfYXhpc0FsaWduID0ge1xuICBib3R0b206IFwiY2VudGVyXCIsXG4gIHRvcDogXCJjZW50ZXJcIixcbiAgbGVmdDogXCJyaWdodFwiLFxuICByaWdodDogXCJsZWZ0XCJcbn07XG5cbnZhciB2Z19heGlzQmFzZWxpbmUgPSB7XG4gIGJvdHRvbTogXCJ0b3BcIixcbiAgdG9wOiBcImJvdHRvbVwiLFxuICBsZWZ0OiBcIm1pZGRsZVwiLFxuICByaWdodDogXCJtaWRkbGVcIlxufTtcblxuZnVuY3Rpb24gdmdfYXhpc0xhYmVsRXh0ZW5kKG9yaWVudCwgbGFiZWxzLCBvbGRTY2FsZSwgbmV3U2NhbGUsIHNpemUsIHBhZCkge1xuICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCkgKyBwYWQ7XG4gIGlmIChvcmllbnQgPT09IFwibGVmdFwiIHx8IG9yaWVudCA9PT0gXCJ0b3BcIikge1xuICAgIHNpemUgKj0gLTE7XG4gIH0gIFxuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJib3R0b21cIikge1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogb2xkU2NhbGUsXG4gICAgICB5OiB7dmFsdWU6IHNpemV9LFxuICAgIH0pO1xuICAgIGRsLmV4dGVuZChsYWJlbHMucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IG5ld1NjYWxlLFxuICAgICAgeToge3ZhbHVlOiBzaXplfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6IFwiY2VudGVyXCJ9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogdmdfYXhpc0Jhc2VsaW5lW29yaWVudF19XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiB7dmFsdWU6IHNpemV9LFxuICAgICAgeTogb2xkU2NhbGUsXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKGxhYmVscy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDoge3ZhbHVlOiBzaXplfSxcbiAgICAgIHk6IG5ld1NjYWxlLFxuICAgICAgYWxpZ246IHt2YWx1ZTogdmdfYXhpc0FsaWduW29yaWVudF19LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogXCJtaWRkbGVcIn1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2Z19heGlzVGlja3NFeHRlbmQob3JpZW50LCB0aWNrcywgb2xkU2NhbGUsIG5ld1NjYWxlLCBzaXplKSB7XG4gIHZhciBzaWduID0gKG9yaWVudCA9PT0gXCJsZWZ0XCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSA/IC0xIDogMTtcbiAgaWYgKHNpemUgPT09IEluZmluaXR5KSB7XG4gICAgc2l6ZSA9IChvcmllbnQgPT09IFwidG9wXCIgfHwgb3JpZW50ID09PSBcImJvdHRvbVwiKVxuICAgICAgPyB7Z3JvdXA6IFwibWFyay5ncm91cC5oZWlnaHRcIiwgbXVsdDogLXNpZ259XG4gICAgICA6IHtncm91cDogXCJtYXJrLmdyb3VwLndpZHRoXCIsIG11bHQ6IC1zaWdufTtcbiAgfSBlbHNlIHtcbiAgICBzaXplID0ge3ZhbHVlOiBzaWduICogc2l6ZX07XG4gIH1cbiAgaWYgKG9yaWVudCA9PT0gXCJ0b3BcIiB8fCBvcmllbnQgPT09IFwiYm90dG9tXCIpIHtcbiAgICBkbC5leHRlbmQodGlja3MucHJvcGVydGllcy5lbnRlciwge1xuICAgICAgeDogIG9sZFNjYWxlLFxuICAgICAgeTogIHt2YWx1ZTogMH0sXG4gICAgICB5Mjogc2l6ZVxuICAgIH0pO1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLnVwZGF0ZSwge1xuICAgICAgeDogIG5ld1NjYWxlLFxuICAgICAgeTogIHt2YWx1ZTogMH0sXG4gICAgICB5Mjogc2l6ZVxuICAgIH0pO1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmV4aXQsIHtcbiAgICAgIHg6ICBuZXdTY2FsZSxcbiAgICB9KTsgICAgICAgIFxuICB9IGVsc2Uge1xuICAgIGRsLmV4dGVuZCh0aWNrcy5wcm9wZXJ0aWVzLmVudGVyLCB7XG4gICAgICB4OiAge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiBzaXplLFxuICAgICAgeTogIG9sZFNjYWxlXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMudXBkYXRlLCB7XG4gICAgICB4OiAge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiBzaXplLFxuICAgICAgeTogIG5ld1NjYWxlXG4gICAgfSk7XG4gICAgZGwuZXh0ZW5kKHRpY2tzLnByb3BlcnRpZXMuZXhpdCwge1xuICAgICAgeTogIG5ld1NjYWxlLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNUaXRsZUV4dGVuZChvcmllbnQsIHRpdGxlLCByYW5nZSwgb2Zmc2V0KSB7XG4gIHZhciBtaWQgPSB+figocmFuZ2VbMF0gKyByYW5nZVsxXSkgLyAyKSxcbiAgICAgIHNpZ24gPSAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJsZWZ0XCIpID8gLTEgOiAxO1xuICBcbiAgaWYgKG9yaWVudCA9PT0gXCJib3R0b21cIiB8fCBvcmllbnQgPT09IFwidG9wXCIpIHtcbiAgICBkbC5leHRlbmQodGl0bGUucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IHt2YWx1ZTogbWlkfSxcbiAgICAgIHk6IHt2YWx1ZTogc2lnbipvZmZzZXR9LFxuICAgICAgYW5nbGU6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkbC5leHRlbmQodGl0bGUucHJvcGVydGllcy51cGRhdGUsIHtcbiAgICAgIHg6IHt2YWx1ZTogc2lnbipvZmZzZXR9LFxuICAgICAgeToge3ZhbHVlOiBtaWR9LFxuICAgICAgYW5nbGU6IHt2YWx1ZTogLTkwfVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNEb21haW5FeHRlbmQob3JpZW50LCBkb21haW4sIHJhbmdlLCBzaXplKSB7XG4gIHZhciBwYXRoO1xuICBpZiAob3JpZW50ID09PSBcInRvcFwiIHx8IG9yaWVudCA9PT0gXCJsZWZ0XCIpIHtcbiAgICBzaXplID0gLTEgKiBzaXplO1xuICB9XG4gIGlmIChvcmllbnQgPT09IFwiYm90dG9tXCIgfHwgb3JpZW50ID09PSBcInRvcFwiKSB7XG4gICAgcGF0aCA9IFwiTVwiICsgcmFuZ2VbMF0gKyBcIixcIiArIHNpemUgKyBcIlYwSFwiICsgcmFuZ2VbMV0gKyBcIlZcIiArIHNpemU7XG4gIH0gZWxzZSB7XG4gICAgcGF0aCA9IFwiTVwiICsgc2l6ZSArIFwiLFwiICsgcmFuZ2VbMF0gKyBcIkgwVlwiICsgcmFuZ2VbMV0gKyBcIkhcIiArIHNpemU7XG4gIH1cbiAgZG9tYWluLnByb3BlcnRpZXMudXBkYXRlLnBhdGggPSB7dmFsdWU6IHBhdGh9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzVXBkYXRlKGl0ZW0sIGdyb3VwLCB0cmFucywgZGIsIHNpZ25hbHMsIHByZWRpY2F0ZXMpIHtcbiAgdmFyIG8gPSB0cmFucyA/IHt9IDogaXRlbSxcbiAgICAgIG9mZnNldCA9IGl0ZW0ubWFyay5kZWYub2Zmc2V0LFxuICAgICAgb3JpZW50ID0gaXRlbS5tYXJrLmRlZi5vcmllbnQsXG4gICAgICB3aWR0aCAgPSBncm91cC53aWR0aCxcbiAgICAgIGhlaWdodCA9IGdyb3VwLmhlaWdodDsgLy8gVE9ETyBmYWxsYmFjayB0byBnbG9iYWwgdyxoP1xuXG4gIGlmIChkbC5pc09iamVjdChvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gLWdyb3VwLnNjYWxlKG9mZnNldC5zY2FsZSkob2Zmc2V0LnZhbHVlKTtcbiAgfVxuXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSBcImxlZnRcIjogICB7IHRwbC5zZXQobywgJ3gnLCAtb2Zmc2V0KTsgdHBsLnNldChvLCAneScsIDApOyBicmVhazsgfVxuICAgIGNhc2UgXCJyaWdodFwiOiAgeyB0cGwuc2V0KG8sICd4Jywgd2lkdGggKyBvZmZzZXQpOyB0cGwuc2V0KG8sICd5JywgMCk7IGJyZWFrOyB9XG4gICAgY2FzZSBcImJvdHRvbVwiOiB7IHRwbC5zZXQobywgJ3gnLCAwKTsgdHBsLnNldChvLCAneScsIGhlaWdodCArIG9mZnNldCk7IGJyZWFrOyB9XG4gICAgY2FzZSBcInRvcFwiOiAgICB7IHRwbC5zZXQobywgJ3gnLCAwKTsgdHBsLnNldChvLCAneScsIC1vZmZzZXQpOyBicmVhazsgfVxuICAgIGRlZmF1bHQ6ICAgICAgIHsgdHBsLnNldChvLCAneCcsIDApOyB0cGwuc2V0KG8sICd5JywgMCk7IH1cbiAgfVxuXG4gIGlmICh0cmFucykgdHJhbnMuaW50ZXJwb2xhdGUoaXRlbSwgbyk7XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNUaWNrcygpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInJ1bGVcIixcbiAgICBpbnRlcmFjdGl2ZTogZmFsc2UsXG4gICAga2V5OiBcImRhdGFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICBzdHJva2U6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0NvbG9yfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja1dpZHRofSxcbiAgICAgICAgb3BhY2l0eToge3ZhbHVlOiAxZS02fVxuICAgICAgfSxcbiAgICAgIGV4aXQ6IHsgb3BhY2l0eToge3ZhbHVlOiAxZS02fSB9LFxuICAgICAgdXBkYXRlOiB7IG9wYWNpdHk6IHt2YWx1ZTogMX0gfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmdfYXhpc1RpY2tMYWJlbHMoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAga2V5OiBcImRhdGFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICBmaWxsOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpY2tMYWJlbENvbG9yfSxcbiAgICAgICAgZm9udDoge3ZhbHVlOiBjb25maWcuYXhpcy50aWNrTGFiZWxGb250fSxcbiAgICAgICAgZm9udFNpemU6IHt2YWx1ZTogY29uZmlnLmF4aXMudGlja0xhYmVsRm9udFNpemV9LFxuICAgICAgICBvcGFjaXR5OiB7dmFsdWU6IDFlLTZ9LFxuICAgICAgICB0ZXh0OiB7ZmllbGQ6IFwibGFiZWxcIn1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7IG9wYWNpdHk6IHt2YWx1ZTogMWUtNn0gfSxcbiAgICAgIHVwZGF0ZTogeyBvcGFjaXR5OiB7dmFsdWU6IDF9IH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHZnX2F4aXNUaXRsZSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRleHRcIixcbiAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICBmb250OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpdGxlRm9udH0sXG4gICAgICAgIGZvbnRTaXplOiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpdGxlRm9udFNpemV9LFxuICAgICAgICBmb250V2VpZ2h0OiB7dmFsdWU6IGNvbmZpZy5heGlzLnRpdGxlRm9udFdlaWdodH0sXG4gICAgICAgIGZpbGw6IHt2YWx1ZTogY29uZmlnLmF4aXMudGl0bGVDb2xvcn0sXG4gICAgICAgIGFsaWduOiB7dmFsdWU6IFwiY2VudGVyXCJ9LFxuICAgICAgICBiYXNlbGluZToge3ZhbHVlOiBcIm1pZGRsZVwifSxcbiAgICAgICAgdGV4dDoge2ZpZWxkOiBcImRhdGFcIn1cbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IHt9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiB2Z19heGlzRG9tYWluKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicGF0aFwiLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiB7dmFsdWU6IDAuNX0sXG4gICAgICAgIHk6IHt2YWx1ZTogMC41fSxcbiAgICAgICAgc3Ryb2tlOiB7dmFsdWU6IGNvbmZpZy5heGlzLmF4aXNDb2xvcn0sXG4gICAgICAgIHN0cm9rZVdpZHRoOiB7dmFsdWU6IGNvbmZpZy5heGlzLmF4aXNXaWR0aH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGF4cztcbiIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEdyb3VwQnkgPSByZXF1aXJlKCcuL0dyb3VwQnknKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksIFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLCBcbiAgICBtZWFzID0gcmVxdWlyZSgnLi9tZWFzdXJlcycpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBBZ2dyZWdhdGUoZ3JhcGgpIHtcbiAgR3JvdXBCeS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGdyb3VwX2J5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwiY291bnRcIjogICAgXCJjb3VudFwiLFxuICAgIFwiYXZnXCI6ICAgICAgXCJhdmdcIixcbiAgICBcIm1pblwiOiAgICAgIFwibWluXCIsXG4gICAgXCJtYXhcIjogICAgICBcIm1heFwiLFxuICAgIFwic3VtXCI6ICAgICAgXCJzdW1cIixcbiAgICBcIm1lYW5cIjogICAgIFwibWVhblwiLFxuICAgIFwidmFyXCI6ICAgICAgXCJ2YXJcIixcbiAgICBcInN0ZGV2XCI6ICAgIFwic3RkZXZcIixcbiAgICBcInZhcnBcIjogICAgIFwidmFycFwiLFxuICAgIFwic3RkZXZwXCI6ICAgXCJzdGRldnBcIixcbiAgICBcIm1lZGlhblwiOiAgIFwibWVkaWFuXCJcbiAgfTtcblxuICAvLyBBZ2dyZWdhdG9ycyBwYXJhbWV0ZXIgaGFuZGxlZCBtYW51YWxseS5cbiAgdGhpcy5fZmllbGRzRGVmICAgPSBudWxsO1xuICB0aGlzLl9BZ2dyZWdhdG9ycyA9IG51bGw7XG4gIHRoaXMuX3NpbmdsZXRvbiAgID0gZmFsc2U7ICAvLyBJZiB0cnVlLCBhbGwgZmllbGRzIGFnZ3JlZ2F0ZWQgd2l0aGluIGEgc2luZ2xlIG1vbm9pZFxuXG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoQWdncmVnYXRlLnByb3RvdHlwZSA9IG5ldyBHcm91cEJ5KCkpO1xuXG5wcm90by5maWVsZHMgPSB7XG4gIHNldDogZnVuY3Rpb24odHJhbnNmb3JtLCBmaWVsZHMpIHtcbiAgICB2YXIgaSwgbGVuLCBmLCBzaWduYWxzID0ge307XG4gICAgZm9yKGk9MCwgbGVuPWZpZWxkcy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGYgPSBmaWVsZHNbaV07XG4gICAgICBpZihmLm5hbWUuc2lnbmFsKSBzaWduYWxzW2YubmFtZS5zaWduYWxdID0gMTtcbiAgICAgIGRsLmFycmF5KGYub3BzKS5mb3JFYWNoKGZ1bmN0aW9uKG8peyBpZihvLnNpZ25hbCkgc2lnbmFsc1tvLnNpZ25hbF0gPSAxIH0pO1xuICAgIH1cblxuICAgIHRyYW5zZm9ybS5fZmllbGRzRGVmID0gZmllbGRzO1xuICAgIHRyYW5zZm9ybS5fQWdncmVnYXRvcnMgPSBudWxsO1xuICAgIHRyYW5zZm9ybS5hZ2dzKCk7XG4gICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCBkbC5rZXlzKHNpZ25hbHMpKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xuICB9XG59O1xuXG5wcm90by5zaW5nbGV0b24gPSBmdW5jdGlvbihjKSB7XG4gIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fc2luZ2xldG9uO1xuICB0aGlzLl9zaW5nbGV0b24gPSBjO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmFnZ3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMsXG4gICAgICBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgZmllbGRzID0gdGhpcy5fZmllbGRzRGVmLFxuICAgICAgYWdncyA9IHRoaXMuX0FnZ3JlZ2F0b3JzLFxuICAgICAgZiwgaSwgaywgbmFtZSwgb3BzLCBtZWFzdXJlcztcblxuICBpZihhZ2dzKSByZXR1cm4gYWdncztcbiAgZWxzZSBhZ2dzID0gdGhpcy5fQWdncmVnYXRvcnMgPSBbXTsgXG5cbiAgZm9yIChpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIGYgPSBmaWVsZHNbaV07XG4gICAgaWYgKGYub3BzLmxlbmd0aCA9PT0gMCkgY29udGludWU7XG5cbiAgICBuYW1lID0gZi5uYW1lLnNpZ25hbCA/IGdyYXBoLnNpZ25hbFJlZihmLm5hbWUuc2lnbmFsKSA6IGYubmFtZTtcbiAgICBvcHMgID0gZGwuYXJyYXkoZi5vcHMuc2lnbmFsID8gZ3JhcGguc2lnbmFsUmVmKGYub3BzLnNpZ25hbCkgOiBmLm9wcyk7XG4gICAgbWVhc3VyZXMgPSBvcHMubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGEgPSBhLnNpZ25hbCA/IGdyYXBoLnNpZ25hbFJlZihhLnNpZ25hbCkgOiBhO1xuICAgICAgcmV0dXJuIG1lYXNbYV0obmFtZSArICdfJyArIHRyYW5zZm9ybS5fb3V0cHV0W2FdKTtcbiAgICB9KTtcbiAgICBhZ2dzLnB1c2goe1xuICAgICAgYWNjZXNzb3I6IGRsLmFjY2Vzc29yKG5hbWUpLFxuICAgICAgZmllbGQ6IHRoaXMuX3NpbmdsZXRvbiA/IEMuU0lOR0xFVE9OIDogbmFtZSxcbiAgICAgIG1lYXN1cmVzOiBtZWFzLmNyZWF0ZShtZWFzdXJlcylcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBhZ2dzO1xufTtcblxucHJvdG8uX3Jlc2V0ID0gZnVuY3Rpb24oaW5wdXQsIG91dHB1dCkge1xuICB0aGlzLl9BZ2dyZWdhdG9ycyA9IG51bGw7IC8vIHJlYnVpbGQgYWdncmVnYXRvcnNcbiAgdGhpcy5hZ2dzKCk7XG4gIHJldHVybiBHcm91cEJ5LnByb3RvdHlwZS5fcmVzZXQuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcbn07XG5cbnByb3RvLl9rZXlzID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdGhpcy5fZ2IuZmllbGRzLmxlbmd0aCA/IFxuICAgIEdyb3VwQnkucHJvdG90eXBlLl9rZXlzLmNhbGwodGhpcywgeCkgOiB7a2V5czogW10sIGtleTogXCJcIn07XG59O1xuXG5wcm90by5fbmV3X2NlbGwgPSBmdW5jdGlvbih4LCBrKSB7XG4gIHZhciBjZWxsID0gR3JvdXBCeS5wcm90b3R5cGUuX25ld19jZWxsLmNhbGwodGhpcywgeCwgayksXG4gICAgICBhZ2dzID0gdGhpcy5hZ2dzKCksXG4gICAgICBpID0gMCwgbGVuID0gYWdncy5sZW5ndGgsIFxuICAgICAgYWdnO1xuXG4gIGZvcig7IGk8bGVuOyBpKyspIHtcbiAgICBhZ2cgPSBhZ2dzW2ldO1xuICAgIGNlbGxbYWdnLmZpZWxkXSA9IG5ldyBhZ2cubWVhc3VyZXMoY2VsbCwgY2VsbC50cGwpO1xuICB9XG5cbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYyA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dzID0gdGhpcy5hZ2dzKCksXG4gICAgICBpID0gMCwgbGVuID0gYWdncy5sZW5ndGgsXG4gICAgICBhZ2c7XG5cbiAgYy5jbnQrKztcbiAgZm9yKDsgaTxsZW47IGkrKykge1xuICAgIGFnZyA9IGFnZ3NbaV07XG4gICAgY1thZ2cuZmllbGRdLmFkZChhZ2cuYWNjZXNzb3IoeCkpO1xuICB9XG4gIGMuZmxnIHw9IEMuTU9EX0NFTEw7XG59O1xuXG5wcm90by5fcmVtID0gZnVuY3Rpb24oeCkge1xuICB2YXIgYyA9IHRoaXMuX2NlbGwoeCksXG4gICAgICBhZ2dzID0gdGhpcy5hZ2dzKCksXG4gICAgICBpID0gMCwgbGVuID0gYWdncy5sZW5ndGgsXG4gICAgICBhZ2c7XG5cbiAgYy5jbnQtLTtcbiAgZm9yKDsgaTxsZW47IGkrKykge1xuICAgIGFnZyA9IGFnZ3NbaV07XG4gICAgY1thZ2cuZmllbGRdLnJlbShhZ2cuYWNjZXNzb3IoeCkpO1xuICB9XG4gIGMuZmxnIHw9IEMuTU9EX0NFTEw7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImFnZ3JlZ2F0ZVwiXSk7XG5cbiAgdGhpcy5fZ2IgPSB0aGlzLmdyb3VwX2J5LmdldCh0aGlzLl9ncmFwaCk7XG5cbiAgdmFyIG91dHB1dCA9IEdyb3VwQnkucHJvdG90eXBlLnRyYW5zZm9ybS5jYWxsKHRoaXMsIGlucHV0LCByZXNldCksXG4gICAgICBhZ2dzID0gdGhpcy5hZ2dzKCksXG4gICAgICBsZW4gPSBhZ2dzLmxlbmd0aCxcbiAgICAgIGksIGssIGM7XG5cbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoIWMpIGNvbnRpbnVlO1xuICAgIGZvcihpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgIGNbYWdnc1tpXS5maWVsZF0uc2V0KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQWdncmVnYXRlOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpO1xuXG5mdW5jdGlvbiBCYXRjaFRyYW5zZm9ybSgpIHtcbn1cblxudmFyIHByb3RvID0gKEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIHRoaXMuX2NvbGxlY3RvciA9IG5ldyBDb2xsZWN0b3IoZ3JhcGgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIE1hdGVyaWFsaXplIHRoZSBjdXJyZW50IGRhdGFzb3VyY2UuXG4gIC8vIFRPRE86IGVmZmljaWVudGx5IHNoYXJlIGNvbGxlY3RvcnNcbiAgdGhpcy5fY29sbGVjdG9yLmV2YWx1YXRlKGlucHV0KTtcbiAgdmFyIGRhdGEgPSB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpO1xuICByZXR1cm4gdGhpcy5iYXRjaFRyYW5zZm9ybShpbnB1dCwgZGF0YSk7XG59O1xuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhdGNoVHJhbnNmb3JtO1xuIiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBCaW4oZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6IHt0eXBlOiBcImZpZWxkXCJ9LFxuICAgIG1pbjoge3R5cGU6IFwidmFsdWVcIn0sXG4gICAgbWF4OiB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBzdGVwOiB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBtYXhiaW5zOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAyMH1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1wiYmluXCI6IFwiYmluXCJ9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEJpbi5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgdHJhbnNmb3JtID0gdGhpcyxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dC5iaW47XG4gICAgICBcbiAgdmFyIGIgPSBkbC5iaW4oe1xuICAgIG1pbjogdGhpcy5taW4uZ2V0KCksXG4gICAgbWF4OiB0aGlzLm1heC5nZXQoKSxcbiAgICBzdGVwOiB0aGlzLnN0ZXAuZ2V0KCksXG4gICAgbWF4YmluczogdGhpcy5tYXhiaW5zLmdldCgpXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZShkKSB7XG4gICAgdmFyIHYgPSB0cmFuc2Zvcm0uZmllbGQuZ2V0KCkuYWNjZXNzb3IoZCk7XG4gICAgdiA9IHYgPT0gbnVsbCA/IG51bGxcbiAgICAgIDogYi5zdGFydCArIGIuc3RlcCAqIH5+KCh2IC0gYi5zdGFydCkgLyBiLnN0ZXApO1xuICAgIHR1cGxlLnNldChkLCBvdXRwdXQsIHYsIGlucHV0LnN0YW1wKTtcbiAgfVxuICBpbnB1dC5hZGQuZm9yRWFjaCh1cGRhdGUpO1xuICBpbnB1dC5tb2QuZm9yRWFjaCh1cGRhdGUpO1xuICBpbnB1dC5yZW0uZm9yRWFjaCh1cGRhdGUpO1xuXG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmluOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIENvbGxlY3RvciA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L0NvbGxlY3RvcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gQ3Jvc3MoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgd2l0aDoge3R5cGU6IFwiZGF0YVwifSxcbiAgICBkaWFnb25hbDoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogXCJ0cnVlXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcImxlZnRcIjogXCJhXCIsIFwicmlnaHRcIjogXCJiXCJ9O1xuICB0aGlzLl9jb2xsZWN0b3IgPSBuZXcgQ29sbGVjdG9yKGdyYXBoKTtcbiAgdGhpcy5fbGFzdFJlbSAgPSBudWxsOyAvLyBNb3N0IHJlY2VudCBzdGFtcCB0aGF0IHJlbSBvY2N1cmVkLiBcbiAgdGhpcy5fbGFzdFdpdGggPSBudWxsOyAvLyBMYXN0IHRpbWUgd2UgY3Jvc3NlZCB3L3dpdGhkcy5cbiAgdGhpcy5faWRzICAgPSB7fTtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcblxuICByZXR1cm4gdGhpcy5yb3V0ZXIodHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChDcm9zcy5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG4vLyBFYWNoIGNhY2hlZCBpbmNvbWluZyB0dXBsZSBhbHNvIGhhcyBhIHN0YW1wIHRvIHRyYWNrIGlmIHdlIG5lZWQgdG8gZG9cbi8vIGxhenkgZmlsdGVyaW5nIG9mIHJlbW92ZWQgdHVwbGVzLlxuZnVuY3Rpb24gY2FjaGUoeCwgdCkge1xuICB2YXIgYyA9IHRoaXMuX2NhY2hlW3guX2lkXSA9IHRoaXMuX2NhY2hlW3guX2lkXSB8fCB7YzogW10sIHM6IHRoaXMuX3N0YW1wfTtcbiAgYy5jLnB1c2godCk7XG59XG5cbmZ1bmN0aW9uIGFkZChvdXRwdXQsIGxlZnQsIHdkYXRhLCBkaWFnLCB4KSB7XG4gIHZhciBkYXRhID0gbGVmdCA/IHdkYXRhIDogdGhpcy5fY29sbGVjdG9yLmRhdGEoKSwgLy8gTGVmdCB0dXBsZXMgY3Jvc3Mgdy9yaWdodC5cbiAgICAgIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIHByZXYgID0geC5fcHJldiAhPT0gdW5kZWZpbmVkID8gbnVsbCA6IHVuZGVmaW5lZCwgXG4gICAgICB0LCB5LCBpZDtcblxuICBmb3IoOyBpPGxlbjsgKytpKSB7XG4gICAgeSA9IGRhdGFbaV07XG4gICAgaWQgPSBsZWZ0ID8geC5faWQrXCJfXCIreS5faWQgOiB5Ll9pZCtcIl9cIit4Ll9pZDtcbiAgICBpZih0aGlzLl9pZHNbaWRdKSBjb250aW51ZTtcbiAgICBpZih4Ll9pZCA9PSB5Ll9pZCAmJiAhZGlhZykgY29udGludWU7XG5cbiAgICB0ID0gdHVwbGUuaW5nZXN0KHt9LCBwcmV2KTtcbiAgICB0W3RoaXMuX291dHB1dC5sZWZ0XSAgPSBsZWZ0ID8geCA6IHk7XG4gICAgdFt0aGlzLl9vdXRwdXQucmlnaHRdID0gbGVmdCA/IHkgOiB4O1xuICAgIG91dHB1dC5hZGQucHVzaCh0KTtcbiAgICBjYWNoZS5jYWxsKHRoaXMsIHgsIHQpO1xuICAgIGNhY2hlLmNhbGwodGhpcywgeSwgdCk7XG4gICAgdGhpcy5faWRzW2lkXSA9IDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gbW9kKG91dHB1dCwgbGVmdCwgeCkge1xuICB2YXIgY3Jvc3MgPSB0aGlzLFxuICAgICAgYyA9IHRoaXMuX2NhY2hlW3guX2lkXTtcblxuICBpZih0aGlzLl9sYXN0UmVtID4gYy5zKSB7ICAvLyBSZW1vdmVkIHR1cGxlcyBoYXZlbid0IGJlZW4gZmlsdGVyZWQgeWV0XG4gICAgYy5jID0gYy5jLmZpbHRlcihmdW5jdGlvbih5KSB7XG4gICAgICB2YXIgdCA9IHlbY3Jvc3MuX291dHB1dFtsZWZ0ID8gXCJyaWdodFwiIDogXCJsZWZ0XCJdXTtcbiAgICAgIHJldHVybiBjcm9zcy5fY2FjaGVbdC5faWRdICE9PSBudWxsO1xuICAgIH0pO1xuICAgIGMucyA9IHRoaXMuX2xhc3RSZW07XG4gIH1cblxuICBvdXRwdXQubW9kLnB1c2guYXBwbHkob3V0cHV0Lm1vZCwgYy5jKTtcbn1cblxuZnVuY3Rpb24gcmVtKG91dHB1dCwgeCkge1xuICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgdGhpcy5fY2FjaGVbeC5faWRdLmMpO1xuICB0aGlzLl9jYWNoZVt4Ll9pZF0gPSBudWxsO1xuICB0aGlzLl9sYXN0UmVtID0gdGhpcy5fc3RhbXA7XG59XG5cbmZ1bmN0aW9uIHVwRmllbGRzKGlucHV0LCBvdXRwdXQpIHtcbiAgaWYoaW5wdXQuYWRkLmxlbmd0aCB8fCBpbnB1dC5yZW0ubGVuZ3RoKSB7XG4gICAgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQubGVmdF0gID0gMTsgXG4gICAgb3V0cHV0LmZpZWxkc1t0aGlzLl9vdXRwdXQucmlnaHRdID0gMTtcbiAgfVxufVxuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICBkZWJ1ZyhpbnB1dCwgW1wiY3Jvc3NpbmdcIl0pO1xuXG4gIC8vIE1hdGVyaWFsaXplIHRoZSBjdXJyZW50IGRhdGFzb3VyY2UuIFRPRE86IHNoYXJlIGNvbGxlY3RvcnNcbiAgdGhpcy5fY29sbGVjdG9yLmV2YWx1YXRlKGlucHV0KTtcblxuICB2YXIgdyA9IHRoaXMud2l0aC5nZXQodGhpcy5fZ3JhcGgpLFxuICAgICAgZGlhZyA9IHRoaXMuZGlhZ29uYWwuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIHNlbGZDcm9zcyA9ICghdy5uYW1lKSxcbiAgICAgIGRhdGEgPSB0aGlzLl9jb2xsZWN0b3IuZGF0YSgpLFxuICAgICAgd291dHB1dCA9IHNlbGZDcm9zcyA/IGlucHV0IDogdy5zb3VyY2UubGFzdCgpLFxuICAgICAgd2RhdGEgICA9IHNlbGZDcm9zcyA/IGRhdGEgOiB3LnNvdXJjZS52YWx1ZXMoKSxcbiAgICAgIG91dHB1dCAgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIHIgPSByZW0uYmluZCh0aGlzLCBvdXRwdXQpOyBcblxuICBpbnB1dC5yZW0uZm9yRWFjaChyKTtcbiAgaW5wdXQuYWRkLmZvckVhY2goYWRkLmJpbmQodGhpcywgb3V0cHV0LCB0cnVlLCB3ZGF0YSwgZGlhZykpO1xuXG4gIGlmKCFzZWxmQ3Jvc3MgJiYgd291dHB1dC5zdGFtcCA+IHRoaXMuX2xhc3RXaXRoKSB7XG4gICAgd291dHB1dC5yZW0uZm9yRWFjaChyKTtcbiAgICB3b3V0cHV0LmFkZC5mb3JFYWNoKGFkZC5iaW5kKHRoaXMsIG91dHB1dCwgZmFsc2UsIGRhdGEsIGRpYWcpKTtcbiAgICB3b3V0cHV0Lm1vZC5mb3JFYWNoKG1vZC5iaW5kKHRoaXMsIG91dHB1dCwgZmFsc2UpKTtcbiAgICB1cEZpZWxkcy5jYWxsKHRoaXMsIHdvdXRwdXQsIG91dHB1dCk7XG4gICAgdGhpcy5fbGFzdFdpdGggPSB3b3V0cHV0LnN0YW1wO1xuICB9XG5cbiAgLy8gTW9kcyBuZWVkIHRvIGNvbWUgYWZ0ZXIgYWxsIHJlbW92YWxzIGhhdmUgYmVlbiBydW4uXG4gIGlucHV0Lm1vZC5mb3JFYWNoKG1vZC5iaW5kKHRoaXMsIG91dHB1dCwgdHJ1ZSkpO1xuICB1cEZpZWxkcy5jYWxsKHRoaXMsIGlucHV0LCBvdXRwdXQpO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENyb3NzOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEdyb3VwQnkgPSByZXF1aXJlKCcuL0dyb3VwQnknKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksIFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBGYWNldChncmFwaCkge1xuICBHcm91cEJ5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7a2V5czoge3R5cGU6IFwiYXJyYXk8ZmllbGQ+XCJ9IH0pO1xuXG4gIHRoaXMuX3BpcGVsaW5lID0gW107XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRmFjZXQucHJvdG90eXBlID0gbmV3IEdyb3VwQnkoKSk7XG5cbnByb3RvLnBpcGVsaW5lID0gZnVuY3Rpb24ocGlwZWxpbmUpIHtcbiAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9waXBlbGluZTtcbiAgdGhpcy5fcGlwZWxpbmUgPSBwaXBlbGluZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5fcmVzZXQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0KSB7XG4gIHZhciBrLCBjO1xuICBmb3IoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGMgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZighYykgY29udGludWU7XG4gICAgb3V0cHV0LnJlbS5wdXNoKGMudHBsKTtcbiAgICBjLmRlbGV0ZSgpO1xuICB9XG4gIHRoaXMuX2NlbGxzID0ge307XG59O1xuXG5wcm90by5fbmV3X3R1cGxlID0gZnVuY3Rpb24oeCwgaykge1xuICByZXR1cm4gdHVwbGUuaW5nZXN0KGssIG51bGwpO1xufTtcblxucHJvdG8uX25ld19jZWxsID0gZnVuY3Rpb24oeCwgaykge1xuICAvLyBSYXRoZXIgdGhhbiBzaGFyaW5nIHRoZSBwaXBlbGluZSBiZXR3ZWVuIGFsbCBub2RlcyxcbiAgLy8gZ2l2ZSBlYWNoIGNlbGwgaXRzIGluZGl2aWR1YWwgcGlwZWxpbmUuIFRoaXMgYWxsb3dzXG4gIC8vIGR5bmFtaWNhbGx5IGFkZGVkIGNvbGxlY3RvcnMgdG8gZG8gdGhlIHJpZ2h0IHRoaW5nXG4gIC8vIHdoZW4gd2lyaW5nIHVwIHRoZSBwaXBlbGluZXMuXG4gIHZhciBjZWxsID0gR3JvdXBCeS5wcm90b3R5cGUuX25ld19jZWxsLmNhbGwodGhpcywgeCwgayksXG4gICAgICBwaXBlbGluZSA9IHRoaXMuX3BpcGVsaW5lLm1hcChmdW5jdGlvbihuKSB7IHJldHVybiBuLmNsb25lKCk7IH0pLFxuICAgICAgZmFjZXQgPSB0aGlzLFxuICAgICAgdCA9IGNlbGwudHBsO1xuXG4gIGNlbGwuZHMgPSB0aGlzLl9ncmFwaC5kYXRhKFwidmdfXCIrdC5faWQsIHBpcGVsaW5lLCB0KTtcbiAgY2VsbC5kZWxldGUgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zyh7fSwgW1wiZGVsZXRpbmcgY2VsbFwiLCBrLmtleV0pO1xuICAgIGZhY2V0LnJlbW92ZUxpc3RlbmVyKHBpcGVsaW5lWzBdKTtcbiAgICBmYWNldC5fZ3JhcGguZGlzY29ubmVjdChwaXBlbGluZSk7XG4gIH07XG5cbiAgdGhpcy5hZGRMaXN0ZW5lcihwaXBlbGluZVswXSk7XG5cbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fYWRkID0gZnVuY3Rpb24oeCkge1xuICB2YXIgY2VsbCA9IEdyb3VwQnkucHJvdG90eXBlLl9hZGQuY2FsbCh0aGlzLCB4KTtcbiAgY2VsbC5kcy5faW5wdXQuYWRkLnB1c2goeCk7XG4gIHJldHVybiBjZWxsO1xufTtcblxucHJvdG8uX21vZCA9IGZ1bmN0aW9uKHgsIHJlc2V0KSB7XG4gIHZhciBjZWxsID0gR3JvdXBCeS5wcm90b3R5cGUuX21vZC5jYWxsKHRoaXMsIHgsIHJlc2V0KTtcbiAgaWYoIShjZWxsLmZsZyAmIEMuQUREX0NFTEwpKSBjZWxsLmRzLl9pbnB1dC5tb2QucHVzaCh4KTsgLy8gUHJvcGFnYXRlIHR1cGxlc1xuICBjZWxsLmZsZyB8PSBDLk1PRF9DRUxMO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9yZW0gPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gR3JvdXBCeS5wcm90b3R5cGUuX3JlbS5jYWxsKHRoaXMsIHgpO1xuICBjZWxsLmRzLl9pbnB1dC5yZW0ucHVzaCh4KTtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImZhY2V0aW5nXCJdKTtcblxuICB0aGlzLl9nYiA9IHRoaXMua2V5cy5nZXQodGhpcy5fZ3JhcGgpO1xuXG4gIHZhciBvdXRwdXQgPSBHcm91cEJ5LnByb3RvdHlwZS50cmFuc2Zvcm0uY2FsbCh0aGlzLCBpbnB1dCwgcmVzZXQpLFxuICAgICAgaywgYztcblxuICBmb3IoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGMgPSB0aGlzLl9jZWxsc1trXTtcbiAgICBpZihjID09IG51bGwpIGNvbnRpbnVlO1xuICAgIGlmKGMuY250ID09PSAwKSB7XG4gICAgICBjLmRlbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwcm9wYWdhdGUgc29ydCwgc2lnbmFscywgZmllbGRzLCBldGMuXG4gICAgICBjaGFuZ2VzZXQuY29weShpbnB1dCwgYy5kcy5faW5wdXQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2V0OyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIGNoYW5nZXNldCA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L2NoYW5nZXNldCcpLCBcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBGaWx0ZXIoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7dGVzdDoge3R5cGU6IFwiZXhwclwifSB9KTtcblxuICB0aGlzLl9za2lwID0ge307XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoRmlsdGVyLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIHRlc3QoeCkge1xuICByZXR1cm4gZXhwci5ldmFsKHRoaXMuX2dyYXBoLCB0aGlzLnRlc3QuZ2V0KHRoaXMuX2dyYXBoKSwgXG4gICAgeCwgbnVsbCwgbnVsbCwgbnVsbCwgdGhpcy5kZXBlbmRlbmN5KEMuU0lHTkFMUykpO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImZpbHRlcmluZ1wiXSk7XG4gIHZhciBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIHNraXAgPSB0aGlzLl9za2lwLFxuICAgICAgZiA9IHRoaXM7XG5cbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmIChza2lwW3guX2lkXSAhPT0gMSkgb3V0cHV0LnJlbS5wdXNoKHgpO1xuICAgIGVsc2Ugc2tpcFt4Ll9pZF0gPSAwO1xuICB9KTtcblxuICBpbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgaWYgKHRlc3QuY2FsbChmLCB4KSkgb3V0cHV0LmFkZC5wdXNoKHgpO1xuICAgIGVsc2Ugc2tpcFt4Ll9pZF0gPSAxO1xuICB9KTtcblxuICBpbnB1dC5tb2QuZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgdmFyIGIgPSB0ZXN0LmNhbGwoZiwgeCksXG4gICAgICAgIHMgPSAoc2tpcFt4Ll9pZF0gPT09IDEpO1xuICAgIGlmIChiICYmIHMpIHtcbiAgICAgIHNraXBbeC5faWRdID0gMDtcbiAgICAgIG91dHB1dC5hZGQucHVzaCh4KTtcbiAgICB9IGVsc2UgaWYgKGIgJiYgIXMpIHtcbiAgICAgIG91dHB1dC5tb2QucHVzaCh4KTtcbiAgICB9IGVsc2UgaWYgKCFiICYmIHMpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcsIGtlZXAgc2tpcCB0cnVlXG4gICAgfSBlbHNlIHsgLy8gIWIgJiYgIXNcbiAgICAgIG91dHB1dC5yZW0ucHVzaCh4KTtcbiAgICAgIHNraXBbeC5faWRdID0gMTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpbHRlcjsiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKSwgXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKTtcblxuZnVuY3Rpb24gRm9sZChncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBmaWVsZHM6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSBcbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge2tleTogXCJrZXlcIiwgdmFsdWU6IFwidmFsdWVcIn07XG4gIHRoaXMuX2NhY2hlID0ge307XG5cbiAgcmV0dXJuIHRoaXMucm91dGVyKHRydWUpLnJldmlzZXModHJ1ZSk7XG59XG5cbnZhciBwcm90byA9IChGb2xkLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIHJzdChpbnB1dCwgb3V0cHV0KSB7IFxuICBmb3IodmFyIGlkIGluIHRoaXMuX2NhY2hlKSBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgdGhpcy5fY2FjaGVbaWRdKTtcbiAgdGhpcy5fY2FjaGUgPSB7fTtcbn07XG5cbmZ1bmN0aW9uIGdldF90dXBsZSh4LCBpLCBsZW4pIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9jYWNoZVt4Ll9pZF0gfHwgKHRoaXMuX2NhY2hlW3guX2lkXSA9IEFycmF5KGxlbikpO1xuICByZXR1cm4gbGlzdFtpXSB8fCAobGlzdFtpXSA9IHR1cGxlLmRlcml2ZSh4LCB4Ll9wcmV2KSk7XG59O1xuXG5mdW5jdGlvbiBmbihkYXRhLCBmaWVsZHMsIGFjY2Vzc29ycywgb3V0LCBzdGFtcCkge1xuICB2YXIgaSA9IDAsIGRsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIGosIGZsZW4gPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgZCwgdDtcblxuICBmb3IoOyBpPGRsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvcihqPTA7IGo8ZmxlbjsgKytqKSB7XG4gICAgICB0ID0gZ2V0X3R1cGxlLmNhbGwodGhpcywgZCwgaiwgZmxlbik7ICBcbiAgICAgIHR1cGxlLnNldCh0LCB0aGlzLl9vdXRwdXQua2V5LCBmaWVsZHNbal0pO1xuICAgICAgdHVwbGUuc2V0KHQsIHRoaXMuX291dHB1dC52YWx1ZSwgYWNjZXNzb3JzW2pdKGQpKTtcbiAgICAgIG91dC5wdXNoKHQpO1xuICAgIH0gICAgICBcbiAgfVxufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIHJlc2V0KSB7XG4gIGRlYnVnKGlucHV0LCBbXCJmb2xkaW5nXCJdKTtcblxuICB2YXIgZm9sZCA9IHRoaXMsXG4gICAgICBvbiA9IHRoaXMuZmllbGRzLmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBmaWVsZHMgPSBvbi5maWVsZHMsIGFjY2Vzc29ycyA9IG9uLmFjY2Vzc29ycyxcbiAgICAgIG91dHB1dCA9IGNoYW5nZXNldC5jcmVhdGUoaW5wdXQpO1xuXG4gIGlmKHJlc2V0KSByc3QuY2FsbCh0aGlzLCBpbnB1dCwgb3V0cHV0KTtcblxuICBmbi5jYWxsKHRoaXMsIGlucHV0LmFkZCwgZmllbGRzLCBhY2Nlc3NvcnMsIG91dHB1dC5hZGQsIGlucHV0LnN0YW1wKTtcbiAgZm4uY2FsbCh0aGlzLCBpbnB1dC5tb2QsIGZpZWxkcywgYWNjZXNzb3JzLCByZXNldCA/IG91dHB1dC5hZGQgOiBvdXRwdXQubW9kLCBpbnB1dC5zdGFtcCk7XG4gIGlucHV0LnJlbS5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICBvdXRwdXQucmVtLnB1c2guYXBwbHkob3V0cHV0LnJlbSwgZm9sZC5fY2FjaGVbeC5faWRdKTtcbiAgICBmb2xkLl9jYWNoZVt4Ll9pZF0gPSBudWxsO1xuICB9KTtcblxuICAvLyBJZiB3ZSdyZSBvbmx5IHByb3BhZ2F0aW5nIHZhbHVlcywgZG9uJ3QgbWFyayBrZXkvdmFsdWUgYXMgdXBkYXRlZC5cbiAgaWYoaW5wdXQuYWRkLmxlbmd0aCB8fCBpbnB1dC5yZW0ubGVuZ3RoIHx8IFxuICAgIGZpZWxkcy5zb21lKGZ1bmN0aW9uKGYpIHsgcmV0dXJuICEhaW5wdXQuZmllbGRzW2ZdOyB9KSlcbiAgICAgIG91dHB1dC5maWVsZHNbdGhpcy5fb3V0cHV0LmtleV0gPSAxLCBvdXRwdXQuZmllbGRzW3RoaXMuX291dHB1dC52YWx1ZV0gPSAxO1xuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGb2xkOyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBGb3JjZShncmFwaCkge1xuICBUcmFuc2Zvcm0ucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLCBncmFwaCk7XG4gIFRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzKHRoaXMsIHtcbiAgICBzaXplOiB7dHlwZTogXCJhcnJheTx2YWx1ZT5cIiwgZGVmYXVsdDogWzUwMCwgNTAwXX0sXG4gICAgbGlua3M6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgbGlua0Rpc3RhbmNlOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAyMH0sXG4gICAgbGlua1N0cmVuZ3RoOiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiAxfSxcbiAgICBjaGFyZ2U6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IDMwfSxcbiAgICBjaGFyZ2VEaXN0YW5jZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogSW5maW5pdHl9LFxuICAgIGl0ZXJhdGlvbnM6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDUwMH0sXG4gICAgZnJpY3Rpb246IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuOX0sXG4gICAgdGhldGE6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IDAuOH0sXG4gICAgZ3Jhdml0eToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC4xfSxcbiAgICBhbHBoYToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC4xfVxuICB9KTtcblxuICB0aGlzLl9ub2RlcyA9IFtdO1xuICB0aGlzLl9saW5rcyA9IFtdO1xuICB0aGlzLl9sYXlvdXQgPSBkMy5sYXlvdXQuZm9yY2UoKTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6IFwibGF5b3V0OnhcIixcbiAgICBcInlcIjogXCJsYXlvdXQ6eVwiLFxuICAgIFwic291cmNlXCI6IFwiX3NvdXJjZVwiLFxuICAgIFwidGFyZ2V0XCI6IFwiX3RhcmdldFwiXG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChGb3JjZS5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBnZXQodHJhbnNmb3JtLCBuYW1lKSB7XG4gIHZhciB2ID0gdHJhbnNmb3JtW25hbWVdLmdldCh0cmFuc2Zvcm0uX2dyYXBoKTtcbiAgcmV0dXJuIHYuYWNjZXNzb3JcbiAgICA/IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHYuYWNjZXNzb3IoeC50dXBsZSk7IH1cbiAgICA6IHYuZmllbGQ7XG59XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG5vZGVJbnB1dCkge1xuICAvLyBnZXQgdmFyaWFibGVzXG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBsaW5rSW5wdXQgPSB0aGlzLmxpbmtzLmdldChnKS5zb3VyY2UubGFzdCgpLFxuICAgICAgbGF5b3V0ID0gdGhpcy5fbGF5b3V0LFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgbm9kZXMgPSB0aGlzLl9ub2RlcyxcbiAgICAgIGxpbmtzID0gdGhpcy5fbGlua3MsXG4gICAgICBpdGVyID0gdGhpcy5pdGVyYXRpb25zLmdldChnKTtcblxuICAvLyBwcm9jZXNzIGFkZGVkIG5vZGVzXG4gIG5vZGVJbnB1dC5hZGQuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgbm9kZXMucHVzaCh7dHVwbGU6IG59KTtcbiAgfSk7XG5cbiAgLy8gcHJvY2VzcyBhZGRlZCBlZGdlc1xuICBsaW5rSW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgIHZhciBsaW5rID0ge1xuICAgICAgdHVwbGU6IGwsXG4gICAgICBzb3VyY2U6IG5vZGVzW2wuc291cmNlXSxcbiAgICAgIHRhcmdldDogbm9kZXNbbC50YXJnZXRdXG4gICAgfTtcbiAgICB0dXBsZS5zZXQobCwgb3V0cHV0LnNvdXJjZSwgbGluay5zb3VyY2UudHVwbGUpO1xuICAgIHR1cGxlLnNldChsLCBvdXRwdXQudGFyZ2V0LCBsaW5rLnRhcmdldC50dXBsZSk7XG4gICAgbGlua3MucHVzaChsaW5rKTtcbiAgfSk7XG5cbiAgLy8gVE9ETyBwcm9jZXNzIFwibW9kXCIgb2YgZWRnZSBzb3VyY2Ugb3IgdGFyZ2V0P1xuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgbGF5b3V0XG4gICAgLnNpemUodGhpcy5zaXplLmdldChnKSlcbiAgICAubGlua0Rpc3RhbmNlKGdldCh0aGlzLCBcImxpbmtEaXN0YW5jZVwiKSlcbiAgICAubGlua1N0cmVuZ3RoKGdldCh0aGlzLCBcImxpbmtTdHJlbmd0aFwiKSlcbiAgICAuY2hhcmdlKGdldCh0aGlzLCBcImNoYXJnZVwiKSlcbiAgICAuY2hhcmdlRGlzdGFuY2UoZ2V0KHRoaXMsIFwiY2hhcmdlRGlzdGFuY2VcIikpXG4gICAgLmZyaWN0aW9uKHRoaXMuZnJpY3Rpb24uZ2V0KGcpKVxuICAgIC50aGV0YSh0aGlzLnRoZXRhLmdldChnKSlcbiAgICAuZ3Jhdml0eSh0aGlzLmdyYXZpdHkuZ2V0KGcpKVxuICAgIC5hbHBoYSh0aGlzLmFscGhhLmdldChnKSlcbiAgICAubm9kZXMobm9kZXMpXG4gICAgLmxpbmtzKGxpbmtzKTtcblxuICAvLyBydW4gbGF5b3V0XG4gIGxheW91dC5zdGFydCgpO1xuICBmb3IgKHZhciBpPTA7IGk8aXRlcjsgKytpKSB7XG4gICAgbGF5b3V0LnRpY2soKTtcbiAgfVxuICBsYXlvdXQuc3RvcCgpO1xuXG4gIC8vIGNvcHkgbGF5b3V0IHZhbHVlcyB0byBub2Rlc1xuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB0dXBsZS5zZXQobi50dXBsZSwgb3V0cHV0LngsIG4ueCk7XG4gICAgdHVwbGUuc2V0KG4udHVwbGUsIG91dHB1dC55LCBuLnkpO1xuICB9KTtcblxuICAvLyBwcm9jZXNzIHJlbW92ZWQgbm9kZXNcbiAgaWYgKG5vZGVJbnB1dC5yZW0ubGVuZ3RoID4gMCkge1xuICAgIHZhciBub2RlSWRzID0gdHVwbGUuaWRNYXAobm9kZUlucHV0LnJlbSk7XG4gICAgdGhpcy5fbm9kZXMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24obikgeyByZXR1cm4gIW5vZGVJZHNbbi50dXBsZS5faWRdOyB9KTtcbiAgfVxuXG4gIC8vIHByb2Nlc3MgcmVtb3ZlZCBlZGdlc1xuICBpZiAobGlua0lucHV0LnJlbS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGxpbmtJZHMgPSB0dXBsZS5pZE1hcChsaW5rSW5wdXQucmVtKTtcbiAgICB0aGlzLl9saW5rcyA9IGxpbmtzLmZpbHRlcihmdW5jdGlvbihsKSB7IHJldHVybiAhbGlua0lkc1tsLnR1cGxlLl9pZF07IH0pO1xuICB9XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBub2RlSW5wdXQuZmllbGRzW291dHB1dC54XSA9IDE7XG4gIG5vZGVJbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgcmV0dXJuIG5vZGVJbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9yY2U7IiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpLCBcbiAgICBleHByZXNzaW9uID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG5mdW5jdGlvbiBGb3JtdWxhKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGZpZWxkOiB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBleHByOiAge3R5cGU6IFwiZXhwclwifVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEZvcm11bGEucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcImZvcm11bGF0aW5nXCJdKTtcbiAgdmFyIHQgPSB0aGlzLCBcbiAgICAgIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIGZpZWxkID0gdGhpcy5maWVsZC5nZXQoZyksXG4gICAgICBleHByID0gdGhpcy5leHByLmdldChnKSxcbiAgICAgIGRlcHMgPSB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTKTtcbiAgXG4gIGZ1bmN0aW9uIHNldCh4KSB7XG4gICAgdmFyIHZhbCA9IGV4cHJlc3Npb24uZXZhbChnLCBleHByLCB4LCBudWxsLCBudWxsLCBudWxsLCBkZXBzKTtcbiAgICB0dXBsZS5zZXQoeCwgZmllbGQsIHZhbCk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBcbiAgaWYgKHRoaXMucmVldmFsdWF0ZShpbnB1dCkpIHtcbiAgICBpbnB1dC5tb2QuZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW2ZpZWxkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybXVsYTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gR2VvKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywgR2VvLlBhcmFtZXRlcnMpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgbG9uOiB7dHlwZTogXCJmaWVsZFwifSxcbiAgICBsYXQ6IHt0eXBlOiBcImZpZWxkXCJ9XG4gIH0pO1xuXG4gIHRoaXMuX291dHB1dCA9IHtcbiAgICBcInhcIjogXCJnZW86eFwiLFxuICAgIFwieVwiOiBcImdlbzp5XCJcbiAgfTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBOb25lXG5cbkdlby5QYXJhbWV0ZXJzID0ge1xuICBwcm9qZWN0aW9uOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcIm1lcmNhdG9yXCJ9LFxuICBjZW50ZXI6ICAgICB7dHlwZTogXCJhcnJheVt2YWx1ZV1cIn0sXG4gIHRyYW5zbGF0ZTogIHt0eXBlOiBcImFycmF5W3ZhbHVlXVwifSxcbiAgcm90YXRlOiAgICAge3R5cGU6IFwiYXJyYXlbdmFsdWVdXCJ9LFxuICBzY2FsZTogICAgICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgcHJlY2lzaW9uOiAge3R5cGU6IFwidmFsdWVcIn0sXG4gIGNsaXBBbmdsZTogIHt0eXBlOiBcInZhbHVlXCJ9LFxuICBjbGlwRXh0ZW50OiB7dHlwZTogXCJ2YWx1ZVwifVxufTtcblxuR2VvLmQzUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgcCA9IHRoaXMucHJvamVjdGlvbi5nZXQoZyksXG4gICAgICBwYXJhbSA9IEdlby5QYXJhbWV0ZXJzLFxuICAgICAgcHJvaiwgbmFtZSwgdmFsdWU7XG5cbiAgaWYgKHAgIT09IHRoaXMuX21vZGUpIHtcbiAgICB0aGlzLl9tb2RlID0gcDtcbiAgICB0aGlzLl9wcm9qZWN0aW9uID0gZDMuZ2VvW3BdKCk7XG4gIH1cbiAgcHJvaiA9IHRoaXMuX3Byb2plY3Rpb247XG5cbiAgZm9yIChuYW1lIGluIHBhcmFtKSB7XG4gICAgaWYgKG5hbWUgPT09IFwicHJvamVjdGlvblwiIHx8ICFwcm9qW25hbWVdKSBjb250aW51ZTtcbiAgICB2YWx1ZSA9IHRoaXNbbmFtZV0uZ2V0KGcpO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IChkbC5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBwcm9qW25hbWVdKCkpIHtcbiAgICAgIHByb2pbbmFtZV0odmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9qO1xufTtcblxudmFyIHByb3RvID0gKEdlby5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0LFxuICAgICAgbG9uID0gdGhpcy5sb24uZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgbGF0ID0gdGhpcy5sYXQuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgcHJvaiA9IEdlby5kM1Byb2plY3Rpb24uY2FsbCh0aGlzKTtcblxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHZhciBsbCA9IFtsb24odCksIGxhdCh0KV07XG4gICAgdmFyIHh5ID0gcHJvaihsbCk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC54LCB4eVswXSk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC55LCB4eVsxXSk7XG4gIH1cblxuICBpbnB1dC5hZGQuZm9yRWFjaChzZXQpO1xuICBpZiAodGhpcy5yZWV2YWx1YXRlKGlucHV0KSkge1xuICAgIGlucHV0Lm1vZC5mb3JFYWNoKHNldCk7XG4gICAgaW5wdXQucmVtLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQueF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnldID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW87XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBHZW8gPSByZXF1aXJlKCcuL0dlbycpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBHZW9QYXRoKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywgR2VvLlBhcmFtZXRlcnMpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgdmFsdWU6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IG51bGx9LFxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJwYXRoXCI6IFwiZ2VvOnBhdGhcIlxuICB9O1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKEdlb1BhdGgucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIGdlb2pzb24gPSB0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvciB8fCBkbC5pZGVudGl0eSxcbiAgICAgIHByb2ogPSBHZW8uZDNQcm9qZWN0aW9uLmNhbGwodGhpcyksXG4gICAgICBwYXRoID0gZDMuZ2VvLnBhdGgoKS5wcm9qZWN0aW9uKHByb2opO1xuXG4gIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5wYXRoLCBwYXRoKGdlb2pzb24odCkpKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgICBpbnB1dC5yZW0uZm9yRWFjaChzZXQpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5wYXRoXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VvUGF0aDtcbiIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKSxcbiAgICBjaGFuZ2VzZXQgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9jaGFuZ2VzZXQnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vdXRpbC9jb25zdGFudHMnKTtcblxuZnVuY3Rpb24gR3JvdXBCeShncmFwaCkge1xuICBpZihncmFwaCkgdGhpcy5pbml0KGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChHcm91cEJ5LnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLmluaXQgPSBmdW5jdGlvbihncmFwaCkge1xuICB0aGlzLl9nYiA9IG51bGw7IC8vIGZpZWxkcythY2Nlc3NvcnMgdG8gZ3JvdXBieSBmaWVsZHNcbiAgdGhpcy5fY2VsbHMgPSB7fTtcbiAgcmV0dXJuIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKVxuICAgIC5yb3V0ZXIodHJ1ZSkucmV2aXNlcyh0cnVlKTtcbn07XG5cbnByb3RvLmRhdGEgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2NlbGxzOyB9O1xuXG5wcm90by5fcmVzZXQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0KSB7XG4gIHZhciBrLCBjO1xuICBmb3IoayBpbiB0aGlzLl9jZWxscykge1xuICAgIGlmKCEoYyA9IHRoaXMuX2NlbGxzW2tdKSkgY29udGludWU7XG4gICAgb3V0cHV0LnJlbS5wdXNoKGMudHBsKTtcbiAgfVxuICB0aGlzLl9jZWxscyA9IHt9O1xufTtcblxucHJvdG8uX2tleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBhY2MgPSB0aGlzLl9nYi5hY2Nlc3NvcnMgfHwgW3RoaXMuX2diLmFjY2Vzc29yXTtcbiAgdmFyIGtleXMgPSBhY2MucmVkdWNlKGZ1bmN0aW9uKGcsIGYpIHtcbiAgICByZXR1cm4gKCh2ID0gZih4KSkgIT09IHVuZGVmaW5lZCkgPyAoZy5wdXNoKHYpLCBnKSA6IGc7XG4gIH0sIFtdKSwgayA9IGtleXMuam9pbihcInxcIiksIHY7XG4gIHJldHVybiBrZXlzLmxlbmd0aCA+IDAgPyB7a2V5czoga2V5cywga2V5OiBrfSA6IHVuZGVmaW5lZDtcbn07XG5cbnByb3RvLl9jZWxsID0gZnVuY3Rpb24oeCkge1xuICB2YXIgayA9IHRoaXMuX2tleXMoeCk7XG4gIHJldHVybiB0aGlzLl9jZWxsc1trLmtleV0gfHwgKHRoaXMuX2NlbGxzW2sua2V5XSA9IHRoaXMuX25ld19jZWxsKHgsIGspKTtcbn07XG5cbnByb3RvLl9uZXdfY2VsbCA9IGZ1bmN0aW9uKHgsIGspIHtcbiAgcmV0dXJuIHtcbiAgICBjbnQ6IDAsXG4gICAgdHBsOiB0aGlzLl9uZXdfdHVwbGUoeCwgayksXG4gICAgZmxnOiBDLkFERF9DRUxMXG4gIH07XG59O1xuXG5wcm90by5fbmV3X3R1cGxlID0gZnVuY3Rpb24oeCwgaykge1xuICB2YXIgZ2IgPSB0aGlzLl9nYixcbiAgICAgIGZpZWxkcyA9IGdiLmZpZWxkcyB8fCBbZ2IuZmllbGRdLFxuICAgICAgYWNjID0gZ2IuYWNjZXNzb3JzIHx8IFtnYi5hY2Nlc3Nvcl0sXG4gICAgICB0ID0ge30sIGksIGxlbjtcblxuICBmb3IoaT0wLCBsZW49ZmllbGRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHRbZmllbGRzW2ldXSA9IGFjY1tpXSh4KTtcbiAgfSBcblxuICByZXR1cm4gdHVwbGUuaW5nZXN0KHQsIG51bGwpO1xufTtcblxucHJvdG8uX2FkZCA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIGNlbGwgPSB0aGlzLl9jZWxsKHgpO1xuICBjZWxsLmNudCArPSAxO1xuICBjZWxsLmZsZyB8PSBDLk1PRF9DRUxMO1xuICByZXR1cm4gY2VsbDtcbn07XG5cbnByb3RvLl9yZW0gPSBmdW5jdGlvbih4KSB7XG4gIHZhciBjZWxsID0gdGhpcy5fY2VsbCh4KTtcbiAgY2VsbC5jbnQgLT0gMTtcbiAgY2VsbC5mbGcgfD0gQy5NT0RfQ0VMTDtcbiAgcmV0dXJuIGNlbGw7XG59O1xuXG5wcm90by5fbW9kID0gZnVuY3Rpb24oeCwgcmVzZXQpIHtcbiAgaWYoeC5fcHJldiAmJiB4Ll9wcmV2ICE9PSBDLlNFTlRJTkVMICYmIHRoaXMuX2tleXMoeC5fcHJldikgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuX3JlbSh4Ll9wcmV2KTtcbiAgICByZXR1cm4gdGhpcy5fYWRkKHgpO1xuICB9IGVsc2UgaWYocmVzZXQpIHsgLy8gU2lnbmFsIGNoYW5nZSB0cmlnZ2VyZWQgcmVmbG93XG4gICAgcmV0dXJuIHRoaXMuX2FkZCh4KTtcbiAgfVxuICByZXR1cm4gdGhpcy5fY2VsbCh4KTtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkge1xuICB2YXIgZ3JvdXBCeSA9IHRoaXMsXG4gICAgICBvdXRwdXQgPSBjaGFuZ2VzZXQuY3JlYXRlKGlucHV0KSxcbiAgICAgIGssIGMsIGYsIHQ7XG5cbiAgaWYocmVzZXQpIHRoaXMuX3Jlc2V0KGlucHV0LCBvdXRwdXQpO1xuXG4gIGlucHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgZ3JvdXBCeS5fYWRkKHgpOyB9KTtcbiAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkgeyBncm91cEJ5Ll9tb2QoeCwgcmVzZXQpOyB9KTtcbiAgaW5wdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgIGlmKHguX3ByZXYgJiYgeC5fcHJldiAhPT0gQy5TRU5USU5FTCAmJiBncm91cEJ5Ll9rZXlzKHguX3ByZXYpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGdyb3VwQnkuX3JlbSh4Ll9wcmV2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBCeS5fcmVtKHgpO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yKGsgaW4gdGhpcy5fY2VsbHMpIHtcbiAgICBjID0gdGhpcy5fY2VsbHNba107XG4gICAgaWYoIWMpIGNvbnRpbnVlO1xuICAgIGYgPSBjLmZsZztcbiAgICB0ID0gYy50cGw7XG5cbiAgICBpZihjLmNudCA9PT0gMCkge1xuICAgICAgaWYoZiA9PT0gQy5NT0RfQ0VMTCkgb3V0cHV0LnJlbS5wdXNoKHQpO1xuICAgICAgdGhpcy5fY2VsbHNba10gPSBudWxsO1xuICAgIH0gZWxzZSBpZihmICYgQy5BRERfQ0VMTCkge1xuICAgICAgb3V0cHV0LmFkZC5wdXNoKHQpO1xuICAgIH0gZWxzZSBpZihmICYgQy5NT0RfQ0VMTCkge1xuICAgICAgb3V0cHV0Lm1vZC5wdXNoKHQpO1xuICAgIH1cbiAgICBjLmZsZyA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cEJ5OyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gTGlua1BhdGgoZ3JhcGgpIHtcbiAgVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgc291cmNlOiAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJfc291cmNlXCJ9LFxuICAgIHRhcmdldDogIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiX3RhcmdldFwifSxcbiAgICB4OiAgICAgICB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBcImxheW91dDp4XCJ9LFxuICAgIHk6ICAgICAgIHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwibGF5b3V0OnlcIn0sXG4gICAgdGVuc2lvbjoge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMC4yfSxcbiAgICBzaGFwZTogICB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcImxpbmVcIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1wicGF0aFwiOiBcImxpbms6cGF0aFwifTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbnZhciBwcm90byA9IChMaW5rUGF0aC5wcm90b3R5cGUgPSBuZXcgVHJhbnNmb3JtKCkpO1xuXG5mdW5jdGlvbiBsaW5lKGQsIHNvdXJjZSwgdGFyZ2V0LCB4LCB5LCB0ZW5zaW9uKSB7XG4gIHZhciBzID0gc291cmNlKGQpLCBzeCA9IHgocyksIHN5ID0geShzKSxcbiAgICAgIHQgPSB0YXJnZXQoZCksIHR4ID0geCh0KSwgdHkgPSB5KHQpO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiTFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG5mdW5jdGlvbiBjdXJ2ZShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KSxcbiAgICAgIGR4ID0gdHggLSBzeCxcbiAgICAgIGR5ID0gdHkgLSBzeSxcbiAgICAgIGl4ID0gdGVuc2lvbiAqIChkeCArIGR5KSxcbiAgICAgIGl5ID0gdGVuc2lvbiAqIChkeSAtIGR4KTtcbiAgcmV0dXJuIFwiTVwiICsgc3ggKyBcIixcIiArIHN5XG4gICAgICAgKyBcIkNcIiArIChzeCtpeCkgKyBcIixcIiArIChzeStpeSlcbiAgICAgICArIFwiIFwiICsgKHR4K2l5KSArIFwiLFwiICsgKHR5LWl4KVxuICAgICAgICsgXCIgXCIgKyB0eCArIFwiLFwiICsgdHk7XG59XG5cbmZ1bmN0aW9uIGRpYWdvbmFsWChkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KSxcbiAgICAgIG0gPSAoc3ggKyB0eCkgLyAyO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiQ1wiICsgbSAgKyBcIixcIiArIHN5XG4gICAgICAgKyBcIiBcIiArIG0gICsgXCIsXCIgKyB0eVxuICAgICAgICsgXCIgXCIgKyB0eCArIFwiLFwiICsgdHk7XG59XG5cbmZ1bmN0aW9uIGRpYWdvbmFsWShkLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgdGVuc2lvbikge1xuICB2YXIgcyA9IHNvdXJjZShkKSwgc3ggPSB4KHMpLCBzeSA9IHkocyksXG4gICAgICB0ID0gdGFyZ2V0KGQpLCB0eCA9IHgodCksIHR5ID0geSh0KSxcbiAgICAgIG0gPSAoc3kgKyB0eSkgLyAyO1xuICByZXR1cm4gXCJNXCIgKyBzeCArIFwiLFwiICsgc3lcbiAgICAgICArIFwiQ1wiICsgc3ggKyBcIixcIiArIG1cbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIG1cbiAgICAgICArIFwiIFwiICsgdHggKyBcIixcIiArIHR5O1xufVxuXG52YXIgc2hhcGVzID0ge1xuICBsaW5lOiAgICAgIGxpbmUsXG4gIGN1cnZlOiAgICAgY3VydmUsXG4gIGRpYWdvbmFsOiAgZGlhZ29uYWxYLFxuICBkaWFnb25hbFg6IGRpYWdvbmFsWCxcbiAgZGlhZ29uYWxZOiBkaWFnb25hbFlcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBvdXRwdXQgPSB0aGlzLl9vdXRwdXQsXG4gICAgICBzaGFwZSA9IHNoYXBlc1t0aGlzLnNoYXBlLmdldChnKV0gfHwgc2hhcGVzLmxpbmUsXG4gICAgICBzb3VyY2UgPSB0aGlzLnNvdXJjZS5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldC5nZXQoZykuYWNjZXNzb3IsXG4gICAgICB4ID0gdGhpcy54LmdldChnKS5hY2Nlc3NvcixcbiAgICAgIHkgPSB0aGlzLnkuZ2V0KGcpLmFjY2Vzc29yLFxuICAgICAgdGVuc2lvbiA9IHRoaXMudGVuc2lvbi5nZXQoZyk7XG4gIFxuICBmdW5jdGlvbiBzZXQodCkge1xuICAgIHZhciBwYXRoID0gc2hhcGUodCwgc291cmNlLCB0YXJnZXQsIHgsIHksIHRlbnNpb24pXG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5wYXRoLCBwYXRoKTtcbiAgfVxuXG4gIGlucHV0LmFkZC5mb3JFYWNoKHNldCk7XG4gIGlmICh0aGlzLnJlZXZhbHVhdGUoaW5wdXQpKSB7XG4gICAgaW5wdXQubW9kLmZvckVhY2goc2V0KTtcbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQucGF0aF0gPSAxO1xuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtQYXRoOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIEMgPSByZXF1aXJlKCcuLi91dGlsL2NvbnN0YW50cycpO1xuXG52YXIgYXJyYXlUeXBlID0gL2FycmF5L2ksXG4gICAgZGF0YVR5cGUgID0gL2RhdGEvaSxcbiAgICBmaWVsZFR5cGUgPSAvZmllbGQvaSxcbiAgICBleHByVHlwZSAgPSAvZXhwci9pO1xuXG5mdW5jdGlvbiBQYXJhbWV0ZXIobmFtZSwgdHlwZSkge1xuICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgdGhpcy5fdHlwZSA9IHR5cGU7XG5cbiAgLy8gSWYgcGFyYW1ldGVyIGlzIGRlZmluZWQgdy9zaWduYWxzLCBpdCBtdXN0IGJlIHJlc29sdmVkXG4gIC8vIG9uIGV2ZXJ5IHB1bHNlLlxuICB0aGlzLl92YWx1ZSA9IFtdO1xuICB0aGlzLl9hY2Nlc3NvcnMgPSBbXTtcbiAgdGhpcy5fcmVzb2x1dGlvbiA9IGZhbHNlO1xuICB0aGlzLl9zaWduYWxzID0ge307XG59XG5cbnZhciBwcm90byA9IFBhcmFtZXRlci5wcm90b3R5cGU7XG5cbnByb3RvLl9nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlzQXJyYXkgPSBhcnJheVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpO1xuXG4gIGlmIChpc0RhdGEpIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHsgbmFtZXM6IHRoaXMuX3ZhbHVlLCBzb3VyY2VzOiB0aGlzLl9hY2Nlc3NvcnMgfSA6XG4gICAgICB7IG5hbWU6IHRoaXMuX3ZhbHVlWzBdLCBzb3VyY2U6IHRoaXMuX2FjY2Vzc29yc1swXSB9O1xuICB9IGVsc2UgaWYgKGlzRmllbGQpIHtcbiAgICByZXR1cm4gaXNBcnJheSA/IHsgZmllbGRzOiB0aGlzLl92YWx1ZSwgYWNjZXNzb3JzOiB0aGlzLl9hY2Nlc3NvcnMgfSA6XG4gICAgICB7IGZpZWxkOiB0aGlzLl92YWx1ZVswXSwgYWNjZXNzb3I6IHRoaXMuX2FjY2Vzc29yc1swXSB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc0FycmF5ID8gdGhpcy5fdmFsdWUgOiB0aGlzLl92YWx1ZVswXTtcbiAgfVxufTtcblxucHJvdG8uZ2V0ID0gZnVuY3Rpb24oZ3JhcGgpIHtcbiAgdmFyIGlzRGF0YSAgPSBkYXRhVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgaXNGaWVsZCA9IGZpZWxkVHlwZS50ZXN0KHRoaXMuX3R5cGUpLFxuICAgICAgcywgaWR4LCB2YWw7XG5cbiAgLy8gSWYgd2UgZG9uJ3QgcmVxdWlyZSByZXNvbHV0aW9uLCByZXR1cm4gdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICBpZiAoIXRoaXMuX3Jlc29sdXRpb24pIHJldHVybiB0aGlzLl9nZXQoKTtcblxuICBpZiAoaXNEYXRhKSB7XG4gICAgdGhpcy5fYWNjZXNzb3JzID0gdGhpcy5fdmFsdWUubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGdyYXBoLmRhdGEodik7IH0pO1xuICAgIHJldHVybiB0aGlzLl9nZXQoKTsgLy8gVE9ETzogc3VwcG9ydCBzaWduYWwgYXMgZGF0YVR5cGVzXG4gIH1cblxuICBmb3IocyBpbiB0aGlzLl9zaWduYWxzKSB7XG4gICAgaWR4ICA9IHRoaXMuX3NpZ25hbHNbc107XG4gICAgdmFsICA9IGdyYXBoLnNpZ25hbFJlZihzKTtcblxuICAgIGlmIChpc0ZpZWxkKSB7XG4gICAgICB0aGlzLl9hY2Nlc3NvcnNbaWR4XSA9IHRoaXMuX3ZhbHVlW2lkeF0gIT0gdmFsID8gXG4gICAgICAgIGRsLmFjY2Vzc29yKHZhbCkgOiB0aGlzLl9hY2Nlc3NvcnNbaWR4XTtcbiAgICB9XG5cbiAgICB0aGlzLl92YWx1ZVtpZHhdID0gdmFsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX2dldCgpO1xufTtcblxucHJvdG8uc2V0ID0gZnVuY3Rpb24odHJhbnNmb3JtLCB2YWx1ZSkge1xuICB2YXIgcGFyYW0gPSB0aGlzLCBcbiAgICAgIGlzRXhwciA9IGV4cHJUeXBlLnRlc3QodGhpcy5fdHlwZSksXG4gICAgICBpc0RhdGEgID0gZGF0YVR5cGUudGVzdCh0aGlzLl90eXBlKSxcbiAgICAgIGlzRmllbGQgPSBmaWVsZFR5cGUudGVzdCh0aGlzLl90eXBlKTtcblxuICB0aGlzLl92YWx1ZSA9IGRsLmFycmF5KHZhbHVlKS5tYXAoZnVuY3Rpb24odiwgaSkge1xuICAgIGlmIChkbC5pc1N0cmluZyh2KSkge1xuICAgICAgaWYgKGlzRXhwcikge1xuICAgICAgICB2YXIgZSA9IGV4cHIodik7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCAgZS5maWVsZHMpO1xuICAgICAgICB0cmFuc2Zvcm0uZGVwZW5kZW5jeShDLlNJR05BTFMsIGUuc2lnbmFscyk7XG4gICAgICAgIHJldHVybiBlLmZuO1xuICAgICAgfSBlbHNlIGlmIChpc0ZpZWxkKSB7ICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICBwYXJhbS5fYWNjZXNzb3JzW2ldID0gZGwuYWNjZXNzb3Iodik7XG4gICAgICAgIHRyYW5zZm9ybS5kZXBlbmRlbmN5KEMuRklFTERTLCB2KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEYXRhKSB7XG4gICAgICAgIHBhcmFtLl9yZXNvbHV0aW9uID0gdHJ1ZTtcbiAgICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5EQVRBLCB2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH0gZWxzZSBpZiAodi52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdi52YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHYuZmllbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyYW0uX2FjY2Vzc29yc1tpXSA9IGRsLmFjY2Vzc29yKHYuZmllbGQpO1xuICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5GSUVMRFMsIHYuZmllbGQpO1xuICAgICAgcmV0dXJuIHYuZmllbGQ7XG4gICAgfSBlbHNlIGlmICh2LnNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbS5fcmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICBwYXJhbS5fc2lnbmFsc1t2LnNpZ25hbF0gPSBpO1xuICAgICAgdHJhbnNmb3JtLmRlcGVuZGVuY3koQy5TSUdOQUxTLCB2LnNpZ25hbCk7XG4gICAgICByZXR1cm4gdi5zaWduYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc2Zvcm07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmFtZXRlcjsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKSxcbiAgICBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEJhdGNoVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9CYXRjaFRyYW5zZm9ybScpLFxuICAgIHR1cGxlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvdHVwbGUnKTtcblxuZnVuY3Rpb24gUGllKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgdmFsdWU6ICAgICAge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogbnVsbH0sXG4gICAgc3RhcnRBbmdsZToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMH0sXG4gICAgZW5kQW5nbGU6ICAge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogMiAqIE1hdGguUEl9LFxuICAgIHNvcnQ6ICAgICAgIHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IGZhbHNlfVxuICB9KTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJzdGFydFwiOiBcImxheW91dDpzdGFydFwiLFxuICAgIFwic3RvcFwiOiAgXCJsYXlvdXQ6c3RvcFwiLFxuICAgIFwibWlkXCI6ICAgXCJsYXlvdXQ6bWlkXCJcbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFBpZS5wcm90b3R5cGUgPSBuZXcgQmF0Y2hUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIG9uZXMoKSB7IHJldHVybiAxOyB9XG5cbnByb3RvLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgdmFyIGcgPSB0aGlzLl9ncmFwaCxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dCxcbiAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5nZXQoZykuYWNjZXNzb3IgfHwgb25lcyxcbiAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydEFuZ2xlLmdldChnKSxcbiAgICAgIHN0b3AgPSB0aGlzLmVuZEFuZ2xlLmdldChnKSxcbiAgICAgIHNvcnQgPSB0aGlzLnNvcnQuZ2V0KGcpO1xuXG4gIHZhciB2YWx1ZXMgPSBkYXRhLm1hcCh2YWx1ZSksXG4gICAgICBhID0gc3RhcnQsXG4gICAgICBrID0gKHN0b3AgLSBzdGFydCkgLyBkMy5zdW0odmFsdWVzKSxcbiAgICAgIGluZGV4ID0gZGwucmFuZ2UoZGF0YS5sZW5ndGgpLFxuICAgICAgaSwgdCwgdjtcblxuICBpZiAoc29ydCkge1xuICAgIGluZGV4LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIHZhbHVlc1thXSAtIHZhbHVlc1tiXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoaT0wOyBpPGluZGV4Lmxlbmd0aDsgKytpKSB7XG4gICAgdCA9IGRhdGFbaW5kZXhbaV1dO1xuICAgIHYgPSB2YWx1ZXNbaW5kZXhbaV1dO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQuc3RhcnQsIGEpO1xuICAgIHR1cGxlLnNldCh0LCBvdXRwdXQubWlkLCAoYSArIDAuNSAqIHYgKiBrKSk7XG4gICAgdHVwbGUuc2V0KHQsIG91dHB1dC5zdG9wLCAoYSArPSB2ICogaykpO1xuICB9XG5cbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdGFydF0gPSAxO1xuICBpbnB1dC5maWVsZHNbb3V0cHV0LnN0b3BdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5taWRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWU7XG4iLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBleHByID0gcmVxdWlyZSgnLi4vcGFyc2UvZXhwcicpLFxuICAgIGRlYnVnID0gcmVxdWlyZSgnLi4vdXRpbC9kZWJ1ZycpO1xuXG5mdW5jdGlvbiBTb3J0KGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge2J5OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIn0gfSk7XG4gIHJldHVybiB0aGlzLnJvdXRlcih0cnVlKTtcbn1cblxudmFyIHByb3RvID0gKFNvcnQucHJvdG90eXBlID0gbmV3IFRyYW5zZm9ybSgpKTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcInNvcnRpbmdcIl0pO1xuXG4gIGlmKGlucHV0LmFkZC5sZW5ndGggfHwgaW5wdXQubW9kLmxlbmd0aCB8fCBpbnB1dC5yZW0ubGVuZ3RoKSB7XG4gICAgaW5wdXQuc29ydCA9IGRsLmNvbXBhcmF0b3IodGhpcy5ieS5nZXQodGhpcy5fZ3JhcGgpLmZpZWxkcyk7XG4gIH1cblxuICByZXR1cm4gaW5wdXQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvcnQ7IiwidmFyIGRsID0gcmVxdWlyZSgnZGF0YWxpYicpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBTdGFjayhncmFwaCkge1xuICBCYXRjaFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIGdyb3VwYnk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSxcbiAgICBzb3J0Ynk6IHt0eXBlOiBcImFycmF5PGZpZWxkPlwifSxcbiAgICB2YWx1ZToge3R5cGU6IFwiZmllbGRcIn0sXG4gICAgb2Zmc2V0OiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiBcInplcm9cIn1cbiAgfSk7XG5cbiAgdGhpcy5fb3V0cHV0ID0ge1xuICAgIFwic3RhcnRcIjogXCJsYXlvdXQ6c3RhcnRcIixcbiAgICBcInN0b3BcIjogIFwibGF5b3V0OnN0b3BcIixcbiAgICBcIm1pZFwiOiAgIFwibGF5b3V0Om1pZFwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoU3RhY2sucHJvdG90eXBlID0gbmV3IEJhdGNoVHJhbnNmb3JtKCkpO1xuXG5wcm90by5iYXRjaFRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCBkYXRhKSB7XG4gIHZhciBnID0gdGhpcy5fZ3JhcGgsXG4gICAgICBncm91cGJ5ID0gdGhpcy5ncm91cGJ5LmdldChnKS5hY2Nlc3NvcnMsXG4gICAgICBzb3J0YnkgPSBkbC5jb21wYXJhdG9yKHRoaXMuc29ydGJ5LmdldChnKS5maWVsZHMpLFxuICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvcixcbiAgICAgIG9mZnNldCA9IHRoaXMub2Zmc2V0LmdldChnKSxcbiAgICAgIG91dHB1dCA9IHRoaXMuX291dHB1dDtcblxuICAvLyBwYXJ0aXRpb24sIHN1bSwgYW5kIHNvcnQgdGhlIHN0YWNrIGdyb3Vwc1xuICB2YXIgZ3JvdXBzID0gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnRieSwgdmFsdWUpO1xuXG4gIC8vIGNvbXB1dGUgc3RhY2sgbGF5b3V0cyBwZXIgZ3JvdXBcbiAgZm9yICh2YXIgaT0wLCBtYXg9Z3JvdXBzLm1heDsgaTxncm91cHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV0sXG4gICAgICAgIHN1bSA9IGdyb3VwLnN1bSxcbiAgICAgICAgb2ZmID0gb2Zmc2V0PT09XCJjZW50ZXJcIiA/IChtYXggLSBzdW0pLzIgOiAwLFxuICAgICAgICBzY2FsZSA9IG9mZnNldD09PVwibm9ybWFsaXplXCIgPyAoMS9zdW0pIDogMSxcbiAgICAgICAgaSwgeCwgYSwgYiA9IG9mZiwgdiA9IDA7XG5cbiAgICAvLyBzZXQgc3RhY2sgY29vcmRpbmF0ZXMgZm9yIGVhY2ggZGF0dW0gaW4gZ3JvdXBcbiAgICBmb3IgKGo9MDsgajxncm91cC5sZW5ndGg7ICsraikge1xuICAgICAgeCA9IGdyb3VwW2pdO1xuICAgICAgYSA9IGI7IC8vIHVzZSBwcmV2aW91cyB2YWx1ZSBmb3Igc3RhcnQgcG9pbnRcbiAgICAgIHYgKz0gdmFsdWUoeCk7XG4gICAgICBiID0gc2NhbGUgKiB2ICsgb2ZmOyAvLyBjb21wdXRlIGVuZCBwb2ludFxuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5zdGFydCwgYSk7XG4gICAgICB0dXBsZS5zZXQoeCwgb3V0cHV0LnN0b3AsIGIpO1xuICAgICAgdHVwbGUuc2V0KHgsIG91dHB1dC5taWQsIDAuNSAqIChhICsgYikpO1xuICAgIH1cbiAgfVxuXG4gIGlucHV0LmZpZWxkc1tvdXRwdXQuc3RhcnRdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5zdG9wXSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQubWlkXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihkYXRhLCBncm91cGJ5LCBzb3J0YnksIHZhbHVlKSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICAgIG1hcCwgaSwgeCwgaywgZywgcywgbWF4O1xuXG4gIC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5zbGljZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcD17fSwgaT0wOyBpPGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgayA9IChncm91cGJ5Lm1hcChmdW5jdGlvbihmKSB7IHJldHVybiBmKHgpOyB9KSk7XG4gICAgICBnID0gbWFwW2tdIHx8IChncm91cHMucHVzaChtYXBba10gPSBbXSksIG1hcFtrXSk7XG4gICAgICBnLnB1c2goeCk7XG4gICAgfVxuICB9XG5cbiAgLy8gY29tcHV0ZSBzdW1zIG9mIGdyb3Vwcywgc29ydCBncm91cHMgYXMgbmVlZGVkXG4gIGZvciAoaz0wLCBtYXg9MDsgazxncm91cHMubGVuZ3RoOyArK2spIHtcbiAgICBnID0gZ3JvdXBzW2tdO1xuICAgIGZvciAoaT0wLCBzPTA7IGk8Zy5sZW5ndGg7ICsraSkge1xuICAgICAgcyArPSB2YWx1ZShnW2ldKTtcbiAgICB9XG4gICAgZy5zdW0gPSBzO1xuICAgIGlmIChzID4gbWF4KSBtYXggPSBzO1xuICAgIGlmIChzb3J0YnkgIT0gbnVsbCkgZy5zb3J0KHNvcnRieSk7XG4gIH1cbiAgZ3JvdXBzLm1heCA9IG1heDtcblxuICByZXR1cm4gZ3JvdXBzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrOyIsInZhciBOb2RlID0gcmVxdWlyZSgnLi4vZGF0YWZsb3cvTm9kZScpLFxuICAgIFBhcmFtZXRlciA9IHJlcXVpcmUoJy4vUGFyYW1ldGVyJyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShncmFwaCkge1xuICBpZihncmFwaCkgTm9kZS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cblRyYW5zZm9ybS5hZGRQYXJhbWV0ZXJzID0gZnVuY3Rpb24ocHJvdG8sIHBhcmFtcykge1xuICB2YXIgcDtcbiAgZm9yICh2YXIgbmFtZSBpbiBwYXJhbXMpIHtcbiAgICBwID0gcGFyYW1zW25hbWVdO1xuICAgIHByb3RvW25hbWVdID0gbmV3IFBhcmFtZXRlcihuYW1lLCBwLnR5cGUpO1xuICAgIGlmIChwLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHByb3RvW25hbWVdLnNldChwcm90bywgcC5kZWZhdWx0KTtcbiAgfVxuICBwcm90by5fcGFyYW1ldGVycyA9IHBhcmFtcztcbn07XG5cbnZhciBwcm90byA9IChUcmFuc2Zvcm0ucHJvdG90eXBlID0gbmV3IE5vZGUoKSk7XG5cbnByb3RvLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gTm9kZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgbi50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgbi5fcGFyYW1ldGVycyA9IHRoaXMuX3BhcmFtZXRlcnM7XG4gIGZvcih2YXIgayBpbiB0aGlzKSB7IFxuICAgIGlmKG5ba10pIGNvbnRpbnVlO1xuICAgIG5ba10gPSB0aGlzW2tdOyBcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbnByb3RvLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKGlucHV0LCByZXNldCkgeyByZXR1cm4gaW5wdXQ7IH07XG5wcm90by5ldmFsdWF0ZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIC8vIE1hbnkgdHJhbnNmb3JtcyBzdG9yZSBjYWNoZXMgdGhhdCBtdXN0IGJlIGludmFsaWRhdGVkIGlmXG4gIC8vIGEgc2lnbmFsIHZhbHVlIGhhcyBjaGFuZ2VkLiBcbiAgdmFyIHJlc2V0ID0gdGhpcy5fc3RhbXAgPCBpbnB1dC5zdGFtcCAmJiB0aGlzLmRlcGVuZGVuY3koQy5TSUdOQUxTKS5zb21lKGZ1bmN0aW9uKHMpIHsgXG4gICAgcmV0dXJuICEhaW5wdXQuc2lnbmFsc1tzXSBcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKGlucHV0LCByZXNldCk7XG59O1xuXG5wcm90by5vdXRwdXQgPSBmdW5jdGlvbihtYXApIHtcbiAgZm9yICh2YXIga2V5IGluIHRoaXMuX291dHB1dCkge1xuICAgIGlmIChtYXBba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9vdXRwdXRba2V5XSA9IG1hcFtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtOyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyksXG4gICAgQmF0Y2hUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL0JhdGNoVHJhbnNmb3JtJyksXG4gICAgdHVwbGUgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy90dXBsZScpO1xuXG5mdW5jdGlvbiBUcmVlbWFwKGdyYXBoKSB7XG4gIEJhdGNoVHJhbnNmb3JtLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgLy8gaGllcmFyY2h5IHBhcmFtZXRlcnNcbiAgICBzb3J0OiB7dHlwZTogXCJhcnJheTxmaWVsZD5cIiwgZGVmYXVsdDogW1wiLXZhbHVlXCJdfSxcbiAgICBjaGlsZHJlbjoge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJjaGlsZHJlblwifSxcbiAgICB2YWx1ZToge3R5cGU6IFwiZmllbGRcIiwgZGVmYXVsdDogXCJ2YWx1ZVwifSxcbiAgICAvLyB0cmVlbWFwIHBhcmFtZXRlcnNcbiAgICBzaXplOiB7dHlwZTogXCJhcnJheTx2YWx1ZT5cIiwgZGVmYXVsdDogWzUwMCwgNTAwXX0sXG4gICAgcm91bmQ6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IHRydWV9LFxuICAgIHN0aWNreToge3R5cGU6IFwidmFsdWVcIiwgZGVmYXVsdDogZmFsc2V9LFxuICAgIHJhdGlvOiB7dHlwZTogXCJ2YWx1ZVwiLCBkZWZhdWx0OiAwLjUgKiAoMSArIE1hdGguc3FydCg1KSl9LFxuICAgIHBhZGRpbmc6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IG51bGx9LFxuICAgIG1vZGU6IHt0eXBlOiBcInZhbHVlXCIsIGRlZmF1bHQ6IFwic3F1YXJpZnlcIn1cbiAgfSk7XG5cbiAgdGhpcy5fbGF5b3V0ID0gZDMubGF5b3V0LnRyZWVtYXAoKTtcblxuICB0aGlzLl9vdXRwdXQgPSB7XG4gICAgXCJ4XCI6ICAgICAgXCJsYXlvdXQ6eFwiLFxuICAgIFwieVwiOiAgICAgIFwibGF5b3V0OnlcIixcbiAgICBcIndpZHRoXCI6ICBcImxheW91dDp3aWR0aFwiLFxuICAgIFwiaGVpZ2h0XCI6IFwibGF5b3V0OmhlaWdodFwiXG4gIH07XG4gIHJldHVybiB0aGlzO1xufVxuXG52YXIgcHJvdG8gPSAoVHJlZW1hcC5wcm90b3R5cGUgPSBuZXcgQmF0Y2hUcmFuc2Zvcm0oKSk7XG5cbnByb3RvLmJhdGNoVHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQsIGRhdGEpIHtcbiAgLy8gZ2V0IHZhcmlhYmxlc1xuICB2YXIgZyA9IHRoaXMuX2dyYXBoLFxuICAgICAgbGF5b3V0ID0gdGhpcy5fbGF5b3V0LFxuICAgICAgb3V0cHV0ID0gdGhpcy5fb3V0cHV0O1xuXG4gIC8vIGNvbmZpZ3VyZSBsYXlvdXRcbiAgbGF5b3V0XG4gICAgLnNvcnQoZGwuY29tcGFyYXRvcih0aGlzLnNvcnQuZ2V0KGcpLmZpZWxkcykpXG4gICAgLmNoaWxkcmVuKHRoaXMuY2hpbGRyZW4uZ2V0KGcpLmFjY2Vzc29yKVxuICAgIC52YWx1ZSh0aGlzLnZhbHVlLmdldChnKS5hY2Nlc3NvcilcbiAgICAuc2l6ZSh0aGlzLnNpemUuZ2V0KGcpKVxuICAgIC5yb3VuZCh0aGlzLnJvdW5kLmdldChnKSlcbiAgICAuc3RpY2t5KHRoaXMuc3RpY2t5LmdldChnKSlcbiAgICAucmF0aW8odGhpcy5yYXRpby5nZXQoZykpXG4gICAgLnBhZGRpbmcodGhpcy5wYWRkaW5nLmdldChnKSlcbiAgICAubW9kZSh0aGlzLm1vZGUuZ2V0KGcpKVxuICAgIC5ub2RlcyhkYXRhWzBdKTtcblxuICAvLyBjb3B5IGxheW91dCB2YWx1ZXMgdG8gbm9kZXNcbiAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKG4pIHtcbiAgICB0dXBsZS5zZXQobiwgb3V0cHV0LngsIG4ueCk7XG4gICAgdHVwbGUuc2V0KG4sIG91dHB1dC55LCBuLnkpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQud2lkdGgsIG4uZHgpO1xuICAgIHR1cGxlLnNldChuLCBvdXRwdXQuaGVpZ2h0LCBuLmR5KTtcbiAgfSk7XG5cbiAgLy8gcmV0dXJuIGNoYW5nZXNldFxuICBpbnB1dC5maWVsZHNbb3V0cHV0LnhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC55XSA9IDE7XG4gIGlucHV0LmZpZWxkc1tvdXRwdXQud2lkdGhdID0gMTtcbiAgaW5wdXQuZmllbGRzW291dHB1dC5oZWlnaHRdID0gMTtcbiAgcmV0dXJuIGlucHV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlbWFwOyIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpLFxuICAgIEdyb3VwQnkgPSByZXF1aXJlKCcuL0dyb3VwQnknKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgZGVidWcgPSByZXF1aXJlKCcuLi91dGlsL2RlYnVnJyk7XG5cbmZ1bmN0aW9uIFVuaXF1ZShncmFwaCkge1xuICBHcm91cEJ5LnByb3RvdHlwZS5pbml0LmNhbGwodGhpcywgZ3JhcGgpO1xuICBUcmFuc2Zvcm0uYWRkUGFyYW1ldGVycyh0aGlzLCB7XG4gICAgZmllbGQ6IHt0eXBlOiBcImZpZWxkXCJ9LFxuICAgIGFzOiB7dHlwZTogXCJ2YWx1ZVwifVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHByb3RvID0gKFVuaXF1ZS5wcm90b3R5cGUgPSBuZXcgR3JvdXBCeSgpKTtcblxucHJvdG8uX25ld190dXBsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIG8gID0ge30sXG4gICAgICBvbiA9IHRoaXMuZmllbGQuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGFzID0gdGhpcy5hcy5nZXQodGhpcy5fZ3JhcGgpO1xuXG4gIG9bYXNdID0gb24uYWNjZXNzb3IoeCk7XG4gIHJldHVybiB0dXBsZS5pbmdlc3QobywgbnVsbCk7XG59O1xuXG5wcm90by50cmFuc2Zvcm0gPSBmdW5jdGlvbihpbnB1dCwgcmVzZXQpIHtcbiAgZGVidWcoaW5wdXQsIFtcInVuaXF1ZXNcIl0pO1xuICB0aGlzLl9nYiA9IHRoaXMuZmllbGQuZ2V0KHRoaXMuX2dyYXBoKTtcbiAgcmV0dXJuIEdyb3VwQnkucHJvdG90eXBlLnRyYW5zZm9ybS5jYWxsKHRoaXMsIGlucHV0LCByZXNldCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXF1ZTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyksXG4gICAgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm0nKSxcbiAgICBDb2xsZWN0b3IgPSByZXF1aXJlKCcuLi9kYXRhZmxvdy9Db2xsZWN0b3InKSxcbiAgICBkZWJ1ZyA9IHJlcXVpcmUoJy4uL3V0aWwvZGVidWcnKTtcblxuZnVuY3Rpb24gWmlwKGdyYXBoKSB7XG4gIFRyYW5zZm9ybS5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGdyYXBoKTtcbiAgVHJhbnNmb3JtLmFkZFBhcmFtZXRlcnModGhpcywge1xuICAgIHdpdGg6IHt0eXBlOiBcImRhdGFcIn0sXG4gICAgYXM6ICB7dHlwZTogXCJ2YWx1ZVwifSxcbiAgICBrZXk6IHt0eXBlOiBcImZpZWxkXCIsIGRlZmF1bHQ6IFwiZGF0YVwifSxcbiAgICB3aXRoS2V5OiB7dHlwZTogXCJmaWVsZFwiLCBkZWZhdWx0OiBudWxsfSxcbiAgICBkZWZhdWx0OiB7dHlwZTogXCJ2YWx1ZVwifVxuICB9KTtcblxuICB0aGlzLl9tYXAgPSB7fTtcbiAgdGhpcy5fY29sbGVjdG9yID0gbmV3IENvbGxlY3RvcihncmFwaCk7XG4gIHRoaXMuX2xhc3RKb2luID0gMDtcblxuICByZXR1cm4gdGhpcy5yZXZpc2VzKHRydWUpO1xufVxuXG52YXIgcHJvdG8gPSAoWmlwLnByb3RvdHlwZSA9IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbmZ1bmN0aW9uIG1wKGspIHtcbiAgcmV0dXJuIHRoaXMuX21hcFtrXSB8fCAodGhpcy5fbWFwW2tdID0gW10pO1xufTtcblxucHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgdmFyIHcgPSB0aGlzLndpdGguZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIHdkcyA9IHcuc291cmNlLFxuICAgICAgd291dHB1dCA9IHdkcy5sYXN0KCksXG4gICAgICB3ZGF0YSA9IHdkcy52YWx1ZXMoKSxcbiAgICAgIGtleSA9IHRoaXMua2V5LmdldCh0aGlzLl9ncmFwaCksXG4gICAgICB3aXRoS2V5ID0gdGhpcy53aXRoS2V5LmdldCh0aGlzLl9ncmFwaCksXG4gICAgICBhcyA9IHRoaXMuYXMuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIGRmbHQgPSB0aGlzLmRlZmF1bHQuZ2V0KHRoaXMuX2dyYXBoKSxcbiAgICAgIG1hcCA9IG1wLmJpbmQodGhpcyksXG4gICAgICByZW0gPSB7fTtcblxuICBkZWJ1ZyhpbnB1dCwgW1wiemlwcGluZ1wiLCB3Lm5hbWVdKTtcblxuICBpZih3aXRoS2V5LmZpZWxkKSB7XG4gICAgaWYod291dHB1dCAmJiB3b3V0cHV0LnN0YW1wID4gdGhpcy5fbGFzdEpvaW4pIHtcbiAgICAgIHdvdXRwdXQucmVtLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgbSA9IG1hcCh3aXRoS2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgICAgaWYobVswXSkgbVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSBkZmx0IH0pO1xuICAgICAgICBtWzFdID0gbnVsbDtcbiAgICAgIH0pO1xuXG4gICAgICB3b3V0cHV0LmFkZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgXG4gICAgICAgIHZhciBtID0gbWFwKHdpdGhLZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICBpZihtWzBdKSBtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IHggfSk7XG4gICAgICAgIG1bMV0gPSB4O1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE9ubHkgcHJvY2VzcyB3b3V0cHV0Lm1vZCB0dXBsZXMgaWYgdGhlIGpvaW4ga2V5IGhhcyBjaGFuZ2VkLlxuICAgICAgLy8gT3RoZXIgZmllbGQgdXBkYXRlcyB3aWxsIGF1dG8tcHJvcGFnYXRlIHZpYSBwcm90b3R5cGUuXG4gICAgICBpZih3b3V0cHV0LmZpZWxkc1t3aXRoS2V5LmZpZWxkXSkge1xuICAgICAgICB3b3V0cHV0Lm1vZC5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgICBpZigheC5fcHJldiB8fCAocHJldiA9IHdpdGhLZXkuYWNjZXNzb3IoeC5fcHJldikpID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgICB2YXIgcHJldm0gPSBtYXAocHJldik7XG4gICAgICAgICAgaWYocHJldm1bMF0pIHByZXZtWzBdLmZvckVhY2goZnVuY3Rpb24oZCkgeyBkW2FzXSA9IGRmbHQgfSk7XG4gICAgICAgICAgcHJldm1bMV0gPSBudWxsO1xuXG4gICAgICAgICAgdmFyIG0gPSBtYXAod2l0aEtleS5hY2Nlc3Nvcih4KSk7XG4gICAgICAgICAgaWYobVswXSkgbVswXS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHsgZFthc10gPSB4IH0pO1xuICAgICAgICAgIG1bMV0gPSB4O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbGFzdEpvaW4gPSB3b3V0cHV0LnN0YW1wO1xuICAgIH1cbiAgXG4gICAgaW5wdXQuYWRkLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIG0gPSBtYXAoa2V5LmFjY2Vzc29yKHgpKTtcbiAgICAgIHhbYXNdID0gbVsxXSB8fCBkZmx0O1xuICAgICAgKG1bMF09bVswXXx8W10pLnB1c2goeCk7XG4gICAgfSk7XG5cbiAgICBpbnB1dC5yZW0uZm9yRWFjaChmdW5jdGlvbih4KSB7IFxuICAgICAgdmFyIGsgPSBrZXkuYWNjZXNzb3IoeCk7XG4gICAgICAocmVtW2tdPXJlbVtrXXx8e30pW3guX2lkXSA9IDE7XG4gICAgfSk7XG5cbiAgICBpZihpbnB1dC5maWVsZHNba2V5LmZpZWxkXSkge1xuICAgICAgaW5wdXQubW9kLmZvckVhY2goZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgaWYoIXguX3ByZXYgfHwgKHByZXYgPSBrZXkuYWNjZXNzb3IoeC5fcHJldikpID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICB2YXIgbSA9IG1hcChrZXkuYWNjZXNzb3IoeCkpO1xuICAgICAgICB4W2FzXSA9IG1bMV0gfHwgZGZsdDtcbiAgICAgICAgKG1bMF09bVswXXx8W10pLnB1c2goeCk7XG4gICAgICAgIChyZW1bcHJldl09cmVtW3ByZXZdfHx7fSlbeC5faWRdID0gMTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGRsLmtleXMocmVtKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHsgXG4gICAgICB2YXIgbSA9IG1hcChrKTtcbiAgICAgIGlmKCFtWzBdKSByZXR1cm47XG4gICAgICBtWzBdID0gbVswXS5maWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gcmVtW2tdW3guX2lkXSAhPT0gMSB9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcnVuIGEgbm9uLWtleS1qb2luIGFnYWluIGlmIHdlJ3ZlIGdvdCBhbnkgYWRkL3JlbVxuICAgIC8vIG9uIGlucHV0IG9yIHdvdXRwdXRcbiAgICBpZihpbnB1dC5hZGQubGVuZ3RoID09IDAgJiYgaW5wdXQucmVtLmxlbmd0aCA9PSAwICYmIFxuICAgICAgICB3b3V0cHV0LmFkZC5sZW5ndGggPT0gMCAmJiB3b3V0cHV0LnJlbS5sZW5ndGggPT0gMCkgcmV0dXJuIGlucHV0O1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGtleS1qb2luLCB0aGVuIHdlIG5lZWQgdG8gbWF0ZXJpYWxpemUgYm90aFxuICAgIC8vIGRhdGEgc291cmNlcyB0byBpdGVyYXRlIHRocm91Z2ggdGhlbS4gXG4gICAgdGhpcy5fY29sbGVjdG9yLmV2YWx1YXRlKGlucHV0KTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5fY29sbGVjdG9yLmRhdGEoKSwgXG4gICAgICAgIHdsZW4gPSB3ZGF0YS5sZW5ndGgsIGk7XG5cbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7IGRhdGFbaV1bYXNdID0gd2RhdGFbaSV3bGVuXTsgfVxuICB9XG5cbiAgaW5wdXQuZmllbGRzW2FzXSA9IDE7XG4gIHJldHVybiBpbnB1dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwOyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBhZ2dyZWdhdGU6ICByZXF1aXJlKCcuL0FnZ3JlZ2F0ZScpLFxuICBiaW46ICAgICAgICByZXF1aXJlKCcuL0JpbicpLFxuICBjcm9zczogICAgICByZXF1aXJlKCcuL0Nyb3NzJyksXG4gIGxpbmtwYXRoOiAgIHJlcXVpcmUoJy4vTGlua1BhdGgnKSxcbiAgZmFjZXQ6ICAgICAgcmVxdWlyZSgnLi9GYWNldCcpLFxuICBmaWx0ZXI6ICAgICByZXF1aXJlKCcuL0ZpbHRlcicpLFxuICBmb2xkOiAgICAgICByZXF1aXJlKCcuL0ZvbGQnKSxcbiAgZm9yY2U6ICAgICAgcmVxdWlyZSgnLi9Gb3JjZScpLFxuICBmb3JtdWxhOiAgICByZXF1aXJlKCcuL0Zvcm11bGEnKSxcbiAgZ2VvOiAgICAgICAgcmVxdWlyZSgnLi9HZW8nKSxcbiAgZ2VvcGF0aDogICAgcmVxdWlyZSgnLi9HZW9QYXRoJyksXG4gIHBpZTogICAgICAgIHJlcXVpcmUoJy4vUGllJyksXG4gIHNvcnQ6ICAgICAgIHJlcXVpcmUoJy4vU29ydCcpLFxuICBzdGFjazogICAgICByZXF1aXJlKCcuL1N0YWNrJyksXG4gIHRyZWVtYXA6ICAgIHJlcXVpcmUoJy4vVHJlZW1hcCcpLFxuICB1bmlxdWU6ICAgICByZXF1aXJlKCcuL1VuaXF1ZScpLFxuICB6aXA6ICAgICAgICByZXF1aXJlKCcuL1ppcCcpXG59OyIsInZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKSxcbiAgICB0dXBsZSA9IHJlcXVpcmUoJy4uL2RhdGFmbG93L3R1cGxlJyksXG4gICAgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCcuLi91dGlsL3F1aWNrc2VsZWN0JyksXG4gICAgQyA9IHJlcXVpcmUoJy4uL3V0aWwvY29uc3RhbnRzJyk7XG5cbnZhciB0eXBlcyA9IHtcbiAgXCJjb3VudFwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcImNvdW50XCIsXG4gICAgaW5pdDogXCJcIixcbiAgICBhZGQ6ICBcIlwiLFxuICAgIHJlbTogIFwiXCIsXG4gICAgc2V0OiAgXCJ0aGlzLmNlbGwuY250XCJcbiAgfSksXG4gIFwiX2NvdW50c1wiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcIl9jb3VudHNcIixcbiAgICBpbml0OiBcInRoaXMuY250cyA9IHt9O1wiLFxuICAgIGFkZDogIFwidGhpcy5jbnRzW3ZdID0gKyt0aGlzLmNudHNbdl0gfHwgMTtcIixcbiAgICByZW06ICBcInRoaXMuY250c1t2XSA9IC0tdGhpcy5jbnRzW3ZdIDwgMCA/IDAgOiB0aGlzLmNudHNbdl07XCIsXG4gICAgc2V0OiAgXCJcIixcbiAgICByZXE6ICBbXCJjb3VudFwiXVxuICB9KSxcbiAgXCJzdW1cIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJzdW1cIixcbiAgICBpbml0OiBcInRoaXMuc3VtID0gMDtcIixcbiAgICBhZGQ6ICBcInRoaXMuc3VtICs9IHY7XCIsXG4gICAgcmVtOiAgXCJ0aGlzLnN1bSAtPSB2O1wiLFxuICAgIHNldDogIFwidGhpcy5zdW1cIlxuICB9KSxcbiAgXCJhdmdcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJhdmdcIixcbiAgICBpbml0OiBcInRoaXMuYXZnID0gMDtcIixcbiAgICBhZGQ6ICBcInZhciBkID0gdiAtIHRoaXMuYXZnOyB0aGlzLmF2ZyArPSBkIC8gdGhpcy5jZWxsLmNudDtcIixcbiAgICByZW06ICBcInZhciBkID0gdiAtIHRoaXMuYXZnOyB0aGlzLmF2ZyAtPSBkIC8gdGhpcy5jZWxsLmNudDtcIixcbiAgICBzZXQ6ICBcInRoaXMuYXZnXCIsXG4gICAgcmVxOiAgW1wiY291bnRcIl0sIGlkeDogMVxuICB9KSxcbiAgXCJ2YXJcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJ2YXJcIixcbiAgICBpbml0OiBcInRoaXMuZGV2ID0gMDtcIixcbiAgICBhZGQ6ICBcInRoaXMuZGV2ICs9IGQgKiAodiAtIHRoaXMuYXZnKTtcIixcbiAgICByZW06ICBcInRoaXMuZGV2IC09IGQgKiAodiAtIHRoaXMuYXZnKTtcIixcbiAgICBzZXQ6ICBcInRoaXMuZGV2IC8gKHRoaXMuY2VsbC5jbnQtMSlcIixcbiAgICByZXE6ICBbXCJhdmdcIl0sIGlkeDogMlxuICB9KSxcbiAgXCJ2YXJwXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwidmFycFwiLFxuICAgIGluaXQ6IFwiXCIsXG4gICAgYWRkOiAgXCJcIixcbiAgICByZW06ICBcIlwiLFxuICAgIHNldDogIFwidGhpcy5kZXYgLyB0aGlzLmNlbGwuY250XCIsXG4gICAgcmVxOiAgW1widmFyXCJdLCBpZHg6IDNcbiAgfSksXG4gIFwic3RkZXZcIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJzdGRldlwiLFxuICAgIGluaXQ6IFwiXCIsXG4gICAgYWRkOiAgXCJcIixcbiAgICByZW06ICBcIlwiLFxuICAgIHNldDogIFwiTWF0aC5zcXJ0KHRoaXMuZGV2IC8gKHRoaXMuY2VsbC5jbnQtMSkpXCIsXG4gICAgcmVxOiAgW1widmFyXCJdLCBpZHg6IDRcbiAgfSksXG4gIFwic3RkZXZwXCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwic3RkZXZwXCIsXG4gICAgaW5pdDogXCJcIixcbiAgICBhZGQ6ICBcIlwiLFxuICAgIHJlbTogIFwiXCIsXG4gICAgc2V0OiAgXCJNYXRoLnNxcnQodGhpcy5kZXYgLyB0aGlzLmNlbGwuY250KVwiLFxuICAgIHJlcTogIFtcInZhclwiXSwgaWR4OiA1XG4gIH0pLFxuICBcIm1pblwiOiBtZWFzdXJlKHtcbiAgICBuYW1lOiBcIm1pblwiLFxuICAgIGluaXQ6IFwidGhpcy5taW4gPSArSW5maW5pdHk7XCIsXG4gICAgYWRkOiAgXCJ0aGlzLm1pbiA9IHYgPCB0aGlzLm1pbiA/IHYgOiB0aGlzLm1pbjtcIixcbiAgICByZW06ICBcInZhciBzZWxmID0gdGhpczsgdGhpcy5taW4gPSB2ID09IHRoaXMubWluIFwiICtcbiAgICAgICAgICBcIj8gdGhpcy5rZXlzKHRoaXMuY250cykucmVkdWNlKGZ1bmN0aW9uKG0sIHYpIHsgXCIgK1xuICAgICAgICAgIFwiICAgcmV0dXJuIHNlbGYuY250c1sodiA9ICt2KV0gPiAwICYmIHYgPCBtID8gdiA6IG0gfSwgK0luZmluaXR5KSBcIiArIFxuICAgICAgICAgIFwiOiB0aGlzLm1pbjtcIixcbiAgICBzZXQ6ICBcInRoaXMubWluXCIsXG4gICAgcmVxOiBbXCJfY291bnRzXCJdLCBpZHg6IDZcbiAgfSksXG4gIFwibWF4XCI6IG1lYXN1cmUoe1xuICAgIG5hbWU6IFwibWF4XCIsXG4gICAgaW5pdDogXCJ0aGlzLm1heCA9IC1JbmZpbml0eTtcIixcbiAgICBhZGQ6ICBcInRoaXMubWF4ID0gdiA+IHRoaXMubWF4ID8gdiA6IHRoaXMubWF4O1wiLFxuICAgIHJlbTogIFwidmFyIHNlbGYgPSB0aGlzOyB0aGlzLm1heCA9IHYgPT0gdGhpcy5tYXggXCIgK1xuICAgICAgICAgIFwiPyB0aGlzLmtleXModGhpcy5jbnRzKS5yZWR1Y2UoZnVuY3Rpb24obSwgdikgeyBcIiArXG4gICAgICAgICAgXCIgICByZXR1cm4gc2VsZi5jbnRzWyh2ID0gK3YpXSA+IDAgJiYgdiA+IG0gPyB2IDogbSB9LCAtSW5maW5pdHkpIFwiICsgXG4gICAgICAgICAgXCI6IHRoaXMubWF4O1wiLFxuICAgIHNldDogIFwidGhpcy5tYXhcIixcbiAgICByZXE6IFtcIl9jb3VudHNcIl0sIGlkeDogN1xuICB9KSxcbiAgXCJtZWRpYW5cIjogbWVhc3VyZSh7XG4gICAgbmFtZTogXCJtZWRpYW5cIixcbiAgICBpbml0OiBcInRoaXMudmFscyA9IFtdOyBcIixcbiAgICBhZGQ6ICBcImlmKHRoaXMudmFscykgdGhpcy52YWxzLnB1c2godik7IFwiLFxuICAgIHJlbTogIFwidGhpcy52YWxzID0gbnVsbDtcIixcbiAgICBzZXQ6ICBcInRoaXMuY2VsbC5jbnQgJSAyID8gdGhpcy5zZWwofn4odGhpcy5jZWxsLmNudC8yKSwgdGhpcy52YWxzLCB0aGlzLmNudHMpIDogXCIrXG4gICAgICAgICAgXCIwLjUgKiAodGhpcy5zZWwofn4odGhpcy5jZWxsLmNudC8yKS0xLCB0aGlzLnZhbHMsIHRoaXMuY250cykgKyB0aGlzLnNlbCh+fih0aGlzLmNlbGwuY250LzIpLCB0aGlzLnZhbHMsIHRoaXMuY250cykpXCIsXG4gICAgcmVxOiBbXCJfY291bnRzXCJdLCBpZHg6IDhcbiAgfSlcbn07XG5cbmZ1bmN0aW9uIG1lYXN1cmUoYmFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob3V0KSB7XG4gICAgdmFyIG0gPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIG0ub3V0ID0gb3V0IHx8IGJhc2UubmFtZTtcbiAgICBpZiAoIW0uaWR4KSBtLmlkeCA9IDA7XG4gICAgcmV0dXJuIG07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoYWdnKSB7XG4gIGZ1bmN0aW9uIGNvbGxlY3QobSwgYSkge1xuICAgIChhLnJlcSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihyKSB7XG4gICAgICBpZiAoIW1bcl0pIGNvbGxlY3QobSwgbVtyXSA9IHR5cGVzW3JdKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBtO1xuICB9XG4gIHZhciBtYXAgPSBhZ2cucmVkdWNlKGNvbGxlY3QsXG4gICAgYWdnLnJlZHVjZShmdW5jdGlvbihtLCBhKSB7IHJldHVybiAobVthLm5hbWVdID0gYSwgbSk7IH0sIHt9KSk7XG4gIHZhciBhbGwgPSBbXTtcbiAgZm9yICh2YXIgayBpbiBtYXApIGFsbC5wdXNoKG1hcFtrXSk7XG4gIGFsbC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gYS5pZHggLSBiLmlkeDsgfSk7XG4gIHJldHVybiBhbGw7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGUoYWdnKSB7XG4gIHZhciBhbGwgPSByZXNvbHZlKGFnZyksXG4gICAgICBjdHIgPSBcInRoaXMudHBsID0gdDsgdGhpcy5jZWxsID0gYztcIixcbiAgICAgIGFkZCA9IFwiXCIsXG4gICAgICByZW0gPSBcIlwiLFxuICAgICAgc2V0ID0gXCJ2YXIgdCA9IHRoaXMudHBsO1wiO1xuXG4gIGFsbC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHsgY3RyICs9IGEuaW5pdDsgYWRkICs9IGEuYWRkOyByZW0gKz0gYS5yZW07IH0pO1xuICBhZ2cuZm9yRWFjaChmdW5jdGlvbihhKSB7IHNldCArPSBcInRoaXMudHVwbGUuc2V0KHQsJ1wiK2Eub3V0K1wiJyxcIithLnNldCtcIik7XCI7IH0pO1xuICBzZXQgKz0gXCJyZXR1cm4gdDtcIjtcblxuICBjdHIgPSBGdW5jdGlvbihcImNcIiwgXCJ0XCIsIGN0cik7XG4gIGN0ci5wcm90b3R5cGUuYWRkID0gRnVuY3Rpb24oXCJ2XCIsIGFkZCk7XG4gIGN0ci5wcm90b3R5cGUucmVtID0gRnVuY3Rpb24oXCJ2XCIsIHJlbSk7XG4gIGN0ci5wcm90b3R5cGUuc2V0ID0gRnVuY3Rpb24oXCJzdGFtcFwiLCBzZXQpO1xuICBjdHIucHJvdG90eXBlLm1vZCA9IG1vZDtcbiAgY3RyLnByb3RvdHlwZS5rZXlzID0gZGwua2V5cztcbiAgY3RyLnByb3RvdHlwZS5zZWwgPSBxdWlja3NlbGVjdDtcbiAgY3RyLnByb3RvdHlwZS50dXBsZSA9IHR1cGxlO1xuICByZXR1cm4gY3RyO1xufVxuXG5mdW5jdGlvbiBtb2Qodl9uZXcsIHZfb2xkKSB7XG4gIGlmICh2X29sZCA9PT0gdW5kZWZpbmVkIHx8IHZfb2xkID09PSB2X25ldykgcmV0dXJuO1xuICB0aGlzLnJlbSh2X29sZCk7XG4gIHRoaXMuYWRkKHZfbmV3KTtcbn07XG5cbnR5cGVzLmNyZWF0ZSAgID0gY29tcGlsZTtcbm1vZHVsZS5leHBvcnRzID0gdHlwZXM7IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCksXG4gICAgQm91bmRzID0gcmVxdWlyZSgnLi4vY29yZS9Cb3VuZHMnKSxcbiAgICBjYW52YXMgPSByZXF1aXJlKCcuLi9yZW5kZXIvY2FudmFzL3BhdGgnKSxcbiAgICBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuXG52YXIgcGFyc2UgPSBjYW52YXMucGFyc2UsXG4gICAgYm91bmRQYXRoID0gY2FudmFzLmJvdW5kcyxcbiAgICBhcmVhUGF0aCA9IGNhbnZhcy5hcmVhLFxuICAgIGxpbmVQYXRoID0gY2FudmFzLmxpbmUsXG4gICAgaGFsZnBpID0gTWF0aC5QSSAvIDIsXG4gICAgc3FydDMgPSBNYXRoLnNxcnQoMyksXG4gICAgdGFuMzAgPSBNYXRoLnRhbigzMCAqIE1hdGguUEkgLyAxODApLFxuICAgIGdmeCA9IG51bGw7XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcobykge1xuICByZXR1cm4gKG8uZm9udFN0eWxlID8gby5mb250U3R5bGUgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250VmFyaWFudCA/IG8uZm9udFZhcmlhbnQgKyBcIiBcIiA6IFwiXCIpXG4gICAgKyAoby5mb250V2VpZ2h0ID8gby5mb250V2VpZ2h0ICsgXCIgXCIgOiBcIlwiKVxuICAgICsgKG8uZm9udFNpemUgIT0gbnVsbCA/IG8uZm9udFNpemUgOiBjb25maWcucmVuZGVyLmZvbnRTaXplKSArIFwicHggXCJcbiAgICArIChvLmZvbnQgfHwgY29uZmlnLnJlbmRlci5mb250KTtcbn1cblxuZnVuY3Rpb24gY29udGV4dCgpIHtcbiAgLy8gVE9ETzogaG93IHRvIGNoZWNrIGlmIG5vZGVKUyBpbiByZXF1aXJlSlM/XG4gIHJldHVybiBnZnggfHwgKGdmeCA9ICgvKmNvbmZpZy5pc05vZGVcbiAgICA/IG5ldyAocmVxdWlyZShcImNhbnZhc1wiKSkoMSwxKVxuICAgIDogKi9kMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcImNhbnZhc1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidmVnYV9oaWRkZW5cIilcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCAxKVxuICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxKVxuICAgICAgICAuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxuICAgICAgICAubm9kZSgpKVxuICAgIC5nZXRDb250ZXh0KFwiMmRcIikpO1xufVxuXG5mdW5jdGlvbiBwYXRoQm91bmRzKG8sIHBhdGgsIGJvdW5kcykge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgYm91bmRzLnNldCgwLCAwLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBib3VuZFBhdGgocGF0aCwgYm91bmRzKTtcbiAgICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBwYXRoKG8sIGJvdW5kcykge1xuICB2YXIgcCA9IG8ucGF0aFxuICAgID8gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2Uoby5wYXRoKSlcbiAgICA6IG51bGw7XG4gIHJldHVybiBwYXRoQm91bmRzKG8sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIGFyZWEobywgYm91bmRzKSB7XG4gIHZhciBpdGVtcyA9IG8ubWFyay5pdGVtcywgbyA9IGl0ZW1zWzBdO1xuICB2YXIgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGFyZWFQYXRoKGl0ZW1zKSkpO1xuICByZXR1cm4gcGF0aEJvdW5kcyhpdGVtc1swXSwgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gbGluZShvLCBib3VuZHMpIHtcbiAgdmFyIGl0ZW1zID0gby5tYXJrLml0ZW1zLCBvID0gaXRlbXNbMF07XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2UobGluZVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW1zWzBdLCBwLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiByZWN0KG8sIGJvdW5kcykge1xuICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgdyA9ICh4ICsgby53aWR0aCkgfHwgMCxcbiAgICAgIGggPSAoeSArIG8uaGVpZ2h0KSB8fCAwO1xuICBib3VuZHMuc2V0KHgsIHksIHcsIGgpO1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBpbWFnZShvLCBib3VuZHMpIHtcbiAgdmFyIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMCxcbiAgICAgIHggPSAoby54fHwwKSAtIChvLmFsaWduID09PSBcImNlbnRlclwiXG4gICAgICAgICAgPyB3LzIgOiAoby5hbGlnbiA9PT0gXCJyaWdodFwiID8gdyA6IDApKSxcbiAgICAgIHkgPSAoby55fHwwKSAtIChvLmJhc2VsaW5lID09PSBcIm1pZGRsZVwiXG4gICAgICAgICAgPyBoLzIgOiAoby5iYXNlbGluZSA9PT0gXCJib3R0b21cIiA/IGggOiAwKSk7XG4gIHJldHVybiBib3VuZHMuc2V0KHgsIHksIHgrdywgeStoKTtcbn1cblxuZnVuY3Rpb24gcnVsZShvLCBib3VuZHMpIHtcbiAgdmFyIHgxLCB5MTtcbiAgYm91bmRzLnNldChcbiAgICB4MSA9IG8ueCB8fCAwLFxuICAgIHkxID0gby55IHx8IDAsXG4gICAgby54MiAhPSBudWxsID8gby54MiA6IHgxLFxuICAgIG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MVxuICApO1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBhcmMobywgYm91bmRzKSB7XG4gIHZhciBjeCA9IG8ueCB8fCAwLFxuICAgICAgY3kgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gaGFsZnBpLFxuICAgICAgeG1pbiA9IEluZmluaXR5LCB4bWF4ID0gLUluZmluaXR5LFxuICAgICAgeW1pbiA9IEluZmluaXR5LCB5bWF4ID0gLUluZmluaXR5LFxuICAgICAgYSwgaSwgbiwgeCwgeSwgaXgsIGl5LCBveCwgb3k7XG5cbiAgdmFyIGFuZ2xlcyA9IFtzYSwgZWFdLFxuICAgICAgcyA9IHNhIC0gKHNhJWhhbGZwaSk7XG4gIGZvciAoaT0wOyBpPDQgJiYgczxlYTsgKytpLCBzKz1oYWxmcGkpIHtcbiAgICBhbmdsZXMucHVzaChzKTtcbiAgfVxuXG4gIGZvciAoaT0wLCBuPWFuZ2xlcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgYSA9IGFuZ2xlc1tpXTtcbiAgICB4ID0gTWF0aC5jb3MoYSk7IGl4ID0gaXIqeDsgb3ggPSBvcip4O1xuICAgIHkgPSBNYXRoLnNpbihhKTsgaXkgPSBpcip5OyBveSA9IG9yKnk7XG4gICAgeG1pbiA9IE1hdGgubWluKHhtaW4sIGl4LCBveCk7XG4gICAgeG1heCA9IE1hdGgubWF4KHhtYXgsIGl4LCBveCk7XG4gICAgeW1pbiA9IE1hdGgubWluKHltaW4sIGl5LCBveSk7XG4gICAgeW1heCA9IE1hdGgubWF4KHltYXgsIGl5LCBveSk7XG4gIH1cblxuICBib3VuZHMuc2V0KGN4K3htaW4sIGN5K3ltaW4sIGN4K3htYXgsIGN5K3ltYXgpO1xuICBpZiAoby5zdHJva2UgJiYgby5vcGFjaXR5ICE9PSAwICYmIG8uc3Ryb2tlV2lkdGggPiAwKSB7XG4gICAgYm91bmRzLmV4cGFuZChvLnN0cm9rZVdpZHRoKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBzeW1ib2wobywgYm91bmRzKSB7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54IHx8IDAsXG4gICAgICB5ID0gby55IHx8IDAsXG4gICAgICByLCB0LCByeCwgcnk7XG5cbiAgc3dpdGNoIChvLnNoYXBlKSB7XG4gICAgY2FzZSBcImNyb3NzXCI6XG4gICAgICByID0gTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICB0ID0gMypyO1xuICAgICAgYm91bmRzLnNldCh4LXQsIHktciwgeCt0LCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiZGlhbW9uZFwiOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJzcXVhcmVcIjpcbiAgICAgIHQgPSBNYXRoLnNxcnQoc2l6ZSk7XG4gICAgICByID0gdCAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtciwgeS1yLCB4K3IsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS1kb3duXCI6XG4gICAgICByeCA9IE1hdGguc3FydChzaXplIC8gc3FydDMpO1xuICAgICAgcnkgPSByeCAqIHNxcnQzIC8gMjtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJ0cmlhbmdsZS11cFwiOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgciA9IE1hdGguc3FydChzaXplL01hdGguUEkpO1xuICAgICAgYm91bmRzLnNldCh4LXIsIHktciwgeCtyLCB5K3IpO1xuICB9XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdHJva2VXaWR0aCA+IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGgpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5cbmZ1bmN0aW9uIHRleHQobywgYm91bmRzLCBub1JvdGF0ZSkge1xuICB2YXIgeCA9IChvLnggfHwgMCkgKyAoby5keCB8fCAwKSxcbiAgICAgIHkgPSAoby55IHx8IDApICsgKG8uZHkgfHwgMCksXG4gICAgICBoID0gby5mb250U2l6ZSB8fCBjb25maWcucmVuZGVyLmZvbnRTaXplLFxuICAgICAgYSA9IG8uYWxpZ24sXG4gICAgICBiID0gby5iYXNlbGluZSxcbiAgICAgIHIgPSBvLnJhZGl1cyB8fCAwLFxuICAgICAgZyA9IGNvbnRleHQoKSwgdywgdDtcblxuICBnLmZvbnQgPSBmb250U3RyaW5nKG8pO1xuICBnLnRleHRBbGlnbiA9IGEgfHwgXCJsZWZ0XCI7XG4gIGcudGV4dEJhc2VsaW5lID0gYiB8fCBcImFscGhhYmV0aWNcIjtcbiAgdyA9IGcubWVhc3VyZVRleHQoby50ZXh0IHx8IFwiXCIpLndpZHRoO1xuXG4gIGlmIChyKSB7XG4gICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG5cbiAgLy8gaG9yaXpvbnRhbFxuICBpZiAoYSA9PT0gXCJjZW50ZXJcIikge1xuICAgIHggPSB4IC0gKHcgLyAyKTtcbiAgfSBlbHNlIGlmIChhID09PSBcInJpZ2h0XCIpIHtcbiAgICB4ID0geCAtIHc7XG4gIH0gZWxzZSB7XG4gICAgLy8gbGVmdCBieSBkZWZhdWx0LCBkbyBub3RoaW5nXG4gIH1cblxuICAvLy8gVE9ETyBmaW5kIGEgcm9idXN0IHNvbHV0aW9uIGZvciBoZWlnaHRzLlxuICAvLy8gVGhlc2Ugb2Zmc2V0cyB3b3JrIGZvciBzb21lIGJ1dCBub3QgYWxsIGZvbnRzLlxuXG4gIC8vIHZlcnRpY2FsXG4gIGlmIChiID09PSBcInRvcFwiKSB7XG4gICAgeSA9IHkgKyAoaC81KTtcbiAgfSBlbHNlIGlmIChiID09PSBcImJvdHRvbVwiKSB7XG4gICAgeSA9IHkgLSBoO1xuICB9IGVsc2UgaWYgKGIgPT09IFwibWlkZGxlXCIpIHtcbiAgICB5ID0geSAtIChoLzIpICsgKGgvMTApO1xuICB9IGVsc2Uge1xuICAgIHkgPSB5IC0gNCpoLzU7IC8vIGFscGhhYmV0aWMgYnkgZGVmYXVsdFxuICB9XG4gIFxuICBib3VuZHMuc2V0KHgsIHksIHgrdywgeStoKTtcbiAgaWYgKG8uYW5nbGUgJiYgIW5vUm90YXRlKSB7XG4gICAgYm91bmRzLnJvdGF0ZShvLmFuZ2xlKk1hdGguUEkvMTgwLCBvLnh8fDAsIG8ueXx8MCk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcy5leHBhbmQobm9Sb3RhdGUgPyAwIDogMSk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwKGcsIGJvdW5kcywgaW5jbHVkZUxlZ2VuZHMpIHtcbiAgdmFyIGF4ZXMgPSBnLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGxlZ2VuZHMgPSBnLmxlZ2VuZEl0ZW1zIHx8IFtdLCBqLCBtO1xuXG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGJvdW5kcy51bmlvbihheGVzW2pdLmJvdW5kcyk7XG4gIH1cbiAgZm9yIChqPTAsIG09Zy5pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgYm91bmRzLnVuaW9uKGcuaXRlbXNbal0uYm91bmRzKTtcbiAgfVxuICBpZiAoaW5jbHVkZUxlZ2VuZHMpIHtcbiAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIGJvdW5kcy51bmlvbihsZWdlbmRzW2pdLmJvdW5kcyk7XG4gICAgfVxuICAgIGlmIChnLndpZHRoICE9IG51bGwgJiYgZy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgYm91bmRzLmFkZChnLndpZHRoLCBnLmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChnLnggIT0gbnVsbCAmJiBnLnkgIT0gbnVsbCkge1xuICAgICAgYm91bmRzLmFkZCgwLCAwKTtcbiAgICB9XG4gIH1cbiAgYm91bmRzLnRyYW5zbGF0ZShnLnh8fDAsIGcueXx8MCk7XG4gIHJldHVybiBib3VuZHM7XG59XG5cbnZhciBtZXRob2RzID0ge1xuICBncm91cDogIGdyb3VwLFxuICBzeW1ib2w6IHN5bWJvbCxcbiAgaW1hZ2U6ICBpbWFnZSxcbiAgcmVjdDogICByZWN0LFxuICBydWxlOiAgIHJ1bGUsXG4gIGFyYzogICAgYXJjLFxuICB0ZXh0OiAgIHRleHQsXG4gIHBhdGg6ICAgcGF0aCxcbiAgYXJlYTogICBhcmVhLFxuICBsaW5lOiAgIGxpbmVcbn07XG5cbmZ1bmN0aW9uIGl0ZW1Cb3VuZHMoaXRlbSwgZnVuYywgb3B0KSB7XG4gIGZ1bmMgPSBmdW5jIHx8IG1ldGhvZHNbaXRlbS5tYXJrLm1hcmt0eXBlXTtcbiAgaWYgKCFpdGVtLmJvdW5kc19wcmV2KSBpdGVtWydib3VuZHM6cHJldiddID0gbmV3IEJvdW5kcygpO1xuICB2YXIgYiA9IGl0ZW0uYm91bmRzLCBwYiA9IGl0ZW1bJ2JvdW5kczpwcmV2J107XG4gIGlmIChiKSBwYi5jbGVhcigpLnVuaW9uKGIpO1xuICBpdGVtLmJvdW5kcyA9IGZ1bmMoaXRlbSwgYiA/IGIuY2xlYXIoKSA6IG5ldyBCb3VuZHMoKSwgb3B0KTtcbiAgaWYgKCFiKSBwYi5jbGVhcigpLnVuaW9uKGl0ZW0uYm91bmRzKTtcbiAgcmV0dXJuIGl0ZW0uYm91bmRzO1xufVxuXG5mdW5jdGlvbiBtYXJrQm91bmRzKG1hcmssIGJvdW5kcywgb3B0KSB7XG4gIGJvdW5kcyA9IGJvdW5kcyB8fCBtYXJrLmJvdW5kcyAmJiBtYXJrLmJvdW5kcy5jbGVhcigpIHx8IG5ldyBCb3VuZHMoKTtcbiAgdmFyIHR5cGUgID0gbWFyay5tYXJrdHlwZSxcbiAgICAgIGZ1bmMgID0gbWV0aG9kc1t0eXBlXSxcbiAgICAgIGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgIGl0ZW0sIGksIGxlbjtcbiAgICAgIFxuICBpZiAodHlwZT09PVwiYXJlYVwiIHx8IHR5cGU9PT1cImxpbmVcIikge1xuICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgIGl0ZW1zWzBdLmJvdW5kcyA9IGZ1bmMoaXRlbXNbMF0sIGJvdW5kcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaT0wLCBsZW49aXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgICBib3VuZHMudW5pb24oaXRlbUJvdW5kcyhpdGVtc1tpXSwgZnVuYywgb3B0KSk7XG4gICAgfVxuICB9XG4gIG1hcmsuYm91bmRzID0gYm91bmRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFyazogIG1hcmtCb3VuZHMsXG4gIGl0ZW06ICBpdGVtQm91bmRzLFxuICB0ZXh0OiAgdGV4dCxcbiAgZ3JvdXA6IGdyb3VwXG59OyIsInZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpLFxuICAgIGNvbmZpZyA9IHt9O1xuXG5jb25maWcuZGVidWcgPSBmYWxzZTtcblxuY29uZmlnLmxvYWQgPSB7XG4gIC8vIGJhc2UgdXJsIGZvciBsb2FkaW5nIGV4dGVybmFsIGRhdGEgZmlsZXNcbiAgLy8gdXNlZCBvbmx5IGZvciBzZXJ2ZXItc2lkZSBvcGVyYXRpb25cbiAgYmFzZVVSTDogXCJcIixcbiAgLy8gQWxsb3dzIGRvbWFpbiByZXN0cmljdGlvbiB3aGVuIHVzaW5nIGRhdGEgbG9hZGluZyB2aWEgWEhSLlxuICAvLyBUbyBlbmFibGUsIHNldCBpdCB0byBhIGxpc3Qgb2YgYWxsb3dlZCBkb21haW5zXG4gIC8vIGUuZy4sIFsnd2lraXBlZGlhLm9yZycsICdlZmYub3JnJ11cbiAgZG9tYWluV2hpdGVMaXN0OiBmYWxzZVxufTtcblxuLy8gdmVyc2lvbiBhbmQgbmFtZXBzYWNlcyBmb3IgZXhwb3J0ZWQgc3ZnXG5jb25maWcuc3ZnTmFtZXNwYWNlID1cbiAgJ3ZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgJyArXG4gICd4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIic7XG5cbi8vIGluc2V0IHBhZGRpbmcgZm9yIGF1dG9tYXRpYyBwYWRkaW5nIGNhbGN1bGF0aW9uXG5jb25maWcuYXV0b3BhZEluc2V0ID0gNTtcblxuLy8gZXh0ZW5zaWJsZSBzY2FsZSBsb29rdXAgdGFibGVcbi8vIGFsbCBkMy5zY2FsZS4qIGluc3RhbmNlcyBhbHNvIHN1cHBvcnRlZFxuY29uZmlnLnNjYWxlID0ge1xuICB0aW1lOiBkMy50aW1lLnNjYWxlLFxuICB1dGM6ICBkMy50aW1lLnNjYWxlLnV0Y1xufTtcblxuLy8gZGVmYXVsdCByZW5kZXJpbmcgc2V0dGluZ3NcbmNvbmZpZy5yZW5kZXIgPSB7XG4gIGxpbmVXaWR0aDogMSxcbiAgbGluZUNhcDogICBcImJ1dHRcIixcbiAgZm9udDogICAgICBcInNhbnMtc2VyaWZcIixcbiAgZm9udFNpemU6ICAxMVxufTtcblxuLy8gZGVmYXVsdCBheGlzIHByb3BlcnRpZXNcbmNvbmZpZy5heGlzID0ge1xuICBvcmllbnQ6IFwiYm90dG9tXCIsXG4gIHRpY2tzOiAxMCxcbiAgcGFkZGluZzogMyxcbiAgYXhpc0NvbG9yOiBcIiMwMDBcIixcbiAgZ3JpZENvbG9yOiBcIiNkOGQ4ZDhcIixcbiAgdGlja0NvbG9yOiBcIiMwMDBcIixcbiAgdGlja0xhYmVsQ29sb3I6IFwiIzAwMFwiLFxuICBheGlzV2lkdGg6IDEsXG4gIHRpY2tXaWR0aDogMSxcbiAgdGlja1NpemU6IDYsXG4gIHRpY2tMYWJlbEZvbnRTaXplOiAxMSxcbiAgdGlja0xhYmVsRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIHRpdGxlQ29sb3I6IFwiIzAwMFwiLFxuICB0aXRsZUZvbnQ6IFwic2Fucy1zZXJpZlwiLFxuICB0aXRsZUZvbnRTaXplOiAxMSxcbiAgdGl0bGVGb250V2VpZ2h0OiBcImJvbGRcIixcbiAgdGl0bGVPZmZzZXQ6IDM1XG59O1xuXG4vLyBkZWZhdWx0IGxlZ2VuZCBwcm9wZXJ0aWVzXG5jb25maWcubGVnZW5kID0ge1xuICBvcmllbnQ6IFwicmlnaHRcIixcbiAgb2Zmc2V0OiAxMCxcbiAgcGFkZGluZzogMyxcbiAgZ3JhZGllbnRTdHJva2VDb2xvcjogXCIjODg4XCIsXG4gIGdyYWRpZW50U3Ryb2tlV2lkdGg6IDEsXG4gIGdyYWRpZW50SGVpZ2h0OiAxNixcbiAgZ3JhZGllbnRXaWR0aDogMTAwLFxuICBsYWJlbENvbG9yOiBcIiMwMDBcIixcbiAgbGFiZWxGb250U2l6ZTogMTAsXG4gIGxhYmVsRm9udDogXCJzYW5zLXNlcmlmXCIsXG4gIGxhYmVsQWxpZ246IFwibGVmdFwiLFxuICBsYWJlbEJhc2VsaW5lOiBcIm1pZGRsZVwiLFxuICBsYWJlbE9mZnNldDogOCxcbiAgc3ltYm9sU2hhcGU6IFwiY2lyY2xlXCIsXG4gIHN5bWJvbFNpemU6IDUwLFxuICBzeW1ib2xDb2xvcjogXCIjODg4XCIsXG4gIHN5bWJvbFN0cm9rZVdpZHRoOiAxLFxuICB0aXRsZUNvbG9yOiBcIiMwMDBcIixcbiAgdGl0bGVGb250OiBcInNhbnMtc2VyaWZcIixcbiAgdGl0bGVGb250U2l6ZTogMTEsXG4gIHRpdGxlRm9udFdlaWdodDogXCJib2xkXCJcbn07XG5cbi8vIGRlZmF1bHQgY29sb3IgdmFsdWVzXG5jb25maWcuY29sb3IgPSB7XG4gIHJnYjogWzEyOCwgMTI4LCAxMjhdLFxuICBsYWI6IFs1MCwgMCwgMF0sXG4gIGhjbDogWzAsIDAsIDUwXSxcbiAgaHNsOiBbMCwgMCwgMC41XVxufTtcblxuLy8gZGVmYXVsdCBzY2FsZSByYW5nZXNcbmNvbmZpZy5yYW5nZSA9IHtcbiAgY2F0ZWdvcnkxMDogW1xuICAgIFwiIzFmNzdiNFwiLFxuICAgIFwiI2ZmN2YwZVwiLFxuICAgIFwiIzJjYTAyY1wiLFxuICAgIFwiI2Q2MjcyOFwiLFxuICAgIFwiIzk0NjdiZFwiLFxuICAgIFwiIzhjNTY0YlwiLFxuICAgIFwiI2UzNzdjMlwiLFxuICAgIFwiIzdmN2Y3ZlwiLFxuICAgIFwiI2JjYmQyMlwiLFxuICAgIFwiIzE3YmVjZlwiXG4gIF0sXG4gIGNhdGVnb3J5MjA6IFtcbiAgICBcIiMxZjc3YjRcIixcbiAgICBcIiNhZWM3ZThcIixcbiAgICBcIiNmZjdmMGVcIixcbiAgICBcIiNmZmJiNzhcIixcbiAgICBcIiMyY2EwMmNcIixcbiAgICBcIiM5OGRmOGFcIixcbiAgICBcIiNkNjI3MjhcIixcbiAgICBcIiNmZjk4OTZcIixcbiAgICBcIiM5NDY3YmRcIixcbiAgICBcIiNjNWIwZDVcIixcbiAgICBcIiM4YzU2NGJcIixcbiAgICBcIiNjNDljOTRcIixcbiAgICBcIiNlMzc3YzJcIixcbiAgICBcIiNmN2I2ZDJcIixcbiAgICBcIiM3ZjdmN2ZcIixcbiAgICBcIiNjN2M3YzdcIixcbiAgICBcIiNiY2JkMjJcIixcbiAgICBcIiNkYmRiOGRcIixcbiAgICBcIiMxN2JlY2ZcIixcbiAgICBcIiM5ZWRhZTVcIlxuICBdLFxuICBzaGFwZXM6IFtcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiY3Jvc3NcIixcbiAgICBcImRpYW1vbmRcIixcbiAgICBcInNxdWFyZVwiLFxuICAgIFwidHJpYW5nbGUtZG93blwiLFxuICAgIFwidHJpYW5nbGUtdXBcIlxuICBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmZpZzsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgQUREX0NFTEw6IDEsXG4gIE1PRF9DRUxMOiAyLFxuXG4gIERBVEE6IFwiZGF0YVwiLFxuICBGSUVMRFM6ICBcImZpZWxkc1wiLFxuICBTQ0FMRVM6ICBcInNjYWxlc1wiLFxuICBTSUdOQUw6ICBcInNpZ25hbFwiLFxuICBTSUdOQUxTOiBcInNpZ25hbHNcIixcblxuICBHUk9VUDogXCJncm91cFwiLFxuXG4gIEVOVEVSOiBcImVudGVyXCIsXG4gIFVQREFURTogXCJ1cGRhdGVcIixcbiAgRVhJVDogXCJleGl0XCIsXG5cbiAgU0VOVElORUw6IHtcInNlbnRpbmVsXCI6IDF9LFxuICBTSU5HTEVUT046IFwiX3NpbmdsZXRvblwiLFxuXG4gIEFERDogXCJhZGRcIixcbiAgUkVNT1ZFOiBcInJlbW92ZVwiLFxuICBUT0dHTEU6IFwidG9nZ2xlXCIsXG4gIENMRUFSOiBcImNsZWFyXCIsXG5cbiAgTElORUFSOiBcImxpbmVhclwiLFxuICBPUkRJTkFMOiBcIm9yZGluYWxcIixcbiAgTE9HOiBcImxvZ1wiLFxuICBQT1dFUjogXCJwb3dcIixcbiAgVElNRTogXCJ0aW1lXCIsXG4gIFFVQU5USUxFOiBcInF1YW50aWxlXCIsXG5cbiAgRE9NQUlOOiBcImRvbWFpblwiLFxuICBSQU5HRTogXCJyYW5nZVwiLFxuXG4gIE1BUks6IFwibWFya1wiLFxuICBBWElTOiBcImF4aXNcIixcblxuICBDT1VOVDogXCJjb3VudFwiLFxuICBNSU46IFwibWluXCIsXG4gIE1BWDogXCJtYXhcIixcblxuICBBU0M6IFwiYXNjXCIsXG4gIERFU0M6IFwiZGVzY1wiXG59OyIsInZhciBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xudmFyIHRzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlucHV0LCBhcmdzKSB7XG4gIGlmICghY29uZmlnLmRlYnVnKSByZXR1cm47XG4gIHZhciBsb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbiAgYXJncy51bnNoaWZ0KGlucHV0LnN0YW1wfHwtMSk7XG4gIGFyZ3MudW5zaGlmdChEYXRlLm5vdygpIC0gdHMpO1xuICBpZihpbnB1dC5hZGQpIGFyZ3MucHVzaChpbnB1dC5hZGQubGVuZ3RoLCBpbnB1dC5tb2QubGVuZ3RoLCBpbnB1dC5yZW0ubGVuZ3RoLCAhIWlucHV0LnJlZmxvdyk7XG4gIGxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcbiAgdHMgPSBEYXRlLm5vdygpO1xufTsiLCJ2YXIgZGwgPSByZXF1aXJlKCdkYXRhbGliJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcXVpY2tzZWxlY3QoaywgeCwgYykge1xuICBmdW5jdGlvbiBzd2FwKGEsIGIpIHtcbiAgICB2YXIgdCA9IHhbYV07XG4gICAgeFthXSA9IHhbYl07XG4gICAgeFtiXSA9IHQ7XG4gIH1cblxuICAvLyB4IG1heSBiZSBudWxsLCBpbiB3aGljaCBjYXNlIGFzc2VtYmxlIGFuIGFycmF5IGZyb20gYyAoY291bnRzKVxuICBpZih4ID09PSBudWxsKSB7XG4gICAgeCA9IFtdO1xuICAgIGRsLmtleXMoYykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgaSA9IDAsIGxlbiA9IGNba107XG4gICAgICBrID0gK2sgfHwgaztcbiAgICAgIGZvcig7IGk8bGVuOyArK2kpIHgucHVzaChrKTtcbiAgICB9KTtcbiAgfVxuICBcbiAgdmFyIGxlZnQgPSAwLFxuICAgICAgcmlnaHQgPSB4Lmxlbmd0aCAtIDEsXG4gICAgICBwb3MsIGksIHBpdm90O1xuICBcbiAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgIHBpdm90ID0geFtrXTtcbiAgICBzd2FwKGssIHJpZ2h0KTtcbiAgICBmb3IgKGkgPSBwb3MgPSBsZWZ0OyBpIDwgcmlnaHQ7ICsraSkge1xuICAgICAgaWYgKHhbaV0gPCBwaXZvdCkgeyBzd2FwKGksIHBvcysrKTsgfVxuICAgIH1cbiAgICBzd2FwKHJpZ2h0LCBwb3MpO1xuICAgIGlmIChwb3MgPT09IGspIGJyZWFrO1xuICAgIGlmIChwb3MgPCBrKSBsZWZ0ID0gcG9zICsgMTtcbiAgICBlbHNlIHJpZ2h0ID0gcG9zIC0gMTtcbiAgfVxuICByZXR1cm4geFtrXTtcbn07Il19\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","module.exports = function(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 1024,\n      base = opt.base || 10,\n      div = opt.div || [5, 2],\n      mins = opt.minstep || 0,\n      logb = Math.log(base),\n      level = Math.ceil(Math.log(maxb) / logb),\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step = Math.max(mins, Math.pow(base, Math.round(Math.log(span) / logb) - level)),\n      nbins = Math.ceil(span / step),\n      precision, v, i, eps;\n\n  if (opt.step != null) {\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n        opt.steps.length - 1,\n        bisectLeft(opt.steps, span / maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // increase step size if too many bins\n    do {\n      step *= base;\n      nbins = Math.ceil(span / step);\n    } while (nbins > maxb);\n\n    // decrease step size if allowed\n    for (i = 0; i < div.length; ++i) {\n      v = step / div[i];\n      if (v >= mins && span / v <= maxb) {\n        step = v;\n        nbins = Math.ceil(span / step);\n      }\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = (min<0 ? -1 : 1) * Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop: max,\n    step: step,\n    unit: precision\n  };\n};\n\nfunction bisectLeft(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (u.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeroes = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n\tmin = min || 0;\n\tmax = max || 1;\n\tvar delta = max - min;\n\tvar f = function() {\n\t\treturn min + delta * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeroes(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tvar f = function() {\n\t\treturn a + Math.max(0, Math.floor(b*(Math.random()-0.001)));\n\t};\n\tf.samples = function(n) { return gen.zeroes(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeroes(n).map(f); };\n\treturn f;\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.csv.parse(data ? data.toString() : data);\n  return d;\n};\n","module.exports = {\n  json: require('./json'),\n  csv: require('./csv'),\n  tsv: require('./tsv'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) ? data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error(\"TopoJSON library not loaded.\"); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if (obj = t.objects[format.feature]) {\n      return topojson.feature(t, obj).features\n    } else {\n      throw Error(\"Invalid TopoJSON object: \"+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if (obj = t.objects[format.mesh]) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error(\"Invalid TopoJSON object: \" + format.mesh);\n    }\n  } else {\n    throw Error(\"Missing TopoJSON feature or mesh parameter.\");\n  }\n\n  return [];\n};\n","var tree = require('../../tree');\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return tree.toTable(data, (format && format.children));\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.tsv.parse(data ? data.toString() : data);\n  return d;\n};\n","var util = require('../util');\n\nvar tests = {\n  bool: function(x) { return x===\"true\" || x===\"false\" || util.isBoolean(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); },\n  num: function(x) { return !isNaN(+x) && !util.isDate(x); }\n};\n\nmodule.exports = function(values, f) {\n  var i, j, v;\n  \n  // types to test for\n  var types = [\n    {type: \"boolean\", test: tests.bool},\n    {type: \"number\", test: tests.num},\n    {type: \"date\", test: tests.date}\n  ];\n  \n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (v != null && !types[j].test(v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return \"string\";\n  }\n  \n  return types[0].type;\n};","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host == \"\") {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function (d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; };\n  \n  try {\n    var url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== \"text\"\n      ? request.response // null on error\n      : request.responseText; // \"\" on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest;\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest\n      && !(\"withCredentials\" in request)\n      && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest;\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    \"onload\" in request\n      ? request.onload = request.onerror = respond\n      : request.onreadystatechange = function() { request.readyState > 3 && respond(); };\n  }\n  \n  request.open(\"GET\", url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(file, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(file, 'utf8');\n  }\n  require('fs').readFile(file, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) opt = {url: opt};\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\nvar formats = require('./formats');\nvar infer = require('./infer-types');\n\nvar PARSERS = {\n  \"number\": util.number,\n  \"boolean\": util.boolean,\n  \"date\": util.date\n};\n\nfunction read(data, format) {\n  var type = (format && format.type) || \"json\";\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  if (types === 'auto') {\n    // perform type inference\n    types = util.keys(data[0]).reduce(function(types, c) {\n      var type = infer(data, util.accessor(c));\n      if (PARSERS[type]) types[c] = type;\n      return types;\n    }, {});\n  }\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return PARSERS[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n}\n\nread.infer = infer;\nread.formats = formats;\nread.parse = parse;\nmodule.exports = read;\n","var dl = module.exports = {};\nvar util = require('./util');\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\ndl.bin = require('./bin');\ndl.summary = require('./summary');\ndl.template = require('./template');\ndl.truncate = require('./truncate');\n\ndl.load = require('./import/load');\ndl.read = require('./import/read');\nutil.extend(dl, require('./import/loaders'));\n\nvar log = require('./log');\ndl.log = function(msg) { log(msg, log.LOG); };\ndl.log.silent = log.silent;\ndl.error = function(msg) { log(msg, log.ERR); };\n","var LOG = \"LOG\";\nvar ERR = \"ERR\";\nvar silent = false;\n\nfunction prepare(msg, type) {\n  return '[' + [\n    '\"'+(type || LOG)+'\"',\n    Date.now(),\n    '\"'+msg+'\"'\n  ].join(\", \") + ']';\n}\n\nfunction log(msg, type) {\n  if (!silent) {\n    msg = prepare(msg, type);\n    console.error(msg);\n  }\n}\n\nlog.silent = function(val) { silent = !!val; };\n\nlog.LOG = LOG;\nlog.ERR = ERR;\nmodule.exports = log;","var util = require('./util');\nvar stats = {};\n\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\nstats.skew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\nstats.minmax = function(values, f) {\n  var s = {min: +Infinity, max: -Infinity}, v, i, n;\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      if (v > s.max) s.max = v;\n      if (v < s.min) s.min = v;\n    }\n  }\n  return s;\n};\n\nstats.minIndex = function(values, f) {\n  if (!util.isArray(values) || values.length==0) return -1;\n  var idx = 0, v, i, n, min = +Infinity;\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && v < min) { min = v; idx = i; }\n  }\n  return idx;\n};\n\nstats.maxIndex = function(values, f) {\n  if (!util.isArray(values) || values.length==0) return -1;\n  var idx = 0, v, i, n, max = -Infinity;\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && v > max) { max = v; idx = i; }\n  }\n  return idx;\n};\n\nstats.entropy = function(counts) {\n  var i, p, s = 0, H = 0;\n  for (i=0; i<counts.length; ++i) {\n    s += counts[i];\n  }\n  if (s === 0) return 0;\n  for (i=0; i<counts.length; ++i) {\n    p = counts[i] / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\nstats.entropy.normalized = function(counts) {\n  var H = stats.entropy(counts);\n  var max = -Math.log(1/counts.length) / Math.LN2;\n  return H / max;\n};\n\nstats.profile = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return null;\n\n  // init\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = f ? f(values[0]) : values[0],\n      max = min,\n      M2 = 0,\n      median = null,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) {\n      // update unique values\n      u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n      // update min/max\n      if (v < min) min = v;\n      if (v > max) max = v;\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // compute median\n  vals.sort(util.cmp);\n  half = Math.floor(vals.length/2);\n  median = (vals.length % 2)\n   ? vals[half]\n   : (vals[half-1] + vals[half]) / 2.0;\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    median:   median,\n    stdev:    sd,\n    skew:     sd === 0 ? 0 : (mean - median) / sd\n  };\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar stats = require('./stats');\n\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"skew:     \" + p.skew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   require('./truncate')\n};\n\nfunction template(text) {\n  var src = source(text, \"d\");\n  src = \"var __t; return \" + src + \";\";\n\n  try {\n    return (new Function(\"d\", src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || \"obj\";\n  var index = 0;\n  var src = \"'\";\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += \"'\\n+((__t=(\"\n        + template_var(interpolate, variable)\n        + \"))==null?'':__t)+\\n'\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + \"'\";\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var format = [];\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || \"\";\n    if (stringCast) {\n      stringCast = false;\n      src = \"String(\" + src + \")\" + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  var src = util.field(prop).map(util.str).join(\"][\");\n  src = variable + \"[\" + src + \"]\";\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a\n          + (args.length > 1 ? ',' + util.number(args[1]) : '')\n          + ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!==\"left\" && b!==\"middle\" && b!==\"center\") ? \"right\" : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\"' + b + '\")';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      default:\n        throw Error(\"Unrecognized template filter: \" + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n};\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === \"'\" && pattern[pattern.length-1] === \"'\") ||\n      (pattern[0] !== '\"' && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error(\"Format pattern must be quoted: \" + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n};\n","var FIELDS = {\n  parent: \"parent\",\n  children: \"children\"\n};\n\nfunction toTable(root, childrenField, parentField) {\n  childrenField = childrenField || FIELDS.children;\n  parentField = parentField || FIELDS.parent;\n  var table = [];\n  \n  function visit(node, parent) {\n    node[parentField] = parent;\n    table.push(node);\n    \n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n\nmodule.exports = {\n  toTable: toTable,\n  fields: FIELDS\n};","module.exports = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis || \"...\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? u_truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","var u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null; // TODO include NaN here?\n};\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };","module.exports = require('./lib/heap');\n","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","var bounds = function(b) {\n  this.clear();\n  if (b) this.union(b);\n};\n\nvar prototype = bounds.prototype;\n\nprototype.clear = function() {\n  this.x1 = +Number.MAX_VALUE;\n  this.y1 = +Number.MAX_VALUE;\n  this.x2 = -Number.MAX_VALUE;\n  this.y2 = -Number.MAX_VALUE;\n  return this;\n};\n\nprototype.set = function(x1, y1, x2, y2) {\n  this.x1 = x1;\n  this.y1 = y1;\n  this.x2 = x2;\n  this.y2 = y2;\n  return this;\n};\n\nprototype.add = function(x, y) {\n  if (x < this.x1) this.x1 = x;\n  if (y < this.y1) this.y1 = y;\n  if (x > this.x2) this.x2 = x;\n  if (y > this.y2) this.y2 = y;\n  return this;\n};\n\nprototype.expand = function(d) {\n  this.x1 -= d;\n  this.y1 -= d;\n  this.x2 += d;\n  this.y2 += d;\n  return this;\n};\n\nprototype.round = function() {\n  this.x1 = Math.floor(this.x1);\n  this.y1 = Math.floor(this.y1);\n  this.x2 = Math.ceil(this.x2);\n  this.y2 = Math.ceil(this.y2);\n  return this;\n};\n\nprototype.translate = function(dx, dy) {\n  this.x1 += dx;\n  this.x2 += dx;\n  this.y1 += dy;\n  this.y2 += dy;\n  return this;\n};\n\nprototype.rotate = function(angle, x, y) {\n  var cos = Math.cos(angle),\n      sin = Math.sin(angle),\n      cx = x - x*cos + y*sin,\n      cy = y - x*sin - y*cos,\n      x1 = this.x1, x2 = this.x2,\n      y1 = this.y1, y2 = this.y2;\n\n  return this.clear()\n    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)\n    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)\n    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)\n    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);\n}\n\nprototype.union = function(b) {\n  if (b.x1 < this.x1) this.x1 = b.x1;\n  if (b.y1 < this.y1) this.y1 = b.y1;\n  if (b.x2 > this.x2) this.x2 = b.x2;\n  if (b.y2 > this.y2) this.y2 = b.y2;\n  return this;\n};\n\nprototype.encloses = function(b) {\n  return b && (\n    this.x1 <= b.x1 &&\n    this.x2 >= b.x2 &&\n    this.y1 <= b.y1 &&\n    this.y2 >= b.y2\n  );\n};\n\nprototype.intersects = function(b) {\n  return b && !(\n    this.x2 < b.x1 ||\n    this.x1 > b.x2 ||\n    this.y2 < b.y1 ||\n    this.y1 > b.y2\n  );\n};\n\nprototype.contains = function(x, y) {\n  return !(\n    x < this.x1 ||\n    x > this.x2 ||\n    y < this.y1 ||\n    y > this.y2\n  );\n};\n\nprototype.width = function() {\n  return this.x2 - this.x1;\n};\n\nprototype.height = function() {\n  return this.y2 - this.y1;\n};\n\nmodule.exports = bounds;","var Graph = require('../dataflow/Graph'), \n    Node  = require('../dataflow/Node'),\n    GroupBuilder = require('../scene/GroupBuilder'),\n    changeset = require('../dataflow/changeset'), \n    dl = require('datalib');\n\nfunction Model() {\n  this._defs = {};\n  this._predicates = {};\n  this._scene = null;\n\n  this.graph = new Graph();\n\n  this._node = new Node(this.graph);\n  this._builder = null; // Top-level scenegraph builder\n};\n\nvar proto = Model.prototype;\n\nproto.defs = function(defs) {\n  if (!arguments.length) return this._defs;\n  this._defs = defs;\n  return this;\n};\n\nproto.data = function() {\n  var data = this.graph.data.apply(this.graph, arguments);\n  if(arguments.length > 1) {  // new Datasource\n    this._node.addListener(data.pipeline()[0]);\n  }\n\n  return data;\n};\n\nfunction predicates(name) {\n  var m = this, predicates = {};\n  if(!dl.isArray(name)) return this._predicates[name];\n  name.forEach(function(n) { predicates[n] = m._predicates[n] });\n  return predicates;\n}\n\nproto.predicate = function(name, predicate) {\n  if(arguments.length === 1) return predicates.call(this, name);\n  return (this._predicates[name] = predicate);\n};\n\nproto.predicates = function() { return this._predicates; };\n\nproto.scene = function(renderer) {\n  if(!arguments.length) return this._scene;\n  if(this._builder) this._node.removeListener(this._builder.disconnect());\n  this._builder = new GroupBuilder(this, this._defs.marks, this._scene={});\n  this._node.addListener(this._builder.connect());\n  var p = this._builder.pipeline();\n  p[p.length-1].addListener(renderer);\n  return this;\n};\n\nproto.addListener = function(l) { this._node.addListener(l); };\nproto.removeListener = function(l) { this._node.removeListener(l); };\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create();\n  this.graph.propagate(cs, this._node);\n};\n\nmodule.exports = Model;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    parseStreams = require('../parse/streams'),\n    canvas = require('../render/canvas/index'),\n    svg = require('../render/svg/index'),\n    svgx = require('../render/svg-xml/index'),\n    Transition = require('../scene/Transition'),\n    config = require('../util/config'),\n    debug = require('../util/debug'),\n    changeset = require('../dataflow/changeset');\n\nvar View = function(el, width, height, model) {\n  this._el    = null;\n  this._model = null;\n  this._width = this.__width = width || 500;\n  this._height = this.__height = height || 300;\n  this._autopad = 1;\n  this._padding = {top:0, left:0, bottom:0, right:0};\n  this._viewport = null;\n  this._renderer = null;\n  this._handler = null;\n  this._io = canvas;\n  if (el) this.initialize(el);\n};\n\nvar prototype = View.prototype;\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  if (this._model !== model) {\n    this._model = model;\n    if (this._handler) this._handler.model(model);\n  }\n  return this;\n};\n\nprototype.data = function(data) {\n  var m = this.model();\n  if (!arguments.length) return m.data();\n  dl.keys(data).forEach(function(d) { m.data(d).add(dl.duplicate(data[d])); });\n  return this;\n};\n\nprototype.width = function(width) {\n  if (!arguments.length) return this.__width;\n  if (this.__width !== width) {\n    this._width = this.__width = width;\n    if (this._el) this.initialize(this._el.parentNode);\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.height = function(height) {\n  if (!arguments.length) return this.__height;\n  if (this.__height !== height) {\n    this._height = this.__height = height;\n    if (this._el) this.initialize(this._el.parentNode);\n    if (this._strict) this._autopad = 1;\n  }\n  return this;\n};\n\nprototype.padding = function(pad) {\n  if (!arguments.length) return this._padding;\n  if (this._padding !== pad) {\n    if (dl.isString(pad)) {\n      this._autopad = 1;\n      this._padding = {top:0, left:0, bottom:0, right:0};\n      this._strict = (pad === \"strict\");\n    } else {\n      this._autopad = 0;\n      this._padding = pad;\n      this._strict = false;\n    }\n    if (this._el) {\n      this._renderer.resize(this._width, this._height, pad);\n      this._handler.padding(pad);\n    }\n  }\n  return this;\n};\n\nprototype.autopad = function(opt) {\n  if (this._autopad < 1) return this;\n  else this._autopad = 0;\n\n  var pad = this._padding,\n      b = this.model().scene().bounds,\n      inset = config.autopadInset,\n      l = b.x1 < 0 ? Math.ceil(-b.x1) + inset : 0,\n      t = b.y1 < 0 ? Math.ceil(-b.y1) + inset : 0,\n      r = b.x2 > this._width  ? Math.ceil(+b.x2 - this._width) + inset : 0,\n      b = b.y2 > this._height ? Math.ceil(+b.y2 - this._height) + inset : 0;\n  pad = {left:l, top:t, right:r, bottom:b};\n\n  if (this._strict) {\n    this._autopad = 0;\n    this._padding = pad;\n    this._width = Math.max(0, this.__width - (l+r));\n    this._height = Math.max(0, this.__height - (t+b));\n    this._model.width(this._width);\n    this._model.height(this._height);\n    if (this._el) this.initialize(this._el.parentNode);\n    this.update();\n  } else {\n    this.padding(pad).update(opt);\n  }\n  return this;\n};\n\nprototype.viewport = function(size) {\n  if (!arguments.length) return this._viewport;\n  if (this._viewport !== size) {\n    this._viewport = size;\n    if (this._el) this.initialize(this._el.parentNode);\n  }\n  return this;\n};\n\nprototype.renderer = function(type) {\n  if (!arguments.length) return this._renderer;\n  if (type === \"canvas\") type = canvas;\n  else if (type === \"svg\") type = svg;\n  else if (type === \"svg-xml\") type = svgx;\n  else if (dl.isString(type)) throw new Error(\"Unknown renderer: \" + type);\n  else if (!type) throw new Error(\"No renderer specified\");\n\n  if (this._io !== type) {\n    this._io = type;\n    this._renderer = null;\n    if (this._el) this.initialize(this._el.parentNode);\n    if (this._build) this.render();\n  }\n  return this;\n};\n\nprototype.initialize = function(el) {\n  var v = this, prevHandler,\n      w = v._width, h = v._height, pad = v._padding;\n  \n  if (!arguments.length || el === null) {\n    el = this._el ? this._el.parentNode : null;\n  }\n\n  if (el) {\n    // clear pre-existing container\n    d3.select(el).select(\"div.vega\").remove();\n    \n    // add div container\n    this._el = el = d3.select(el)\n      .append(\"div\")\n      .attr(\"class\", \"vega\")\n      .style(\"position\", \"relative\")\n      .node();\n    if (v._viewport) {\n      d3.select(el)\n        .style(\"width\",  (v._viewport[0] || w)+\"px\")\n        .style(\"height\", (v._viewport[1] || h)+\"px\")\n        .style(\"overflow\", \"auto\");\n    }\n  }\n\n  // renderer\n  v._renderer = (v._renderer || new this._io.Renderer())\n    .initialize(el, w, h, pad);\n  \n  if (el) {\n    // input handler\n    prevHandler = v._handler;\n    v._handler = new this._io.Handler()\n      .initialize(el, pad, v)\n      .model(v._model);\n\n    if (prevHandler) {\n      prevHandler.handlers().forEach(function(h) {\n        v._handler.on(h.type, h.handler);\n      });\n    } else {\n      // Register event listeners for signal stream definitions.\n      parseStreams(this);\n    }\n  }\n  \n  return this;\n};\n\nprototype.update = function(opt) {    \n  opt = opt || {};\n  var v = this,\n      trans = opt.duration\n        ? new Transition(opt.duration, opt.ease)\n        : null;\n\n  // TODO: with streaming data API, adds should dl.duplicate just parseSpec\n  // to prevent Vega from polluting the environment.\n\n  var cs = changeset.create();\n  if(trans) cs.trans = trans;\n  if(opt.reflow !== undefined) cs.reflow = opt.reflow\n\n  if(!v._build) {\n    v._renderNode = new Node(v._model.graph)\n      .router(true);\n\n    v._renderNode.evaluate = function(input) {\n      debug(input, [\"rendering\"]);\n\n      var s = v._model.scene();\n      if(input.trans) {\n        input.trans.start(function(items) { v._renderer.render(s, items); });\n      } else {\n        v._renderer.render(s);\n      }\n\n      // For all updated datasources, finalize their changesets.\n      var d, ds;\n      for(d in input.data) {\n        ds = v._model.data(d);\n        if(!ds.revises()) continue;\n        changeset.finalize(ds.last());\n      }\n\n      return input;\n    };\n\n    v._model.scene(v._renderNode);\n    v._build = true;\n  }\n\n  // Pulse the entire model (Datasources + scene).\n  v._model.fire(cs);\n\n  return v.autopad(opt);\n};\n\nprototype.on = function() {\n  this._handler.on.apply(this._handler, arguments);\n  return this;\n};\n\nprototype.off = function() {\n  this._handler.off.apply(this._handler, arguments);\n  return this;\n};\n\nView.factory = function(model) {\n  return function(opt) {\n    opt = opt || {};\n    var defs = model.defs();\n    var v = new View()\n      .model(model)\n      .width(defs.width)\n      .height(defs.height)\n      .padding(defs.padding)\n      .renderer(opt.renderer || \"canvas\");\n\n    v.initialize(opt.el);\n    if (opt.data) v.data(opt.data);\n  \n    return v;\n  };    \n};\n\nmodule.exports = View;\n","var Node = require('./Node'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Collector(graph) {\n  Node.prototype.init.call(this, graph);\n  this._data = [];\n  return this.router(true)\n    .collector(true);\n}\n\nvar proto = (Collector.prototype = new Node());\n\nproto.data = function() { return this._data; }\n\nproto.evaluate = function(input) {\n  debug(input, [\"collecting\"]);\n\n  if (input.reflow) {\n    input = changeset.create(input);\n    input.mod = this._data.slice();\n    return input;\n  }\n\n  if (input.rem.length) {\n    var ids = input.rem.reduce(function(m,x) { return (m[x._id]=1, m); }, {});\n    this._data = this._data.filter(function(x) { return ids[x._id] !== 1; });\n  }\n\n  if (input.add.length) {\n    this._data = this._data.length ? this._data.concat(input.add) : input.add;\n  }\n\n  if (input.sort) {\n    this._data.sort(input.sort);\n  }\n\n  return input;\n};\n\nmodule.exports = Collector;","var dl = require('datalib'),\n    changeset = require('./changeset'), \n    tuple = require('./tuple'), \n    Node = require('./Node'),\n    Collector = require('./Collector'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Datasource(graph, name, facet) {\n  this._graph = graph;\n  this._name = name;\n  this._data = [];\n  this._source = null;\n  this._facet = facet;\n  this._input = changeset.create();\n  this._output = null;    // Output changeset\n\n  this._pipeline  = null; // Pipeline of transformations.\n  this._collector = null; // Collector to materialize output of pipeline\n  this._revises = false; // Does any pipeline operator need to track prev?\n};\n\nvar proto = Datasource.prototype;\n\nproto.name = function(name) {\n  if(!arguments.length) return this._name;\n  return (this._name = name, this);\n};\n\nproto.source = function(src) {\n  if(!arguments.length) return this._source;\n  return (this._source = this._graph.data(src));\n};\n\nproto.add = function(d) {\n  var prev = this._revises ? null : undefined;\n\n  this._input.add = this._input.add\n    .concat(dl.array(d).map(function(d) { return tuple.ingest(d, prev); }));\n  return this;\n};\n\nproto.remove = function(where) {\n  var d = this._data.filter(where);\n  this._input.rem = this._input.rem.concat(d);\n  return this;\n};\n\nproto.update = function(where, field, func) {\n  var mod = this._input.mod,\n      ids = tuple.idMap(mod),\n      prev = this._revises ? null : undefined; \n\n  this._input.fields[field] = 1;\n  this._data.filter(where).forEach(function(x) {\n    var prev = x[field],\n        next = func(x);\n    if (prev !== next) {\n      tuple.set(x, field, next);\n      if(ids[x._id] !== 1) {\n        mod.push(x);\n        ids[x._id] = 1;\n      }\n    }\n  });\n  return this;\n};\n\nproto.values = function(data) {\n  if(!arguments.length)\n    return this._collector ? this._collector.data() : this._data;\n\n  // Replace backing data\n  this._input.rem = this._data.slice();\n  if (data) { this.add(data); }\n  return this;\n};\n\nfunction set_prev(d) { if(d._prev === undefined) d._prev = C.SENTINEL; }\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new dataflow node needs it now\n  // ensure existing tuples have prev set.\n  if(!this._revises && p) {\n    this._data.forEach(set_prev);\n    this._input.add.forEach(set_prev); // New tuples that haven't yet been merged into _data\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\nproto.last = function() { return this._output; };\n\nproto.fire = function(input) {\n  if(input) this._input = input;\n  this._graph.propagate(this._input, this._pipeline[0]); \n};\n\nproto.pipeline = function(pipeline) {\n  var ds = this, n, c;\n  if(!arguments.length) return this._pipeline;\n\n  if(pipeline.length) {\n    // If we have a pipeline, add a collector to the end to materialize\n    // the output.\n    ds._collector = new Collector(this._graph);\n    pipeline.push(ds._collector);\n    ds._revises = pipeline.some(function(p) { return p.revises(); });\n  }\n\n  // Input node applies the datasource's delta, and propagates it to \n  // the rest of the pipeline. It receives touches to reflow data.\n  var input = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  input.evaluate = function(input) {\n    debug(input, [\"input\", ds._name]);\n\n    var delta = ds._input, \n        out = changeset.create(input),\n        rem;\n\n    // Delta might contain fields updated through API\n    dl.keys(delta.fields).forEach(function(f) { out.fields[f] = 1 });\n\n    if(input.reflow) {\n      out.mod = ds._data.slice();\n    } else {\n      // update data\n      if(delta.rem.length) {\n        rem = tuple.idMap(delta.rem);\n        ds._data = ds._data\n          .filter(function(x) { return rem[x._id] !== 1 });\n      }\n\n      if(delta.add.length) ds._data = ds._data.concat(delta.add);\n\n      // reset change list\n      ds._input = changeset.create();\n\n      out.add = delta.add; \n      out.mod = delta.mod;\n      out.rem = delta.rem;\n    }\n\n    return (out.facet = ds._facet, out);\n  };\n\n  pipeline.unshift(input);\n\n  // Output node captures the last changeset seen by this datasource\n  // (needed for joins and builds) and materializes any nested data.\n  // If this datasource is faceted, materializes the values in the facet.\n  var output = new Node(this._graph)\n    .router(true)\n    .collector(true);\n\n  output.evaluate = function(input) {\n    debug(input, [\"output\", ds._name]);\n    var output = changeset.create(input, true);\n\n    if(ds._facet) {\n      ds._facet.values = ds.values();\n      input.facet = null;\n    }\n\n    ds._output = input;\n    output.data[ds._name] = 1;\n    return output;\n  };\n\n  pipeline.push(output);\n\n  this._pipeline = pipeline;\n  this._graph.connect(ds._pipeline);\n  return this;\n};\n\nproto.listener = function() { \n  var l = new Node(this._graph).router(true),\n      dest = this,\n      prev = this._revises ? null : undefined;\n\n  l.evaluate = function(input) {\n    dest._srcMap = dest._srcMap || {};  // to propagate tuples correctly\n    var map = dest._srcMap,\n        output  = changeset.create(input);\n\n    output.add = input.add.map(function(t) {\n      return (map[t._id] = tuple.derive(t, t._prev !== undefined ? t._prev : prev));\n    });\n    output.mod = input.mod.map(function(t) { return map[t._id]; });\n    output.rem = input.rem.map(function(t) { \n      var o = map[t._id];\n      map[t._id] = null;\n      return o;\n    });\n\n    return (dest._input = output);\n  };\n\n  l.addListener(this._pipeline[0]);\n  return l;\n};\n\nproto.addListener = function(l) {\n  if(l instanceof Datasource) {\n    if(this._collector) this._collector.addListener(l.listener());\n    else this._pipeline[0].addListener(l.listener());\n  } else {\n    this._pipeline[this._pipeline.length-1].addListener(l);      \n  }\n\n  return this;\n};\n\nproto.removeListener = function(l) {\n  this._pipeline[this._pipeline.length-1].removeListener(l);\n};\n\nproto.listeners = function(ds) {\n  return ds \n    ? this._collector ? this._collector.listeners() : this._pipeline[0].listeners()\n    : this._pipeline[this._pipeline.length-1].listeners();\n};\n\nmodule.exports = Datasource;","var dl = require('datalib'),\n    Heap = require('heap'),\n    Datasource = require('./Datasource'),\n    Signal = require('./Signal'),\n    changeset = require('./changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Graph() {\n  this._stamp = 0;\n  this._rank  = 0;\n\n  this._data = {};\n  this._signals = {};\n\n  this.doNotPropagate = {};\n}\n\nvar proto = Graph.prototype;\n\nproto.data = function(name, pipeline, facet) {\n  if(arguments.length === 1) return this._data[name];\n  return (this._data[name] = new Datasource(this, name, facet)\n    .pipeline(pipeline));\n};\n\nfunction signal(name) {\n  var m = this, i, len;\n  if(!dl.isArray(name)) return this._signals[name];\n  return name.map(function(n) { m._signals[n]; });\n}\n\nproto.signal = function(name, init) {\n  var m = this;\n  if(arguments.length === 1) return signal.call(this, name);\n  return (this._signals[name] = new Signal(this, name, init));\n};\n\nproto.signalValues = function(name) {\n  var graph = this;\n  if(!dl.isArray(name)) return this._signals[name].value();\n  return name.reduce(function(sg, n) {\n    return (sg[n] = graph._signals[n].value(), sg);\n  }, {});\n};\n\nproto.signalRef = function(ref) {\n  if(!dl.isArray(ref)) ref = dl.field(ref);\n  var value = this.signal(ref.shift()).value();\n  if(ref.length > 0) {\n    var fn = Function(\"s\", \"return s[\"+ref.map(dl.str).join(\"][\")+\"]\");\n    value = fn.call(null, value);\n  }\n\n  return value;\n};\n\nvar schedule = function(a, b) {\n  // If the nodes are equal, propagate the non-reflow pulse first,\n  // so that we can ignore subsequent reflow pulses. \n  if(a.rank == b.rank) return a.pulse.reflow ? 1 : -1;\n  else return a.rank - b.rank; \n};\n\nproto.propagate = function(pulse, node) {\n  var v, l, n, p, r, i, len, reflowed;\n\n  // new PQ with each propagation cycle so that we can pulse branches\n  // of the dataflow graph during a propagation (e.g., when creating\n  // a new inline datasource).\n  var pq = new Heap(schedule); \n\n  if(pulse.stamp) throw \"Pulse already has a non-zero stamp\"\n\n  pulse.stamp = ++this._stamp;\n  pq.push({ node: node, pulse: pulse, rank: node.rank() });\n\n  while (pq.size() > 0) {\n    v = pq.pop(), n = v.node, p = v.pulse, r = v.rank, l = n._listeners;\n    reflowed = p.reflow && n.last() >= p.stamp;\n\n    if(reflowed) continue; // Don't needlessly reflow ops.\n\n    // A node's rank might change during a propagation (e.g. instantiating\n    // a group's dataflow branch). Re-queue if it has. T\n    // TODO: use pq.replace or pq.poppush?\n    if(r != n.rank()) {\n      debug(p, ['Rank mismatch', r, n.rank()]);\n      pq.push({ node: n, pulse: p, rank: n.rank() });\n      continue;\n    }\n\n    p = this.evaluate(p, n);\n\n    // Even if we didn't run the node, we still want to propagate \n    // the pulse. \n    if (p !== this.doNotPropagate) {\n      for (i = 0, len = l.length; i < len; i++) {\n        pq.push({ node: l[i], pulse: p, rank: l[i]._rank });\n      }\n    }\n  }\n};\n\n// Connect a branch of dataflow nodes. \n// Dependencies get wired to the nearest collector. \nfunction forEachNode(branch, fn) {\n  var node, collector, i, len;\n  for(i=0, len=branch.length; i<len; ++i) {\n    node = branch[i];\n    if(node.collector()) collector = node;\n    fn(node, collector, i);\n  }\n}\n\nproto.connect = function(branch) {\n  debug({}, ['connecting']);\n  var graph = this;\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { \n        graph.data(d)\n          .revises(n.revises())\n          .addListener(c);\n      });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).addListener(c); });\n    }\n\n    if(i > 0) {\n      branch[i-1].addListener(branch[i]);\n    }\n  });\n\n  return branch;\n};\n\nproto.disconnect = function(branch) {\n  debug({}, ['disconnecting']);\n  var graph = this;\n\n  forEachNode(branch, function(n, c, i) {\n    var data = n.dependency(C.DATA),\n        signals = n.dependency(C.SIGNALS);\n\n    if(data.length > 0) {\n      data.forEach(function(d) { graph.data(d).removeListener(c); });\n    }\n\n    if(signals.length > 0) {\n      signals.forEach(function(s) { graph.signal(s).removeListener(c) });\n    }\n\n    n.disconnect();  \n  });\n\n  return branch;\n};\n\nproto.reevaluate = function(pulse, node) {\n  var reflowed = !pulse.reflow || (pulse.reflow && node.last() >= pulse.stamp),\n      run = !!pulse.add.length || !!pulse.rem.length || node.router();\n  run = run || !reflowed;\n  return run || node.reevaluate(pulse);\n};\n\nproto.evaluate = function(pulse, node) {\n  if(!this.reevaluate(pulse, node)) return pulse;\n  pulse = node.evaluate(pulse);\n  node.last(pulse.stamp);\n  return pulse\n};\n\nmodule.exports = Graph;","var dl = require('datalib'),\n    C = require('../util/constants'),\n    REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nvar node_id = 1;\n\nfunction Node(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = Node.prototype;\n\nproto.init = function(graph) {\n  this._id = node_id++;\n  this._graph = graph;\n  this._rank = ++graph._rank; // For topologial sort\n  this._stamp = 0;  // Last stamp seen\n\n  this._listeners = [];\n  this._registered = {}; // To prevent duplicate listeners\n\n  this._deps = {\n    data:    [],\n    fields:  [],\n    scales:  [],\n    signals: [],\n  };\n\n  this._isRouter = false; // Responsible for propagating tuples, cannot ever be skipped\n  this._isCollector = false;  // Holds a materialized dataset, pulse to reflow\n  this._revises = false; // Does the operator require tuples' previous values? \n  return this;\n};\n\nproto.clone = function() {\n  var n = new Node(this._graph);\n  n.evaluate = this.evaluate;\n  n._deps = this._deps;\n  n._isRouter = this._isRouter;\n  n._isCollector = this._isCollector;\n  return n;\n};\n\nproto.rank = function() { return this._rank; };\n\nproto.last = function(stamp) { \n  if(!arguments.length) return this._stamp;\n  this._stamp = stamp;\n  return this;\n};\n\nproto.dependency = function(type, deps) {\n  var d = this._deps[type];\n  if(arguments.length === 1) return d;\n  if(deps === null) { // Clear dependencies of a certain type\n    while(d.length > 0) d.pop();\n  } else {\n    if(!dl.isArray(deps) && d.indexOf(deps) < 0) d.push(deps);\n    else d.push.apply(d, dl.array(deps));\n  }\n  return this;\n};\n\nproto.router = function(bool) {\n  if(!arguments.length) return this._isRouter;\n  this._isRouter = !!bool\n  return this;\n};\n\nproto.collector = function(bool) {\n  if(!arguments.length) return this._isCollector;\n  this._isCollector = !!bool;\n  return this;\n};\n\nproto.revises = function(bool) {\n  if(!arguments.length) return this._revises;\n  this._revises = !!bool;\n  return this;\n};\n\nproto.listeners = function() {\n  return this._listeners;\n};\n\nproto.addListener = function(l) {\n  if(!(l instanceof Node)) throw \"Listener is not a Node\";\n  if(this._registered[l._id]) return this;\n\n  this._listeners.push(l);\n  this._registered[l._id] = 1;\n  if(this._rank > l._rank) {\n    var q = [l];\n    while(q.length) {\n      var cur = q.splice(0,1)[0];\n      cur._rank = ++this._graph._rank;\n      q.push.apply(q, cur._listeners);\n    }\n  }\n\n  return this;\n};\n\nproto.removeListener = function (l) {\n  var foundSending = false;\n  for (var i = 0, len = this._listeners.length; i < len && !foundSending; i++) {\n    if (this._listeners[i] === l) {\n      this._listeners.splice(i, 1);\n      this._registered[l._id] = null;\n      foundSending = true;\n    }\n  }\n  \n  return foundSending;\n};\n\nproto.disconnect = function() {\n  this._listeners = [];\n  this._registered = {};\n};\n\nproto.evaluate = function(pulse) { return pulse; }\n\nproto.reevaluate = function(pulse) {\n  var node = this, reeval = false;\n  return REEVAL.some(function(prop) {\n    reeval = reeval || node._deps[prop].some(function(k) { return !!pulse[prop][k] });\n    return reeval;\n  });\n\n  return this;\n};\n\nmodule.exports = Node;","var Node = require('./Node'),\n    changeset = require('./changeset');\n\nfunction Signal(graph, name, init) {\n  Node.prototype.init.call(this, graph);\n  this._name  = name;\n  this._value = init;\n  return this;\n};\n\nvar proto = (Signal.prototype = new Node());\n\nproto.name = function() { return this._name; };\n\nproto.value = function(val) {\n  if(!arguments.length) return this._value;\n  this._value = val;\n  return this;\n};\n\nproto.fire = function(cs) {\n  if(!cs) cs = changeset.create(null, true);\n  cs.signals[this._name] = 1;\n  this._graph.propagate(cs, this);\n};\n\nmodule.exports = Signal;","var C = require('../util/constants');\nvar REEVAL = [C.DATA, C.FIELDS, C.SCALES, C.SIGNALS];\n\nfunction create(cs, reflow) {\n  var out = {};\n  copy(cs, out);\n\n  out.add = [];\n  out.mod = [];\n  out.rem = [];\n\n  out.reflow = reflow;\n\n  return out;\n}\n\nfunction reset_prev(x) {\n  x._prev = (x._prev === undefined) ? undefined : C.SENTINEL;\n}\n\nfunction finalize(cs) {\n  for(i=0, len=cs.add.length; i<len; ++i) reset_prev(cs.add[i]);\n  for(i=0, len=cs.mod.length; i<len; ++i) reset_prev(cs.mod[i]);\n}\n\nfunction copy(a, b) {\n  b.stamp = a ? a.stamp : 0;\n  b.sort  = a ? a.sort  : null;\n  b.facet = a ? a.facet : null;\n  b.trans = a ? a.trans : null;\n  REEVAL.forEach(function(d) { b[d] = a ? a[d] : {}; });\n}\n\nmodule.exports = {\n  create: create,\n  copy: copy,\n  finalize: finalize,\n};","var dl = require('datalib'),\n    C = require('../util/constants'),\n    tuple_id = 1;\n\n// Object.create is expensive. So, when ingesting, trust that the\n// datum is an object that has been appropriately sandboxed from \n// the outside environment. \nfunction ingest(datum, prev) {\n  datum = dl.isObject(datum) ? datum : {data: datum};\n  datum._id = tuple_id++;\n  datum._prev = (prev !== undefined) ? (prev || C.SENTINEL) : undefined;\n  return datum;\n}\n\nfunction derive(datum, prev) {\n  return ingest(Object.create(datum), prev);\n}\n\n// WARNING: operators should only call this once per timestamp!\nfunction set(t, k, v) {\n  var prev = t[k];\n  if(prev === v) return;\n  set_prev(t, k);\n  t[k] = v;\n}\n\nfunction set_prev(t, k) {\n  if(t._prev === undefined) return;\n  t._prev = (t._prev === C.SENTINEL) ? {} : t._prev;\n  t._prev[k] = t[k];\n}\n\nfunction reset() { tuple_id = 1; }\n\nfunction idMap(a) {\n  return a.reduce(function(m,x) {\n    return (m[x._id] = 1, m);\n  }, {});\n};\n\nmodule.exports = {\n  ingest: ingest,\n  derive: derive,\n  set:    set,\n  prev:   set_prev,\n  reset:  reset,\n  idMap:  idMap\n};","var dl = require('datalib');\n\nmodule.exports = function(opt) {\n  opt = opt || {};\n  var constants = opt.constants || require('./constants');\n  var functions = (opt.functions || require('./functions'))(codegen);\n  var idWhiteList = opt.idWhiteList ? dl.toMap(opt.idWhiteList) : null;\n  var idBlackList = opt.idBlackList ? dl.toMap(opt.idBlackList) : null;\n  var memberDepth = 0;\n\n  // TODO generalize?\n  var DATUM = 'd';\n  var SIGNAL_PREFIX = 'sg.';\n  var signals = {};\n  var fields = {};\n\n  function codegen_wrap(ast) {    \n    var retval = {\n      fn: codegen(ast),\n      signals: dl.keys(signals),\n      fields: dl.keys(fields)\n    };\n    signals = {};\n    fields = {};\n    return retval;\n  }\n\n  function codegen(ast) {\n    if (ast instanceof String) return ast;\n    var generator = CODEGEN_TYPES[ast.type];\n    if (generator == null) {\n      throw new Error(\"Unsupported type: \" + ast.type);\n    }\n    return generator(ast);\n  }\n\n  var CODEGEN_TYPES = {\n    \"Literal\": function(n) {\n        return n.raw;\n      },\n    \"Identifier\": function(n) {\n        var id = n.name;\n        if (memberDepth > 0) {\n          return id;\n        }\n        if (constants.hasOwnProperty(id)) {\n          return constants[id];\n        }\n        if (idWhiteList) {\n          if (idWhiteList.hasOwnProperty(id)) {\n            return id;\n          } else {\n            signals[id] = 1;\n            return SIGNAL_PREFIX + id; // HACKish...\n          }\n        }\n        if (idBlackList && idBlackList.hasOwnProperty(id)) {\n          throw new Error(\"Illegal identifier: \" + id);\n        }\n        return id;\n      },\n    \"Program\": function(n) {\n        return n.body.map(codegen).join(\"\\n\");\n      },\n    \"MemberExpression\": function(n) {\n        var d = !n.computed;\n        var o = codegen(n.object);\n        if (d) memberDepth += 1;\n        var p = codegen(n.property);\n        if (o === DATUM) { fields[p] = 1; } // HACKish...\n        if (d) memberDepth -= 1;\n        return o + (d ? \".\"+p : \"[\"+p+\"]\");\n      },\n    \"CallExpression\": function(n) {\n        if (n.callee.type !== \"Identifier\") {\n          throw new Error(\"Illegal callee type: \" + n.callee.type);\n        }\n        var callee = n.callee.name;\n        var args = n.arguments;\n        var fn = functions.hasOwnProperty(callee) && functions[callee];\n        if (!fn) throw new Error(\"Unrecognized function: \" + callee);\n        return fn instanceof Function\n          ? fn(args)\n          : fn + \"(\" + args.map(codegen).join(\",\") + \")\";\n      },\n    \"ArrayExpression\": function(n) {\n        return \"[\" + n.elements.map(codegen).join(\",\") + \"]\";\n      },\n    \"BinaryExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"UnaryExpression\": function(n) {\n        return \"(\" + n.operator + codegen(n.argument) + \")\";\n      },\n    \"UpdateExpression\": function(n) {\n        return \"(\" + (prefix\n          ? n.operator + codegen(n.argument)\n          : codegen(n.argument) + n.operator\n        ) + \")\";\n      },\n    \"ConditionalExpression\": function(n) {\n        return \"(\" + codegen(n.test)\n          + \"?\" + codegen(n.consequent)\n          + \":\" + codegen(n.alternate)\n          + \")\";\n      },\n    \"LogicalExpression\": function(n) {\n        return \"(\" + codegen(n.left) + n.operator + codegen(n.right) + \")\";\n      },\n    \"ObjectExpression\": function(n) {\n        return \"{\" + n.properties.map(codegen).join(\",\") + \"}\";\n      },\n    \"Property\": function(n) {\n        memberDepth += 1;\n        var k = codegen(n.key);\n        memberDepth -= 1;\n        return k + \":\" + codegen(n.value);\n      },\n    \"ExpressionStatement\": function(n) {\n        return codegen(n.expression);\n      }\n  };\n  \n  return codegen_wrap;\n};","module.exports = {\n  \"NaN\":     \"NaN\",\n  \"E\":       \"Math.E\",\n  \"LN2\":     \"Math.LN2\",\n  \"LN10\":    \"Math.LN10\",\n  \"LOG2E\":   \"Math.LOG2E\",\n  \"LOG10E\":  \"Math.LOG10E\",\n  \"PI\":      \"Math.PI\",\n  \"SQRT1_2\": \"Math.SQRT1_2\",\n  \"SQRT2\":   \"Math.SQRT2\"\n};","var datalib = require('datalib');\n\nmodule.exports = function(codegen) {\n\n  function fncall(name, args, cast, type) {\n    var obj = codegen(args[0]);\n    if (cast) {\n      obj = cast + \"(\" + obj + \")\";\n      if (dl.startsWith(cast, \"new \")) obj = \"(\" + obj + \")\";\n    }\n    return obj + \".\" + name + (type < 0 ? \"\" : type === 0\n      ? \"()\"\n      : \"(\" + args.slice(1).map(codegen).join(\",\") + \")\");\n  }\n  \n  var DATE = \"new Date\";\n  var STRING = \"String\";\n  var REGEXP = \"RegExp\";\n\n  return {\n    // MATH functions\n    \"isNaN\":    \"isNaN\",\n    \"isFinite\": \"isFinite\",\n    \"abs\":      \"Math.abs\",\n    \"acos\":     \"Math.acos\",\n    \"asin\":     \"Math.asin\",\n    \"atan\":     \"Math.atan\",\n    \"atan2\":    \"Math.atan2\",\n    \"ceil\":     \"Math.ceil\",\n    \"cos\":      \"Math.cos\",\n    \"exp\":      \"Math.exp\",\n    \"floor\":    \"Math.floor\",\n    \"log\":      \"Math.log\",\n    \"max\":      \"Math.max\",\n    \"min\":      \"Math.min\",\n    \"pow\":      \"Math.pow\",\n    \"random\":   \"Math.random\",\n    \"round\":    \"Math.round\",\n    \"sin\":      \"Math.sin\",\n    \"sqrt\":     \"Math.sqrt\",\n    \"tan\":      \"Math.tan\",\n\n    // DATE functions\n    \"now\":      \"Date.now\",\n    \"datetime\": \"new Date\",\n    \"date\": function(args) {\n        return fncall(\"getDate\", args, DATE, 0);\n      },\n    \"day\": function(args) {\n        return fncall(\"getDay\", args, DATE, 0);\n      },\n    \"year\": function(args) {\n        return fncall(\"getFullYear\", args, DATE, 0);\n      },\n    \"month\": function(args) {\n        return fncall(\"getMonth\", args, DATE, 0);\n      },\n    \"hours\": function(args) {\n        return fncall(\"getHours\", args, DATE, 0);\n      },\n    \"minutes\": function(args) {\n        return fncall(\"getMinutes\", args, DATE, 0);\n      },\n    \"seconds\": function(args) {\n        return fncall(\"getSeconds\", args, DATE, 0);\n      },\n    \"milliseconds\": function(args) {\n        return fncall(\"getMilliseconds\", args, DATE, 0);\n      },\n    \"time\": function(args) {\n        return fncall(\"getTime\", args, DATE, 0);\n      },\n    \"timezoneoffset\": function(args) {\n        return fncall(\"getTimezoneOffset\", args, DATE, 0);\n      },\n    \"utcdate\": function(args) {\n        return fncall(\"getUTCDate\", args, DATE, 0);\n      },\n    \"utcday\": function(args) {\n        return fncall(\"getUTCDay\", args, DATE, 0);\n      },\n    \"utcyear\": function(args) {\n        return fncall(\"getUTCFullYear\", args, DATE, 0);\n      },\n    \"utcmonth\": function(args) {\n        return fncall(\"getUTCMonth\", args, DATE, 0);\n      },\n    \"utchours\": function(args) {\n        return fncall(\"getUTCHours\", args, DATE, 0);\n      },\n    \"utcminutes\": function(args) {\n        return fncall(\"getUTCMinutes\", args, DATE, 0);\n      },\n    \"utcseconds\": function(args) {\n        return fncall(\"getUTCSeconds\", args, DATE, 0);\n      },\n    \"utcmilliseconds\": function(args) {\n        return fncall(\"getUTCMilliseconds\", args, DATE, 0);\n      },\n\n    // shared sequence functions\n    \"length\": function(args) {\n        return fncall(\"length\", args, null, -1);\n      },\n    \"indexof\": function(args) {\n        return fncall(\"indexOf\", args, null);\n      },\n    \"lastindexof\": function(args) {\n        return fncall(\"lastIndexOf\", args, null);\n      },\n\n    // STRING functions\n    \"parseFloat\": \"parseFloat\",\n    \"parseInt\": \"parseInt\",\n    \"upper\": function(args) {\n        return fncall(\"toUpperCase\", args, STRING, 0);\n      },\n    \"lower\": function(args) {\n        return fncall(\"toLowerCase\", args, STRING, 0);\n      },\n    \"slice\": function(args) {\n        return fncall(\"slice\", args, STRING);\n      },\n    \"substring\": function(args) {\n        return fncall(\"substring\", args, STRING);\n      },\n\n    // REGEXP functions\n    \"test\": function(args) {\n        return fncall(\"test\", args, REGEXP);\n      },\n    \n    // Control Flow functions\n    \"if\": function(args) {\n        if (args.length < 3)\n          throw new Error(\"Missing arguments to if function.\");\n        if (args.length > 3)\n        throw new Error(\"Too many arguments to if function.\");\n        var a = args.map(codegen);\n        return a[0]+\"?\"+a[1]+\":\"+a[2];\n      }\n  };\n};","var parser = require('./parser'),\n    codegen = require('./codegen');\n    \nmodule.exports = {\n  parse: function(input, opt) { return parser.parse(\"(\"+input+\")\", opt); },\n  code: function(opt) { return codegen(opt); }\n};\n","/*\n  The following expression parser is based on Esprima (http://esprima.org/).\n  Original header comment and license for Esprima is included here:\n\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\nmodule.exports = (function() {\n  'use strict';\n\n  var Token,\n      TokenName,\n      Syntax,\n      PropertyKind,\n      Messages,\n      Regex,\n      source,\n      strict,\n      index,\n      lineNumber,\n      lineStart,\n      length,\n      lookahead,\n      state,\n      extra;\n\n  Token = {\n      BooleanLiteral: 1,\n      EOF: 2,\n      Identifier: 3,\n      Keyword: 4,\n      NullLiteral: 5,\n      NumericLiteral: 6,\n      Punctuator: 7,\n      StringLiteral: 8,\n      RegularExpression: 9\n  };\n\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  Syntax = {\n      AssignmentExpression: 'AssignmentExpression',\n      ArrayExpression: 'ArrayExpression',\n      BinaryExpression: 'BinaryExpression',\n      CallExpression: 'CallExpression',\n      ConditionalExpression: 'ConditionalExpression',\n      ExpressionStatement: 'ExpressionStatement',\n      Identifier: 'Identifier',\n      Literal: 'Literal',\n      LogicalExpression: 'LogicalExpression',\n      MemberExpression: 'MemberExpression',\n      ObjectExpression: 'ObjectExpression',\n      Program: 'Program',\n      Property: 'Property',\n      UnaryExpression: 'UnaryExpression',\n      UpdateExpression: 'UpdateExpression'\n  };\n\n  PropertyKind = {\n      Data: 1,\n      Get: 2,\n      Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n      UnexpectedToken:  'Unexpected token %0',\n      UnexpectedNumber:  'Unexpected number',\n      UnexpectedString:  'Unexpected string',\n      UnexpectedIdentifier:  'Unexpected identifier',\n      UnexpectedReserved:  'Unexpected reserved word',\n      UnexpectedEOS:  'Unexpected end of input',\n      NewlineAfterThrow:  'Illegal newline after throw',\n      InvalidRegExp: 'Invalid regular expression',\n      UnterminatedRegExp:  'Invalid regular expression: missing /',\n      InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n      InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n      MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n      NoCatchOrFinally:  'Missing catch or finally after try',\n      UnknownLabel: 'Undefined label \\'%0\\'',\n      Redeclaration: '%0 \\'%1\\' has already been declared',\n      IllegalContinue: 'Illegal continue statement',\n      IllegalBreak: 'Illegal break statement',\n      IllegalReturn: 'Illegal return statement',\n      StrictModeWith:  'Strict mode code may not include a with statement',\n      StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n      StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n      StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n      StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n      StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n      StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n      StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n      StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n      AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n      AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n      StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n      StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n      StrictReservedWord:  'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n      NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n      NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n      if (!condition) {\n          throw new Error('ASSERT: ' + message);\n      }\n  }\n\n  function isDecimalDigit(ch) {\n      return (ch >= 0x30 && ch <= 0x39);   // 0..9\n  }\n\n  function isHexDigit(ch) {\n      return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n\n  function isOctalDigit(ch) {\n      return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n      return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n          (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n      return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n  }\n\n  function isIdentifierPart(ch) {\n      return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n          (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n          (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n          (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n          (ch === 0x5C) ||                      // \\ (backslash)\n          ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n      switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  function isStrictModeReservedWord(id) {\n      switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n          return true;\n      default:\n          return false;\n      }\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n      if (strict && isStrictModeReservedWord(id)) {\n          return true;\n      }\n\n      // 'const' is specialized as Keyword in V8.\n      // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n      // Some others are from future reserved words.\n\n      switch (id.length) {\n      case 2:\n          return (id === 'if') || (id === 'in') || (id === 'do');\n      case 3:\n          return (id === 'var') || (id === 'for') || (id === 'new') ||\n              (id === 'try') || (id === 'let');\n      case 4:\n          return (id === 'this') || (id === 'else') || (id === 'case') ||\n              (id === 'void') || (id === 'with') || (id === 'enum');\n      case 5:\n          return (id === 'while') || (id === 'break') || (id === 'catch') ||\n              (id === 'throw') || (id === 'const') || (id === 'yield') ||\n              (id === 'class') || (id === 'super');\n      case 6:\n          return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n              (id === 'switch') || (id === 'export') || (id === 'import');\n      case 7:\n          return (id === 'default') || (id === 'finally') || (id === 'extends');\n      case 8:\n          return (id === 'function') || (id === 'continue') || (id === 'debugger');\n      case 10:\n          return (id === 'instanceof');\n      default:\n          return false;\n      }\n  }\n\n  function skipComment() {\n      var ch, start;\n\n      start = (index === 0);\n      while (index < length) {\n          ch = source.charCodeAt(index);\n\n          if (isWhiteSpace(ch)) {\n              ++index;\n          } else if (isLineTerminator(ch)) {\n              ++index;\n              if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                  ++index;\n              }\n              ++lineNumber;\n              lineStart = index;\n              start = true;\n          } else {\n              break;\n          }\n      }\n  }\n\n  function scanHexEscape(prefix) {\n      var i, len, ch, code = 0;\n\n      len = (prefix === 'u') ? 4 : 2;\n      for (i = 0; i < len; ++i) {\n          if (index < length && isHexDigit(source[index])) {\n              ch = source[index++];\n              code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n          } else {\n              return '';\n          }\n      }\n      return String.fromCharCode(code);\n  }\n\n  function scanUnicodeCodePointEscape() {\n      var ch, code, cu1, cu2;\n\n      ch = source[index];\n      code = 0;\n\n      // At least, one hex digit is required.\n      if (ch === '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      while (index < length) {\n          ch = source[index++];\n          if (!isHexDigit(ch)) {\n              break;\n          }\n          code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      }\n\n      if (code > 0x10FFFF || ch !== '}') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      // UTF-16 Encoding\n      if (code <= 0xFFFF) {\n          return String.fromCharCode(code);\n      }\n      cu1 = ((code - 0x10000) >> 10) + 0xD800;\n      cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n      return String.fromCharCode(cu1, cu2);\n  }\n\n  function getEscapedIdentifier() {\n      var ch, id;\n\n      ch = source.charCodeAt(index++);\n      id = String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n          if (source.charCodeAt(index) !== 0x75) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          ++index;\n          ch = scanHexEscape('u');\n          if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n          id = ch;\n      }\n\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (!isIdentifierPart(ch)) {\n              break;\n          }\n          ++index;\n          id += String.fromCharCode(ch);\n\n          // '\\u' (U+005C, U+0075) denotes an escaped character.\n          if (ch === 0x5C) {\n              id = id.substr(0, id.length - 1);\n              if (source.charCodeAt(index) !== 0x75) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              ++index;\n              ch = scanHexEscape('u');\n              if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n              id += ch;\n          }\n      }\n\n      return id;\n  }\n\n  function getIdentifier() {\n      var start, ch;\n\n      start = index++;\n      while (index < length) {\n          ch = source.charCodeAt(index);\n          if (ch === 0x5C) {\n              // Blackslash (U+005C) marks Unicode escape sequence.\n              index = start;\n              return getEscapedIdentifier();\n          }\n          if (isIdentifierPart(ch)) {\n              ++index;\n          } else {\n              break;\n          }\n      }\n\n      return source.slice(start, index);\n  }\n\n  function scanIdentifier() {\n      var start, id, type;\n\n      start = index;\n\n      // Backslash (U+005C) starts an escaped character.\n      id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n      // There is no keyword or literal with only one character.\n      // Thus, it must be an identifier.\n      if (id.length === 1) {\n          type = Token.Identifier;\n      } else if (isKeyword(id)) {\n          type = Token.Keyword;\n      } else if (id === 'null') {\n          type = Token.NullLiteral;\n      } else if (id === 'true' || id === 'false') {\n          type = Token.BooleanLiteral;\n      } else {\n          type = Token.Identifier;\n      }\n\n      return {\n          type: type,\n          value: id,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n      var start = index,\n          code = source.charCodeAt(index),\n          code2,\n          ch1 = source[index],\n          ch2,\n          ch3,\n          ch4;\n\n      switch (code) {\n\n      // Check for most common single-character punctuators.\n      case 0x2E:  // . dot\n      case 0x28:  // ( open bracket\n      case 0x29:  // ) close bracket\n      case 0x3B:  // ; semicolon\n      case 0x2C:  // , comma\n      case 0x7B:  // { open curly brace\n      case 0x7D:  // } close curly brace\n      case 0x5B:  // [\n      case 0x5D:  // ]\n      case 0x3A:  // :\n      case 0x3F:  // ?\n      case 0x7E:  // ~\n          ++index;\n          if (extra.tokenize) {\n              if (code === 0x28) {\n                  extra.openParenToken = extra.tokens.length;\n              } else if (code === 0x7B) {\n                  extra.openCurlyToken = extra.tokens.length;\n              }\n          }\n          return {\n              type: Token.Punctuator,\n              value: String.fromCharCode(code),\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n\n      default:\n          code2 = source.charCodeAt(index + 1);\n\n          // '=' (U+003D) marks an assignment or comparison operator.\n          if (code2 === 0x3D) {\n              switch (code) {\n              case 0x2B:  // +\n              case 0x2D:  // -\n              case 0x2F:  // /\n              case 0x3C:  // <\n              case 0x3E:  // >\n              case 0x5E:  // ^\n              case 0x7C:  // |\n              case 0x25:  // %\n              case 0x26:  // &\n              case 0x2A:  // *\n                  index += 2;\n                  return {\n                      type: Token.Punctuator,\n                      value: String.fromCharCode(code) + String.fromCharCode(code2),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n\n              case 0x21: // !\n              case 0x3D: // =\n                  index += 2;\n\n                  // !== and ===\n                  if (source.charCodeAt(index) === 0x3D) {\n                      ++index;\n                  }\n                  return {\n                      type: Token.Punctuator,\n                      value: source.slice(start, index),\n                      lineNumber: lineNumber,\n                      lineStart: lineStart,\n                      start: start,\n                      end: index\n                  };\n              }\n          }\n      }\n\n      // 4-character punctuator: >>>=\n\n      ch4 = source.substr(index, 4);\n\n      if (ch4 === '>>>=') {\n          index += 4;\n          return {\n              type: Token.Punctuator,\n              value: ch4,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 3-character punctuators: === !== >>> <<= >>=\n\n      ch3 = ch4.substr(0, 3);\n\n      if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n          index += 3;\n          return {\n              type: Token.Punctuator,\n              value: ch3,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // Other 2-character punctuators: ++ -- << >> && ||\n      ch2 = ch3.substr(0, 2);\n\n      if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n          index += 2;\n          return {\n              type: Token.Punctuator,\n              value: ch2,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      // 1-character punctuators: < > = ! + - * % & | ^ /\n\n      if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n          ++index;\n          return {\n              type: Token.Punctuator,\n              value: ch1,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n      var number = '';\n\n      while (index < length) {\n          if (!isHexDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (number.length === 0) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt('0x' + number, 16),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanOctalLiteral(start) {\n      var number = '0' + source[index++];\n      while (index < length) {\n          if (!isOctalDigit(source[index])) {\n              break;\n          }\n          number += source[index++];\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseInt(number, 8),\n          octal: true,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function scanNumericLiteral() {\n      var number, start, ch;\n\n      ch = source[index];\n      assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n          'Numeric literal must start with a decimal digit or a decimal point');\n\n      start = index;\n      number = '';\n      if (ch !== '.') {\n          number = source[index++];\n          ch = source[index];\n\n          // Hex number starts with '0x'.\n          // Octal number starts with '0'.\n          if (number === '0') {\n              if (ch === 'x' || ch === 'X') {\n                  ++index;\n                  return scanHexLiteral(start);\n              }\n              if (isOctalDigit(ch)) {\n                  return scanOctalLiteral(start);\n              }\n\n              // decimal number starts with '0' such as '09' is illegal.\n              if (ch && isDecimalDigit(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          }\n\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === '.') {\n          number += source[index++];\n          while (isDecimalDigit(source.charCodeAt(index))) {\n              number += source[index++];\n          }\n          ch = source[index];\n      }\n\n      if (ch === 'e' || ch === 'E') {\n          number += source[index++];\n\n          ch = source[index];\n          if (ch === '+' || ch === '-') {\n              number += source[index++];\n          }\n          if (isDecimalDigit(source.charCodeAt(index))) {\n              while (isDecimalDigit(source.charCodeAt(index))) {\n                  number += source[index++];\n              }\n          } else {\n              throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n          }\n      }\n\n      if (isIdentifierStart(source.charCodeAt(index))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.NumericLiteral,\n          value: parseFloat(number),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n      var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n      startLineNumber = lineNumber;\n      startLineStart = lineStart;\n\n      quote = source[index];\n      assert((quote === '\\'' || quote === '\"'),\n          'String literal must starts with a quote');\n\n      start = index;\n      ++index;\n\n      while (index < length) {\n          ch = source[index++];\n\n          if (ch === quote) {\n              quote = '';\n              break;\n          } else if (ch === '\\\\') {\n              ch = source[index++];\n              if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                  switch (ch) {\n                  case 'u':\n                  case 'x':\n                      if (source[index] === '{') {\n                          ++index;\n                          str += scanUnicodeCodePointEscape();\n                      } else {\n                          restore = index;\n                          unescaped = scanHexEscape(ch);\n                          if (unescaped) {\n                              str += unescaped;\n                          } else {\n                              index = restore;\n                              str += ch;\n                          }\n                      }\n                      break;\n                  case 'n':\n                      str += '\\n';\n                      break;\n                  case 'r':\n                      str += '\\r';\n                      break;\n                  case 't':\n                      str += '\\t';\n                      break;\n                  case 'b':\n                      str += '\\b';\n                      break;\n                  case 'f':\n                      str += '\\f';\n                      break;\n                  case 'v':\n                      str += '\\x0B';\n                      break;\n\n                  default:\n                      if (isOctalDigit(ch)) {\n                          code = '01234567'.indexOf(ch);\n\n                          // \\0 is not octal escape sequence\n                          if (code !== 0) {\n                              octal = true;\n                          }\n\n                          if (index < length && isOctalDigit(source[index])) {\n                              octal = true;\n                              code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                              // 3 digits are only allowed when string starts\n                              // with 0, 1, 2, 3\n                              if ('0123'.indexOf(ch) >= 0 &&\n                                      index < length &&\n                                      isOctalDigit(source[index])) {\n                                  code = code * 8 + '01234567'.indexOf(source[index++]);\n                              }\n                          }\n                          str += String.fromCharCode(code);\n                      } else {\n                          str += ch;\n                      }\n                      break;\n                  }\n              } else {\n                  ++lineNumber;\n                  if (ch ===  '\\r' && source[index] === '\\n') {\n                      ++index;\n                  }\n                  lineStart = index;\n              }\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              break;\n          } else {\n              str += ch;\n          }\n      }\n\n      if (quote !== '') {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n\n      return {\n          type: Token.StringLiteral,\n          value: str,\n          octal: octal,\n          startLineNumber: startLineNumber,\n          startLineStart: startLineStart,\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n      };\n  }\n\n  function testRegExp(pattern, flags) {\n      var tmp = pattern,\n          value;\n\n      if (flags.indexOf('u') >= 0) {\n          // Replace each astral symbol and every Unicode code point\n          // escape sequence with a single ASCII symbol to avoid throwing on\n          // regular expressions that are only valid in combination with the\n          // `/u` flag.\n          // Note: replacing with the ASCII symbol `x` might cause false\n          // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n          // perfectly valid pattern that is equivalent to `[a-b]`, but it\n          // would be replaced by `[x-b]` which throws an error.\n          tmp = tmp\n              .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                  if (parseInt($1, 16) <= 0x10FFFF) {\n                      return 'x';\n                  }\n                  throwError({}, Messages.InvalidRegExp);\n              })\n              .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n      }\n\n      // First, detect invalid regular expressions.\n      try {\n          value = new RegExp(tmp);\n      } catch (e) {\n          throwError({}, Messages.InvalidRegExp);\n      }\n\n      // Return a regular expression object for this pattern-flag pair, or\n      // `null` in case the current environment doesn't support the flags it\n      // uses.\n      try {\n          return new RegExp(pattern, flags);\n      } catch (exception) {\n          return null;\n      }\n  }\n\n  function scanRegExpBody() {\n      var ch, str, classMarker, terminated, body;\n\n      ch = source[index];\n      assert(ch === '/', 'Regular expression literal must start with a slash');\n      str = source[index++];\n\n      classMarker = false;\n      terminated = false;\n      while (index < length) {\n          ch = source[index++];\n          str += ch;\n          if (ch === '\\\\') {\n              ch = source[index++];\n              // ECMA-262 7.8.5\n              if (isLineTerminator(ch.charCodeAt(0))) {\n                  throwError({}, Messages.UnterminatedRegExp);\n              }\n              str += ch;\n          } else if (isLineTerminator(ch.charCodeAt(0))) {\n              throwError({}, Messages.UnterminatedRegExp);\n          } else if (classMarker) {\n              if (ch === ']') {\n                  classMarker = false;\n              }\n          } else {\n              if (ch === '/') {\n                  terminated = true;\n                  break;\n              } else if (ch === '[') {\n                  classMarker = true;\n              }\n          }\n      }\n\n      if (!terminated) {\n          throwError({}, Messages.UnterminatedRegExp);\n      }\n\n      // Exclude leading and trailing slash.\n      body = str.substr(1, str.length - 2);\n      return {\n          value: body,\n          literal: str\n      };\n  }\n\n  function scanRegExpFlags() {\n      var ch, str, flags, restore;\n\n      str = '';\n      flags = '';\n      while (index < length) {\n          ch = source[index];\n          if (!isIdentifierPart(ch.charCodeAt(0))) {\n              break;\n          }\n\n          ++index;\n          if (ch === '\\\\' && index < length) {\n              ch = source[index];\n              if (ch === 'u') {\n                  ++index;\n                  restore = index;\n                  ch = scanHexEscape('u');\n                  if (ch) {\n                      flags += ch;\n                      for (str += '\\\\u'; restore < index; ++restore) {\n                          str += source[restore];\n                      }\n                  } else {\n                      index = restore;\n                      flags += 'u';\n                      str += '\\\\u';\n                  }\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              } else {\n                  str += '\\\\';\n                  throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n              }\n          } else {\n              flags += ch;\n              str += ch;\n          }\n      }\n\n      return {\n          value: flags,\n          literal: str\n      };\n  }\n\n  function scanRegExp() {\n      var start, body, flags, value;\n\n      lookahead = null;\n      skipComment();\n      start = index;\n\n      body = scanRegExpBody();\n      flags = scanRegExpFlags();\n      value = testRegExp(body.value, flags.value);\n\n      if (extra.tokenize) {\n          return {\n              type: Token.RegularExpression,\n              value: value,\n              regex: {\n                  pattern: body.value,\n                  flags: flags.value\n              },\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: start,\n              end: index\n          };\n      }\n\n      return {\n          literal: body.literal + flags.literal,\n          value: value,\n          regex: {\n              pattern: body.value,\n              flags: flags.value\n          },\n          start: start,\n          end: index\n      };\n  }\n\n  function collectRegex() {\n      var pos, loc, regex, token;\n\n      skipComment();\n\n      pos = index;\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      regex = scanRegExp();\n\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (!extra.tokenize) {\n          // Pop the previous token, which is likely '/' or '/='\n          if (extra.tokens.length > 0) {\n              token = extra.tokens[extra.tokens.length - 1];\n              if (token.range[0] === pos && token.type === 'Punctuator') {\n                  if (token.value === '/' || token.value === '/=') {\n                      extra.tokens.pop();\n                  }\n              }\n          }\n\n          extra.tokens.push({\n              type: 'RegularExpression',\n              value: regex.literal,\n              regex: regex.regex,\n              range: [pos, index],\n              loc: loc\n          });\n      }\n\n      return regex;\n  }\n\n  function isIdentifierName(token) {\n      return token.type === Token.Identifier ||\n          token.type === Token.Keyword ||\n          token.type === Token.BooleanLiteral ||\n          token.type === Token.NullLiteral;\n  }\n\n  function advanceSlash() {\n      var prevToken,\n          checkToken;\n      // Using the following algorithm:\n      // https://github.com/mozilla/sweet.js/wiki/design\n      prevToken = extra.tokens[extra.tokens.length - 1];\n      if (!prevToken) {\n          // Nothing before that: it cannot be a division.\n          return collectRegex();\n      }\n      if (prevToken.type === 'Punctuator') {\n          if (prevToken.value === ']') {\n              return scanPunctuator();\n          }\n          if (prevToken.value === ')') {\n              checkToken = extra.tokens[extra.openParenToken - 1];\n              if (checkToken &&\n                      checkToken.type === 'Keyword' &&\n                      (checkToken.value === 'if' ||\n                       checkToken.value === 'while' ||\n                       checkToken.value === 'for' ||\n                       checkToken.value === 'with')) {\n                  return collectRegex();\n              }\n              return scanPunctuator();\n          }\n          if (prevToken.value === '}') {\n              // Dividing a function by anything makes little sense,\n              // but we have to check for that.\n              if (extra.tokens[extra.openCurlyToken - 3] &&\n                      extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                  // Anonymous function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 4];\n                  if (!checkToken) {\n                      return scanPunctuator();\n                  }\n              } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                      extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                  // Named function.\n                  checkToken = extra.tokens[extra.openCurlyToken - 5];\n                  if (!checkToken) {\n                      return collectRegex();\n                  }\n              } else {\n                  return scanPunctuator();\n              }\n              return scanPunctuator();\n          }\n          return collectRegex();\n      }\n      if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n          return collectRegex();\n      }\n      return scanPunctuator();\n  }\n\n  function advance() {\n      var ch;\n\n      skipComment();\n\n      if (index >= length) {\n          return {\n              type: Token.EOF,\n              lineNumber: lineNumber,\n              lineStart: lineStart,\n              start: index,\n              end: index\n          };\n      }\n\n      ch = source.charCodeAt(index);\n\n      if (isIdentifierStart(ch)) {\n          return scanIdentifier();\n      }\n\n      // Very common: ( and ) and ;\n      if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n          return scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (ch === 0x27 || ch === 0x22) {\n          return scanStringLiteral();\n      }\n\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (ch === 0x2E) {\n          if (isDecimalDigit(source.charCodeAt(index + 1))) {\n              return scanNumericLiteral();\n          }\n          return scanPunctuator();\n      }\n\n      if (isDecimalDigit(ch)) {\n          return scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      if (extra.tokenize && ch === 0x2F) {\n          return advanceSlash();\n      }\n\n      return scanPunctuator();\n  }\n\n  function collectToken() {\n      var loc, token, value, entry;\n\n      skipComment();\n      loc = {\n          start: {\n              line: lineNumber,\n              column: index - lineStart\n          }\n      };\n\n      token = advance();\n      loc.end = {\n          line: lineNumber,\n          column: index - lineStart\n      };\n\n      if (token.type !== Token.EOF) {\n          value = source.slice(token.start, token.end);\n          entry = {\n              type: TokenName[token.type],\n              value: value,\n              range: [token.start, token.end],\n              loc: loc\n          };\n          if (token.regex) {\n              entry.regex = {\n                  pattern: token.regex.pattern,\n                  flags: token.regex.flags\n              };\n          }\n          extra.tokens.push(entry);\n      }\n\n      return token;\n  }\n\n  function lex() {\n      var token;\n\n      token = lookahead;\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n      index = token.end;\n      lineNumber = token.lineNumber;\n      lineStart = token.lineStart;\n\n      return token;\n  }\n\n  function peek() {\n      var pos, line, start;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n  }\n\n  function Position() {\n      this.line = lineNumber;\n      this.column = index - lineStart;\n  }\n\n  function SourceLocation() {\n      this.start = new Position();\n      this.end = null;\n  }\n\n  function WrappingSourceLocation(startToken) {\n      if (startToken.type === Token.StringLiteral) {\n          this.start = {\n              line: startToken.startLineNumber,\n              column: startToken.start - startToken.startLineStart\n          };\n      } else {\n          this.start = {\n              line: startToken.lineNumber,\n              column: startToken.start - startToken.lineStart\n          };\n      }\n      this.end = null;\n  }\n\n  function Node() {\n      // Skip comment.\n      index = lookahead.start;\n      if (lookahead.type === Token.StringLiteral) {\n          lineNumber = lookahead.startLineNumber;\n          lineStart = lookahead.startLineStart;\n      } else {\n          lineNumber = lookahead.lineNumber;\n          lineStart = lookahead.lineStart;\n      }\n      if (extra.range) {\n          this.range = [index, 0];\n      }\n      if (extra.loc) {\n          this.loc = new SourceLocation();\n      }\n  }\n\n  function WrappingNode(startToken) {\n      if (extra.range) {\n          this.range = [startToken.start, 0];\n      }\n      if (extra.loc) {\n          this.loc = new WrappingSourceLocation(startToken);\n      }\n  }\n\n  WrappingNode.prototype = Node.prototype = {\n\n      finish: function () {\n          if (extra.range) {\n              this.range[1] = index;\n          }\n          if (extra.loc) {\n              this.loc.end = new Position();\n              if (extra.source) {\n                  this.loc.source = extra.source;\n              }\n          }\n      },\n\n      finishArrayExpression: function (elements) {\n          this.type = Syntax.ArrayExpression;\n          this.elements = elements;\n          this.finish();\n          return this;\n      },\n\n      finishAssignmentExpression: function (operator, left, right) {\n          this.type = Syntax.AssignmentExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishBinaryExpression: function (operator, left, right) {\n          this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n          this.operator = operator;\n          this.left = left;\n          this.right = right;\n          this.finish();\n          return this;\n      },\n\n      finishCallExpression: function (callee, args) {\n          this.type = Syntax.CallExpression;\n          this.callee = callee;\n          this.arguments = args;\n          this.finish();\n          return this;\n      },\n\n      finishConditionalExpression: function (test, consequent, alternate) {\n          this.type = Syntax.ConditionalExpression;\n          this.test = test;\n          this.consequent = consequent;\n          this.alternate = alternate;\n          this.finish();\n          return this;\n      },\n\n      finishExpressionStatement: function (expression) {\n          this.type = Syntax.ExpressionStatement;\n          this.expression = expression;\n          this.finish();\n          return this;\n      },\n\n      finishIdentifier: function (name) {\n          this.type = Syntax.Identifier;\n          this.name = name;\n          this.finish();\n          return this;\n      },\n\n      finishLiteral: function (token) {\n          this.type = Syntax.Literal;\n          this.value = token.value;\n          this.raw = source.slice(token.start, token.end);\n          if (token.regex) {\n              if (this.raw == '//') {\n                this.raw = '/(?:)/';\n              }\n              this.regex = token.regex;\n          }\n          this.finish();\n          return this;\n      },\n\n      finishMemberExpression: function (accessor, object, property) {\n          this.type = Syntax.MemberExpression;\n          this.computed = accessor === '[';\n          this.object = object;\n          this.property = property;\n          this.finish();\n          return this;\n      },\n\n      finishObjectExpression: function (properties) {\n          this.type = Syntax.ObjectExpression;\n          this.properties = properties;\n          this.finish();\n          return this;\n      },\n\n      finishProgram: function (body) {\n          this.type = Syntax.Program;\n          this.body = body;\n          this.finish();\n          return this;\n      },\n\n      finishProperty: function (kind, key, value) {\n          this.type = Syntax.Property;\n          this.key = key;\n          this.value = value;\n          this.kind = kind;\n          this.finish();\n          return this;\n      },\n\n      finishUnaryExpression: function (operator, argument) {\n          this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n          this.operator = operator;\n          this.argument = argument;\n          this.prefix = true;\n          this.finish();\n          return this;\n      }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n      var pos, line, start, found;\n\n      pos = index;\n      line = lineNumber;\n      start = lineStart;\n      skipComment();\n      found = lineNumber !== line;\n      index = pos;\n      lineNumber = line;\n      lineStart = start;\n\n      return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n      var error,\n          args = Array.prototype.slice.call(arguments, 2),\n          msg = messageFormat.replace(\n              /%(\\d)/g,\n              function (whole, index) {\n                  assert(index < args.length, 'Message reference must be in range');\n                  return args[index];\n              }\n          );\n\n      if (typeof token.lineNumber === 'number') {\n          error = new Error('Line ' + token.lineNumber + ': ' + msg);\n          error.index = token.start;\n          error.lineNumber = token.lineNumber;\n          error.column = token.start - lineStart + 1;\n      } else {\n          error = new Error('Line ' + lineNumber + ': ' + msg);\n          error.index = index;\n          error.lineNumber = lineNumber;\n          error.column = index - lineStart + 1;\n      }\n\n      error.description = msg;\n      throw error;\n  }\n\n  function throwErrorTolerant() {\n      try {\n          throwError.apply(null, arguments);\n      } catch (e) {\n          if (extra.errors) {\n              extra.errors.push(e);\n          } else {\n              throw e;\n          }\n      }\n  }\n\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n      if (token.type === Token.EOF) {\n          throwError(token, Messages.UnexpectedEOS);\n      }\n\n      if (token.type === Token.NumericLiteral) {\n          throwError(token, Messages.UnexpectedNumber);\n      }\n\n      if (token.type === Token.StringLiteral) {\n          throwError(token, Messages.UnexpectedString);\n      }\n\n      if (token.type === Token.Identifier) {\n          throwError(token, Messages.UnexpectedIdentifier);\n      }\n\n      if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n              throwError(token, Messages.UnexpectedReserved);\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n              throwErrorTolerant(token, Messages.StrictReservedWord);\n              return;\n          }\n          throwError(token, Messages.UnexpectedToken, token.value);\n      }\n\n      // BooleanLiteral, NullLiteral, or Punctuator.\n      throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n      var token = lex();\n      if (token.type !== Token.Punctuator || token.value !== value) {\n          throwUnexpected(token);\n      }\n  }\n\n  /**\n   * @name expectTolerant\n   * @description Quietly expect the given token value when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @param {String} value The value we are expecting the lookahead token to have\n   * @since 2.0\n   */\n  function expectTolerant(value) {\n      if (extra.errors) {\n          var token = lookahead;\n          if (token.type !== Token.Punctuator && token.value !== value) {\n              throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          } else {\n              lex();\n          }\n      } else {\n          expect(value);\n      }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n      var token = lex();\n      if (token.type !== Token.Keyword || token.value !== keyword) {\n          throwUnexpected(token);\n      }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n      return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n      return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  function consumeSemicolon() {\n      var line;\n\n      // Catch the very common case first: immediately a semicolon (U+003B).\n      if (source.charCodeAt(index) === 0x3B || match(';')) {\n          lex();\n          return;\n      }\n\n      line = lineNumber;\n      skipComment();\n      if (lineNumber !== line) {\n          return;\n      }\n\n      if (lookahead.type !== Token.EOF && !match('}')) {\n          throwUnexpected(lookahead);\n      }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n      return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n      var elements = [], node = new Node();\n\n      expect('[');\n\n      while (!match(']')) {\n          if (match(',')) {\n              lex();\n              elements.push(null);\n          } else {\n              elements.push(parseAssignmentExpression());\n\n              if (!match(']')) {\n                  expect(',');\n              }\n          }\n      }\n\n      lex();\n\n      return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parseObjectPropertyKey() {\n      var token, node = new Node();\n\n      token = lex();\n\n      // Note: This function is called only from parseObjectProperty(), where\n      // EOF and Punctuator tokens are already filtered out.\n\n      if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n          if (strict && token.octal) {\n              throwErrorTolerant(token, Messages.StrictOctalLiteral);\n          }\n          return node.finishLiteral(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseObjectProperty() {\n      var token, key, id, value, param, node = new Node();\n\n      token = lookahead;\n\n      if (token.type === Token.Identifier) {\n          id = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', id, value);\n      }\n      if (token.type === Token.EOF || token.type === Token.Punctuator) {\n          throwUnexpected(token);\n      } else {\n          key = parseObjectPropertyKey();\n          expect(':');\n          value = parseAssignmentExpression();\n          return node.finishProperty('init', key, value);\n      }\n  }\n\n  function parseObjectInitialiser() {\n      var properties = [], token, property, name, key, kind, map = {}, toString = String, node = new Node();\n\n      expect('{');\n\n      while (!match('}')) {\n          property = parseObjectProperty();\n\n          if (property.key.type === Syntax.Identifier) {\n              name = property.key.name;\n          } else {\n              name = toString(property.key.value);\n          }\n          kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n          key = '$' + name;\n          if (Object.prototype.hasOwnProperty.call(map, key)) {\n              if (map[key] === PropertyKind.Data) {\n                  if (strict && kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                  } else if (kind !== PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  }\n              } else {\n                  if (kind === PropertyKind.Data) {\n                      throwErrorTolerant({}, Messages.AccessorDataProperty);\n                  } else if (map[key] & kind) {\n                      throwErrorTolerant({}, Messages.AccessorGetSet);\n                  }\n              }\n              map[key] |= kind;\n          } else {\n              map[key] = kind;\n          }\n\n          properties.push(property);\n\n          if (!match('}')) {\n              expectTolerant(',');\n          }\n      }\n\n      expect('}');\n\n      return node.finishObjectExpression(properties);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n      var expr;\n\n      expect('(');\n\n      ++state.parenthesisCount;\n\n      expr = parseExpression();\n\n      expect(')');\n\n      return expr;\n  }\n\n\n  // 11.1 Primary Expressions\n\n  var legalKeywords = {\"if\":1, \"this\":1};\n\n  function parsePrimaryExpression() {\n      var type, token, expr, node;\n\n      if (match('(')) {\n          return parseGroupExpression();\n      }\n\n      if (match('[')) {\n          return parseArrayInitialiser();\n      }\n\n      if (match('{')) {\n          return parseObjectInitialiser();\n      }\n\n      type = lookahead.type;\n      node = new Node();\n\n      if (type === Token.Identifier || legalKeywords[lookahead.value]) {\n          expr = node.finishIdentifier(lex().value);\n      } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n          if (strict && lookahead.octal) {\n              throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n          }\n          expr = node.finishLiteral(lex());\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\");\n      } else if (type === Token.BooleanLiteral) {\n          token = lex();\n          token.value = (token.value === 'true');\n          expr = node.finishLiteral(token);\n      } else if (type === Token.NullLiteral) {\n          token = lex();\n          token.value = null;\n          expr = node.finishLiteral(token);\n      } else if (match('/') || match('/=')) {\n          if (typeof extra.tokens !== 'undefined') {\n              expr = node.finishLiteral(collectRegex());\n          } else {\n              expr = node.finishLiteral(scanRegExp());\n          }\n          peek();\n      } else {\n          throwUnexpected(lex());\n      }\n\n      return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n      var args = [];\n\n      expect('(');\n\n      if (!match(')')) {\n          while (index < length) {\n              args.push(parseAssignmentExpression());\n              if (match(')')) {\n                  break;\n              }\n              expectTolerant(',');\n          }\n      }\n\n      expect(')');\n\n      return args;\n  }\n\n  function parseNonComputedProperty() {\n      var token, node = new Node();\n\n      token = lex();\n\n      if (!isIdentifierName(token)) {\n          throwUnexpected(token);\n      }\n\n      return node.finishIdentifier(token.value);\n  }\n\n  function parseNonComputedMember() {\n      expect('.');\n\n      return parseNonComputedProperty();\n  }\n\n  function parseComputedMember() {\n      var expr;\n\n      expect('[');\n\n      expr = parseExpression();\n\n      expect(']');\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpressionAllowCall() {\n      var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n      startToken = lookahead;\n      state.allowIn = true;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else if (match('(')) {\n              args = parseArguments();\n              expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n          } else if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else {\n              break;\n          }\n      }\n      state.allowIn = previousAllowIn;\n\n      return expr;\n  }\n\n  function parseLeftHandSideExpression() {\n      var expr, property, startToken;\n      assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n      startToken = lookahead;\n      expr = parsePrimaryExpression();\n\n      for (;;) {\n          if (match('[')) {\n              property = parseComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n          } else if (match('.')) {\n              property = parseNonComputedMember();\n              expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n          } else {\n              break;\n          }\n      }\n      return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n      var expr, token, startToken = lookahead;\n\n      expr = parseLeftHandSideExpressionAllowCall();\n\n      if (lookahead.type === Token.Punctuator) {\n          if ((match('++') || match('--')) && !peekLineTerminator()) {\n              throw new Error(\"Disabled.\");\n          }\n      }\n\n      return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n      var token, expr, startToken;\n\n      if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n          expr = parsePostfixExpression();\n      } else if (match('++') || match('--')) {\n          throw new Error(\"Disabled.\");\n      } else if (match('+') || match('-') || match('~') || match('!')) {\n          startToken = lookahead;\n          token = lex();\n          expr = parseUnaryExpression();\n          expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n          throw new Error(\"Disabled.\");\n      } else {\n          expr = parsePostfixExpression();\n      }\n\n      return expr;\n  }\n\n  function binaryPrecedence(token, allowIn) {\n      var prec = 0;\n\n      if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n          return 0;\n      }\n\n      switch (token.value) {\n      case '||':\n          prec = 1;\n          break;\n\n      case '&&':\n          prec = 2;\n          break;\n\n      case '|':\n          prec = 3;\n          break;\n\n      case '^':\n          prec = 4;\n          break;\n\n      case '&':\n          prec = 5;\n          break;\n\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n          prec = 6;\n          break;\n\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n          prec = 7;\n          break;\n\n      case 'in':\n          prec = allowIn ? 7 : 0;\n          break;\n\n      case '<<':\n      case '>>':\n      case '>>>':\n          prec = 8;\n          break;\n\n      case '+':\n      case '-':\n          prec = 9;\n          break;\n\n      case '*':\n      case '/':\n      case '%':\n          prec = 11;\n          break;\n\n      default:\n          break;\n      }\n\n      return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n      var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n      marker = lookahead;\n      left = parseUnaryExpression();\n\n      token = lookahead;\n      prec = binaryPrecedence(token, state.allowIn);\n      if (prec === 0) {\n          return left;\n      }\n      token.prec = prec;\n      lex();\n\n      markers = [marker, lookahead];\n      right = parseUnaryExpression();\n\n      stack = [left, token, right];\n\n      while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n          // Reduce: make a binary expression from the three topmost entries.\n          while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n              right = stack.pop();\n              operator = stack.pop().value;\n              left = stack.pop();\n              markers.pop();\n              expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n              stack.push(expr);\n          }\n\n          // Shift.\n          token = lex();\n          token.prec = prec;\n          stack.push(token);\n          markers.push(lookahead);\n          expr = parseUnaryExpression();\n          stack.push(expr);\n      }\n\n      // Final reduce to clean-up the stack.\n      i = stack.length - 1;\n      expr = stack[i];\n      markers.pop();\n      while (i > 1) {\n          expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n          i -= 2;\n      }\n\n      return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n      var expr, previousAllowIn, consequent, alternate, startToken;\n\n      startToken = lookahead;\n\n      expr = parseBinaryExpression();\n\n      if (match('?')) {\n          lex();\n          previousAllowIn = state.allowIn;\n          state.allowIn = true;\n          consequent = parseAssignmentExpression();\n          state.allowIn = previousAllowIn;\n          expect(':');\n          alternate = parseAssignmentExpression();\n\n          expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      }\n\n      return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n      var oldParenthesisCount, token, expr, right, list, startToken;\n\n      oldParenthesisCount = state.parenthesisCount;\n\n      startToken = lookahead;\n      token = lookahead;\n\n      expr = parseConditionalExpression();\n\n      return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n      var expr, startToken = lookahead, expressions;\n\n      expr = parseAssignmentExpression();\n\n      if (match(',')) {\n          throw new Error(\"Disabled.\"); // no sequence expressions\n      }\n\n      return expr;\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n      var expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n      var type = lookahead.type,\n          expr,\n          labeledBody,\n          key,\n          node;\n\n      if (type === Token.EOF) {\n          throwUnexpected(lookahead);\n      }\n\n      if (type === Token.Punctuator && lookahead.value === '{') {\n          throw new Error(\"Disabled.\"); // block statement\n      }\n\n      node = new Node();\n\n      if (type === Token.Punctuator) {\n          switch (lookahead.value) {\n          case ';':\n              throw new Error(\"Disabled.\"); // empty statement\n          case '(':\n              return parseExpressionStatement(node);\n          default:\n              break;\n          }\n      } else if (type === Token.Keyword) {\n          throw new Error(\"Disabled.\"); // keyword\n      }\n\n      expr = parseExpression();\n      consumeSemicolon();\n      return node.finishExpressionStatement(expr);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n      if (lookahead.type === Token.Keyword) {\n          switch (lookahead.value) {\n          case 'const':\n          case 'let':\n              throw new Error(\"Disabled.\");\n          case 'function':\n              throw new Error(\"Disabled.\");\n          default:\n              return parseStatement();\n          }\n      }\n\n      if (lookahead.type !== Token.EOF) {\n          return parseStatement();\n      }\n  }\n\n  function parseSourceElements() {\n      var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n      while (index < length) {\n          token = lookahead;\n          if (token.type !== Token.StringLiteral) {\n              break;\n          }\n\n          sourceElement = parseSourceElement();\n          sourceElements.push(sourceElement);\n          if (sourceElement.expression.type !== Syntax.Literal) {\n              // this is not directive\n              break;\n          }\n          directive = source.slice(token.start + 1, token.end - 1);\n          if (directive === 'use strict') {\n              strict = true;\n              if (firstRestricted) {\n                  throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n              }\n          } else {\n              if (!firstRestricted && token.octal) {\n                  firstRestricted = token;\n              }\n          }\n      }\n\n      while (index < length) {\n          sourceElement = parseSourceElement();\n          if (typeof sourceElement === 'undefined') {\n              break;\n          }\n          sourceElements.push(sourceElement);\n      }\n      return sourceElements;\n  }\n\n  function parseProgram() {\n      var body, node;\n\n      skipComment();\n      peek();\n      node = new Node();\n      strict = true; // assume strict\n\n      body = parseSourceElements();\n      return node.finishProgram(body);\n  }\n\n  function filterTokenLocation() {\n      var i, entry, token, tokens = [];\n\n      for (i = 0; i < extra.tokens.length; ++i) {\n          entry = extra.tokens[i];\n          token = {\n              type: entry.type,\n              value: entry.value\n          };\n          if (entry.regex) {\n              token.regex = {\n                  pattern: entry.regex.pattern,\n                  flags: entry.regex.flags\n              };\n          }\n          if (extra.range) {\n              token.range = entry.range;\n          }\n          if (extra.loc) {\n              token.loc = entry.loc;\n          }\n          tokens.push(token);\n      }\n\n      extra.tokens = tokens;\n  }\n\n  function tokenize(code, options) {\n      var toString,\n          tokens;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n\n      // Options matching.\n      options = options || {};\n\n      // Of course we collect tokens here.\n      options.tokens = true;\n      extra.tokens = [];\n      extra.tokenize = true;\n      // The following two fields are necessary to compute the Regex tokens.\n      extra.openParenToken = -1;\n      extra.openCurlyToken = -1;\n\n      extra.range = (typeof options.range === 'boolean') && options.range;\n      extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n          extra.errors = [];\n      }\n\n      try {\n          peek();\n          if (lookahead.type === Token.EOF) {\n              return extra.tokens;\n          }\n\n          lex();\n          while (lookahead.type !== Token.EOF) {\n              try {\n                  lex();\n              } catch (lexError) {\n                  if (extra.errors) {\n                      extra.errors.push(lexError);\n                      // We have to break on the first error\n                      // to avoid infinite loops.\n                      break;\n                  } else {\n                      throw lexError;\n                  }\n              }\n          }\n\n          filterTokenLocation();\n          tokens = extra.tokens;\n          if (typeof extra.errors !== 'undefined') {\n              tokens.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n      return tokens;\n  }\n\n  function parse(code, options) {\n      var program, toString;\n\n      toString = String;\n      if (typeof code !== 'string' && !(code instanceof String)) {\n          code = toString(code);\n      }\n\n      source = code;\n      index = 0;\n      lineNumber = (source.length > 0) ? 1 : 0;\n      lineStart = 0;\n      length = source.length;\n      lookahead = null;\n      state = {\n          allowIn: true,\n          labelSet: {},\n          parenthesisCount: 0,\n          inFunctionBody: false,\n          inIteration: false,\n          inSwitch: false,\n          lastCommentStart: -1\n      };\n\n      extra = {};\n      if (typeof options !== 'undefined') {\n          extra.range = (typeof options.range === 'boolean') && options.range;\n          extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n          if (extra.loc && options.source !== null && options.source !== undefined) {\n              extra.source = toString(options.source);\n          }\n\n          if (typeof options.tokens === 'boolean' && options.tokens) {\n              extra.tokens = [];\n          }\n          if (typeof options.tolerant === 'boolean' && options.tolerant) {\n              extra.errors = [];\n          }\n      }\n\n      try {\n          program = parseProgram();\n          if (typeof extra.tokens !== 'undefined') {\n              filterTokenLocation();\n              program.tokens = extra.tokens;\n          }\n          if (typeof extra.errors !== 'undefined') {\n              program.errors = extra.errors;\n          }\n      } catch (e) {\n          throw e;\n      } finally {\n          extra = {};\n      }\n\n      return program;\n  }\n\n  return {\n    tokenize: tokenize,\n    parse: parse\n  };\n\n})();","var dl = require('datalib'),\n    axs = require('../scene/axis'),\n    config = require('../util/config');\n\nvar ORIENT = {\n  \"x\":      \"bottom\",\n  \"y\":      \"left\",\n  \"top\":    \"top\",\n  \"bottom\": \"bottom\",\n  \"left\":   \"left\",\n  \"right\":  \"right\"\n};\n\nfunction axes(model, spec, axes, group) {\n  (spec || []).forEach(function(def, index) {\n    axes[index] = axes[index] || axs(model);\n    axis(def, index, axes[index], group);\n  });\n};\n\nfunction axis(def, index, axis, group) {\n  // axis scale\n  if (def.scale !== undefined) {\n    axis.scale(group.scale(def.scale));\n  }\n\n  // axis orientation\n  axis.orient(def.orient || ORIENT[def.type]);\n  // axis offset\n  axis.offset(def.offset || 0);\n  // axis layer\n  axis.layer(def.layer || \"front\");\n  // axis grid lines\n  axis.grid(def.grid || false);\n  // axis title\n  axis.title(def.title || null);\n  // axis title offset\n  axis.titleOffset(def.titleOffset != null\n    ? def.titleOffset : config.axis.titleOffset);\n  // axis values\n  axis.tickValues(def.values || null);\n  // axis label formatting\n  axis.tickFormat(def.format || null);\n  // axis tick subdivision\n  axis.tickSubdivide(def.subdivide || 0);\n  // axis tick padding\n  axis.tickPadding(def.tickPadding || config.axis.padding);\n\n  // axis tick size(s)\n  var size = [];\n  if (def.tickSize !== undefined) {\n    for (var i=0; i<3; ++i) size.push(def.tickSize);\n  } else {\n    var ts = config.axis.tickSize;\n    size = [ts, ts, ts];\n  }\n  if (def.tickSizeMajor != null) size[0] = def.tickSizeMajor;\n  if (def.tickSizeMinor != null) size[1] = def.tickSizeMinor;\n  if (def.tickSizeEnd   != null) size[2] = def.tickSizeEnd;\n  if (size.length) {\n    axis.tickSize.apply(axis, size);\n  }\n\n  // tick arguments\n  if (def.ticks != null) {\n    var ticks = dl.isArray(def.ticks) ? def.ticks : [def.ticks];\n    axis.ticks.apply(axis, ticks);\n  } else {\n    axis.ticks(config.axis.ticks);\n  }\n\n  // style properties\n  var p = def.properties;\n  if (p && p.ticks) {\n    axis.majorTickProperties(p.majorTicks\n      ? dl.extend({}, p.ticks, p.majorTicks) : p.ticks);\n    axis.minorTickProperties(p.minorTicks\n      ? dl.extend({}, p.ticks, p.minorTicks) : p.ticks);\n  } else {\n    axis.majorTickProperties(p && p.majorTicks || {});\n    axis.minorTickProperties(p && p.minorTicks || {});\n  }\n  axis.tickLabelProperties(p && p.labels || {});\n  axis.titleProperties(p && p.title || {});\n  axis.gridLineProperties(p && p.grid || {});\n  axis.domainProperties(p && p.axis || {});\n}\n\nmodule.exports = axes;","var dl = require('datalib'),\n    config = require('../util/config'),\n    parseTransforms = require('./transforms'),\n    parseModify = require('./modify');\n\nvar parseData = function(model, spec, callback) {\n  var count = 0;\n\n  function loaded(d) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + d.url + \" \" + error);\n      } else {\n        model.data(d.name).values(dl.read(data, d.format));\n      }\n      if (--count === 0) callback();\n    }\n  }\n\n  // process each data set definition\n  (spec || []).forEach(function(d) {\n    if (d.url) {\n      count += 1;\n      dl.load(dl.extend({url: d.url}, config.load), loaded(d));\n    }\n    parseData.datasource(model, d);\n  });\n\n  if (count === 0) setTimeout(callback, 1);\n  return spec;\n};\n\nparseData.datasource = function(model, d) {\n  var transform = (d.transform||[]).map(function(t) { return parseTransforms(model, t) }),\n      mod = (d.modify||[]).map(function(m) { return parseModify(model, m, d) }),\n      ds = model.data(d.name, mod.concat(transform));\n\n  if (d.values) {\n    ds.values(dl.read(d.values, d.format));\n  } else if (d.source) {\n    ds.source(d.source)\n      .revises(ds.revises()) // If new ds revises, then it's origin must revise too.\n      .addListener(ds);  // Derived ds will be pulsed by its src rather than the model.\n    model.removeListener(ds.pipeline()[0]); \n  }\n\n  return ds;    \n};\n\nmodule.exports = parseData;\n","/*\n * Generated by PEG.js 0.8.0.\n *\n * http://pegjs.majda.cz/\n */\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction SyntaxError(message, expected, found, offset, line, column) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.offset   = offset;\n  this.line     = line;\n  this.column   = column;\n\n  this.name     = \"SyntaxError\";\n}\n\npeg$subclass(SyntaxError, Error);\n\nfunction parse(input) {\n  var options = arguments.length > 1 ? arguments[1] : {},\n\n      peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = peg$FAILED,\n      peg$c1 = \",\",\n      peg$c2 = { type: \"literal\", value: \",\", description: \"\\\",\\\"\" },\n      peg$c3 = function(o, m) { return [o].concat(m) },\n      peg$c4 = function(o) { return [o] },\n      peg$c5 = \"[\",\n      peg$c6 = { type: \"literal\", value: \"[\", description: \"\\\"[\\\"\" },\n      peg$c7 = \"]\",\n      peg$c8 = { type: \"literal\", value: \"]\", description: \"\\\"]\\\"\" },\n      peg$c9 = \">\",\n      peg$c10 = { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n      peg$c11 = function(f1, f2, o) { return {start: f1, end: f2, middle: o}},\n      peg$c12 = [],\n      peg$c13 = function(s, f) { return (s.filters = f), s },\n      peg$c14 = function(s) { return s },\n      peg$c15 = null,\n      peg$c16 = function(t, e) { return { event: e, target: t } },\n      peg$c17 = /^[:a-zA-z0-9_\\-]/,\n      peg$c18 = { type: \"class\", value: \"[:a-zA-z0-9_\\\\-]\", description: \"[:a-zA-z0-9_\\\\-]\" },\n      peg$c19 = function(s) { return { signal: s.join(\"\") }},\n      peg$c20 = \"(\",\n      peg$c21 = { type: \"literal\", value: \"(\", description: \"\\\"(\\\"\" },\n      peg$c22 = \")\",\n      peg$c23 = { type: \"literal\", value: \")\", description: \"\\\")\\\"\" },\n      peg$c24 = function(m) { return { stream: m }},\n      peg$c25 = \".\",\n      peg$c26 = { type: \"literal\", value: \".\", description: \"\\\".\\\"\" },\n      peg$c27 = \":\",\n      peg$c28 = { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n      peg$c29 = function(c) { return { type:'class', value: c } },\n      peg$c30 = \"#\",\n      peg$c31 = { type: \"literal\", value: \"#\", description: \"\\\"#\\\"\" },\n      peg$c32 = function(id) { return { type:'id', value: id } },\n      peg$c33 = \"mousedown\",\n      peg$c34 = { type: \"literal\", value: \"mousedown\", description: \"\\\"mousedown\\\"\" },\n      peg$c35 = \"mouseup\",\n      peg$c36 = { type: \"literal\", value: \"mouseup\", description: \"\\\"mouseup\\\"\" },\n      peg$c37 = \"click\",\n      peg$c38 = { type: \"literal\", value: \"click\", description: \"\\\"click\\\"\" },\n      peg$c39 = \"dblclick\",\n      peg$c40 = { type: \"literal\", value: \"dblclick\", description: \"\\\"dblclick\\\"\" },\n      peg$c41 = \"wheel\",\n      peg$c42 = { type: \"literal\", value: \"wheel\", description: \"\\\"wheel\\\"\" },\n      peg$c43 = \"keydown\",\n      peg$c44 = { type: \"literal\", value: \"keydown\", description: \"\\\"keydown\\\"\" },\n      peg$c45 = \"keypress\",\n      peg$c46 = { type: \"literal\", value: \"keypress\", description: \"\\\"keypress\\\"\" },\n      peg$c47 = \"keyup\",\n      peg$c48 = { type: \"literal\", value: \"keyup\", description: \"\\\"keyup\\\"\" },\n      peg$c49 = \"mousewheel\",\n      peg$c50 = { type: \"literal\", value: \"mousewheel\", description: \"\\\"mousewheel\\\"\" },\n      peg$c51 = \"mousemove\",\n      peg$c52 = { type: \"literal\", value: \"mousemove\", description: \"\\\"mousemove\\\"\" },\n      peg$c53 = \"mouseout\",\n      peg$c54 = { type: \"literal\", value: \"mouseout\", description: \"\\\"mouseout\\\"\" },\n      peg$c55 = \"mouseover\",\n      peg$c56 = { type: \"literal\", value: \"mouseover\", description: \"\\\"mouseover\\\"\" },\n      peg$c57 = \"mouseenter\",\n      peg$c58 = { type: \"literal\", value: \"mouseenter\", description: \"\\\"mouseenter\\\"\" },\n      peg$c59 = \"touchstart\",\n      peg$c60 = { type: \"literal\", value: \"touchstart\", description: \"\\\"touchstart\\\"\" },\n      peg$c61 = \"touchmove\",\n      peg$c62 = { type: \"literal\", value: \"touchmove\", description: \"\\\"touchmove\\\"\" },\n      peg$c63 = \"touchend\",\n      peg$c64 = { type: \"literal\", value: \"touchend\", description: \"\\\"touchend\\\"\" },\n      peg$c65 = function(field) { return field  },\n      peg$c66 = /^['\"a-zA-Z0-9_.><=! \\t\\-]/,\n      peg$c67 = { type: \"class\", value: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\", description: \"['\\\"a-zA-Z0-9_.><=! \\\\t\\\\-]\" },\n      peg$c68 = function(v) { return v.join(\"\") },\n      peg$c69 = /^[ \\t\\r\\n]/,\n      peg$c70 = { type: \"class\", value: \"[ \\\\t\\\\r\\\\n]\", description: \"[ \\\\t\\\\r\\\\n]\" },\n\n      peg$currPos          = 0,\n      peg$reportedPos      = 0,\n      peg$cachedPos        = 0,\n      peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$reportedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$reportedPos;\n  }\n\n  function line() {\n    return peg$computePosDetails(peg$reportedPos).line;\n  }\n\n  function column() {\n    return peg$computePosDetails(peg$reportedPos).column;\n  }\n\n  function expected(description) {\n    throw peg$buildException(\n      null,\n      [{ type: \"other\", description: description }],\n      peg$reportedPos\n    );\n  }\n\n  function error(message) {\n    throw peg$buildException(message, null, peg$reportedPos);\n  }\n\n  function peg$computePosDetails(pos) {\n    function advance(details, startPos, endPos) {\n      var p, ch;\n\n      for (p = startPos; p < endPos; p++) {\n        ch = input.charAt(p);\n        if (ch === \"\\n\") {\n          if (!details.seenCR) { details.line++; }\n          details.column = 1;\n          details.seenCR = false;\n        } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n          details.line++;\n          details.column = 1;\n          details.seenCR = true;\n        } else {\n          details.column++;\n          details.seenCR = false;\n        }\n      }\n    }\n\n    if (peg$cachedPos !== pos) {\n      if (peg$cachedPos > pos) {\n        peg$cachedPos = 0;\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n      }\n      advance(peg$cachedPosDetails, peg$cachedPos, pos);\n      peg$cachedPos = pos;\n    }\n\n    return peg$cachedPosDetails;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildException(message, expected, pos) {\n    function cleanupExpected(expected) {\n      var i = 1;\n\n      expected.sort(function(a, b) {\n        if (a.description < b.description) {\n          return -1;\n        } else if (a.description > b.description) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n\n      while (i < expected.length) {\n        if (expected[i - 1] === expected[i]) {\n          expected.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    function buildMessage(expected, found) {\n      function stringEscape(s) {\n        function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n        return s\n          .replace(/\\\\/g,   '\\\\\\\\')\n          .replace(/\"/g,    '\\\\\"')\n          .replace(/\\x08/g, '\\\\b')\n          .replace(/\\t/g,   '\\\\t')\n          .replace(/\\n/g,   '\\\\n')\n          .replace(/\\f/g,   '\\\\f')\n          .replace(/\\r/g,   '\\\\r')\n          .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n          .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n          .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n          .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n      }\n\n      var expectedDescs = new Array(expected.length),\n          expectedDesc, foundDesc, i;\n\n      for (i = 0; i < expected.length; i++) {\n        expectedDescs[i] = expected[i].description;\n      }\n\n      expectedDesc = expected.length > 1\n        ? expectedDescs.slice(0, -1).join(\", \")\n            + \" or \"\n            + expectedDescs[expected.length - 1]\n        : expectedDescs[0];\n\n      foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n      return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n    }\n\n    var posDetails = peg$computePosDetails(pos),\n        found      = pos < input.length ? input.charAt(pos) : null;\n\n    if (expected !== null) {\n      cleanupExpected(expected);\n    }\n\n    return new SyntaxError(\n      message !== null ? message : buildMessage(expected, found),\n      expected,\n      found,\n      pos,\n      posDetails.line,\n      posDetails.column\n    );\n  }\n\n  function peg$parsestart() {\n    var s0;\n\n    s0 = peg$parsemerged();\n\n    return s0;\n  }\n\n  function peg$parsemerged() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseordered();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c2); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsemerged();\n            if (s5 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c3(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseordered();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c4(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseordered() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesep();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsefiltered();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsesep();\n          if (s4 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 44) {\n              s5 = peg$c1;\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c2); }\n            }\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsesep();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parsefiltered();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsesep();\n                  if (s8 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 93) {\n                      s9 = peg$c7;\n                      peg$currPos++;\n                    } else {\n                      s9 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c8); }\n                    }\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsesep();\n                      if (s10 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 62) {\n                          s11 = peg$c9;\n                          peg$currPos++;\n                        } else {\n                          s11 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c10); }\n                        }\n                        if (s11 !== peg$FAILED) {\n                          s12 = peg$parsesep();\n                          if (s12 !== peg$FAILED) {\n                            s13 = peg$parseordered();\n                            if (s13 !== peg$FAILED) {\n                              peg$reportedPos = s0;\n                              s1 = peg$c11(s3, s7, s13);\n                              s0 = s1;\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$c0;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$c0;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$c0;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$c0;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$c0;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$c0;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$c0;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$c0;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsefiltered();\n    }\n\n    return s0;\n  }\n\n  function peg$parsefiltered() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsestream();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsefilter();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsefilter();\n        }\n      } else {\n        s2 = peg$c0;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c13(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsestream();\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c14(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsestream() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseclass();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseid();\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$c15;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseeventType();\n      if (s2 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c16(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c17.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c18); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c17.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c18); }\n          }\n        }\n      } else {\n        s1 = peg$c0;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$reportedPos = s0;\n        s1 = peg$c19(s1);\n      }\n      s0 = s1;\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 40) {\n          s1 = peg$c20;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c21); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsemerged();\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 41) {\n              s3 = peg$c22;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c23); }\n            }\n            if (s3 !== peg$FAILED) {\n              peg$reportedPos = s0;\n              s1 = peg$c24(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$c0;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$c0;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseclass() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c25;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c26); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c29(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseid() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 35) {\n      s1 = peg$c30;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 58) {\n          s3 = peg$c27;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c32(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parseeventType() {\n    var s0;\n\n    if (input.substr(peg$currPos, 9) === peg$c33) {\n      s0 = peg$c33;\n      peg$currPos += 9;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 7) === peg$c35) {\n        s0 = peg$c35;\n        peg$currPos += 7;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c37) {\n          s0 = peg$c37;\n          peg$currPos += 5;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 8) === peg$c39) {\n            s0 = peg$c39;\n            peg$currPos += 8;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c40); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.substr(peg$currPos, 5) === peg$c41) {\n              s0 = peg$c41;\n              peg$currPos += 5;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c42); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.substr(peg$currPos, 7) === peg$c43) {\n                s0 = peg$c43;\n                peg$currPos += 7;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c44); }\n              }\n              if (s0 === peg$FAILED) {\n                if (input.substr(peg$currPos, 8) === peg$c45) {\n                  s0 = peg$c45;\n                  peg$currPos += 8;\n                } else {\n                  s0 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c46); }\n                }\n                if (s0 === peg$FAILED) {\n                  if (input.substr(peg$currPos, 5) === peg$c47) {\n                    s0 = peg$c47;\n                    peg$currPos += 5;\n                  } else {\n                    s0 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c48); }\n                  }\n                  if (s0 === peg$FAILED) {\n                    if (input.substr(peg$currPos, 10) === peg$c49) {\n                      s0 = peg$c49;\n                      peg$currPos += 10;\n                    } else {\n                      s0 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c50); }\n                    }\n                    if (s0 === peg$FAILED) {\n                      if (input.substr(peg$currPos, 9) === peg$c51) {\n                        s0 = peg$c51;\n                        peg$currPos += 9;\n                      } else {\n                        s0 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c52); }\n                      }\n                      if (s0 === peg$FAILED) {\n                        if (input.substr(peg$currPos, 8) === peg$c53) {\n                          s0 = peg$c53;\n                          peg$currPos += 8;\n                        } else {\n                          s0 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c54); }\n                        }\n                        if (s0 === peg$FAILED) {\n                          if (input.substr(peg$currPos, 9) === peg$c55) {\n                            s0 = peg$c55;\n                            peg$currPos += 9;\n                          } else {\n                            s0 = peg$FAILED;\n                            if (peg$silentFails === 0) { peg$fail(peg$c56); }\n                          }\n                          if (s0 === peg$FAILED) {\n                            if (input.substr(peg$currPos, 10) === peg$c57) {\n                              s0 = peg$c57;\n                              peg$currPos += 10;\n                            } else {\n                              s0 = peg$FAILED;\n                              if (peg$silentFails === 0) { peg$fail(peg$c58); }\n                            }\n                            if (s0 === peg$FAILED) {\n                              if (input.substr(peg$currPos, 10) === peg$c59) {\n                                s0 = peg$c59;\n                                peg$currPos += 10;\n                              } else {\n                                s0 = peg$FAILED;\n                                if (peg$silentFails === 0) { peg$fail(peg$c60); }\n                              }\n                              if (s0 === peg$FAILED) {\n                                if (input.substr(peg$currPos, 9) === peg$c61) {\n                                  s0 = peg$c61;\n                                  peg$currPos += 9;\n                                } else {\n                                  s0 = peg$FAILED;\n                                  if (peg$silentFails === 0) { peg$fail(peg$c62); }\n                                }\n                                if (s0 === peg$FAILED) {\n                                  if (input.substr(peg$currPos, 8) === peg$c63) {\n                                    s0 = peg$c63;\n                                    peg$currPos += 8;\n                                  } else {\n                                    s0 = peg$FAILED;\n                                    if (peg$silentFails === 0) { peg$fail(peg$c64); }\n                                  }\n                                }\n                              }\n                            }\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefilter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c5;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 93) {\n          s3 = peg$c7;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c8); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$reportedPos = s0;\n          s1 = peg$c65(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$c0;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$c0;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$c0;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c66.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c67); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c66.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c67); }\n        }\n      }\n    } else {\n      s1 = peg$c0;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$reportedPos = s0;\n      s1 = peg$c68(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesep() {\n    var s0, s1;\n\n    s0 = [];\n    if (peg$c69.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c70); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      if (peg$c69.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c70); }\n      }\n    }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail({ type: \"end\", description: \"end of input\" });\n    }\n\n    throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n  }\n}\n\nmodule.exports = {\n  SyntaxError: SyntaxError,\n  parse:       parse\n};","var dl = require('datalib'),\n    expression = require('../expression');\n\nvar expr = (function() {\n  var parse = expression.parse;\n  var codegen = expression.code({\n    idWhiteList: ['d', 'e', 'i', 'p', 'sg']\n  });\n\n  return function(expr) {    \n    var value = codegen(parse(expr));\n    value.fn = Function('d', 'e', 'i', 'p', 'sg',\n      '\"use strict\"; return (' + value.fn + ');');\n    return value;\n  };\n})();\n\nexpr.eval = function(graph, fn, d, e, i, p, sg) {\n  sg = graph.signalValues(dl.array(sg));\n  return fn.call(null, d, e, i, p, sg);\n};\n\nmodule.exports = expr;","var dl = require('datalib'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nmodule.exports = function parseInteractors(model, spec, defFactory) {\n  var count = 0,\n      sg = {}, pd = {}, mk = {},\n      signals = [], predicates = [];\n\n  function loaded(i) {\n    return function(error, data) {\n      if (error) {\n        dl.error(\"LOADING FAILED: \" + i.url);\n      } else {\n        var def = dl.isObject(data) ? data : JSON.parse(data);\n        interactor(i.name, def);\n      }\n      if (--count == 0) inject();\n    }\n  }\n\n  function interactor(name, def) {\n    sg = {}, pd = {};\n    if (def.signals)    signals.push.apply(signals, nsSignals(name, def.signals));\n    if (def.predicates) predicates.push.apply(predicates, nsPredicates(name, def.predicates));\n    nsMarks(name, def.marks);\n  }\n\n  function inject() {\n    if (dl.keys(mk).length > 0) injectMarks(spec.marks);\n    spec.signals = dl.array(spec.signals);\n    spec.predicates = dl.array(spec.predicates);\n    spec.signals.unshift.apply(spec.signals, signals);\n    spec.predicates.unshift.apply(spec.predicates, predicates);\n    defFactory();\n  }\n\n  function injectMarks(marks) {\n    var m, r, i, len;\n    marks = dl.array(marks);\n\n    for(i = 0, len = marks.length; i < len; i++) {\n      m = marks[i];\n      if (r = mk[m.type]) {\n        marks[i] = dl.duplicate(r);\n        if (m.from) marks[i].from = m.from;\n        if (m.properties) {\n          [C.ENTER, C.UPDATE, C.EXIT].forEach(function(p) {\n            marks[i].properties[p] = dl.extend(r.properties[p], m.properties[p]);\n          });\n        }\n      } else if (m.marks) {  // TODO how to override properties of nested marks?\n        injectMarks(m.marks);\n      }\n    }    \n  }\n\n  function ns(n, s) { \n    if (dl.isString(s)) {\n      return s + \"_\" + n;\n    } else {\n      dl.keys(s).forEach(function(x) { \n        var regex = new RegExp('\\\\b'+x+'\\\\b', \"g\");\n        n = n.replace(regex, s[x]) \n      });\n      return n;\n    }\n  }\n\n  function nsSignals(name, signals) {\n    signals = dl.array(signals);\n    // Two passes to ns all signals, and then overwrite their definitions\n    // in case signal order is important.\n    signals.forEach(function(s) { s.name = sg[s.name] = ns(s.name, name); });\n    signals.forEach(function(s) {\n      (s.streams || []).forEach(function(t) {\n        t.type = ns(t.type, sg);\n        t.expr = ns(t.expr, sg);\n      });\n    });\n    return signals;\n  }\n\n  function nsPredicates(name, predicates) {\n    predicates = dl.array(predicates);\n    predicates.forEach(function(p) {\n      p.name = pd[p.name] = ns(p.name, name);\n\n      [p.operands, p.range].forEach(function(x) {\n        (x || []).forEach(function(o) {\n          if (o.signal) o.signal = ns(o.signal, sg);\n          else if (o.predicate) nsOperand(o);\n        })\n      });\n\n    });  \n    return predicates; \n  }\n\n  function nsOperand(o) {\n    o.predicate = pd[o.predicate];\n    dl.keys(o.input).forEach(function(k) {\n      var i = o.input[k];\n      if (i.signal) i.signal = ns(i.signal, sg);\n    });\n  }\n\n  function nsMarks(name, marks) {\n    (marks || []).forEach(function(m) { \n      nsProperties(m.properties.enter);\n      nsProperties(m.properties.update);\n      nsProperties(m.properties.exit);\n      mk[ns(m.name, name)] = m; \n    });\n  }\n\n  function nsProperties(propset) {\n    dl.keys(propset).forEach(function(k) {\n      var p = propset[k];\n      if (p.signal) p.signal = ns(p.signal, sg);\n      else if (p.rule) {\n        p.rule.forEach(function(r) { \n          if (r.signal) r.signal = ns(r.signal, sg);\n          if (r.predicate) nsOperand(r); \n        });\n      }\n    });\n  }\n\n  (spec.interactors || []).forEach(function(i) {\n    if (i.url) {\n      count += 1;\n      dl.load(dl.extend({url: i.url}, config.load), loaded(i));\n    }\n  });\n\n  if (count === 0) setTimeout(inject, 1);\n  return spec;\n}","var dl = require('datalib'),\n    parseProperties = require('./properties');\n\nmodule.exports = function parseMark(model, mark) {\n  var props = mark.properties,\n      group = mark.marks;\n\n  // parse mark property definitions\n  dl.keys(props).forEach(function(k) {\n    props[k] = parseProperties(model, mark.type, props[k]);\n  });\n\n  // parse delay function\n  if (mark.delay) {\n    mark.delay = parseProperties(model, mark.type, {delay: mark.delay});\n  }\n\n  // recurse if group type\n  if (group) {\n    mark.marks = group.map(function(g) { return parseMark(model, g); });\n  }\n    \n  return mark;\n};","var parseMark = require('./mark');\n\nmodule.exports = function(model, spec, width, height) {\n  return {\n    type: \"group\",\n    width: width,\n    height: height,\n    scales: spec.scales || [],\n    axes: spec.axes || [],\n    // legends: spec.legends || [],\n    marks: (spec.marks || []).map(function(m) { return parseMark(model, m); })\n  };\n};","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nvar filter = function(field, value, src, dest) {\n  for(var i = src.length-1; i >= 0; --i) {\n    if(src[i][field] == value)\n      dest.push.apply(dest, src.splice(i, 1));\n  }\n};\n\nmodule.exports = function parseModify(model, def, ds) {\n  var graph = model.graph,\n      signal = def.signal ? dl.field(def.signal) : null, \n      signalName = signal ? signal[0] : null,\n      predicate = def.predicate ? model.predicate(def.predicate) : null,\n      reeval = (predicate === null),\n      node = new Node(graph);\n\n  node.evaluate = function(input) {\n    if(predicate !== null) {\n      var db = {};\n      (predicate.data||[]).forEach(function(d) { db[d] = model.data(d).values(); });\n\n      // TODO: input\n      reeval = predicate({}, db, graph.signalValues(predicate.signals||[]), model._predicates);\n    }\n\n    debug(input, [def.type+\"ing\", reeval]);\n    if(!reeval) return input;\n\n    var datum = {}, \n        value = signal ? graph.signalRef(def.signal) : null,\n        d = model.data(ds.name),\n        prev = d.revises() ? null : undefined,\n        t = null;\n\n    datum[def.field] = value;\n\n    // We have to modify ds._data so that subsequent pulses contain\n    // our dynamic data. W/o modifying ds._data, only the output\n    // collector will contain dynamic tuples. \n    if(def.type == C.ADD) {\n      t = tuple.ingest(datum, prev);\n      input.add.push(t);\n      d._data.push(t);\n    } else if(def.type == C.REMOVE) {\n      filter(def.field, value, input.add, input.rem);\n      filter(def.field, value, input.mod, input.rem);\n      d._data = d._data.filter(function(x) { return x[def.field] !== value });\n    } else if(def.type == C.TOGGLE) {\n      var add = [], rem = [];\n      filter(def.field, value, input.rem, add);\n      filter(def.field, value, input.add, rem);\n      filter(def.field, value, input.mod, rem);\n      if(add.length == 0 && rem.length == 0) add.push(tuple.ingest(datum));\n\n      input.add.push.apply(input.add, add);\n      d._data.push.apply(d._data, add);\n      input.rem.push.apply(input.rem, rem);\n      d._data = d._data.filter(function(x) { return rem.indexOf(x) === -1 });\n    } else if(def.type == C.CLEAR) {\n      input.rem.push.apply(input.rem, input.add);\n      input.rem.push.apply(input.rem, input.mod);\n      input.add = [];\n      input.mod = [];\n      d._data  = [];\n    } \n\n    input.fields[def.field] = 1;\n    return input;\n  };\n\n  if(signalName) node.dependency(C.SIGNALS, signalName);\n  if(predicate)  node.dependency(C.SIGNALS, predicate.signals);\n  \n  return node;\n}","var dl = require('datalib');\n\nmodule.exports = function parsePadding(pad) {\n  if (pad == null) return \"auto\";\n  else if (dl.isString(pad)) return pad===\"strict\" ? \"strict\" : \"auto\";\n  else if (dl.isObject(pad)) return pad;\n  var p = dl.isNumber(pad) ? pad : 20;\n  return {top:p, left:p, right:p, bottom:p};\n}","var dl = require('datalib');\n\nmodule.exports = function parsePredicate(model, spec) {\n  var types = {\n    '=':  parseComparator,\n    '==': parseComparator,\n    '!=': parseComparator,\n    '>':  parseComparator,\n    '>=': parseComparator,\n    '<':  parseComparator,\n    '<=': parseComparator,\n    'and': parseLogical,\n    '&&':  parseLogical,\n    'or':  parseLogical,\n    '||':  parseLogical,\n    'in': parseIn\n  };\n\n  function parseSignal(signal, signals) {\n    var s = dl.field(signal),\n        code = \"signals[\"+s.map(dl.str).join(\"][\")+\"]\";\n    signals[s.shift()] = 1;\n    return code;\n  };\n\n  function parseOperands(operands) {\n    var decl = [], defs = [],\n        signals = {}, db = {};\n\n    dl.array(operands).forEach(function(o, i) {\n      var signal, name = \"o\"+i, def = \"\";\n      \n      if(o.value !== undefined) def = dl.str(o.value);\n      else if(o.arg)    def = \"args[\"+dl.str(o.arg)+\"]\";\n      else if(o.signal) def = parseSignal(o.signal, signals);\n      else if(o.predicate) {\n        var pred = model.predicate(o.predicate);\n        pred.signals.forEach(function(s) { signals[s] = 1; });\n        pred.data.forEach(function(d) { db[d] = 1 });\n\n        dl.keys(o.input).forEach(function(k) {\n          var i = o.input[k], signal;\n          def += \"args[\"+dl.str(k)+\"] = \";\n          if(i.signal)   def += parseSignal(i.signal, signals);\n          else if(i.arg) def += \"args[\"+dl.str(i.arg)+\"]\";\n          def+=\", \";\n        });\n\n        def+= \"predicates[\"+dl.str(o.predicate)+\"](args, db, signals, predicates)\";\n      }\n\n      decl.push(name);\n      defs.push(name+\"=(\"+def+\")\");\n    });\n\n    return {\n      code: \"var \" + decl.join(\", \") + \";\\n\" + defs.join(\";\\n\") + \";\\n\",\n      signals: dl.keys(signals),\n      data: dl.keys(db)\n    }\n  };\n\n  function parseComparator(spec) {\n    var ops = parseOperands(spec.operands);\n    if(spec.type == '=') spec.type = '==';\n\n    return {\n      code: ops.code + \"return \" + [\"o0\", \"o1\"].join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseLogical(spec) {\n    var ops = parseOperands(spec.operands),\n        o = [], i = 0, len = spec.operands.length;\n\n    while(o.push(\"o\"+i++)<len);\n    if(spec.type == 'and') spec.type = '&&';\n    else if(spec.type == 'or') spec.type = '||';\n\n    return {\n      code: ops.code + \"return \" + o.join(spec.type) + \";\",\n      signals: ops.signals,\n      data: ops.data\n    };\n  };\n\n  function parseIn(spec) {\n    var o = [spec.item];\n    if(spec.range) o.push.apply(o, spec.range);\n    if(spec.scale) o.push(spec.scale);\n\n    var ops = parseOperands(o),\n        code = ops.code;\n\n    if(spec.data) {\n      var field = dl.field(spec.field).map(dl.str);\n      code += \"var where = function(d) { return d[\"+field.join(\"][\")+\"] == o0 };\\n\";\n      code += \"return db[\"+dl.str(spec.data)+\"].filter(where).length > 0;\";\n    } else if(spec.range) {\n      // TODO: inclusive/exclusive range?\n      // TODO: inverting ordinal scales\n      if(spec.scale) code += \"o1 = o3(o1);\\no2 = o3(o2);\\n\";\n      code += \"return o1 < o2 ? o1 <= o0 && o0 <= o2 : o2 <= o0 && o0 <= o1\";\n    }\n\n    return {\n      code: code, \n      signals: ops.signals, \n      data: ops.data.concat(spec.data ? [spec.data] : [])\n    };\n  };\n\n  (spec || []).forEach(function(s) {\n    var parse = types[s.type](s);\n    var pred = Function(\"args\", \"db\", \"signals\", \"predicates\", parse.code);\n    pred.signals = parse.signals;\n    pred.data = parse.data;\n    model.predicate(s.name, pred);\n  });\n\n  return spec;\n}","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    tuple = require('../dataflow/tuple'),\n    config = require('../util/config');\n\nfunction compile(model, mark, spec) {\n  var code = \"\",\n      names = dl.keys(spec),\n      i, len, name, ref, vars = {}, \n      deps = {\n        signals: {},\n        scales: {},\n        data: {}\n      };\n      \n  code += \"var o = trans ? {} : item;\\n\"\n  \n  for (i=0, len=names.length; i<len; ++i) {\n    ref = spec[name = names[i]];\n    code += (i > 0) ? \"\\n  \" : \"  \";\n    if(ref.rule) {\n      ref = rule(model, name, ref.rule);\n      code += \"\\n  \" + ref.code\n    } else {\n      ref = valueRef(name, ref);\n      code += \"this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\";\n    }\n\n    vars[name] = true;\n    ['signals', 'scales', 'data'].forEach(function(p) {\n      if(ref[p] != null) dl.array(ref[p]).forEach(function(k) { deps[p][k] = 1 });\n    });\n  }\n\n  if (vars.x2) {\n    if (vars.x) {\n      code += \"\\n  if (o.x > o.x2) { \"\n            + \"var t = o.x;\"\n            + \"this.tpl.set(o, 'x', o.x2);\"\n            + \"this.tpl.set(o, 'x2', t); \"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'width', (o.x2 - o.x));\";\n    } else if (vars.width) {\n      code += \"\\n  this.tpl.set(o, 'x', (o.x2 - o.width));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'x', o.x2);\"\n    }\n  }\n\n  if (vars.y2) {\n    if (vars.y) {\n      code += \"\\n  if (o.y > o.y2) { \"\n            + \"var t = o.y;\"\n            + \"this.tpl.set(o, 'y', o.y2);\"\n            + \"this.tpl.set(o, 'y2', t);\"\n            + \"};\";\n      code += \"\\n  this.tpl.set(o, 'height', (o.y2 - o.y));\";\n    } else if (vars.height) {\n      code += \"\\n  this.tpl.set(o, 'y', (o.y2 - o.height));\";\n    } else {\n      code += \"\\n  this.tpl.set(o, 'y', o.y2);\"\n    }\n  }\n  \n  if (hasPath(mark, vars)) code += \"\\n  item.touch();\";\n  code += \"\\n  if (trans) trans.interpolate(item, o);\";\n\n  try {\n    var encoder = Function(\"item\", \"group\", \"trans\", \"db\", \n      \"signals\", \"predicates\", code);\n    encoder.tpl  = tuple;\n    encoder.util = dl;\n    encoder.d3   = d3; // For color spaces\n    return {\n      encode: encoder,\n      signals: dl.keys(deps.signals),\n      scales: dl.keys(deps.scales),\n      data: dl.keys(deps.data)\n    }\n  } catch (e) {\n    dl.error(e);\n    dl.log(code);\n  }\n}\n\nfunction hasPath(mark, vars) {\n  return vars.path ||\n    ((mark===\"area\" || mark===\"line\") &&\n      (vars.x || vars.x2 || vars.width ||\n       vars.y || vars.y2 || vars.height ||\n       vars.tension || vars.interpolate));\n}\n\nvar GROUP_VARS = {\n  \"width\": 1,\n  \"height\": 1,\n  \"mark.group.width\": 1,\n  \"mark.group.height\": 1\n};\n\nfunction rule(model, name, rules) {\n  var signals = [], scales = [], db = [],\n      inputs = [], code = \"\";\n\n  (rules||[]).forEach(function(r, i) {\n    var predName = r.predicate,\n        pred = model.predicate(predName),\n        input = [], args = name+\"_arg\"+i,\n        ref;\n\n    dl.keys(r.input).forEach(function(k) {\n      var ref = valueRef(i, r.input[k]);\n      input.push(dl.str(k)+\": \"+ref.val);\n      if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n      if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n    });\n\n    ref = valueRef(name, r);\n    if(ref.signals) signals.push.apply(signals, dl.array(ref.signals));\n    if(ref.scales)  scales.push.apply(scales, dl.array(ref.scales));\n\n    if(predName) {\n      signals.push.apply(signals, pred.signals);\n      db.push.apply(db, pred.data);\n      inputs.push(args+\" = {\"+input.join(', ')+\"}\");\n      code += \"if(predicates[\"+dl.str(predName)+\"](\"+args+\", db, signals, predicates)) {\\n\" +\n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\";\n      code += rules[i+1] ? \"  } else \" : \"  }\";\n    } else {\n      code += \"{\\n\" + \n        \"    this.tpl.set(o, \"+dl.str(name)+\", \"+ref.val+\");\\n\"+\n        \"  }\";\n    }\n  });\n\n  code = \"var \" + inputs.join(\",\\n      \") + \";\\n  \" + code;\n  return {code: code, signals: signals, scales: scales, data: db};\n}\n\nfunction valueRef(name, ref) {\n  if (ref == null) return null;\n  var isColor = name===\"fill\" || name===\"stroke\";\n  var signals = [];\n\n  if (isColor) {\n    if (ref.c) {\n      return colorRef(\"hcl\", ref.h, ref.c, ref.l);\n    } else if (ref.h || ref.s) {\n      return colorRef(\"hsl\", ref.h, ref.s, ref.l);\n    } else if (ref.l || ref.a) {\n      return colorRef(\"lab\", ref.l, ref.a, ref.b);\n    } else if (ref.r || ref.g || ref.b) {\n      return colorRef(\"rgb\", ref.r, ref.g, ref.b);\n    }\n  }\n\n  // initialize value\n  var val = null, signalRef = null;\n  if (ref.value !== undefined) {\n    val = dl.str(ref.value);\n  }\n\n  if (ref.signal !== undefined) {\n    signalRef = dl.field(ref.signal);\n    val = \"signals[\"+signalRef.map(dl.str).join(\"][\")+\"]\"; \n    signals.push(signalRef.shift());\n  }\n\n  // get field reference for enclosing group\n  if (ref.group != null) {\n    var grp = \"group.datum\";\n    if (dl.isString(ref.group)) {\n      grp = GROUP_VARS[ref.group]\n        ? \"group.\" + ref.group\n        : \"group.datum[\"+dl.field(ref.group).map(dl.str).join(\"][\")+\"]\";\n    }\n  }\n\n  // get data field value\n  if (ref.field != null) {\n    if (dl.isString(ref.field)) {\n      val = \"item.datum[\"+dl.field(ref.field).map(dl.str).join(\"][\")+\"]\";\n      if (ref.group != null) { val = \"this.util.accessor(\"+val+\")(\"+grp+\")\"; }\n    } else if(ref.field.signal) {\n      signalRef = dl.field(ref.field.signal);\n      val = \"item.datum[signals[\"+signalRef.map(dl.str).join(\"][\")+\"]]\";\n      if (ref.group != null) { val = \"this.util.accessor(\"+val+\")(\"+grp+\")\"; }\n      signals.push(signalRef.shift());\n    } else {\n      val = \"this.util.accessor(group.datum[\"\n          + dl.field(ref.field.group).map(dl.str).join(\"][\")\n          + \"])(item.datum)\";\n    }\n  } else if (ref.group != null) {\n    val = grp;\n  }\n\n  if (ref.scale != null) {\n    var scale = null;\n    if(dl.isString(ref.scale)) {\n      scale = dl.str(ref.scale);\n    } else if(ref.scale.signal) {\n      signalRef = dl.field(ref.scale.signal);\n      scale = \"signals[\"+signalRef.map(dl.str).join(\"][\")+\"]\";\n      signals.push(signalRef.shift());\n    } else {\n      scale = (ref.scale.group ? \"group\" : \"item\")\n        + \".datum[\" + dl.str(ref.scale.group || ref.scale.field) + \"]\";\n    }\n\n    scale = \"group.scale(\" + scale + \")\";\n    if(ref.invert) scale += \".invert\";  // TODO: ordinal scales\n\n    // run through scale function if val specified.\n    // if no val, scale function is predicate arg.\n    if(val !== null || ref.band || ref.mult || ref.offset) {\n      val = scale + (ref.band ? \".rangeBand()\" : \n        \"(\"+(val !== null ? val : \"item.datum.data\")+\")\");\n    } else {\n      val = scale;\n    }\n  }\n  \n  // multiply, offset, return value\n  val = \"(\" + (ref.mult?(dl.number(ref.mult)+\" * \"):\"\") + val + \")\"\n    + (ref.offset ? \" + \" + dl.number(ref.offset) : \"\");\n  return {val: val, signals: signals, scales: ref.scale};\n}\n\nfunction colorRef(type, x, y, z) {\n  var xx = x ? valueRef(\"\", x) : config.color[type][0],\n      yy = y ? valueRef(\"\", y) : config.color[type][1],\n      zz = z ? valueRef(\"\", z) : config.color[type][2]\n      signals = [], scales = [];\n\n  [xx, yy, zz].forEach(function(v) {\n    if(v.signals) signals.push.apply(signals, v.signals);\n    if(v.scales)  scales.push(v.scales);\n  });\n\n  return {\n    val: \"(this.d3.\" + type + \"(\" + [xx.val, yy.val, zz.val].join(\",\") + ') + \"\")',\n    signals: signals,\n    scales: scales\n  };\n}\n\nmodule.exports = compile;","var expr = require('./expr'),\n    C = require('../util/constants');\n\nmodule.exports = function parseSignals(model, spec) {\n  var graph = model.graph;\n\n  // process each signal definition\n  (spec || []).forEach(function(s) {\n    var signal = graph.signal(s.name, s.init),\n        exp;\n\n    if(s.expr) {\n      exp = expr(s.expr);\n      signal.evaluate = function(input) {\n        var value = expr.eval(graph, exp.fn, null, null, null, null, exp.signals);\n        if(spec.scale) value = model.scale(spec, value);\n        signal.value(value);\n        input.signals[s.name] = 1;\n        return input;\n      };\n      signal.dependency(C.SIGNALS, exp.signals);\n      exp.signals.forEach(function(dep) { graph.signal(dep).addListener(signal); });\n    }\n  });\n\n  return spec;\n};","var dl = require('datalib'),\n    Model = require('../core/Model'), \n    View = require('../core/View'), \n    parsePadding = require('../parse/padding'),\n    parseMarks = require('../parse/marks'),\n    parseSignals = require('../parse/signals'),\n    parsePredicates = require('../parse/predicates'),\n    parseData = require('../parse/data'),\n    parseInteractors = require('../parse/interactors');\n\nmodule.exports = function parseSpec(spec, callback, viewFactory) {\n  // protect against subsequent spec modification\n  spec = dl.duplicate(spec);\n\n  viewFactory = viewFactory || View.factory;\n\n  var width = spec.width || 500,\n      height = spec.height || 500,\n      viewport = spec.viewport || null,\n      model = new Model();\n\n  parseInteractors(model, spec, function() {\n    model.defs({\n      width: width,\n      height: height,\n      viewport: viewport,\n      padding: parsePadding(spec.padding),\n      signals: parseSignals(model, spec.signals),\n      predicates: parsePredicates(model, spec.predicates),\n      marks: parseMarks(model, spec, width, height),\n      data: parseData(model, spec.data, function() { callback(viewFactory(model)); })\n    });\n  });\n}\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    changset = require('../dataflow/changeset'),\n    selector = require('./events'),\n    expr = require('./expr'),\n    C = require('../util/constants');\n\nvar START = \"start\", MIDDLE = \"middle\", END = \"end\";\n\nmodule.exports = function(view) {\n  var model = view.model(),\n      graph = model.graph,\n      spec  = model.defs().signals,\n      register = {}, nodes = {};\n\n  function scale(def, value, item) {\n    if(!item || !item.scale) {\n      item = (item && item.mark) ? item.mark.group : model.scene().items[0];\n    }\n\n    var scale = item.scale(def.scale.signal || def.scale);\n    if(!scale) return value;\n    return def.invert ? scale.invert(value) : scale(value);\n  }\n\n  function signal(sig, selector, exp, spec) {\n    var n = new Node(graph),\n        item = spec.item ? graph.signal(spec.item.signal) : null;\n    n.evaluate = function(input) {\n      if(!input.signals[selector.signal]) return graph.doNotPropagate;\n      var val = expr.eval(graph, exp.fn, null, null, null, null, exp.signals);\n      if(spec.scale) val = scale(spec, val, item ? item.value() : null);\n      sig.value(val);\n      input.signals[sig.name()] = 1;\n      input.reflow = true;\n      return input;  \n    };\n    n.dependency(C.SIGNALS, selector.signal);\n    n.addListener(sig);\n    graph.signal(selector.signal).addListener(n);\n  };\n\n  function event(sig, selector, exp, spec) {\n    var filters = selector.filters || [],\n        target = selector.target;\n\n    if(target) filters.push(\"i.\"+target.type+\"==\"+dl.str(target.value));\n\n    register[selector.event] = register[selector.event] || [];\n    register[selector.event].push({\n      signal: sig,\n      exp: exp,\n      filters: filters.map(function(f) { return expr(f); }),\n      spec: spec\n    });\n\n    nodes[selector.event] = nodes[selector.event] || new Node(graph);\n    nodes[selector.event].addListener(sig);\n  };\n\n  function orderedStream(sig, selector, exp, spec) {\n    var name = sig.name(), \n        trueFn = expr(\"true\"),\n        s = {};\n\n    s[START]  = graph.signal(name + START,  false);\n    s[MIDDLE] = graph.signal(name + MIDDLE, false);\n    s[END]    = graph.signal(name + END,    false);\n\n    var router = new Node(graph);\n    router.evaluate = function(input) {\n      if(s[START].value() === true && s[END].value() === false) {\n        // TODO: Expand selector syntax to allow start/end signals into stream.\n        // Until then, prevent old middles entering stream on new start.\n        if(input.signals[name+START]) return graph.doNotPropagate;\n\n        sig.value(s[MIDDLE].value());\n        input.signals[name] = 1;\n        return input;\n      }\n\n      if(s[END].value() === true) {\n        s[START].value(false);\n        s[END].value(false);\n      }\n\n      return graph.doNotPropagate;\n    };\n    router.addListener(sig);\n\n    [START, MIDDLE, END].forEach(function(x) {\n      var val = (x == MIDDLE) ? exp : trueFn,\n          sp = (x == MIDDLE) ? spec : {};\n\n      if(selector[x].event) event(s[x], selector[x], val, sp);\n      else if(selector[x].signal) signal(s[x], selector[x], val, sp);\n      else if(selector[x].stream) mergedStream(s[x], selector[x].stream, val, sp);\n      s[x].addListener(router);\n    });\n  };\n\n  function mergedStream(sig, selector, exp, spec) {\n    selector.forEach(function(s) {\n      if(s.event)       event(sig, s, exp, spec);\n      else if(s.signal) signal(sig, s, exp, spec);\n      else if(s.start)  orderedStream(sig, s, exp, spec);\n      else if(s.stream) mergedStream(sig, s.stream, exp, spec);\n    });\n  };\n\n  (spec || []).forEach(function(sig) {\n    var signal = graph.signal(sig.name);\n    if(sig.expr) return;  // Cannot have an expr and stream definition.\n\n    (sig.streams || []).forEach(function(stream) {\n      var sel = selector.parse(stream.type),\n          exp = expr(stream.expr);\n      mergedStream(signal, sel, exp, stream);\n    });\n  });\n\n  // We register the event listeners all together so that if multiple\n  // signals are registered on the same event, they will receive the\n  // new value on the same pulse. \n\n  // TODO: Filters, time intervals, target selectors\n  dl.keys(register).forEach(function(r) {\n    var handlers = register[r], \n        node = nodes[r];\n\n    view.on(r, function(evt, item) {\n      var cs = changset.create(null, true),\n          pad = view.padding(),\n          filtered = false,\n          val, h, i, m, d;\n\n      evt.preventDefault(); // Stop text selection\n      m = d3.mouse((d3.event=evt, view._el)); // Relative position within container\n      item = item||{};\n      d = item.datum||{};\n      var p = {x: m[0] - pad.left, y: m[1] - pad.top};\n\n      for(i = 0; i < handlers.length; i++) {\n        h = handlers[i];\n        filtered = h.filters.some(function(f) {\n          return !expr.eval(graph, f.fn, d, evt, item, p, f.signals);\n        });\n        if(filtered) continue;\n        \n        val = expr.eval(graph, h.exp.fn, d, evt, item, p, h.exp.signals); \n        if(h.spec.scale) val = scale(h.spec, val, item);\n        h.signal.value(val);\n        cs.signals[h.signal.name()] = 1;\n      }\n\n      graph.propagate(cs, node);\n    });\n  })\n};","var dl = require('datalib'),\n    transforms = require('../transforms/index');\n\nmodule.exports = function parseTransforms(model, def) {\n  var tx = new transforms[def.type](model.graph);\n  if(def.type == 'facet') {\n    var pipeline = (def.transform||[])\n      .map(function(t) { return parseTransforms(model, t); });\n    tx.pipeline(pipeline);\n  }\n\n  // We want to rename output fields before setting any other properties,\n  // as subsequent properties may require output to be set (e.g. group by).\n  if(def.output) tx.output(def.output);\n\n  dl.keys(def).forEach(function(k) {\n    if(k === 'type' || k === 'output') return;\n    if(k === 'transform' && def.type === 'facet') return;\n    (tx[k]).set(tx, def[k]);\n  });\n\n  return tx;\n};","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    marks = require('./marks');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._canvas = d3.select(el).select(\"canvas.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  \n  // add event listeners\n  var canvas = this._canvas, that = this;\n  events.forEach(function(type) {\n    canvas.addEventListener(type, function(evt) {\n      prototype[type].call(that, evt);\n    });\n  });\n  \n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// setup events\nvar events = [\n  \"mousedown\",\n  \"mouseup\",\n  \"click\",\n  \"dblclick\",\n  \"wheel\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"mousewheel\",\n  \"touchstart\"\n];\nevents.forEach(function(type) {\n  prototype[type] = function(evt) {\n    this.fire(type, evt);\n  };\n});\nevents.push(\"mousemove\");\nevents.push(\"mouseout\");\nevents.push(\"touchmove\");\nevents.push(\"touchend\");\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nprototype.touchmove = prototype.mousemove = function(evt) {\n  var pad = this._padding,\n      b = evt.target.getBoundingClientRect(),\n      x = evt.clientX - b.left,\n      y = evt.clientY - b.top,\n      a = this._active,\n      p = this.pick(this._model.scene(), x, y, x-pad.left, y-pad.top);\n\n  if (p === a) {\n    this.fire(\"mousemove\", evt);\n    if(evt.type == \"touchmove\") this.fire(\"touchmove\", evt);\n    return;\n  } else if (a) {\n    this.fire(\"mouseout\", evt);\n    if(evt.type == \"touchend\") this.fire(\"touchend\", evt);\n  }\n  this._active = p;\n  if (p) {\n    this.fire(\"mouseover\", evt);\n    if(evt.type == \"touchstart\") this.fire(\"touchstart\", evt);\n  }\n};\n\nprototype.touchend = prototype.mouseout = function(evt) {\n  if (this._active) {\n    this.fire(\"mouseout\", evt);\n    this.fire(\"touchend\", evt);\n  }\n  this._active = null;\n};\n\n// to keep firefox happy\nprototype.DOMMouseScroll = function(evt) {\n  this.fire(\"mousewheel\", evt);\n};\n\n// fire an event\nprototype.fire = function(type, evt) {\n  var a = this._active,\n      h = this._handlers[type];\n  if (h) {\n    for (var i=0, len=h.length; i<len; ++i) {\n      h[i].handler.call(this._obj, evt, a);\n    }\n  }\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers;\n  h = h[name] || (h[name] = []);\n  h.push({\n    type: type,\n    handler: handler\n  });\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name];\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) h.splice(i, 1);\n  }\n  return this;\n};\n\n// retrieve the current canvas context\nprototype.context = function() {\n  return this._canvas.getContext(\"2d\");\n};\n\n// find the scenegraph item at the current mouse position\n// x, y -- the absolute x, y mouse coordinates on the canvas element\n// gx, gy -- the relative coordinates within the current group\nprototype.pick = function(scene, x, y, gx, gy) {\n  var g = this.context(),\n      marktype = scene.marktype,\n      picker = marks.pick[marktype];\n  return picker.call(this, g, scene, x, y, gx, gy);\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    Bounds = require('../../core/Bounds'),\n    config = require('../../util/config'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._ctx = null;\n  this._el = null;\n  this._imgload = 0;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n  \n  if (!el) return this; // early exit if no DOM element\n\n  // select canvas element\n  var canvas = d3.select(el)\n    .selectAll(\"canvas.marks\")\n    .data([1]);\n  \n  // create new canvas element if needed\n  canvas.enter()\n    .append(\"canvas\")\n    .attr(\"class\", \"marks\");\n  \n  // remove extraneous canvas if needed\n  canvas.exit().remove();\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  if (this._el) {\n    var canvas = d3.select(this._el).select(\"canvas.marks\");\n\n    // initialize canvas attributes\n    canvas\n      .attr(\"width\", width + pad.left + pad.right)\n      .attr(\"height\", height + pad.top + pad.bottom);\n\n    // get the canvas graphics context\n    var s;\n    this._ctx = canvas.node().getContext(\"2d\");\n    this._ctx._ratio = (s = scaleCanvas(canvas.node(), this._ctx) || 1);\n    this._ctx.setTransform(s, 0, 0, s, s*pad.left, s*pad.top);\n  }\n  \n  initializeLineDash(this._ctx);\n  return this;\n};\n\nfunction scaleCanvas(canvas, ctx) {\n  // get canvas pixel data\n  var devicePixelRatio = window.devicePixelRatio || 1,\n      backingStoreRatio = (\n        ctx.webkitBackingStorePixelRatio ||\n        ctx.mozBackingStorePixelRatio ||\n        ctx.msBackingStorePixelRatio ||\n        ctx.oBackingStorePixelRatio ||\n        ctx.backingStorePixelRatio) || 1,\n      ratio = devicePixelRatio / backingStoreRatio;\n\n  if (devicePixelRatio !== backingStoreRatio) {\n    var w = canvas.width, h = canvas.height;\n    // set actual and visible canvas size\n    canvas.setAttribute(\"width\", w * ratio);\n    canvas.setAttribute(\"height\", h * ratio);\n    canvas.style.width = w + 'px';\n    canvas.style.height = h + 'px';\n  }\n  return ratio;\n}\n\nfunction initializeLineDash(ctx) {\n  if (ctx.vgLineDash) return; // already set\n\n  var NODASH = [];\n  if (ctx.setLineDash) {\n    ctx.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };\n    ctx.vgLineDashOffset = function(off) { this.lineDashOffset = off; };\n  } else if (ctx.webkitLineDash !== undefined) {\n  \tctx.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };\n    ctx.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };\n  } else if (ctx.mozDash !== undefined) {\n    ctx.vgLineDash = function(dash) { this.mozDash = dash; };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  } else {\n    ctx.vgLineDash = function(dash) { /* unsupported */ };\n    ctx.vgLineDashOffset = function(off) { /* unsupported */ };\n  }\n}\n\nprototype.context = function(ctx) {\n  if (ctx) { this._ctx = ctx; return this; }\n  else return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.pendingImages = function() {\n  return this._imgload;\n};\n\nfunction translatedBounds(item, bounds) {\n  var b = new Bounds(bounds);\n  while ((item = item.mark.group) != null) {\n    b.translate(item.x || 0, item.y || 0);\n  }\n  return b;\n}\n  \nfunction getBounds(items) {\n  return !items ? null :\n    dl.array(items).reduce(function(b, item) {\n      return b.union(translatedBounds(item, item.bounds))\n              .union(translatedBounds(item, item['bounds:prev']));\n    }, new Bounds());  \n}\n\nfunction setBounds(g, bounds) {\n  var bbox = null;\n  if (bounds) {\n    bbox = (new Bounds(bounds)).round();\n    g.beginPath();\n    g.rect(bbox.x1, bbox.y1, bbox.width(), bbox.height());\n    g.clip();\n  }\n  return bbox;\n}\n\nprototype.render = function(scene, items) {\n  var g = this._ctx,\n      pad = this._padding,\n      w = this._width + pad.left + pad.right,\n      h = this._height + pad.top + pad.bottom,\n      bb = null, bb2;\n\n  // setup\n  this._scene = scene;\n  g.save();\n  bb = setBounds(g, getBounds(items));\n  g.clearRect(-pad.left, -pad.top, w, h);\n\n  // render\n  this.draw(g, scene, bb);\n\n  // render again to handle possible bounds change\n  if (items) {\n    g.restore();\n    g.save();\n    bb2 = setBounds(g, getBounds(items));\n    if (!bb.encloses(bb2)) {\n      g.clearRect(-pad.left, -pad.top, w, h);\n      this.draw(g, scene, bb2);\n    }\n  }\n  \n  // takedown\n  g.restore();\n  this._scene = null;\n};\n\nprototype.draw = function(ctx, scene, bounds) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, bounds);\n};\n\nprototype.renderAsync = function(scene) {\n  // TODO make safe for multiple scene rendering?\n  var renderer = this;\n  if (renderer._async_id) {\n    clearTimeout(renderer._async_id);\n  }\n  renderer._async_id = setTimeout(function() {\n    renderer.render(scene);\n    delete renderer._async_id;\n  }, 50);\n};\n\nprototype.loadImage = function(uri) {\n  var renderer = this,\n      scene = renderer._scene,\n      image = null, url;\n\n  renderer._imgload += 1;\n  if (dl.isNode) {\n    image = new ((typeof window !== \"undefined\" ? window.canvas : typeof global !== \"undefined\" ? global.canvas : null).Image)();\n    dl.load(dl.extend({url: uri}, config.load), function(err, data) {\n      if (err) { dl.error(err); return; }\n      image.src = data;\n      image.loaded = true;\n      renderer._imgload -= 1;\n    });\n  } else {\n    image = new Image();\n    url = config.baseURL + uri;\n    image.onload = function() {\n      image.loaded = true;\n      renderer._imgload -= 1;\n      renderer.renderAsync(scene);\n    };\n    image.src = url;\n  }\n\n  return image;\n};\n\nmodule.exports = renderer;","module.exports = {\n  Handler:  require('./Handler'),\n  Renderer: require('./Renderer')\n};","var Bounds = require('../../core/Bounds'),\n    boundsCalc = require('../../util/bounds'),\n    config = require('../../util/config'),\n    path = require('./path');\n\nvar parsePath = path.parse,\n    renderPath = path.render,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    tmpBounds = new Bounds();\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\n// path generators\n\nfunction arcPath(g, o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - Math.PI/2,\n      ea = (o.endAngle || 0) - Math.PI/2;\n  g.beginPath();\n  if (ir === 0) g.moveTo(x, y);\n  else g.arc(x, y, ir, sa, ea, 0);\n  g.arc(x, y, or, ea, sa, 1);\n  g.closePath();\n}\n\nfunction areaPath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.area(items)));\n  renderPath(g, p);\n}\n\nfunction linePath(g, items) {\n  var o = items[0],\n      m = o.mark,\n      p = m.pathCache || (m.pathCache = parsePath(path.line(items)));\n  renderPath(g, p);\n}\n\nfunction pathPath(g, o) {\n  if (o.path == null) return;\n  var p = o.pathCache || (o.pathCache = parsePath(o.path));\n  return renderPath(g, p, o.x, o.y);\n}\n\nfunction symbolPath(g, o) {\n  g.beginPath();\n  var size = o.size != null ? o.size : 100,\n      x = o.x, y = o.y, r, t, rx, ry;\n\n  if (o.shape == null || o.shape === \"circle\") {\n    r = Math.sqrt(size/Math.PI);\n    g.arc(x, y, r, 0, 2*Math.PI, 0);\n    g.closePath();\n    return;\n  }\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      g.moveTo(x-t, y-r);\n      g.lineTo(x-r, y-r);\n      g.lineTo(x-r, y-t);\n      g.lineTo(x+r, y-t);\n      g.lineTo(x+r, y-r);\n      g.lineTo(x+t, y-r);\n      g.lineTo(x+t, y+r);\n      g.lineTo(x+r, y+r);\n      g.lineTo(x+r, y+t);\n      g.lineTo(x-r, y+t);\n      g.lineTo(x-r, y+r);\n      g.lineTo(x-t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y);\n      g.lineTo(x, y+ry);\n      g.lineTo(x-rx, y);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      g.rect(x-r, y-r, t, t);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y+ry);\n      g.lineTo(x+rx, y-ry);\n      g.lineTo(x-rx, y-ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      g.moveTo(x, y-ry);\n      g.lineTo(x+rx, y+ry);\n      g.lineTo(x-rx, y+ry);\n  }\n  g.closePath();\n}\n\nfunction lineStroke(g, items) {\n  var o = items[0],\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  linePath(g, items);\n}\n\nfunction ruleStroke(g, o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0,\n      x2 = o.x2 != null ? o.x2 : x1,\n      y2 = o.y2 != null ? o.y2 : y1,\n      lw = o.strokeWidth,\n      lc = o.strokeCap;\n\n  g.lineWidth = lw != null ? lw : config.render.lineWidth;\n  g.lineCap   = lc != null ? lc : config.render.lineCap;\n  g.beginPath();\n  g.moveTo(x1, y1);\n  g.lineTo(x2, y2);\n}\n\n// drawing functions\n\nfunction drawPathOne(path, g, o, items) {\n  var fill = o.fill, stroke = o.stroke, opac, lc, lw;\n\n  path(g, items);\n\n  opac = o.opacity == null ? 1 : o.opacity;\n  if (opac == 0 || !fill && !stroke) return;\n\n  if (fill) {\n    g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n    g.fillStyle = color(g, o, fill);\n    g.fill();\n  }\n\n  if (stroke) {\n    lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n    if (lw > 0) {\n      g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n      g.strokeStyle = color(g, o, stroke);\n      g.lineWidth = lw;\n      g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n      g.vgLineDash(o.strokeDash || null);\n      g.vgLineDashOffset(o.strokeDashOffset || 0);\n      g.stroke();\n    }\n  }\n}\n\nfunction drawPathAll(path, g, scene, bounds) {\n  var i, len, item;\n  for (i=0, len=scene.items.length; i<len; ++i) {\n    item = scene.items[i];\n    if (bounds && !bounds.intersects(item.bounds))\n      continue; // bounds check\n    drawPathOne(path, g, item, item);\n  }\n}\n\nfunction drawRect(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lc, lw, x, y, w, h;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x = o.x || 0;\n    y = o.y || 0;\n    w = o.width || 0;\n    h = o.height || 0;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillRect(x, y, w, h);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.strokeRect(x, y, w, h);\n      }\n    }\n  }\n}\n\nfunction drawRule(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, stroke, opac, lc, lw, x1, y1, x2, y2;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    x1 = o.x || 0;\n    y1 = o.y || 0;\n    x2 = o.x2 != null ? o.x2 : x1;\n    y2 = o.y2 != null ? o.y2 : y1;\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n    \n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : config.render.lineWidth;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(g, o, stroke);\n        g.lineWidth = lw;\n        g.lineCap = (lc = o.strokeCap) != null ? lc : config.render.lineCap;\n        g.vgLineDash(o.strokeDash || null);\n        g.vgLineDashOffset(o.strokeDashOffset || 0);\n        g.beginPath();\n        g.moveTo(x1, y1);\n        g.lineTo(x2, y2);\n        g.stroke();\n      }\n    }\n  }\n}\n\nfunction drawImage(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var renderer = this,\n      items = scene.items, o;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    if (!(o.image && o.image.url === o.url)) {\n      o.image = renderer.loadImage(o.url);\n      o.image.url = o.url;\n    }\n\n    var x, y, w, h, opac;\n    w = o.width || (o.image && o.image.width) || 0;\n    h = o.height || (o.image && o.image.height) || 0;\n    x = (o.x||0) - (o.align === \"center\"\n      ? w/2 : (o.align === \"right\" ? w : 0));\n    y = (o.y||0) - (o.baseline === \"middle\"\n      ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n\n    if (o.image.loaded) {\n      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;\n      g.drawImage(o.image, x, y, w, h);\n    }\n  }\n}\n\nfunction drawText(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items,\n      o, fill, stroke, opac, lw, x, y, r, t;\n\n  for (var i=0, len=items.length; i<len; ++i) {\n    o = items[i];\n    if (bounds && !bounds.intersects(o.bounds))\n      continue; // bounds check\n\n    g.font = fontString(o);\n    g.textAlign = o.align || \"left\";\n    g.textBaseline = o.baseline || \"alphabetic\";\n\n    opac = o.opacity == null ? 1 : o.opacity;\n    if (opac == 0) continue;\n\n    x = o.x || 0;\n    y = o.y || 0;\n    if (r = o.radius) {\n      t = (o.theta || 0) - Math.PI/2;\n      x += r * Math.cos(t);\n      y += r * Math.sin(t);\n    }\n\n    if (o.angle) {\n      g.save();\n      g.translate(x, y);\n      g.rotate(o.angle * Math.PI/180);\n      x = o.dx || 0;\n      y = o.dy || 0;\n    } else {\n      x += (o.dx || 0);\n      y += (o.dy || 0);\n    }\n\n    if (fill = o.fill) {\n      g.globalAlpha = opac * (o.fillOpacity==null ? 1 : o.fillOpacity);\n      g.fillStyle = color(g, o, fill);\n      g.fillText(o.text, x, y);\n    }\n\n    if (stroke = o.stroke) {\n      lw = (lw = o.strokeWidth) != null ? lw : 1;\n      if (lw > 0) {\n        g.globalAlpha = opac * (o.strokeOpacity==null ? 1 : o.strokeOpacity);\n        g.strokeStyle = color(o, stroke);\n        g.lineWidth = lw;\n        g.strokeText(o.text, x, y);\n      }\n    }\n\n    if (o.angle) g.restore();\n  }\n}\n\nfunction drawAll(pathFunc) {\n  return function(g, scene, bounds) {\n    drawPathAll(pathFunc, g, scene, bounds);\n  }\n}\n\nfunction drawOne(pathFunc) {\n  return function(g, scene, bounds) {\n    if (!scene.items.length) return;\n    if (bounds && !bounds.intersects(scene.items[0].bounds))\n      return; // bounds check\n    drawPathOne(pathFunc, g, scene.items[0], scene.items);\n  }\n}\n\nfunction drawGroup(g, scene, bounds) {\n  if (!scene.items.length) return;\n  var items = scene.items, group, axes, legends,\n      renderer = this, gx, gy, gb, i, n, j, m;\n\n  drawRect(g, scene, bounds);\n\n  for (i=0, n=items.length; i<n; ++i) {\n    group = items[i];\n    axes = group.axisItems || [];\n    legends = group.legendItems || [];\n    gx = group.x || 0;\n    gy = group.y || 0;\n\n    // render group contents\n    g.save();\n    g.translate(gx, gy);\n    if (group.clip) {\n      g.beginPath();\n      g.rect(0, 0, group.width || 0, group.height || 0);\n      g.clip();\n    }\n    \n    if (bounds) bounds.translate(-gx, -gy);\n    \n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=group.items.length; j<m; ++j) {\n      renderer.draw(g, group.items[j], bounds);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        renderer.draw(g, axes[j], bounds);\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      renderer.draw(g, legends[j], bounds);\n    }\n    \n    if (bounds) bounds.translate(gx, gy);\n    g.restore();\n  }    \n}\n\nfunction color(g, o, value) {\n  return (value.id)\n    ? gradient(g, value, o.bounds)\n    : value;\n}\n\nfunction gradient(g, p, b) {\n  var w = b.width(),\n      h = b.height(),\n      x1 = b.x1 + p.x1 * w,\n      y1 = b.y1 + p.y1 * h,\n      x2 = b.x1 + p.x2 * w,\n      y2 = b.y1 + p.y2 * h,\n      grad = g.createLinearGradient(x1, y1, x2, y2),\n      stop = p.stops,\n      i, n;\n\n  for (i=0, n=stop.length; i<n; ++i) {\n    grad.addColorStop(stop[i].offset, stop[i].color);\n  }\n  return grad;\n}\n\n// hit testing\n\nfunction pickGroup(g, scene, x, y, gx, gy) {\n  if (scene.items.length === 0 ||\n      scene.bounds && !scene.bounds.contains(gx, gy)) {\n    return false;\n  }\n  var items = scene.items, subscene, group, hit, dx, dy,\n      handler = this, i, j;\n\n  for (i=items.length; --i>=0;) {\n    group = items[i];\n    dx = group.x || 0;\n    dy = group.y || 0;\n\n    g.save();\n    g.translate(dx, dy);\n    for (j=group.items.length; --j >= 0;) {\n      subscene = group.items[j];\n      if (subscene.interactive === false) continue;\n      hit = handler.pick(subscene, x, y, gx-dx, gy-dy);\n      if (hit) {\n        g.restore();\n        return hit;\n      }\n    }\n    g.restore();\n  }\n\n  return scene.interactive\n    ? pickAll(hitTests.group, g, scene, x, y, gx, gy)\n    : false;\n}\n\nfunction pickAll(test, g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var o, b, i;\n\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n\n  for (i=scene.items.length; --i >= 0;) {\n    o = scene.items[i]; b = o.bounds;\n    // first hit test against bounding box\n    if ((b && !b.contains(gx, gy)) || !b) continue;\n    // if in bounding box, perform more careful test\n    if (test(g, o, x, y, gx, gy)) return o;\n  }\n  return false;\n}\n\nfunction pickArea(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.area(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pickLine(g, scene, x, y, gx, gy) {\n  if (!scene.items.length) return false;\n  var items = scene.items,\n      o, b, i, di, dd, od, dx, dy;\n\n  b = items[0].bounds;\n  if (b && !b.contains(gx, gy)) return false;\n  if (g._ratio !== 1) {\n    x *= g._ratio;\n    y *= g._ratio;\n  }\n  if (!hitTests.line(g, items, x, y)) return false;\n  return items[0];\n}\n\nfunction pick(test) {\n  return function (g, scene, x, y, gx, gy) {\n    return pickAll(test, g, scene, x, y, gx, gy);\n  };\n}\n\nfunction textHit(g, o, x, y, gx, gy) {\n  if (!o.fontSize) return false;\n  if (!o.angle) return true; // bounds sufficient if no rotation\n\n  var b = boundsCalc.text(o, tmpBounds, true),\n      a = -o.angle * Math.PI / 180,\n      cos = Math.cos(a),\n      sin = Math.sin(a),\n      x = o.x,\n      y = o.y,\n      px = cos*gx - sin*gy + (x - x*cos + y*sin),\n      py = sin*gx + cos*gy + (y - x*sin - y*cos);\n\n  return b.contains(px, py);\n}\n\nvar hitTests = {\n  text:   textHit,\n  rect:   function(g,o,x,y) { return true; }, // bounds test is sufficient\n  image:  function(g,o,x,y) { return true; }, // bounds test is sufficient\n  group:  function(g,o,x,y) { return o.fill || o.stroke; },\n  rule:   function(g,o,x,y) {\n            if (!g.isPointInStroke) return false;\n            ruleStroke(g,o); return g.isPointInStroke(x,y);\n          },\n  line:   function(g,s,x,y) {\n            if (!g.isPointInStroke) return false;\n            lineStroke(g,s); return g.isPointInStroke(x,y);\n          },\n  arc:    function(g,o,x,y) { arcPath(g,o);  return g.isPointInPath(x,y); },\n  area:   function(g,s,x,y) { areaPath(g,s); return g.isPointInPath(x,y); },\n  path:   function(g,o,x,y) { pathPath(g,o); return g.isPointInPath(x,y); },\n  symbol: function(g,o,x,y) { symbolPath(g,o); return g.isPointInPath(x,y); }\n};\n\nmodule.exports = {\n  draw: {\n    group:   drawGroup,\n    area:    drawOne(areaPath),\n    line:    drawOne(linePath),\n    arc:     drawAll(arcPath),\n    path:    drawAll(pathPath),\n    symbol:  drawAll(symbolPath),\n    rect:    drawRect,\n    rule:    drawRule,\n    text:    drawText,\n    image:   drawImage,\n    drawOne: drawOne, // expose for extensibility\n    drawAll: drawAll  // expose for extensibility\n  },\n  pick: {\n    group:   pickGroup,\n    area:    pickArea,\n    line:    pickLine,\n    arc:     pick(hitTests.arc),\n    path:    pick(hitTests.path),\n    symbol:  pick(hitTests.symbol),\n    rect:    pick(hitTests.rect),\n    rule:    pick(hitTests.rule),\n    text:    pick(hitTests.text),\n    image:   pick(hitTests.image),\n    pickAll: pickAll  // expose for extensibility\n  }\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../../core/Bounds');\n\n// Path parsing and rendering code taken from fabric.js -- Thanks!\nvar cmdLength = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },\n    re = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\\d)-/g, /\\s|,|###/];\n\nfunction parse(path) {\n  var result = [],\n      currentPath,\n      chunks,\n      parsed;\n\n  // First, break path into command sequence\n  path = path.slice().replace(re[0], '###$1').split(re[1]).slice(1);\n\n  // Next, parse each command in turn\n  for (var i=0, j, chunksParsed, len=path.length; i<len; i++) {\n    currentPath = path[i];\n    chunks = currentPath.slice(1).trim().replace(re[2],'$1###-').split(re[3]);\n    chunksParsed = [currentPath.charAt(0)];\n\n    for (var j = 0, jlen = chunks.length; j < jlen; j++) {\n      parsed = parseFloat(chunks[j]);\n      if (!isNaN(parsed)) {\n        chunksParsed.push(parsed);\n      }\n    }\n\n    var command = chunksParsed[0].toLowerCase(),\n        commandLength = cmdLength[command];\n\n    if (chunksParsed.length - 1 > commandLength) {\n      for (var k = 1, klen = chunksParsed.length; k < klen; k += commandLength) {\n        result.push([ chunksParsed[0] ].concat(chunksParsed.slice(k, k + commandLength)));\n      }\n    }\n    else {\n      result.push(chunksParsed);\n    }\n  }\n\n  return result;\n}\n\nfunction drawArc(g, x, y, coords, bounds, l, t) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    g.bezierCurveTo.apply(g, bez);\n    bounds.add(bez[0]-l, bez[1]-t);\n    bounds.add(bez[2]-l, bez[3]-t);\n    bounds.add(bez[4]-l, bez[5]-t);\n  }\n}\n\nfunction boundArc(x, y, coords, bounds) {\n  var rx = coords[0];\n  var ry = coords[1];\n  var rot = coords[2];\n  var large = coords[3];\n  var sweep = coords[4];\n  var ex = coords[5];\n  var ey = coords[6];\n  var segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);\n  for (var i=0; i<segs.length; i++) {\n    var bez = segmentToBezier.apply(null, segs[i]);\n    bounds.add(bez[0], bez[1]);\n    bounds.add(bez[2], bez[3]);\n    bounds.add(bez[4], bez[5]);\n  }\n}\n\nvar arcToSegmentsCache = { },\n    segmentToBezierCache = { },\n    join = Array.prototype.join,\n    argsStr;\n\n// Copied from Inkscape svgtopdf, thanks!\nfunction arcToSegments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {\n  argsStr = join.call(arguments);\n  if (arcToSegmentsCache[argsStr]) {\n    return arcToSegmentsCache[argsStr];\n  }\n\n  var th = rotateX * (Math.PI/180);\n  var sin_th = Math.sin(th);\n  var cos_th = Math.cos(th);\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;\n  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;\n  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);\n  if (pl > 1) {\n    pl = Math.sqrt(pl);\n    rx *= pl;\n    ry *= pl;\n  }\n\n  var a00 = cos_th / rx;\n  var a01 = sin_th / rx;\n  var a10 = (-sin_th) / ry;\n  var a11 = (cos_th) / ry;\n  var x0 = a00 * ox + a01 * oy;\n  var y0 = a10 * ox + a11 * oy;\n  var x1 = a00 * x + a01 * y;\n  var y1 = a10 * x + a11 * y;\n\n  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);\n  var sfactor_sq = 1 / d - 0.25;\n  if (sfactor_sq < 0) sfactor_sq = 0;\n  var sfactor = Math.sqrt(sfactor_sq);\n  if (sweep == large) sfactor = -sfactor;\n  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);\n  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);\n\n  var th0 = Math.atan2(y0-yc, x0-xc);\n  var th1 = Math.atan2(y1-yc, x1-xc);\n\n  var th_arc = th1-th0;\n  if (th_arc < 0 && sweep == 1){\n    th_arc += 2*Math.PI;\n  } else if (th_arc > 0 && sweep == 0) {\n    th_arc -= 2 * Math.PI;\n  }\n\n  var segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));\n  var result = [];\n  for (var i=0; i<segments; i++) {\n    var th2 = th0 + i * th_arc / segments;\n    var th3 = th0 + (i+1) * th_arc / segments;\n    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];\n  }\n\n  return (arcToSegmentsCache[argsStr] = result);\n}\n\nfunction segmentToBezier(cx, cy, th0, th1, rx, ry, sin_th, cos_th) {\n  argsStr = join.call(arguments);\n  if (segmentToBezierCache[argsStr]) {\n    return segmentToBezierCache[argsStr];\n  }\n\n  var a00 = cos_th * rx;\n  var a01 = -sin_th * ry;\n  var a10 = sin_th * rx;\n  var a11 = cos_th * ry;\n\n  var cos_th0 = Math.cos(th0);\n  var sin_th0 = Math.sin(th0);\n  var cos_th1 = Math.cos(th1);\n  var sin_th1 = Math.sin(th1);\n\n  var th_half = 0.5 * (th1 - th0);\n  var sin_th_h2 = Math.sin(th_half * 0.5);\n  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);\n  var x1 = cx + cos_th0 - t * sin_th0;\n  var y1 = cy + sin_th0 + t * cos_th0;\n  var x3 = cx + cos_th1;\n  var y3 = cy + sin_th1;\n  var x2 = x3 + t * sin_th1;\n  var y2 = y3 - t * cos_th1;\n\n  return (segmentToBezierCache[argsStr] = [\n    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,\n    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,\n    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3\n  ]);\n}\n\nfunction render(g, path, l, t) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY,\n      bounds = new Bounds();\n  if (l == undefined) l = 0;\n  if (t == undefined) t = 0;\n\n  g.beginPath();\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        g.lineTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        g.moveTo(x + l, y + t);\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        g.bezierCurveTo(\n          x + current[1] + l, // x1\n          y + current[2] + t, // y1\n          controlX + l, // x2\n          controlY + t, // y2\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        g.bezierCurveTo(\n          current[1] + l,\n          current[2] + t,\n          controlX + l,\n          controlY + t,\n          x + l,\n          y + t\n        );\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          x + current[1] + l,\n          y + current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        g.bezierCurveTo(\n          controlX + l,\n          controlY + t,\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        g.quadraticCurveTo(\n          current[1] + l,\n          current[2] + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        g.quadraticCurveTo(\n          controlX + l,\n          controlY + t,\n          tempX + l,\n          tempY + t\n        );\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x + l,\n          current[7] + y + t\n        ], bounds, l, t);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        drawArc(g, x + l, y + t, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + l,\n          current[7] + t\n        ], bounds, l, t);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        g.closePath();\n        break;\n    }\n    previous = current;\n  }\n  return bounds.translate(l, t);\n}\n\nfunction bounds(path, bounds) {\n  var current, // current instruction\n      previous = null,\n      x = 0, // current x\n      y = 0, // current y\n      controlX = 0, // current control point x\n      controlY = 0, // current control point y\n      tempX,\n      tempY,\n      tempControlX,\n      tempControlY;\n\n  for (var i=0, len=path.length; i<len; ++i) {\n    current = path[i];\n\n    switch (current[0]) { // first letter\n\n      case 'l': // lineto, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'L': // lineto, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'h': // horizontal lineto, relative\n        x += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'H': // horizontal lineto, absolute\n        x = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'v': // vertical lineto, relative\n        y += current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'V': // verical lineto, absolute\n        y = current[1];\n        bounds.add(x, y);\n        break;\n\n      case 'm': // moveTo, relative\n        x += current[1];\n        y += current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'M': // moveTo, absolute\n        x = current[1];\n        y = current[2];\n        bounds.add(x, y);\n        break;\n\n      case 'c': // bezierCurveTo, relative\n        tempX = x + current[5];\n        tempY = y + current[6];\n        controlX = x + current[3];\n        controlY = y + current[4];\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'C': // bezierCurveTo, absolute\n        x = current[5];\n        y = current[6];\n        controlX = current[3];\n        controlY = current[4];\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(x, y);\n        break;\n\n      case 's': // shorthand cubic bezierCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n        bounds.add(controlX, controlY);\n        bounds.add(x + current[1], y + current[2]);\n        bounds.add(tempX, tempY);\n\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        break;\n\n      case 'S': // shorthand cubic bezierCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n        // calculate reflection of previous control points\n        controlX = 2*x - controlX;\n        controlY = 2*y - controlY;\n        x = tempX;\n        y = tempY;\n        bounds.add(current[1], current[2]);\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        // set control point to 2nd one of this command\n        // \"... the first control point is assumed to be the reflection of the second control point on the previous command relative to the current point.\"\n        controlX = current[1];\n        controlY = current[2];\n\n        break;\n\n      case 'q': // quadraticCurveTo, relative\n        // transform to absolute x,y\n        tempX = x + current[3];\n        tempY = y + current[4];\n\n        controlX = x + current[1];\n        controlY = y + current[2];\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'Q': // quadraticCurveTo, absolute\n        tempX = current[3];\n        tempY = current[4];\n\n        x = tempX;\n        y = tempY;\n        controlX = current[1];\n        controlY = current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 't': // shorthand quadraticCurveTo, relative\n\n        // transform to absolute x,y\n        tempX = x + current[1];\n        tempY = y + current[2];\n\n        if (previous[0].match(/[QqTt]/) === null) {\n          // If there is no previous command or if the previous command was not a Q, q, T or t,\n          // assume the control point is coincident with the current point\n          controlX = x;\n          controlY = y;\n        }\n        else if (previous[0] === 't') {\n          // calculate reflection of previous control points for t\n          controlX = 2 * x - tempControlX;\n          controlY = 2 * y - tempControlY;\n        }\n        else if (previous[0] === 'q') {\n          // calculate reflection of previous control points for q\n          controlX = 2 * x - controlX;\n          controlY = 2 * y - controlY;\n        }\n\n        tempControlX = controlX;\n        tempControlY = controlY;\n\n        x = tempX;\n        y = tempY;\n        controlX = x + current[1];\n        controlY = y + current[2];\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'T':\n        tempX = current[1];\n        tempY = current[2];\n\n        // calculate reflection of previous control points\n        controlX = 2 * x - controlX;\n        controlY = 2 * y - controlY;\n\n        x = tempX;\n        y = tempY;\n        bounds.add(controlX, controlY);\n        bounds.add(tempX, tempY);\n        break;\n\n      case 'a':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6] + x,\n          current[7] + y\n        ], bounds);\n        x += current[6];\n        y += current[7];\n        break;\n\n      case 'A':\n        boundArc(x, y, [\n          current[1],\n          current[2],\n          current[3],\n          current[4],\n          current[5],\n          current[6],\n          current[7]\n        ], bounds);\n        x = current[6];\n        y = current[7];\n        break;\n\n      case 'z':\n      case 'Z':\n        break;\n    }\n    previous = current;\n  }\n  return bounds;\n}\n\nfunction area(items) {\n  var o = items[0];\n  var area = d3.svg.area()\n    .x(function(d) { return d.x; })\n    .y1(function(d) { return d.y; })\n    .y0(function(d) { return d.y + d.height; });\n  if (o.interpolate) area.interpolate(o.interpolate);\n  if (o.tension != null) area.tension(o.tension);\n  return area(items);\n}\n\nfunction line(items) {\n  var o = items[0];\n  var line = d3.svg.line()\n   .x(function(d) { return d.x; })\n   .y(function(d) { return d.y; });\n  if (o.interpolate) line.interpolate(o.interpolate);\n  if (o.tension != null) line.tension(o.tension);\n  return line(items);\n}\n\nmodule.exports = {\n  parse:  parse,\n  render: render,\n  bounds: bounds,\n  area:   area,\n  line:   line\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config'),\n    SVGBuilder = require('./svg');\n\nvar renderer = function() {\n  this._builder = null;\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._builder = new SVGBuilder();\n  return this.resize(width, height, pad);\n}\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad || {top:0, left:0, bottom:0, right:0};\n  this._autopad = dl.isString(this._padding) ? 1 : 0;\n\n  var w = this._width, h = this._height, pad = this._padding;\n  \n  // (re-)configure builder size\n  this._builder.initialize(null, w, h, pad);\n\n  return this;\n};\n\nprototype.render = function(scene, items) {\n  // headless always draws the entire scene, ignoring items\n  this._builder.render(scene);\n  return this;\n};\n\nprototype.svg = function() {\n  return this._builder.svg();\n};\n\nmodule.exports = renderer;\n","module.exports = {\n  Renderer: require('./Renderer')\n};\n","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../../util/config');\n\nvar renderer = function() {\n  this._gid = 0; // group id counter for d3 dom compat\n  this._text = {\n    head: \"\",\n    root: \"\",\n    foot: \"\",\n    defs: \"\",\n    body: \"\"\n  };\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nfunction open(tag, attr, raw) {\n  var s = \"<\" + tag;\n  if (attr) {\n    for (var key in attr) {\n      var val = attr[key];\n      if (val != null) {\n        s += \" \" + key + '=\"' + val + '\"';\n      }\n    }\n  }\n  if (raw) s += \" \" + raw;\n  return s + \">\";\n}\n\nfunction close(tag) {\n  return \"</\" + tag + \">\";\n}\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, w, h, pad) {\n  var t = this._text;\n\n  t.head = open('svg', {\n    \"class\": 'marks',\n    width: w + pad.left + pad.right,\n    height: h + pad.top + pad.bottom,\n  }, config.svgNamespace);\n\n  t.root = open('g', {\n    transform: 'translate(' + pad.left + ',' + pad.top + ')'\n  });\n\n  t.foot = close('g') + close('svg');\n};\n\nprototype.svg = function() {\n  var t = this._text;\n  return t.head + t.defs + t.root + t.body + t.foot;\n};\n\nprototype.buildDefs = function() {\n  var all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = \"\", grad, clip, i, j;\n\n  for (i=0; i<dgrad.length; ++i) {\n    var id = dgrad[i],\n        def = all.gradient[id],\n        stops = def.stops;\n\n    defs += open(\"linearGradient\", {\n      id: id,\n      x1: def.x1,\n      x2: def.x2,\n      y1: def.y1,\n      y2: def.y2\n    });\n    \n    for (j=0; j<stops.length; ++j) {\n      defs += open(\"stop\", {\n        offset: stops[j].offset,\n        \"stop-color\": stops[j].color\n      }) + close(\"stop\");\n    }\n    \n    defs += close(\"linearGradient\");\n  }\n  \n  for (i=0; i<dclip.length; ++i) {\n    var id = dclip[i],\n        def = all.clipping[id];\n\n    defs += open(\"clipPath\", {id: id});\n\n    defs += open(\"rect\", {\n      x: 0,\n      y: 0,\n      width: def.width,\n      height: def.height\n    }) + close(\"rect\");\n\n    defs += close(\"clipPath\");\n  }\n  \n  if (defs.length > 0) {\n    return open(\"defs\") + defs + close(\"defs\");\n  } else {\n    return \"\"\n  }\n  return defs;\n};\n\nprototype.render = function(scene) {\n  this._gid = 0; // reset the group counter\n  this._text.body = this.draw(scene);\n  this._text.defs = this.buildDefs();\n};\n\nprototype.draw = function(scene) {\n  var meta = MARKS[scene.marktype];\n  if (!meta) {\n    return; // no known marktype (e.g., an interactor)\n  }\n  var tag  = meta[0],\n      attr = meta[1],\n      nest = meta[2] || false,\n      data = nest ? [scene.items] : scene.items,\n      defs = this._defs,\n      svg = \"\", i, sty;\n\n  var cls = cssClass(scene.def);\n\n  // style literals to exactly match the d3 dom\n  var styl = null;\n  if (cls === 'type-rule' || cls === 'type-path')\n    styl = 'style=\"pointer-events: none;\"';\n  else if (cls !== 'type-group')\n    styl = 'style=\"\"';\n\n  svg += open('g', {\n    'id': 'g' + ++this._gid, // d3 dom compat\n    'class': cssClass(scene.def)\n  }, styl);\n\n  for (i=0; i<data.length; ++i) {\n    var sty = tag === 'g' ? null : style(data[i], tag, defs);\n    svg += open(tag, attr(data[i], defs), sty);\n    if (tag === 'text') svg += escape_text(data[i].text);\n    if (tag === 'g') svg += this.drawGroup(data[i]);\n    svg += close(tag);\n  }\n\n  return svg + close('g');\n};\n\nfunction escape_text(s) {\n  s = (s == null ? \"\" : String(s));\n  return s.replace(/&/g, '&amp;')\n          .replace(/</g, '&lt;')\n          .replace(/>/g, '&gt;');\n}\n\nfunction escape_font(s) {\n  return String(s).replace(/\\\"/g, \"'\");\n}\n\nvar MARKS = {\n  group:  ['g', group],\n  area:   ['path', area, true],\n  line:   ['path', line, true],\n  arc:    ['path', arc],\n  path:   ['path', path],\n  symbol: ['path', symbol],\n  rect:   ['rect', rect],\n  rule:   ['line', rule],\n  text:   ['text', text],\n  image:  ['image', image]\n};\n\nprototype.drawGroup = function(scene) {\n  var svg = \"\",\n      axes = scene.axisItems || [],\n      items = scene.items,\n      legends = scene.legendItems || [],\n      i, j, m;\n\n  svg += group_bg(scene);\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer === \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=items.length; j<m; ++j) {\n    svg += this.draw(items[j]);\n  }\n  for (j=0, m=axes.length; j<m; ++j) {\n    if (axes[j].def.layer !== \"back\") {\n      svg += this.draw(axes[j]);\n    }\n  }\n  for (j=0, m=legends.length; j<m; ++j) {\n    svg += this.draw(legends[j]);\n  }\n\n  return svg;\n};\n\n///\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n\n  var styl = o.mark.interactive === false ?\n    'style=\"pointer-events: none;\"' : \n    'style=\"\"';\n\n  return open('rect', {\n    'class': 'background'\n  }, styl) + close('rect');\n}\n\nfunction group(o, defs) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      attr = {transform: \"translate(\"+x+\",\"+y+\")\"};\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    defs.clipping[id] = c;\n    attr[\"clip-path\"] = \"url(#\"+id+\")\";\n  }\n\n  return attr;\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: arc_path(o)\n  };\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0],\n      path = o.orient === \"horizontal\" ? area_path_h : area_path_v;\n  path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: path(items)};\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  return {d: line_path(items)};\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: o.path\n  };\n}\n\nfunction rect(o) {\n  return {\n    x: o.x || 0,\n    y: o.y || 0,\n    width: o.width || 0,\n    height: o.height || 0\n  };\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  return {\n    x1: x1,\n    y1: y1,\n    x2: o.x2 != null ? o.x2 : x1,\n    y2: o.y2 != null ? o.y2 : y1\n  };\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  return {\n    transform: \"translate(\"+x+\",\"+y+\")\",\n    d: symbol_path(o)\n  };\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  return {\n    \"xlink:href\": url,\n    x: x,\n    y: y,\n    width: w,\n    height: h\n  };\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  return {\n    x: x + dx,\n    y: y + dy,\n    'text-anchor': align,\n    transform: a ? \"rotate(\"+a+\" \"+x+\",\"+y+\")\" : null,\n    dy: base ? base : null\n  };\n}\n\n///\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction xw(o)    { return o.x + o.width || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n\nvar arc_path    = d3.svg.arc(),\n    area_path_v = d3.svg.area().x(x).y1(y).y0(yh),\n    area_path_h = d3.svg.area().y(y).x0(xw).x1(x),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\n\nvar styleProps = dl.keys(styles);\n\nfunction style(d, tag, defs) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return null;\n\n  var s = \"\";\n\n  if (tag === 'text') {\n    s += 'font: ' + fontString(o) + ';';\n  }\n  \n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") s += 'fill: none;';\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        defs.gradient[value.id] = value;\n        value = \"url(\" + window.location.href + \"#\" + value.id + \")\";\n      }\n      s += (s.length ? ' ' : '') + name + ': ' + value + ';'\n    }\n  }\n  \n  // not that we don't exclude blank styles for d3 dom compat\n  return 'style=\"'+s+'\"';\n}\n\nfunction fontString(o) {\n  var f = (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font && escape_font(o.font) || config.render.font);\n  return f;\n}\n\nmodule.exports = renderer;\n","var dl = require('datalib');\n\nvar handler = function(el, model) {\n  this._active = null;\n  this._handlers = {};\n  if (el) this.initialize(el);\n  if (model) this.model(model);\n};\n\nfunction svgHandler(handler) {\n  var that = this;\n  return function(evt) {\n    var target = evt.target,\n        item = target.__data__;\n\n    if (item) item = item.mark ? item : item[0];\n    handler.call(that._obj, evt, item);\n  };\n}\n\nfunction eventName(name) {\n  var i = name.indexOf(\".\");\n  return i < 0 ? name : name.slice(0,i);\n}\n\nvar prototype = handler.prototype;\n\nprototype.initialize = function(el, pad, obj) {\n  this._el = d3.select(el).node();\n  this._svg = d3.select(el).select(\"svg.marks\").node();\n  this._padding = pad;\n  this._obj = obj || null;\n  return this;\n};\n\nprototype.padding = function(pad) {\n  this._padding = pad;\n  return this;\n};\n\nprototype.model = function(model) {\n  if (!arguments.length) return this._model;\n  this._model = model;\n  return this;\n};\n\nprototype.handlers = function() {\n  var h = this._handlers;\n  return dl.keys(h).reduce(function(a, k) {\n    return h[k].reduce(function(a, x) { return (a.push(x), a); }, a);\n  }, []);\n};\n\n// add an event handler\nprototype.on = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers,\n      dom = d3.select(this._svg).node();\n      \n  var x = {\n    type: type,\n    handler: handler,\n    svg: svgHandler.call(this, handler)\n  };\n  h = h[name] || (h[name] = []);\n  h.push(x);\n\n  dom.addEventListener(name, x.svg);\n  return this;\n};\n\n// remove an event handler\nprototype.off = function(type, handler) {\n  var name = eventName(type),\n      h = this._handlers[name],\n      dom = d3.select(this._svg).node();\n  if (!h) return;\n  for (var i=h.length; --i>=0;) {\n    if (h[i].type !== type) continue;\n    if (!handler || h[i].handler === handler) {\n      dom.removeEventListener(name, h[i].svg);\n      h.splice(i, 1);\n    }\n  }\n  return this;\n};\n\nmodule.exports = handler;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    marks = require('./marks');\n\nvar renderer = function() {\n  this._svg = null;\n  this._ctx = null;\n  this._el = null;\n  this._defs = {\n    gradient: {},\n    clipping: {}\n  };\n};\n\nvar prototype = renderer.prototype;\n\nprototype.initialize = function(el, width, height, pad) {\n  this._el = el;\n\n  // remove any existing svg element\n  d3.select(el).select(\"svg.marks\").remove();\n\n  // create svg element and initialize attributes\n  this._svg = d3.select(el)\n    .append(\"svg\")\n    .attr(\"class\", \"marks\");\n  \n  // set the svg root group\n  this._ctx = this._svg.append(\"g\");\n  \n  return this.resize(width, height, pad);\n};\n\nprototype.resize = function(width, height, pad) {\n  this._width = width;\n  this._height = height;\n  this._padding = pad;\n  \n  this._svg\n    .attr(\"width\", width + pad.left + pad.right)\n    .attr(\"height\", height + pad.top + pad.bottom);\n    \n  this._ctx\n    .attr(\"transform\", \"translate(\"+pad.left+\",\"+pad.top+\")\");\n\n  return this;\n};\n\nprototype.context = function() {\n  return this._ctx;\n};\n\nprototype.element = function() {\n  return this._el;\n};\n\nprototype.updateDefs = function() {\n  var svg = this._svg,\n      all = this._defs,\n      dgrad = dl.keys(all.gradient),\n      dclip = dl.keys(all.clipping),\n      defs = svg.select(\"defs\"), grad, clip;\n\n  // get or create svg defs block\n  if (dgrad.length===0 && dclip.length==0) { defs.remove(); return; }\n  if (defs.empty()) defs = svg.insert(\"defs\", \":first-child\");\n  \n  grad = defs.selectAll(\"linearGradient\").data(dgrad, dl.identity);\n  grad.enter().append(\"linearGradient\").attr(\"id\", dl.identity);\n  grad.exit().remove();\n  grad.each(function(id) {\n    var def = all.gradient[id],\n        grd = d3.select(this);\n\n    // set gradient coordinates\n    grd.attr({x1: def.x1, x2: def.x2, y1: def.y1, y2: def.y2});\n\n    // set gradient stops\n    stop = grd.selectAll(\"stop\").data(def.stops);\n    stop.enter().append(\"stop\");\n    stop.exit().remove();\n    stop.attr(\"offset\", function(d) { return d.offset; })\n        .attr(\"stop-color\", function(d) { return d.color; });\n  });\n  \n  clip = defs.selectAll(\"clipPath\").data(dclip, dl.identity);\n  clip.enter().append(\"clipPath\").attr(\"id\", dl.identity);\n  clip.exit().remove();\n  clip.each(function(id) {\n    var def = all.clipping[id],\n        cr = d3.select(this).selectAll(\"rect\").data([1]);\n    cr.enter().append(\"rect\");\n    cr.attr(\"x\", 0)\n      .attr(\"y\", 0)\n      .attr(\"width\", def.width)\n      .attr(\"height\", def.height);\n  });\n};\n\nprototype.render = function(scene, items) {\n  marks.current = this;\n\n  if (items) {\n    this.renderItems(dl.array(items));\n  } else {\n    this.draw(this._ctx, scene, -1);\n  }\n  this.updateDefs();\n\n delete marks.current;\n};\n\nprototype.renderItems = function(items) {\n  var item, node, type, nest, i, n;\n\n  for (i=0, n=items.length; i<n; ++i) {\n    item = items[i];\n    node = item._svg;\n    type = item.mark.marktype;\n\n    item = marks.nested[type] ? item.mark.items : item;\n    marks.update[type].call(node, item);\n    marks.style.call(node, item);\n  }\n}\n\nprototype.draw = function(ctx, scene, index) {\n  var marktype = scene.marktype,\n      renderer = marks.draw[marktype];\n  renderer.call(this, ctx, scene, index);\n};\n\nmodule.exports = renderer;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = require('../../util/config');\n\nfunction x(o)     { return o.x || 0; }\nfunction y(o)     { return o.y || 0; }\nfunction yh(o)    { return o.y + o.height || 0; }\nfunction key(o)   { return o.key; }\nfunction size(o)  { return o.size==null ? 100 : o.size; }\nfunction shape(o) { return o.shape || \"circle\"; }\n    \nvar arc_path    = d3.svg.arc(),\n    area_path   = d3.svg.area().x(x).y1(y).y0(yh),\n    line_path   = d3.svg.line().x(x).y(y),\n    symbol_path = d3.svg.symbol().type(shape).size(size);\n\nvar mark_id = 0,\n    clip_id = 0;\n\nvar textAlign = {\n  \"left\":   \"start\",\n  \"center\": \"middle\",\n  \"right\":  \"end\"\n};\n\nvar styles = {\n  \"fill\":             \"fill\",\n  \"fillOpacity\":      \"fill-opacity\",\n  \"stroke\":           \"stroke\",\n  \"strokeWidth\":      \"stroke-width\",\n  \"strokeOpacity\":    \"stroke-opacity\",\n  \"strokeCap\":        \"stroke-linecap\",\n  \"strokeDash\":       \"stroke-dasharray\",\n  \"strokeDashOffset\": \"stroke-dashoffset\",\n  \"opacity\":          \"opacity\"\n};\nvar styleProps = dl.keys(styles);\n\nfunction style(d) {\n  var i, n, prop, name, value,\n      o = d.mark ? d : d.length ? d[0] : null;\n  if (o === null) return;\n\n  for (i=0, n=styleProps.length; i<n; ++i) {\n    prop = styleProps[i];\n    name = styles[prop];\n    value = o[prop];\n\n    if (value == null) {\n      if (name === \"fill\") this.style.setProperty(name, \"none\", null);\n      else this.style.removeProperty(name);\n    } else {\n      if (value.id) {\n        // ensure definition is included\n        marks.current._defs.gradient[value.id] = value;\n        value = \"url(#\" + value.id + \")\";\n      }\n      this.style.setProperty(name, value+\"\", null);\n    }\n  }\n}\n\nfunction arc(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", arc_path(o));\n}\n\nfunction area(items) {\n  if (!items.length) return;\n  var o = items[0];\n  area_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", area_path(items));\n}\n\nfunction line(items) {\n  if (!items.length) return;\n  var o = items[0];\n  line_path\n    .interpolate(o.interpolate || \"linear\")\n    .tension(o.tension == null ? 0.7 : o.tension);\n  this.setAttribute(\"d\", line_path(items));\n}\n\nfunction path(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  if (o.path != null) this.setAttribute(\"d\", o.path);\n}\n\nfunction rect(o) {\n  this.setAttribute(\"x\", o.x || 0);\n  this.setAttribute(\"y\", o.y || 0);\n  this.setAttribute(\"width\", o.width || 0);\n  this.setAttribute(\"height\", o.height || 0);\n}\n\nfunction rule(o) {\n  var x1 = o.x || 0,\n      y1 = o.y || 0;\n  this.setAttribute(\"x1\", x1);\n  this.setAttribute(\"y1\", y1);\n  this.setAttribute(\"x2\", o.x2 != null ? o.x2 : x1);\n  this.setAttribute(\"y2\", o.y2 != null ? o.y2 : y1);\n}\n\nfunction symbol(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n  this.setAttribute(\"d\", symbol_path(o));\n}\n\nfunction image(o) {\n  var w = o.width || (o.image && o.image.width) || 0,\n      h = o.height || (o.image && o.image.height) || 0,\n      x = o.x - (o.align === \"center\"\n        ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = o.y - (o.baseline === \"middle\"\n        ? h/2 : (o.baseline === \"bottom\" ? h : 0)),\n      url = config.baseURL + o.url;\n  \n  this.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", url);\n  this.setAttribute(\"x\", x);\n  this.setAttribute(\"y\", y);\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n  \nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction text(o) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      dx = o.dx || 0,\n      dy = o.dy || 0,\n      a = o.angle || 0,\n      r = o.radius || 0,\n      align = textAlign[o.align || \"left\"],\n      base = o.baseline===\"top\" ? \".9em\"\n           : o.baseline===\"middle\" ? \".35em\" : 0;\n\n  if (r) {\n    var t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  this.setAttribute(\"x\", x + dx);\n  this.setAttribute(\"y\", y + dy);\n  this.setAttribute(\"text-anchor\", align);\n  \n  if (a) this.setAttribute(\"transform\", \"rotate(\"+a+\" \"+x+\",\"+y+\")\");\n  else this.removeAttribute(\"transform\");\n  \n  if (base) this.setAttribute(\"dy\", base);\n  else this.removeAttribute(\"dy\");\n  \n  this.textContent = o.text;\n  this.style.setProperty(\"font\", fontString(o), null);\n}\n\nfunction group(o) {\n  var x = o.x || 0,\n      y = o.y || 0;\n  this.setAttribute(\"transform\", \"translate(\"+x+\",\"+y+\")\");\n\n  if (o.clip) {\n    var c = {width: o.width || 0, height: o.height || 0},\n        id = o.clip_id || (o.clip_id = \"clip\" + clip_id++);\n    marks.current._defs.clipping[id] = c;\n    this.setAttribute(\"clip-path\", \"url(#\"+id+\")\");\n  }\n}\n\nfunction group_bg(o) {\n  var w = o.width || 0,\n      h = o.height || 0;\n  this.setAttribute(\"width\", w);\n  this.setAttribute(\"height\", h);\n}\n\nfunction cssClass(def) {\n  var cls = \"type-\" + def.type;\n  if (def.name) cls += \" \" + def.name;\n  return cls;\n}\n\nfunction draw(tag, attr, nest) {\n  return function(g, scene, index) {\n    drawMark(g, scene, index, \"mark_\", tag, attr, nest);\n  };\n}\n\nfunction drawMark(g, scene, index, prefix, tag, attr, nest) {\n  var data = nest ? [scene.items] : scene.items,\n      evts = scene.interactive===false ? \"none\" : null,\n      grps = g.node().childNodes,\n      notG = (tag !== \"g\"),\n      p = (p = grps[index+1]) // +1 to skip group background rect\n        ? d3.select(p)\n        : g.append(\"g\")\n           .attr(\"id\", \"g\"+(++mark_id))\n           .attr(\"class\", cssClass(scene.def));\n\n  var id = p.attr(\"id\"),\n      s = \"#\" + id + \" > \" + tag,\n      m = p.selectAll(s).data(data),\n      e = m.enter().append(tag);\n\n  if (notG) {\n    p.style(\"pointer-events\", evts);\n    e.each(function(d) {\n      if (d.mark) d._svg = this;\n      else if (d.length) d[0]._svg = this;\n    });\n  } else {\n    e.append(\"rect\").attr(\"class\",\"background\").style(\"pointer-events\",evts);\n  }\n  \n  m.exit().remove();\n  m.each(attr);\n  if (notG) m.each(style);\n  else p.selectAll(s+\" > rect.background\").each(group_bg).each(style);\n  \n  return p;\n}\n\nfunction drawGroup(g, scene, index, prefix) {    \n  var p = drawMark(g, scene, index, prefix || \"group_\", \"g\", group),\n      c = p.node().childNodes, n = c.length, i, j, m;\n  \n  for (i=0; i<n; ++i) {\n    var items = c[i].__data__.items,\n        legends = c[i].__data__.legendItems || [],\n        axes = c[i].__data__.axisItems || [],\n        sel = d3.select(c[i]),\n        idx = 0;\n\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer === \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=items.length; j<m; ++j) {\n      this.draw(sel, items[j], idx++);\n    }\n    for (j=0, m=axes.length; j<m; ++j) {\n      if (axes[j].def.layer !== \"back\") {\n        drawGroup.call(this, sel, axes[j], idx++, \"axis_\");\n      }\n    }\n    for (j=0, m=legends.length; j<m; ++j) {\n      drawGroup.call(this, sel, legends[j], idx++, \"legend_\");\n    }\n  }\n}\n\nvar marks = module.exports = {\n  update: {\n    group:   rect,\n    area:    area,\n    line:    line,\n    arc:     arc,\n    path:    path,\n    symbol:  symbol,\n    rect:    rect,\n    rule:    rule,\n    text:    text,\n    image:   image\n  },\n  nested: {\n    \"area\": true,\n    \"line\": true\n  },\n  style: style,\n  draw: {\n    group:   drawGroup,\n    area:    draw(\"path\", area, true),\n    line:    draw(\"path\", line, true),\n    arc:     draw(\"path\", arc),\n    path:    draw(\"path\", path),\n    symbol:  draw(\"path\", symbol),\n    rect:    draw(\"rect\", rect),\n    rule:    draw(\"line\", rule),\n    text:    draw(\"text\", text),\n    image:   draw(\"image\", image),\n    draw:    draw // expose for extensibility\n  },\n  current: null\n};","var Node = require('../dataflow/Node'),\n    bounds = require('../util/bounds'),\n    C = require('../util/constants'),\n    debug = require('../util/debug');\n\nfunction Bounder(model, mark) {\n  this._mark = mark;\n  return Node.prototype.init.call(this, model.graph).router(true);\n}\n\nvar proto = (Bounder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"bounds\", this._mark.marktype]);\n\n  bounds.mark(this._mark);\n  if (this._mark.marktype === C.GROUP) \n    bounds.mark(this._mark, null, false);\n\n  input.reflow = true;\n  return input;\n};\n\nmodule.exports = Bounder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Encoder  = require('./Encoder'),\n    Bounder  = require('./Bounder'),\n    Item  = require('./Item'),\n    parseData = require('../parse/data'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Builder() {    \n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (Builder.prototype = new Node());\n\nproto.init = function(model, def, mark, parent, parent_id, inheritFrom) {\n  Node.prototype.init.call(this, model.graph)\n    .router(true)\n    .collector(true);\n\n  this._model = model;\n  this._def   = def;\n  this._mark  = mark;\n  this._from  = (def.from ? def.from.data : null) || inheritFrom;\n  this._ds    = dl.isString(this._from) ? model.data(this._from) : null;\n  this._map   = {};\n\n  this._revises = false;  // Should scenegraph items track _prev?\n\n  mark.def = def;\n  mark.marktype = def.type;\n  mark.interactive = !(def.interactive === false);\n  mark.items = [];\n\n  this._parent = parent;\n  this._parent_id = parent_id;\n\n  if(def.from && (def.from.mark || def.from.transform || def.from.modify)) {\n    inlineDs.call(this);\n  }\n\n  // Non-group mark builders are super nodes. Encoder and Bounder remain \n  // separate operators but are embedded and called by Builder.evaluate.\n  this._isSuper = (this._def.type !== C.GROUP); \n  this._encoder = new Encoder(this._model, this._mark);\n  this._bounder = new Bounder(this._model, this._mark);\n\n  if(this._ds) { this._encoder.dependency(C.DATA, this._from); }\n\n  // Since Builders are super nodes, copy over encoder dependencies\n  // (bounder has no registered dependencies).\n  this.dependency(C.DATA, this._encoder.dependency(C.DATA));\n  this.dependency(C.SCALES, this._encoder.dependency(C.SCALES));\n  this.dependency(C.SIGNALS, this._encoder.dependency(C.SIGNALS));\n\n  return this;\n};\n\nproto.revises = function(p) {\n  if(!arguments.length) return this._revises;\n\n  // If we've not needed prev in the past, but a new inline ds needs it now\n  // ensure existing items have prev set.\n  if(!this._revises && p) {\n    this._items.forEach(function(d) { if(d._prev === undefined) d._prev = C.SENTINEL; });\n  }\n\n  this._revises = this._revises || p;\n  return this;\n};\n\n// Reactive geometry and mark-level transformations are handled here \n// because they need their group's data-joined context. \nfunction inlineDs() {\n  var from = this._def.from,\n      geom = from.mark,\n      src, name, spec, sibling, output;\n\n  if(geom) {\n    name = [\"vg\", this._parent_id, geom].join(\"_\");\n    spec = {\n      name: name,\n      transform: from.transform, \n      modify: from.modify\n    };\n  } else {\n    src = this._model.data(this._from);\n    name = [\"vg\", this._from, this._def.type, src.listeners(true).length].join(\"_\");\n    spec = {\n      name: name,\n      source: this._from,\n      transform: from.transform,\n      modify: from.modify\n    };\n  }\n\n  this._from = name;\n  this._ds = parseData.datasource(this._model, spec);\n  var revises = this._ds.revises();\n\n  if(geom) {\n    sibling = this.sibling(geom).revises(revises);\n    if(sibling._isSuper) sibling.addListener(this._ds.listener());\n    else sibling._bounder.addListener(this._ds.listener());\n  } else {\n    // At this point, we have a new datasource but it is empty as\n    // the propagation cycle has already crossed the datasources. \n    // So, we repulse just this datasource. This should be safe\n    // as the ds isn't connected to the scenegraph yet.\n    \n    var output = this._ds.source().revises(revises).last();\n        input  = changeset.create(output);\n\n    input.add = output.add;\n    input.mod = output.mod;\n    input.rem = output.rem;\n    input.stamp = null;\n    this._graph.propagate(input, this._ds.listener());\n  }\n}\n\nproto.pipeline = function() {\n  return [this];\n};\n\nproto.connect = function() {\n  var builder = this;\n\n  this._model.graph.connect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).addListener(builder);\n  });\n\n  if(this._parent) {\n    if(this._isSuper) this.addListener(this._parent._collector);\n    else this._bounder.addListener(this._parent._collector);\n  }\n\n  return this;\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  if(!this._listeners.length) return this;\n\n  Node.prototype.disconnect.call(this);\n  this._model.graph.disconnect(this.pipeline());\n  this._encoder.dependency(C.SCALES).forEach(function(s) {\n    builder._parent.scale(s).removeListener(builder);\n  });\n  return this;\n};\n\nproto.sibling = function(name) {\n  return this._parent.child(name, this._parent_id);\n};\n\nproto.evaluate = function(input) {\n  debug(input, [\"building\", this._from, this._def.type]);\n\n  var output, fullUpdate, fcs, data;\n\n  if(this._ds) {\n    output = changeset.create(input);\n\n    // We need to determine if any encoder dependencies have been updated.\n    // However, the encoder's data source will likely be updated, and shouldn't\n    // trigger all items to mod.\n    data = dl.duplicate(output.data);\n    delete output.data[this._ds.name()];\n    fullUpdate = this._encoder.reevaluate(output);\n    output.data = data;\n\n    // If a scale or signal in the update propset has been updated, \n    // send forward all items for reencoding if we do an early return.\n    if(fullUpdate) output.mod = this._mark.items.slice();\n\n    fcs = this._ds.last();\n    if(!fcs) {\n      output.reflow = true\n    } else if(fcs.stamp > this._stamp) {\n      output = joinDatasource.call(this, fcs, this._ds.values(), fullUpdate);\n    }\n  } else {\n    fullUpdate = this._encoder.reevaluate(input);\n    data = dl.isFunction(this._def.from) ? this._def.from() : [C.SENTINEL];\n    output = joinValues.call(this, input, data, fullUpdate);\n  }\n\n  output = this._graph.evaluate(output, this._encoder);\n  return this._isSuper ? this._graph.evaluate(output, this._bounder) : output;\n};\n\nfunction newItem() {\n  var prev = this._revises ? null : undefined,\n      item = tuple.ingest(new Item(this._mark), prev);\n\n  // For the root node's item\n  if(this._def.width)  tuple.set(item, \"width\",  this._def.width);\n  if(this._def.height) tuple.set(item, \"height\", this._def.height);\n  return item;\n};\n\nfunction join(data, keyf, next, output, prev, mod) {\n  var i, key, len, item, datum, enter;\n\n  for(i=0, len=data.length; i<len; ++i) {\n    datum = data[i];\n    item  = keyf ? this._map[key = keyf(datum)] : prev[i];\n    enter = item ? false : (item = newItem.call(this), true);\n    item.status = enter ? C.ENTER : C.UPDATE;\n    item.datum = datum;\n    tuple.set(item, \"key\", key);\n    this._map[key] = item;\n    next.push(item);\n    if(enter) output.add.push(item);\n    else if(!mod || (mod && mod[datum._id])) output.mod.push(item);\n  }\n}\n\nfunction joinDatasource(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key || \"_id\"),\n      add = input.add, \n      mod = input.mod, \n      rem = input.rem,\n      next = [],\n      i, key, len, item, datum, enter;\n\n  // Build rems first, and put them at the head of the next items\n  // Then build the rest of the data values (which won't contain rem).\n  // This will preserve the sort order without needing anything extra.\n\n  for(i=0, len=rem.length; i<len; ++i) {\n    item = this._map[key = keyf(rem[i])];\n    item.status = C.EXIT;\n    next.push(item);\n    output.rem.push(item);\n    this._map[key] = null;\n  }\n\n  join.call(this, data, keyf, next, output, null, tuple.idMap(fullUpdate ? data : mod));\n\n  return (this._mark.items = next, output);\n}\n\nfunction joinValues(input, data, fullUpdate) {\n  var output = changeset.create(input),\n      keyf = keyFunction(this._def.key),\n      prev = this._mark.items || [],\n      next = [],\n      i, key, len, item, datum, enter;\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    item.status = C.EXIT;\n    if (keyf) this._map[item.key] = item;\n  }\n  \n  join.call(this, data, keyf, next, output, prev, fullUpdate ? tuple.idMap(data) : null);\n\n  for (i=0, len=prev.length; i<len; ++i) {\n    item = prev[i];\n    if (item.status === C.EXIT) {\n      tuple.set(item, \"key\", keyf ? item.key : this._items.length);\n      next.splice(0, 0, item);  // Keep item around for \"exit\" transition.\n      output.rem.push(item);\n    }\n  }\n  \n  return (this._mark.items = next, output);\n};\n\nfunction keyFunction(key) {\n  if (key == null) return null;\n  var f = dl.array(key).map(dl.accessor);\n  return function(d) {\n    for (var s=\"\", i=0, n=f.length; i<n; ++i) {\n      if (i>0) s += \"|\";\n      s += String(f[i](d));\n    }\n    return s;\n  }\n};\n\nmodule.exports = Builder;","var Node = require('../dataflow/Node'),\n    C = require('../util/constants'),\n    debug = require('../util/debug'),\n    EMPTY = {};\n\nfunction Encoder(model, mark) {\n  var props = mark.def.properties || {},\n      update = props.update;\n\n  Node.prototype.init.call(this, model.graph)\n\n  this._model = model;\n  this._mark  = mark;\n\n  if(update) {\n    this.dependency(C.DATA, update.data);\n    this.dependency(C.SCALES, update.scales);\n    this.dependency(C.SIGNALS, update.signals);\n  }\n\n  return this;\n}\n\nvar proto = (Encoder.prototype = new Node());\n\nproto.evaluate = function(input) {\n  debug(input, [\"encoding\", this._mark.def.type]);\n  var items = this._mark.items,\n      props = this._mark.def.properties || {},\n      enter  = props.enter,\n      update = props.update,\n      exit   = props.exit,\n      i, len, item;\n\n  // Items marked for removal are at the head of items. Process them first.\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    item = input.rem[i];\n    if(update) encode.call(this, update, item, input.trans);\n    if(exit)   encode.call(this, exit,   item, input.trans); \n    if(input.trans && !exit) input.trans.interpolate(item, EMPTY);\n    else if(!input.trans) item.remove();\n  }\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    item = input.add[i];\n    if(enter)  encode.call(this, enter,  item, input.trans);\n    if(update) encode.call(this, update, item, input.trans);\n    item.status = C.UPDATE;\n  }\n\n  if(update) {\n    for(i=0, len=input.mod.length; i<len; ++i) {\n      item = input.mod[i];\n      encode.call(this, update, item, input.trans);\n    }\n  }\n\n  return input;\n};\n\nfunction encode(prop, item, trans, stamp) {\n  var model = this._model,\n      enc = prop.encode,\n      sg = this._graph.signalValues(prop.signals||[]),\n      db = (prop.data||[]).reduce(function(db, ds) { \n        return db[ds] = model.data(ds).values(), db;\n      }, {});\n\n  enc.call(enc, item, item.mark.group||item, trans, db, sg, model.predicates());\n}\n\nmodule.exports = Encoder;","var dl = require('datalib'),\n    Node = require('../dataflow/Node'),\n    Collector = require('../dataflow/Collector'),\n    Builder = require('./Builder'),\n    Scale = require('./Scale'),\n    parseAxes = require('../parse/axes'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction GroupBuilder() {\n  this._children = {};\n  this._scaler = null;\n  this._recursor = null;\n\n  this._scales = {};\n  this.scale = scale.bind(this);\n  return arguments.length ? this.init.apply(this, arguments) : this;\n}\n\nvar proto = (GroupBuilder.prototype = new Builder());\n\nproto.init = function(model, def, mark, parent, parent_id, inheritFrom) {\n  var builder = this;\n\n  this._scaler = new Node(model.graph);\n\n  (def.scales||[]).forEach(function(s) { \n    s = builder.scale(s.name, new Scale(model, s, builder));\n    builder._scaler.addListener(s);  // Scales should be computed after group is encoded\n  });\n\n  this._recursor = new Node(model.graph);\n  this._recursor.evaluate = recurse.bind(this);\n\n  var scales = (def.axes||[]).reduce(function(acc, x) {\n    return (acc[x.scale] = 1, acc);\n  }, {});\n  this._recursor.dependency(C.SCALES, dl.keys(scales));\n\n  // We only need a collector for up-propagation of bounds calculation,\n  // so only GroupBuilders, and not regular Builders, have collectors.\n  this._collector = new Collector(model.graph);\n\n  return Builder.prototype.init.apply(this, arguments);\n};\n\nproto.evaluate = function(input) {\n  var output = Builder.prototype.evaluate.apply(this, arguments),\n      builder = this;\n\n  output.add.forEach(function(group) { buildGroup.call(builder, output, group); });\n  return output;\n};\n\nproto.pipeline = function() {\n  return [this, this._scaler, this._recursor, this._collector, this._bounder];\n};\n\nproto.disconnect = function() {\n  var builder = this;\n  dl.keys(builder._children).forEach(function(group_id) {\n    builder._children[group_id].forEach(function(c) {\n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect();\n    })\n  });\n\n  builder._children = {};\n  return Builder.prototype.disconnect.call(this);\n};\n\nproto.child = function(name, group_id) {\n  var children = this._children[group_id],\n      i = 0, len = children.length,\n      child;\n\n  for(; i<len; ++i) {\n    child = children[i];\n    if(child.type == C.MARK && child.builder._def.name == name) break;\n  }\n\n  return child.builder;\n};\n\nfunction recurse(input) {\n  var builder = this,\n      hasMarks = this._def.marks && this._def.marks.length > 0,\n      hasAxes = this._def.axes && this._def.axes.length > 0,\n      i, len, group, pipeline, def, inline = false;\n\n  for(i=0, len=input.add.length; i<len; ++i) {\n    group = input.add[i];\n    if(hasMarks) buildMarks.call(this, input, group);\n    if(hasAxes)  buildAxes.call(this, input, group);\n  }\n\n  // Wire up new children builders in reverse to minimize graph rewrites.\n  for (i=input.add.length-1; i>=0; --i) {\n    group = input.add[i];\n    for (j=this._children[group._id].length-1; j>=0; --j) {\n      c = this._children[group._id][j];\n      c.builder.connect();\n      pipeline = c.builder.pipeline();\n      def = c.builder._def;\n\n      // This new child needs to be built during this propagation cycle.\n      // We could add its builder as a listener off the _recursor node, \n      // but try to inline it if we can to minimize graph dispatches.\n      inline = (def.type !== C.GROUP);\n      inline = inline && (this._model.data(c.from) !== undefined); \n      inline = inline && (pipeline[pipeline.length-1].listeners().length == 1); // Reactive geom\n      c.inline = inline;\n\n      if(inline) c.builder.evaluate(input);\n      else this._recursor.addListener(c.builder);\n    }\n  }\n\n  for(i=0, len=input.mod.length; i<len; ++i) {\n    group = input.mod[i];\n    // Remove temporary connection for marks that draw from a source\n    if(hasMarks) {\n      builder._children[group._id].forEach(function(c) {\n        if(c.type == C.MARK && !c.inline && builder._model.data(c.from) !== undefined ) {\n          builder._recursor.removeListener(c.builder);\n        }\n      });\n    }\n\n    // Update axes data defs\n    if(hasAxes) {\n      parseAxes(builder._model, builder._def.axes, group.axes, group);\n      group.axes.forEach(function(a, i) { a.def() });\n    }      \n  }\n\n  for(i=0, len=input.rem.length; i<len; ++i) {\n    group = input.rem[i];\n    // For deleted groups, disconnect their children\n    builder._children[group._id].forEach(function(c) { \n      builder._recursor.removeListener(c.builder);\n      c.builder.disconnect(); \n    });\n    delete builder._children[group._id];\n  }\n\n  return input;\n};\n\nfunction scale(name, scale) {\n  var group = this;\n  if(arguments.length === 2) return (group._scales[name] = scale, scale);\n  while(scale == null) {\n    scale = group._scales[name];\n    group = group.mark ? group.mark.group : group._parent;\n    if(!group) break;\n  }\n  return scale;\n}\n\nfunction buildGroup(input, group) {\n  debug(input, [\"building group\", group._id]);\n\n  group._scales = group._scales || {};    \n  group.scale  = scale.bind(group);\n\n  group.items = group.items || [];\n  this._children[group._id] = this._children[group._id] || [];\n\n  group.axes = group.axes || [];\n  group.axisItems = group.axisItems || [];\n}\n\nfunction buildMarks(input, group) {\n  debug(input, [\"building marks\", group._id]);\n  var marks = this._def.marks,\n      listeners = [],\n      mark, from, inherit, i, len, m, b;\n\n  for(i=0, len=marks.length; i<len; ++i) {\n    mark = marks[i];\n    from = mark.from || {};\n    inherit = \"vg_\"+group.datum._id;\n    group.items[i] = {group: group};\n    b = (mark.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(this._model, mark, group.items[i], this, group._id, inherit);\n    this._children[group._id].push({ \n      builder: b, \n      from: from.data || (from.mark ? (\"vg_\" + group._id + \"_\" + from.mark) : inherit), \n      type: C.MARK \n    });\n  }\n}\n\nfunction buildAxes(input, group) {\n  var axes = group.axes,\n      axisItems = group.axisItems,\n      builder = this;\n\n  parseAxes(this._model, this._def.axes, axes, group);\n  axes.forEach(function(a, i) {\n    var scale = builder._def.axes[i].scale,\n        def = a.def(),\n        b = null;\n\n    axisItems[i] = {group: group, axisDef: def};\n    b = (def.type === C.GROUP) ? new GroupBuilder() : new Builder();\n    b.init(builder._model, def, axisItems[i], builder)\n      .dependency(C.SCALES, scale);\n    builder._children[group._id].push({ builder: b, type: C.AXIS, scale: scale });\n  });\n}\n\nmodule.exports = GroupBuilder;","function Item(mark) {\n  this.mark = mark;\n}\n\nvar prototype = Item.prototype;\n\nprototype.hasPropertySet = function(name) {\n  var props = this.mark.def.properties;\n  return props && props[name] != null;\n};\n\nprototype.cousin = function(offset, index) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      group = mark.group,\n      iidx = index==null ? mark.items.indexOf(this) : index,\n      midx = group.items.indexOf(mark) + offset;\n  return group.items[midx].items[iidx];\n};\n\nprototype.sibling = function(offset) {\n  if (offset === 0) return this;\n  offset = offset || -1;\n  var mark = this.mark,\n      iidx = mark.items.indexOf(this) + offset;\n  return mark.items[iidx];\n};\n\nprototype.remove = function() {\n  var item = this,\n      list = item.mark.items,\n      i = list.indexOf(item);\n  if (i >= 0) (i===list.length-1) ? list.pop() : list.splice(i, 1);\n  return item;\n};\n\nprototype.touch = function() {\n  if (this.pathCache) this.pathCache = null;\n  if (this.mark.pathCache) this.mark.pathCache = null;\n};\n\nmodule.exports = Item;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Node = require('../dataflow/Node'),\n    Aggregate = require('../transforms/Aggregate'),\n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    config = require('../util/config'),\n    C = require('../util/constants');\n\nvar GROUP_PROPERTY = {width: 1, height: 1};\n\nfunction Scale(model, def, parent) {\n  this._model   = model;\n  this._def     = def;\n  this._parent  = parent;\n  this._updated = false;\n  return Node.prototype.init.call(this, model.graph);\n}\n\nvar proto = (Scale.prototype = new Node());\n\nproto.evaluate = function(input) {\n  var self = this,\n      fn = function(group) { scale.call(self, group); };\n\n  this._updated = false;\n  input.add.forEach(fn);\n  input.mod.forEach(fn);\n\n  // Scales are at the end of an encoding pipeline, so they should forward a\n  // reflow pulse. Thus, if multiple scales update in the parent group, we don't\n  // reevaluate child marks multiple times. \n  if (this._updated) input.scales[this._def.name] = 1;\n  return changeset.create(input, true);\n};\n\n// All of a scale's dependencies are registered during propagation as we parse\n// dataRefs. So a scale must be responsible for connecting itself to dependents.\nproto.dependency = function(type, deps) {\n  if (arguments.length == 2) {\n    deps = dl.array(deps);\n    for(var i=0, len=deps.length; i<len; ++i) {\n      this._graph[type == C.DATA ? C.DATA : C.SIGNAL](deps[i])\n        .addListener(this._parent);\n    }\n  }\n\n  return Node.prototype.dependency.call(this, type, deps);\n};\n\nfunction scale(group) {\n  var name = this._def.name,\n      prev = name + \":prev\",\n      s = instance.call(this, group.scale(name)),\n      m = s.type===C.ORDINAL ? ordinal : quantitative,\n      rng = range.call(this, group);\n\n  m.call(this, s, rng, group);\n\n  group.scale(name, s);\n  group.scale(prev, group.scale(prev) || s);\n\n  return s;\n}\n\nfunction instance(scale) {\n  var type = this._def.type || C.LINEAR;\n  if (!scale || type !== scale.type) {\n    var ctor = config.scale[type] || d3.scale[type];\n    if (!ctor) dl.error(\"Unrecognized scale type: \" + type);\n    (scale = ctor()).type = scale.type || type;\n    scale.scaleName = this._def.name;\n    scale._prev = {};\n  }\n  return scale;\n}\n\nfunction ordinal(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, sort, str, refs, dataDrivenRange = false;\n  \n  // range pre-processing for data-driven ranges\n  if (dl.isObject(def.range) && !dl.isArray(def.range)) {\n    dataDrivenRange = true;\n    rng = dataRef.call(this, C.RANGE, def.range, scale, group);\n  }\n  \n  // domain\n  domain = dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  if (dl.equal(prev.range, rng)) return;\n\n  str = typeof rng[0] === 'string';\n  if (str || rng.length > 2 || rng.length===1 || dataDrivenRange) {\n    scale.range(rng); // color or shape values\n  } else if (def.points) {\n    scale.rangePoints(rng, def.padding||0);\n  } else if (def.round || def.round===undefined) {\n    scale.rangeRoundBands(rng, def.padding||0);\n  } else {\n    scale.rangeBands(rng, def.padding||0);\n  }\n\n  prev.range = rng;\n  this._updated = true;\n}\n\nfunction quantitative(scale, rng, group) {\n  var def = this._def,\n      prev = scale._prev,\n      domain, interval;\n\n  // domain\n  domain = (def.type === C.QUANTILE)\n    ? dataRef.call(this, C.DOMAIN, def.domain, scale, group)\n    : domainMinMax.call(this, scale, group);\n  if (domain && !dl.equal(prev.domain, domain)) {\n    scale.domain(domain);\n    prev.domain = domain;\n    this._updated = true;\n  } \n\n  // range\n  // vertical scales should flip by default, so use XOR here\n  if (def.range === \"height\") rng = rng.reverse();\n  if (dl.equal(prev.range, rng)) return;\n  scale[def.round && scale.rangeRound ? \"rangeRound\" : \"range\"](rng);\n  prev.range = rng;\n  this._updated = true;\n\n  // TODO: Support signals for these properties. Until then, only eval\n  // them once.\n  if (this._stamp > 0) return;\n  if (def.exponent && def.type===C.POWER) scale.exponent(def.exponent);\n  if (def.clamp) scale.clamp(true);\n  if (def.nice) {\n    if (def.type === C.TIME) {\n      interval = d3.time[def.nice];\n      if (!interval) dl.error(\"Unrecognized interval: \" + interval);\n      scale.nice(interval);\n    } else {\n      scale.nice();\n    }\n  }\n}\n\nfunction dataRef(which, def, scale, group) {\n  if (def == null) { return []; }\n  if (dl.isArray(def)) return def.map(signal.bind(this));\n\n  var self = this, graph = this._graph,\n      refs = def.fields || dl.array(def),\n      uniques = scale.type === C.ORDINAL || scale.type === C.QUANTILE,\n      ck = \"_\"+which,\n      cache = scale[ck],\n      cacheField = {ops: []},  // the field and measures in the aggregator\n      sort = def.sort,\n      i, rlen, j, flen, r, fields, from, data, keys;\n\n  if (!cache) {\n    cache = scale[ck] = new Aggregate(graph);\n    cacheField.ops = [];\n    cache.singleton(true);\n    if (uniques && sort) cacheField.ops.push(sort.stat);\n  }\n\n  for(i=0, rlen=refs.length; i<rlen; ++i) {\n    r = refs[i];\n    from = r.data || \"vg_\"+group.datum._id;\n    data = graph.data(from)\n      .revises(true)\n      .last();\n\n    if (data.stamp <= this._stamp) continue;\n\n    fields = dl.array(r.field).map(function(f) {\n      if (f.group) return dl.accessor(f.group)(group.datum)\n      return f; // String or {\"signal\"}\n    });\n\n    if (uniques) {\n      cacheField.name = sort ? sort.field : \"_id\";\n      cache.fields.set(cache, [cacheField]);\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cache.group_by.set(cache, fields[j])\n          .evaluate(data);\n      }\n    } else {\n      for (j=0, flen=fields.length; j<flen; ++j) {\n        cacheField.name = fields[j];\n        cacheField.ops  = [C.MIN, C.MAX];\n        cache.fields.set(cache, [cacheField]) // Treat as flat datasource\n          .evaluate(data);\n      }\n    }\n\n    this.dependency(C.DATA, from);\n    cache.dependency(C.SIGNALS).forEach(function(s) { self.dependency(C.SIGNALS, s) });\n  }\n\n  data = cache.data();\n  if (uniques) {\n    keys = dl.keys(data)\n      .filter(function(k) { return data[k] != null; });\n\n    if (sort) {\n      sort = sort.order.signal ? graph.signalRef(sort.order.signal) : sort.order;\n      sort = (sort == C.DESC ? \"-\" : \"+\") + \"tpl.\" + cacheField.name;\n      sort = dl.comparator(sort);\n      keys = keys.map(function(k) { return { key: k, tpl: data[k].tpl }})\n        .sort(sort)\n        .map(function(k) { return k.key; });\n    // } else {  // \"First seen\" order\n    //   sort = dl.comparator(\"tpl._id\");\n    }\n\n    return keys;\n  } else {\n    data = data[\"\"]; // Unpack flat aggregation\n    return (data === null) ? [] : [data[C.SINGLETON].min, data[C.SINGLETON].max];\n  }\n}\n\nfunction signal(v) {\n  var s = v.signal, ref;\n  if (!s) return v;\n  this.dependency(C.SIGNALS, (ref = dl.field(s))[0]);\n  return this._graph.signalRef(ref);\n}\n\nfunction domainMinMax(scale, group) {\n  var def = this._def,\n      domain = [null, null], refs, z;\n\n  if (def.domain !== undefined) {\n    domain = (!dl.isObject(def.domain)) ? domain :\n      dataRef.call(this, C.DOMAIN, def.domain, scale, group);\n  }\n\n  z = domain.length - 1;\n  if (def.domainMin !== undefined) {\n    if (dl.isObject(def.domainMin)) {\n      if (def.domainMin.signal) {\n        domain[0] = signal.call(this, def.domainMin);\n      } else {\n        domain[0] = dataRef.call(this, C.DOMAIN+C.MIN, def.domainMin, scale, group)[0];\n      }\n    } else {\n      domain[0] = def.domainMin;\n    }\n  }\n  if (def.domainMax !== undefined) {\n    if (dl.isObject(def.domainMax)) {\n      if (def.domainMax.signal) {\n        domain[z] = signal.call(this, def.domainMax);\n      } else {\n        domain[z] = dataRef.call(this, C.DOMAIN+C.MAX, def.domainMax, scale, group)[1];\n      }\n    } else {\n      domain[z] = def.domainMax;\n    }\n  }\n  if (def.type !== C.LOG && def.type !== C.TIME && (def.zero || def.zero===undefined)) {\n    domain[0] = Math.min(0, domain[0]);\n    domain[z] = Math.max(0, domain[z]);\n  }\n  return domain;\n}\n\nfunction range(group) {\n  var def = this._def,\n      rng = [null, null];\n\n  if (def.range !== undefined) {\n    if (typeof def.range === 'string') {\n      if (GROUP_PROPERTY[def.range]) {\n        rng = [0, group[def.range]];\n      } else if (config.range[def.range]) {\n        rng = config.range[def.range];\n      } else {\n        dl.error(\"Unrecogized range: \"+def.range);\n        return rng;\n      }\n    } else if (dl.isArray(def.range)) {\n      rng = def.range.map(signal.bind(this));\n    } else if (dl.isObject(def.range)) {\n      return null; // early exit\n    } else {\n      rng = [0, def.range];\n    }\n  }\n  if (def.rangeMin !== undefined) {\n    rng[0] = def.rangeMin.signal ? signal.call(this, def.rangeMin) : def.rangeMin;\n  }\n  if (def.rangeMax !== undefined) {\n    rng[rng.length-1] = def.rangeMax.signal ? signal.call(this, def.rangeMax) : def.rangeMax;\n  }\n  \n  if (def.reverse !== undefined) {\n    var rev = def.reverse;\n    if (dl.isObject(rev)) {\n      rev = dl.accessor(rev.field)(group.datum);\n    }\n    if (rev) rng = rng.reverse();\n  }\n  \n  return rng;\n}\n\nmodule.exports = Scale;","var tuple = require('../dataflow/tuple'),\n    calcBounds = require('../util/bounds'),\n    C = require('../util/constants');\n\nfunction Transition(duration, ease) {\n  this.duration = duration || 500;\n  this.ease = ease && d3.ease(ease) || d3.ease(\"cubic-in-out\");\n  this.updates = {next: null};\n}\n\nvar prototype = Transition.prototype;\n\nvar skip = {\n  \"text\": 1,\n  \"url\":  1\n};\n\nprototype.interpolate = function(item, values, stamp) {\n  var key, curr, next, interp, list = null;\n\n  for (key in values) {\n    curr = item[key];\n    next = values[key];      \n    if (curr !== next) {\n      if (skip[key] || curr === undefined) {\n        // skip interpolation for specific keys or undefined start values\n        tuple.set(item, key, next);\n      } else if (typeof curr === \"number\" && !isFinite(curr)) {\n        // for NaN or infinite numeric values, skip to final value\n        tuple.set(item, key, next);\n      } else {\n        // otherwise lookup interpolator\n        interp = d3.interpolate(curr, next);\n        interp.property = key;\n        (list || (list=[])).push(interp);\n      }\n    }\n  }\n\n  if (list === null && item.status === C.EXIT) {\n    list = []; // ensure exiting items are included\n  }\n\n  if (list != null) {\n    list.item = item;\n    list.ease = item.mark.ease || this.ease;\n    list.next = this.updates.next;\n    this.updates.next = list;\n  }\n  return this;\n};\n\nprototype.start = function(callback) {\n  var t = this, prev = t.updates, curr = prev.next;\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    if (curr.item.status === C.EXIT) curr.remove = true;\n  }\n  t.callback = callback;\n  d3.timer(function(elapsed) { return step.call(t, elapsed); });\n};\n\nfunction step(elapsed) {\n  var list = this.updates, prev = list, curr = prev.next,\n      duration = this.duration,\n      item, delay, f, e, i, n, stop = true;\n\n  for (; curr!=null; prev=curr, curr=prev.next) {\n    item = curr.item;\n    delay = item.delay || 0;\n\n    f = (elapsed - delay) / duration;\n    if (f < 0) { stop = false; continue; }\n    if (f > 1) f = 1;\n    e = curr.ease(f);\n\n    for (i=0, n=curr.length; i<n; ++i) {\n      item[curr[i].property] = curr[i](e);\n    }\n    item.touch();\n    calcBounds.item(item);\n\n    if (f === 1) {\n      if (curr.remove) item.remove();\n      prev.next = curr.next;\n      curr = prev;\n    } else {\n      stop = false;\n    }\n  }\n\n  this.callback();\n  return stop;\n};\n\nmodule.exports = Transition;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    dl = require('datalib'),\n    config = require('../util/config'),\n    tpl = require('../dataflow/tuple'),\n    parseMark = require('../parse/mark');\n\nfunction axs(model) {\n  var scale,\n      orient = config.axis.orient,\n      offset = 0,\n      titleOffset = config.axis.titleOffset,\n      axisDef = {},\n      layer = \"front\",\n      grid = false,\n      title = null,\n      tickMajorSize = config.axis.tickSize,\n      tickMinorSize = config.axis.tickSize,\n      tickEndSize = config.axis.tickSize,\n      tickPadding = config.axis.padding,\n      tickValues = null,\n      tickFormatString = null,\n      tickFormat = null,\n      tickSubdivide = 0,\n      tickArguments = [config.axis.ticks],\n      gridLineStyle = {},\n      tickLabelStyle = {},\n      majorTickStyle = {},\n      minorTickStyle = {},\n      titleStyle = {},\n      domainStyle = {},\n      m = { // Axis marks as references for updates\n        gridLines: null,\n        majorTicks: null,\n        minorTicks: null,\n        tickLabels: null,\n        domain: null,\n        title: null\n      };\n\n  var axis = {};\n\n  function reset() {\n    axisDef.type = null;\n  };\n\n  axis.def = function() {\n    if(!axisDef.type) axis_def(scale);\n\n    // tick format\n    tickFormat = !tickFormatString ? null : ((scale.type === 'time')\n      ? d3.time.format(tickFormatString)\n      : d3.format(tickFormatString));\n\n    // generate data\n    // We don't _really_ need to model these as tuples as no further\n    // data transformation is done. So we optimize for a high churn rate. \n    var injest = function(d) { return {data: d}; };\n    var major = tickValues == null\n      ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain())\n      : tickValues;\n    var minor = vg_axisSubdivide(scale, major, tickSubdivide).map(injest);\n    major = major.map(injest);\n    var fmt = tickFormat==null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : String) : tickFormat;\n    major.forEach(function(d) { d.label = fmt(d.data); });\n    var tdata = title ? [title].map(injest) : [];\n\n    axisDef.marks[0].from = function() { return grid ? major : []; };\n    axisDef.marks[1].from = function() { return major; };\n    axisDef.marks[2].from = function() { return minor; };\n    axisDef.marks[3].from = axisDef.marks[1].from;\n    axisDef.marks[4].from = function() { return [1]; };\n    axisDef.marks[5].from = function() { return tdata; };\n    axisDef.offset = offset;\n    axisDef.orient = orient;\n    axisDef.layer = layer;\n    return axisDef;\n  };\n\n  function axis_def(scale) {\n    // setup scale mapping\n    var newScale, oldScale, range;\n    if (scale.type === \"ordinal\") {\n      newScale = {scale: scale.scaleName, offset: 0.5 + scale.rangeBand()/2};\n      oldScale = newScale;\n    } else {\n      newScale = {scale: scale.scaleName, offset: 0.5};\n      oldScale = {scale: scale.scaleName+\":prev\", offset: 0.5};\n    }\n    range = vg_axisScaleRange(scale);\n\n    // setup axis marks\n    if (!m.gridLines)  m.gridLines  = vg_axisTicks();\n    if (!m.majorTicks) m.majorTicks = vg_axisTicks();\n    if (!m.minorTicks) m.minorTicks = vg_axisTicks();\n    if (!m.tickLabels) m.tickLabels = vg_axisTickLabels();\n    if (!m.domain) m.domain = vg_axisDomain();\n    if (!m.title)  m.title  = vg_axisTitle();\n    m.gridLines.properties.enter.stroke = {value: config.axis.gridColor};\n\n    // extend axis marks based on axis orientation\n    vg_axisTicksExtend(orient, m.gridLines, oldScale, newScale, Infinity);\n    vg_axisTicksExtend(orient, m.majorTicks, oldScale, newScale, tickMajorSize);\n    vg_axisTicksExtend(orient, m.minorTicks, oldScale, newScale, tickMinorSize);\n    vg_axisLabelExtend(orient, m.tickLabels, oldScale, newScale, tickMajorSize, tickPadding);\n\n    vg_axisDomainExtend(orient, m.domain, range, tickEndSize);\n    vg_axisTitleExtend(orient, m.title, range, titleOffset); // TODO get offset\n    \n    // add / override custom style properties\n    dl.extend(m.gridLines.properties.update, gridLineStyle);\n    dl.extend(m.majorTicks.properties.update, majorTickStyle);\n    dl.extend(m.minorTicks.properties.update, minorTickStyle);\n    dl.extend(m.tickLabels.properties.update, tickLabelStyle);\n    dl.extend(m.domain.properties.update, domainStyle);\n    dl.extend(m.title.properties.update, titleStyle);\n\n    var marks = [m.gridLines, m.majorTicks, m.minorTicks, m.tickLabels, m.domain, m.title];\n    dl.extend(axisDef, {\n      type: \"group\",\n      interactive: false,\n      properties: { \n        enter: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        },\n        update: {\n          encode: vg_axisUpdate,\n          scales: [scale.scaleName],\n          signals: [], data: []\n        }\n      }\n    });\n\n    axisDef.marks = marks.map(function(m) { return parseMark(model, m); });\n  };\n\n  axis.scale = function(x) {\n    if (!arguments.length) return scale;\n    if (scale !== x) { scale = x; reset(); }\n    return axis;\n  };\n\n  axis.orient = function(x) {\n    if (!arguments.length) return orient;\n    if (orient !== x) {\n      orient = x in vg_axisOrients ? x + \"\" : config.axis.orient;\n      reset();\n    }\n    return axis;\n  };\n\n  axis.title = function(x) {\n    if (!arguments.length) return title;\n    if (title !== x) { title = x; reset(); }\n    return axis;\n  };\n\n  axis.ticks = function() {\n    if (!arguments.length) return tickArguments;\n    tickArguments = arguments;\n    return axis;\n  };\n\n  axis.tickValues = function(x) {\n    if (!arguments.length) return tickValues;\n    tickValues = x;\n    return axis;\n  };\n\n  axis.tickFormat = function(x) {\n    if (!arguments.length) return tickFormatString;\n    if (tickFormatString !== x) {\n      tickFormatString = x;\n      reset();\n    }\n    return axis;\n  };\n  \n  axis.tickSize = function(x, y) {\n    if (!arguments.length) return tickMajorSize;\n    var n = arguments.length - 1,\n        major = +x,\n        minor = n > 1 ? +y : tickMajorSize,\n        end   = n > 0 ? +arguments[n] : tickMajorSize;\n\n    if (tickMajorSize !== major ||\n        tickMinorSize !== minor ||\n        tickEndSize !== end) {\n      reset();\n    }\n\n    tickMajorSize = major;\n    tickMinorSize = minor;\n    tickEndSize = end;\n    return axis;\n  };\n\n  axis.tickSubdivide = function(x) {\n    if (!arguments.length) return tickSubdivide;\n    tickSubdivide = +x;\n    return axis;\n  };\n  \n  axis.offset = function(x) {\n    if (!arguments.length) return offset;\n    offset = dl.isObject(x) ? x : +x;\n    return axis;\n  };\n\n  axis.tickPadding = function(x) {\n    if (!arguments.length) return tickPadding;\n    if (tickPadding !== +x) { tickPadding = +x; reset(); }\n    return axis;\n  };\n\n  axis.titleOffset = function(x) {\n    if (!arguments.length) return titleOffset;\n    if (titleOffset !== +x) { titleOffset = +x; reset(); }\n    return axis;\n  };\n\n  axis.layer = function(x) {\n    if (!arguments.length) return layer;\n    if (layer !== x) { layer = x; reset(); }\n    return axis;\n  };\n\n  axis.grid = function(x) {\n    if (!arguments.length) return grid;\n    if (grid !== x) { grid = x; reset(); }\n    return axis;\n  };\n\n  axis.gridLineProperties = function(x) {\n    if (!arguments.length) return gridLineStyle;\n    if (gridLineStyle !== x) { gridLineStyle = x; }\n    return axis;\n  };\n\n  axis.majorTickProperties = function(x) {\n    if (!arguments.length) return majorTickStyle;\n    if (majorTickStyle !== x) { majorTickStyle = x; }\n    return axis;\n  };\n\n  axis.minorTickProperties = function(x) {\n    if (!arguments.length) return minorTickStyle;\n    if (minorTickStyle !== x) { minorTickStyle = x; }\n    return axis;\n  };\n\n  axis.tickLabelProperties = function(x) {\n    if (!arguments.length) return tickLabelStyle;\n    if (tickLabelStyle !== x) { tickLabelStyle = x; }\n    return axis;\n  };\n\n  axis.titleProperties = function(x) {\n    if (!arguments.length) return titleStyle;\n    if (titleStyle !== x) { titleStyle = x; }\n    return axis;\n  };\n\n  axis.domainProperties = function(x) {\n    if (!arguments.length) return domainStyle;\n    if (domainStyle !== x) { domainStyle = x; }\n    return axis;\n  };\n  \n  axis.reset = function() { reset(); };\n\n  return axis;\n};\n\nvar vg_axisOrients = {top: 1, right: 1, bottom: 1, left: 1};\n\nfunction vg_axisSubdivide(scale, ticks, m) {\n  subticks = [];\n  if (m && ticks.length > 1) {\n    var extent = vg_axisScaleExtent(scale.domain()),\n        subticks,\n        i = -1,\n        n = ticks.length,\n        d = (ticks[1] - ticks[0]) / ++m,\n        j,\n        v;\n    while (++i < n) {\n      for (j = m; --j > 0;) {\n        if ((v = +ticks[i] - j * d) >= extent[0]) {\n          subticks.push(v);\n        }\n      }\n    }\n    for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n      subticks.push(v);\n    }\n  }\n  return subticks;\n}\n\nfunction vg_axisScaleExtent(domain) {\n  var start = domain[0], stop = domain[domain.length - 1];\n  return start < stop ? [start, stop] : [stop, start];\n}\n\nfunction vg_axisScaleRange(scale) {\n  return scale.rangeExtent\n    ? scale.rangeExtent()\n    : vg_axisScaleExtent(scale.range());\n}\n\nvar vg_axisAlign = {\n  bottom: \"center\",\n  top: \"center\",\n  left: \"right\",\n  right: \"left\"\n};\n\nvar vg_axisBaseline = {\n  bottom: \"top\",\n  top: \"bottom\",\n  left: \"middle\",\n  right: \"middle\"\n};\n\nfunction vg_axisLabelExtend(orient, labels, oldScale, newScale, size, pad) {\n  size = Math.max(size, 0) + pad;\n  if (orient === \"left\" || orient === \"top\") {\n    size *= -1;\n  }  \n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(labels.properties.enter, {\n      x: oldScale,\n      y: {value: size},\n    });\n    dl.extend(labels.properties.update, {\n      x: newScale,\n      y: {value: size},\n      align: {value: \"center\"},\n      baseline: {value: vg_axisBaseline[orient]}\n    });\n  } else {\n    dl.extend(labels.properties.enter, {\n      x: {value: size},\n      y: oldScale,\n    });\n    dl.extend(labels.properties.update, {\n      x: {value: size},\n      y: newScale,\n      align: {value: vg_axisAlign[orient]},\n      baseline: {value: \"middle\"}\n    });\n  }\n}\n\nfunction vg_axisTicksExtend(orient, ticks, oldScale, newScale, size) {\n  var sign = (orient === \"left\" || orient === \"top\") ? -1 : 1;\n  if (size === Infinity) {\n    size = (orient === \"top\" || orient === \"bottom\")\n      ? {group: \"mark.group.height\", mult: -sign}\n      : {group: \"mark.group.width\", mult: -sign};\n  } else {\n    size = {value: sign * size};\n  }\n  if (orient === \"top\" || orient === \"bottom\") {\n    dl.extend(ticks.properties.enter, {\n      x:  oldScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.update, {\n      x:  newScale,\n      y:  {value: 0},\n      y2: size\n    });\n    dl.extend(ticks.properties.exit, {\n      x:  newScale,\n    });        \n  } else {\n    dl.extend(ticks.properties.enter, {\n      x:  {value: 0},\n      x2: size,\n      y:  oldScale\n    });\n    dl.extend(ticks.properties.update, {\n      x:  {value: 0},\n      x2: size,\n      y:  newScale\n    });\n    dl.extend(ticks.properties.exit, {\n      y:  newScale,\n    });\n  }\n}\n\nfunction vg_axisTitleExtend(orient, title, range, offset) {\n  var mid = ~~((range[0] + range[1]) / 2),\n      sign = (orient === \"top\" || orient === \"left\") ? -1 : 1;\n  \n  if (orient === \"bottom\" || orient === \"top\") {\n    dl.extend(title.properties.update, {\n      x: {value: mid},\n      y: {value: sign*offset},\n      angle: {value: 0}\n    });\n  } else {\n    dl.extend(title.properties.update, {\n      x: {value: sign*offset},\n      y: {value: mid},\n      angle: {value: -90}\n    });\n  }\n}\n\nfunction vg_axisDomainExtend(orient, domain, range, size) {\n  var path;\n  if (orient === \"top\" || orient === \"left\") {\n    size = -1 * size;\n  }\n  if (orient === \"bottom\" || orient === \"top\") {\n    path = \"M\" + range[0] + \",\" + size + \"V0H\" + range[1] + \"V\" + size;\n  } else {\n    path = \"M\" + size + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + size;\n  }\n  domain.properties.update.path = {value: path};\n}\n\nfunction vg_axisUpdate(item, group, trans, db, signals, predicates) {\n  var o = trans ? {} : item,\n      offset = item.mark.def.offset,\n      orient = item.mark.def.orient,\n      width  = group.width,\n      height = group.height; // TODO fallback to global w,h?\n\n  if (dl.isObject(offset)) {\n    offset = -group.scale(offset.scale)(offset.value);\n  }\n\n  switch (orient) {\n    case \"left\":   { tpl.set(o, 'x', -offset); tpl.set(o, 'y', 0); break; }\n    case \"right\":  { tpl.set(o, 'x', width + offset); tpl.set(o, 'y', 0); break; }\n    case \"bottom\": { tpl.set(o, 'x', 0); tpl.set(o, 'y', height + offset); break; }\n    case \"top\":    { tpl.set(o, 'x', 0); tpl.set(o, 'y', -offset); break; }\n    default:       { tpl.set(o, 'x', 0); tpl.set(o, 'y', 0); }\n  }\n\n  if (trans) trans.interpolate(item, o);\n}\n\nfunction vg_axisTicks() {\n  return {\n    type: \"rule\",\n    interactive: false,\n    key: \"data\",\n    properties: {\n      enter: {\n        stroke: {value: config.axis.tickColor},\n        strokeWidth: {value: config.axis.tickWidth},\n        opacity: {value: 1e-6}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTickLabels() {\n  return {\n    type: \"text\",\n    interactive: true,\n    key: \"data\",\n    properties: {\n      enter: {\n        fill: {value: config.axis.tickLabelColor},\n        font: {value: config.axis.tickLabelFont},\n        fontSize: {value: config.axis.tickLabelFontSize},\n        opacity: {value: 1e-6},\n        text: {field: \"label\"}\n      },\n      exit: { opacity: {value: 1e-6} },\n      update: { opacity: {value: 1} }\n    }\n  };\n}\n\nfunction vg_axisTitle() {\n  return {\n    type: \"text\",\n    interactive: true,\n    properties: {\n      enter: {\n        font: {value: config.axis.titleFont},\n        fontSize: {value: config.axis.titleFontSize},\n        fontWeight: {value: config.axis.titleFontWeight},\n        fill: {value: config.axis.titleColor},\n        align: {value: \"center\"},\n        baseline: {value: \"middle\"},\n        text: {field: \"data\"}\n      },\n      update: {}\n    }\n  };\n}\n\nfunction vg_axisDomain() {\n  return {\n    type: \"path\",\n    interactive: false,\n    properties: {\n      enter: {\n        x: {value: 0.5},\n        y: {value: 0.5},\n        stroke: {value: config.axis.axisColor},\n        strokeWidth: {value: config.axis.axisWidth}\n      },\n      update: {}\n    }\n  };\n}\n\nmodule.exports = axs;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'), \n    meas = require('./measures'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Aggregate(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    group_by: {type: \"array<field>\"}\n  });\n\n  this._output = {\n    \"count\":    \"count\",\n    \"avg\":      \"avg\",\n    \"min\":      \"min\",\n    \"max\":      \"max\",\n    \"sum\":      \"sum\",\n    \"mean\":     \"mean\",\n    \"var\":      \"var\",\n    \"stdev\":    \"stdev\",\n    \"varp\":     \"varp\",\n    \"stdevp\":   \"stdevp\",\n    \"median\":   \"median\"\n  };\n\n  // Aggregators parameter handled manually.\n  this._fieldsDef   = null;\n  this._Aggregators = null;\n  this._singleton   = false;  // If true, all fields aggregated within a single monoid\n\n  return this;\n}\n\nvar proto = (Aggregate.prototype = new GroupBy());\n\nproto.fields = {\n  set: function(transform, fields) {\n    var i, len, f, signals = {};\n    for(i=0, len=fields.length; i<len; ++i) {\n      f = fields[i];\n      if(f.name.signal) signals[f.name.signal] = 1;\n      dl.array(f.ops).forEach(function(o){ if(o.signal) signals[o.signal] = 1 });\n    }\n\n    transform._fieldsDef = fields;\n    transform._Aggregators = null;\n    transform.aggs();\n    transform.dependency(C.SIGNALS, dl.keys(signals));\n    return transform;\n  }\n};\n\nproto.singleton = function(c) {\n  if(!arguments.length) return this._singleton;\n  this._singleton = c;\n  return this;\n};\n\nproto.aggs = function() {\n  var transform = this,\n      graph = this._graph,\n      fields = this._fieldsDef,\n      aggs = this._Aggregators,\n      f, i, k, name, ops, measures;\n\n  if(aggs) return aggs;\n  else aggs = this._Aggregators = []; \n\n  for (i = 0; i < fields.length; i++) {\n    f = fields[i];\n    if (f.ops.length === 0) continue;\n\n    name = f.name.signal ? graph.signalRef(f.name.signal) : f.name;\n    ops  = dl.array(f.ops.signal ? graph.signalRef(f.ops.signal) : f.ops);\n    measures = ops.map(function(a) {\n      a = a.signal ? graph.signalRef(a.signal) : a;\n      return meas[a](name + '_' + transform._output[a]);\n    });\n    aggs.push({\n      accessor: dl.accessor(name),\n      field: this._singleton ? C.SINGLETON : name,\n      measures: meas.create(measures)\n    });\n  }\n\n  return aggs;\n};\n\nproto._reset = function(input, output) {\n  this._Aggregators = null; // rebuild aggregators\n  this.aggs();\n  return GroupBy.prototype._reset.call(this, input, output);\n};\n\nproto._keys = function(x) {\n  return this._gb.fields.length ? \n    GroupBy.prototype._keys.call(this, x) : {keys: [], key: \"\"};\n};\n\nproto._new_cell = function(x, k) {\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length, \n      agg;\n\n  for(; i<len; i++) {\n    agg = aggs[i];\n    cell[agg.field] = new agg.measures(cell, cell.tpl);\n  }\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt++;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].add(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto._rem = function(x) {\n  var c = this._cell(x),\n      aggs = this.aggs(),\n      i = 0, len = aggs.length,\n      agg;\n\n  c.cnt--;\n  for(; i<len; i++) {\n    agg = aggs[i];\n    c[agg.field].rem(agg.accessor(x));\n  }\n  c.flg |= C.MOD_CELL;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"aggregate\"]);\n\n  this._gb = this.group_by.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      aggs = this.aggs(),\n      len = aggs.length,\n      i, k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    for(i=0; i<len; i++) {\n      c[aggs[i].field].set();\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Aggregate;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector');\n\nfunction BatchTransform() {\n}\n\nvar proto = (BatchTransform.prototype = new Transform());\n\nproto.init = function(graph) {\n  Transform.prototype.init.call(this, graph);\n  this._collector = new Collector(graph);\n  return this;\n};\n\nproto.transform = function(input) {\n  // Materialize the current datasource.\n  // TODO: efficiently share collectors\n  this._collector.evaluate(input);\n  var data = this._collector.data();\n  return this.batchTransform(input, data);\n};\n\nproto.batchTransform = function(input, data) {\n};\n\nmodule.exports = BatchTransform;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Bin(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    min: {type: \"value\"},\n    max: {type: \"value\"},\n    step: {type: \"value\"},\n    maxbins: {type: \"value\", default: 20}\n  });\n\n  this._output = {\"bin\": \"bin\"};\n  return this;\n}\n\nvar proto = (Bin.prototype = new Transform());\n\nproto.transform = function(input) {\n  var transform = this,\n      output = this._output.bin;\n      \n  var b = dl.bin({\n    min: this.min.get(),\n    max: this.max.get(),\n    step: this.step.get(),\n    maxbins: this.maxbins.get()\n  });\n\n  function update(d) {\n    var v = transform.field.get().accessor(d);\n    v = v == null ? null\n      : b.start + b.step * ~~((v - b.start) / b.step);\n    tuple.set(d, output, v, input.stamp);\n  }\n  input.add.forEach(update);\n  input.mod.forEach(update);\n  input.rem.forEach(update);\n\n  return input;\n};\n\nmodule.exports = Bin;","var Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset');\n\nfunction Cross(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    diagonal: {type: \"value\", default: \"true\"}\n  });\n\n  this._output = {\"left\": \"a\", \"right\": \"b\"};\n  this._collector = new Collector(graph);\n  this._lastRem  = null; // Most recent stamp that rem occured. \n  this._lastWith = null; // Last time we crossed w/withds.\n  this._ids   = {};\n  this._cache = {};\n\n  return this.router(true);\n}\n\nvar proto = (Cross.prototype = new Transform());\n\n// Each cached incoming tuple also has a stamp to track if we need to do\n// lazy filtering of removed tuples.\nfunction cache(x, t) {\n  var c = this._cache[x._id] = this._cache[x._id] || {c: [], s: this._stamp};\n  c.c.push(t);\n}\n\nfunction add(output, left, wdata, diag, x) {\n  var data = left ? wdata : this._collector.data(), // Left tuples cross w/right.\n      i = 0, len = data.length,\n      prev  = x._prev !== undefined ? null : undefined, \n      t, y, id;\n\n  for(; i<len; ++i) {\n    y = data[i];\n    id = left ? x._id+\"_\"+y._id : y._id+\"_\"+x._id;\n    if(this._ids[id]) continue;\n    if(x._id == y._id && !diag) continue;\n\n    t = tuple.ingest({}, prev);\n    t[this._output.left]  = left ? x : y;\n    t[this._output.right] = left ? y : x;\n    output.add.push(t);\n    cache.call(this, x, t);\n    cache.call(this, y, t);\n    this._ids[id] = 1;\n  }\n}\n\nfunction mod(output, left, x) {\n  var cross = this,\n      c = this._cache[x._id];\n\n  if(this._lastRem > c.s) {  // Removed tuples haven't been filtered yet\n    c.c = c.c.filter(function(y) {\n      var t = y[cross._output[left ? \"right\" : \"left\"]];\n      return cross._cache[t._id] !== null;\n    });\n    c.s = this._lastRem;\n  }\n\n  output.mod.push.apply(output.mod, c.c);\n}\n\nfunction rem(output, x) {\n  output.rem.push.apply(output.rem, this._cache[x._id].c);\n  this._cache[x._id] = null;\n  this._lastRem = this._stamp;\n}\n\nfunction upFields(input, output) {\n  if(input.add.length || input.rem.length) {\n    output.fields[this._output.left]  = 1; \n    output.fields[this._output.right] = 1;\n  }\n}\n\nproto.transform = function(input) {\n  debug(input, [\"crossing\"]);\n\n  // Materialize the current datasource. TODO: share collectors\n  this._collector.evaluate(input);\n\n  var w = this.with.get(this._graph),\n      diag = this.diagonal.get(this._graph),\n      selfCross = (!w.name),\n      data = this._collector.data(),\n      woutput = selfCross ? input : w.source.last(),\n      wdata   = selfCross ? data : w.source.values(),\n      output  = changeset.create(input),\n      r = rem.bind(this, output); \n\n  input.rem.forEach(r);\n  input.add.forEach(add.bind(this, output, true, wdata, diag));\n\n  if(!selfCross && woutput.stamp > this._lastWith) {\n    woutput.rem.forEach(r);\n    woutput.add.forEach(add.bind(this, output, false, data, diag));\n    woutput.mod.forEach(mod.bind(this, output, false));\n    upFields.call(this, woutput, output);\n    this._lastWith = woutput.stamp;\n  }\n\n  // Mods need to come after all removals have been run.\n  input.mod.forEach(mod.bind(this, output, true));\n  upFields.call(this, input, output);\n\n  return output;\n};\n\nmodule.exports = Cross;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Facet(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {keys: {type: \"array<field>\"} });\n\n  this._pipeline = [];\n  return this;\n}\n\nvar proto = (Facet.prototype = new GroupBy());\n\nproto.pipeline = function(pipeline) {\n  if(!arguments.length) return this._pipeline;\n  this._pipeline = pipeline;\n  return this;\n};\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    output.rem.push(c.tpl);\n    c.delete();\n  }\n  this._cells = {};\n};\n\nproto._new_tuple = function(x, k) {\n  return tuple.ingest(k, null);\n};\n\nproto._new_cell = function(x, k) {\n  // Rather than sharing the pipeline between all nodes,\n  // give each cell its individual pipeline. This allows\n  // dynamically added collectors to do the right thing\n  // when wiring up the pipelines.\n  var cell = GroupBy.prototype._new_cell.call(this, x, k),\n      pipeline = this._pipeline.map(function(n) { return n.clone(); }),\n      facet = this,\n      t = cell.tpl;\n\n  cell.ds = this._graph.data(\"vg_\"+t._id, pipeline, t);\n  cell.delete = function() {\n    debug({}, [\"deleting cell\", k.key]);\n    facet.removeListener(pipeline[0]);\n    facet._graph.disconnect(pipeline);\n  };\n\n  this.addListener(pipeline[0]);\n\n  return cell;\n};\n\nproto._add = function(x) {\n  var cell = GroupBy.prototype._add.call(this, x);\n  cell.ds._input.add.push(x);\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  var cell = GroupBy.prototype._mod.call(this, x, reset);\n  if(!(cell.flg & C.ADD_CELL)) cell.ds._input.mod.push(x); // Propagate tuples\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = GroupBy.prototype._rem.call(this, x);\n  cell.ds._input.rem.push(x);\n  return cell;\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"faceting\"]);\n\n  this._gb = this.keys.get(this._graph);\n\n  var output = GroupBy.prototype.transform.call(this, input, reset),\n      k, c;\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(c == null) continue;\n    if(c.cnt === 0) {\n      c.delete();\n    } else {\n      // propagate sort, signals, fields, etc.\n      changeset.copy(input, c.ds._input);\n    }\n  }\n\n  return output;\n};\n\nmodule.exports = Facet;","var Transform = require('./Transform'),\n    changeset = require('../dataflow/changeset'), \n    expr = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Filter(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {test: {type: \"expr\"} });\n\n  this._skip = {};\n  return this;\n}\n\nvar proto = (Filter.prototype = new Transform());\n\nfunction test(x) {\n  return expr.eval(this._graph, this.test.get(this._graph), \n    x, null, null, null, this.dependency(C.SIGNALS));\n};\n\nproto.transform = function(input) {\n  debug(input, [\"filtering\"]);\n  var output = changeset.create(input),\n      skip = this._skip,\n      f = this;\n\n  input.rem.forEach(function(x) {\n    if (skip[x._id] !== 1) output.rem.push(x);\n    else skip[x._id] = 0;\n  });\n\n  input.add.forEach(function(x) {\n    if (test.call(f, x)) output.add.push(x);\n    else skip[x._id] = 1;\n  });\n\n  input.mod.forEach(function(x) {\n    var b = test.call(f, x),\n        s = (skip[x._id] === 1);\n    if (b && s) {\n      skip[x._id] = 0;\n      output.add.push(x);\n    } else if (b && !s) {\n      output.mod.push(x);\n    } else if (!b && s) {\n      // do nothing, keep skip true\n    } else { // !b && !s\n      output.rem.push(x);\n      skip[x._id] = 1;\n    }\n  });\n\n  return output;\n};\n\nmodule.exports = Filter;","var Transform = require('./Transform'),\n    debug = require('../util/debug'), \n    tuple = require('../dataflow/tuple'), \n    changeset = require('../dataflow/changeset');\n\nfunction Fold(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    fields: {type: \"array<field>\"} \n  });\n\n  this._output = {key: \"key\", value: \"value\"};\n  this._cache = {};\n\n  return this.router(true).revises(true);\n}\n\nvar proto = (Fold.prototype = new Transform());\n\nfunction rst(input, output) { \n  for(var id in this._cache) output.rem.push.apply(output.rem, this._cache[id]);\n  this._cache = {};\n};\n\nfunction get_tuple(x, i, len) {\n  var list = this._cache[x._id] || (this._cache[x._id] = Array(len));\n  return list[i] || (list[i] = tuple.derive(x, x._prev));\n};\n\nfunction fn(data, fields, accessors, out, stamp) {\n  var i = 0, dlen = data.length,\n      j, flen = fields.length,\n      d, t;\n\n  for(; i<dlen; ++i) {\n    d = data[i];\n    for(j=0; j<flen; ++j) {\n      t = get_tuple.call(this, d, j, flen);  \n      tuple.set(t, this._output.key, fields[j]);\n      tuple.set(t, this._output.value, accessors[j](d));\n      out.push(t);\n    }      \n  }\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"folding\"]);\n\n  var fold = this,\n      on = this.fields.get(this._graph),\n      fields = on.fields, accessors = on.accessors,\n      output = changeset.create(input);\n\n  if(reset) rst.call(this, input, output);\n\n  fn.call(this, input.add, fields, accessors, output.add, input.stamp);\n  fn.call(this, input.mod, fields, accessors, reset ? output.add : output.mod, input.stamp);\n  input.rem.forEach(function(x) {\n    output.rem.push.apply(output.rem, fold._cache[x._id]);\n    fold._cache[x._id] = null;\n  });\n\n  // If we're only propagating values, don't mark key/value as updated.\n  if(input.add.length || input.rem.length || \n    fields.some(function(f) { return !!input.fields[f]; }))\n      output.fields[this._output.key] = 1, output.fields[this._output.value] = 1;\n  return output;\n};\n\nmodule.exports = Fold;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Force(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    size: {type: \"array<value>\", default: [500, 500]},\n    links: {type: \"data\"},\n    linkDistance: {type: \"field\", default: 20},\n    linkStrength: {type: \"field\", default: 1},\n    charge: {type: \"field\", default: 30},\n    chargeDistance: {type: \"field\", default: Infinity},\n    iterations: {type: \"value\", default: 500},\n    friction: {type: \"value\", default: 0.9},\n    theta: {type: \"value\", default: 0.8},\n    gravity: {type: \"value\", default: 0.1},\n    alpha: {type: \"value\", default: 0.1}\n  });\n\n  this._nodes = [];\n  this._links = [];\n  this._layout = d3.layout.force();\n\n  this._output = {\n    \"x\": \"layout:x\",\n    \"y\": \"layout:y\",\n    \"source\": \"_source\",\n    \"target\": \"_target\"\n  };\n\n  return this;\n}\n\nvar proto = (Force.prototype = new Transform());\n\nfunction get(transform, name) {\n  var v = transform[name].get(transform._graph);\n  return v.accessor\n    ? function(x) { return v.accessor(x.tuple); }\n    : v.field;\n}\n\nproto.transform = function(nodeInput) {\n  // get variables\n  var g = this._graph,\n      linkInput = this.links.get(g).source.last(),\n      layout = this._layout,\n      output = this._output,\n      nodes = this._nodes,\n      links = this._links,\n      iter = this.iterations.get(g);\n\n  // process added nodes\n  nodeInput.add.forEach(function(n) {\n    nodes.push({tuple: n});\n  });\n\n  // process added edges\n  linkInput.add.forEach(function(l) {\n    var link = {\n      tuple: l,\n      source: nodes[l.source],\n      target: nodes[l.target]\n    };\n    tuple.set(l, output.source, link.source.tuple);\n    tuple.set(l, output.target, link.target.tuple);\n    links.push(link);\n  });\n\n  // TODO process \"mod\" of edge source or target?\n\n  // configure layout\n  layout\n    .size(this.size.get(g))\n    .linkDistance(get(this, \"linkDistance\"))\n    .linkStrength(get(this, \"linkStrength\"))\n    .charge(get(this, \"charge\"))\n    .chargeDistance(get(this, \"chargeDistance\"))\n    .friction(this.friction.get(g))\n    .theta(this.theta.get(g))\n    .gravity(this.gravity.get(g))\n    .alpha(this.alpha.get(g))\n    .nodes(nodes)\n    .links(links);\n\n  // run layout\n  layout.start();\n  for (var i=0; i<iter; ++i) {\n    layout.tick();\n  }\n  layout.stop();\n\n  // copy layout values to nodes\n  nodes.forEach(function(n) {\n    tuple.set(n.tuple, output.x, n.x);\n    tuple.set(n.tuple, output.y, n.y);\n  });\n\n  // process removed nodes\n  if (nodeInput.rem.length > 0) {\n    var nodeIds = tuple.idMap(nodeInput.rem);\n    this._nodes = nodes.filter(function(n) { return !nodeIds[n.tuple._id]; });\n  }\n\n  // process removed edges\n  if (linkInput.rem.length > 0) {\n    var linkIds = tuple.idMap(linkInput.rem);\n    this._links = links.filter(function(l) { return !linkIds[l.tuple._id]; });\n  }\n\n  // return changeset\n  nodeInput.fields[output.x] = 1;\n  nodeInput.fields[output.y] = 1;\n  return nodeInput;\n};\n\nmodule.exports = Force;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'), \n    expression = require('../parse/expr'),\n    debug = require('../util/debug'),\n    C = require('../util/constants');\n\nfunction Formula(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"value\"},\n    expr:  {type: \"expr\"}\n  });\n\n  return this;\n}\n\nvar proto = (Formula.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"formulating\"]);\n  var t = this, \n      g = this._graph,\n      field = this.field.get(g),\n      expr = this.expr.get(g),\n      deps = this.dependency(C.SIGNALS);\n  \n  function set(x) {\n    var val = expression.eval(g, expr, x, null, null, null, deps);\n    tuple.set(x, field, val);\n  }\n\n  input.add.forEach(set);\n  \n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[field] = 1;\n  return input;\n};\n\nmodule.exports = Formula;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Geo(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    lon: {type: \"field\"},\n    lat: {type: \"field\"}\n  });\n\n  this._output = {\n    \"x\": \"geo:x\",\n    \"y\": \"geo:y\"\n  };\n  return this;\n}\n\nvar None\n\nGeo.Parameters = {\n  projection: {type: \"value\", default: \"mercator\"},\n  center:     {type: \"array[value]\"},\n  translate:  {type: \"array[value]\"},\n  rotate:     {type: \"array[value]\"},\n  scale:      {type: \"value\"},\n  precision:  {type: \"value\"},\n  clipAngle:  {type: \"value\"},\n  clipExtent: {type: \"value\"}\n};\n\nGeo.d3Projection = function() {\n  var g = this._graph,\n      p = this.projection.get(g),\n      param = Geo.Parameters,\n      proj, name, value;\n\n  if (p !== this._mode) {\n    this._mode = p;\n    this._projection = d3.geo[p]();\n  }\n  proj = this._projection;\n\n  for (name in param) {\n    if (name === \"projection\" || !proj[name]) continue;\n    value = this[name].get(g);\n    if (value === undefined || (dl.isArray(value) && value.length === 0)) {\n      continue;\n    }\n    if (value !== proj[name]()) {\n      proj[name](value);\n    }\n  }\n\n  return proj;\n};\n\nvar proto = (Geo.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      lon = this.lon.get(g).accessor,\n      lat = this.lat.get(g).accessor,\n      proj = Geo.d3Projection.call(this);\n\n  function set(t) {\n    var ll = [lon(t), lat(t)];\n    var xy = proj(ll);\n    tuple.set(t, output.x, xy[0]);\n    tuple.set(t, output.y, xy[1]);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  return input;\n};\n\nmodule.exports = Geo;\n","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Geo = require('./Geo'),\n    Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction GeoPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, Geo.Parameters);\n  Transform.addParameters(this, {\n    value: {type: \"field\", default: null},\n  });\n\n  this._output = {\n    \"path\": \"geo:path\"\n  };\n  return this;\n}\n\nvar proto = (GeoPath.prototype = new Transform());\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      geojson = this.value.get(g).accessor || dl.identity,\n      proj = Geo.d3Projection.call(this),\n      path = d3.geo.path().projection(proj);\n\n  function set(t) {\n    tuple.set(t, output.path, path(geojson(t)));\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n    input.rem.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = GeoPath;\n","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple'),\n    changeset = require('../dataflow/changeset'),\n    C = require('../util/constants');\n\nfunction GroupBy(graph) {\n  if(graph) this.init(graph);\n  return this;\n}\n\nvar proto = (GroupBy.prototype = new Transform());\n\nproto.init = function(graph) {\n  this._gb = null; // fields+accessors to groupby fields\n  this._cells = {};\n  return Transform.prototype.init.call(this, graph)\n    .router(true).revises(true);\n};\n\nproto.data = function() { return this._cells; };\n\nproto._reset = function(input, output) {\n  var k, c;\n  for(k in this._cells) {\n    if(!(c = this._cells[k])) continue;\n    output.rem.push(c.tpl);\n  }\n  this._cells = {};\n};\n\nproto._keys = function(x) {\n  var acc = this._gb.accessors || [this._gb.accessor];\n  var keys = acc.reduce(function(g, f) {\n    return ((v = f(x)) !== undefined) ? (g.push(v), g) : g;\n  }, []), k = keys.join(\"|\"), v;\n  return keys.length > 0 ? {keys: keys, key: k} : undefined;\n};\n\nproto._cell = function(x) {\n  var k = this._keys(x);\n  return this._cells[k.key] || (this._cells[k.key] = this._new_cell(x, k));\n};\n\nproto._new_cell = function(x, k) {\n  return {\n    cnt: 0,\n    tpl: this._new_tuple(x, k),\n    flg: C.ADD_CELL\n  };\n};\n\nproto._new_tuple = function(x, k) {\n  var gb = this._gb,\n      fields = gb.fields || [gb.field],\n      acc = gb.accessors || [gb.accessor],\n      t = {}, i, len;\n\n  for(i=0, len=fields.length; i<len; ++i) {\n    t[fields[i]] = acc[i](x);\n  } \n\n  return tuple.ingest(t, null);\n};\n\nproto._add = function(x) {\n  var cell = this._cell(x);\n  cell.cnt += 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._rem = function(x) {\n  var cell = this._cell(x);\n  cell.cnt -= 1;\n  cell.flg |= C.MOD_CELL;\n  return cell;\n};\n\nproto._mod = function(x, reset) {\n  if(x._prev && x._prev !== C.SENTINEL && this._keys(x._prev) !== undefined) {\n    this._rem(x._prev);\n    return this._add(x);\n  } else if(reset) { // Signal change triggered reflow\n    return this._add(x);\n  }\n  return this._cell(x);\n};\n\nproto.transform = function(input, reset) {\n  var groupBy = this,\n      output = changeset.create(input),\n      k, c, f, t;\n\n  if(reset) this._reset(input, output);\n\n  input.add.forEach(function(x) { groupBy._add(x); });\n  input.mod.forEach(function(x) { groupBy._mod(x, reset); });\n  input.rem.forEach(function(x) {\n    if(x._prev && x._prev !== C.SENTINEL && groupBy._keys(x._prev) !== undefined) {\n      groupBy._rem(x._prev);\n    } else {\n      groupBy._rem(x);\n    }\n  });\n\n  for(k in this._cells) {\n    c = this._cells[k];\n    if(!c) continue;\n    f = c.flg;\n    t = c.tpl;\n\n    if(c.cnt === 0) {\n      if(f === C.MOD_CELL) output.rem.push(t);\n      this._cells[k] = null;\n    } else if(f & C.ADD_CELL) {\n      output.add.push(t);\n    } else if(f & C.MOD_CELL) {\n      output.mod.push(t);\n    }\n    c.flg = 0;\n  }\n\n  return output;\n};\n\nmodule.exports = GroupBy;","var Transform = require('./Transform'),\n    tuple = require('../dataflow/tuple');\n\nfunction LinkPath(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    source:  {type: \"field\", default: \"_source\"},\n    target:  {type: \"field\", default: \"_target\"},\n    x:       {type: \"field\", default: \"layout:x\"},\n    y:       {type: \"field\", default: \"layout:y\"},\n    tension: {type: \"value\", default: 0.2},\n    shape:   {type: \"value\", default: \"line\"}\n  });\n\n  this._output = {\"path\": \"link:path\"};\n  return this;\n}\n\nvar proto = (LinkPath.prototype = new Transform());\n\nfunction line(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t);\n  return \"M\" + sx + \",\" + sy\n       + \"L\" + tx + \",\" + ty;\n}\n\nfunction curve(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      dx = tx - sx,\n      dy = ty - sy,\n      ix = tension * (dx + dy),\n      iy = tension * (dy - dx);\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + (sx+ix) + \",\" + (sy+iy)\n       + \" \" + (tx+iy) + \",\" + (ty-ix)\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalX(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sx + tx) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + m  + \",\" + sy\n       + \" \" + m  + \",\" + ty\n       + \" \" + tx + \",\" + ty;\n}\n\nfunction diagonalY(d, source, target, x, y, tension) {\n  var s = source(d), sx = x(s), sy = y(s),\n      t = target(d), tx = x(t), ty = y(t),\n      m = (sy + ty) / 2;\n  return \"M\" + sx + \",\" + sy\n       + \"C\" + sx + \",\" + m\n       + \" \" + tx + \",\" + m\n       + \" \" + tx + \",\" + ty;\n}\n\nvar shapes = {\n  line:      line,\n  curve:     curve,\n  diagonal:  diagonalX,\n  diagonalX: diagonalX,\n  diagonalY: diagonalY\n};\n\nproto.transform = function(input) {\n  var g = this._graph,\n      output = this._output,\n      shape = shapes[this.shape.get(g)] || shapes.line,\n      source = this.source.get(g).accessor,\n      target = this.target.get(g).accessor,\n      x = this.x.get(g).accessor,\n      y = this.y.get(g).accessor,\n      tension = this.tension.get(g);\n  \n  function set(t) {\n    var path = shape(t, source, target, x, y, tension)\n    tuple.set(t, output.path, path);\n  }\n\n  input.add.forEach(set);\n  if (this.reevaluate(input)) {\n    input.mod.forEach(set);\n  }\n\n  input.fields[output.path] = 1;\n  return input;\n};\n\nmodule.exports = LinkPath;","var dl = require('datalib'),\n    expr = require('../parse/expr'),\n    C = require('../util/constants');\n\nvar arrayType = /array/i,\n    dataType  = /data/i,\n    fieldType = /field/i,\n    exprType  = /expr/i;\n\nfunction Parameter(name, type) {\n  this._name = name;\n  this._type = type;\n\n  // If parameter is defined w/signals, it must be resolved\n  // on every pulse.\n  this._value = [];\n  this._accessors = [];\n  this._resolution = false;\n  this._signals = {};\n}\n\nvar proto = Parameter.prototype;\n\nproto._get = function() {\n  var isArray = arrayType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  if (isData) {\n    return isArray ? { names: this._value, sources: this._accessors } :\n      { name: this._value[0], source: this._accessors[0] };\n  } else if (isField) {\n    return isArray ? { fields: this._value, accessors: this._accessors } :\n      { field: this._value[0], accessor: this._accessors[0] };\n  } else {\n    return isArray ? this._value : this._value[0];\n  }\n};\n\nproto.get = function(graph) {\n  var isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type),\n      s, idx, val;\n\n  // If we don't require resolution, return the value immediately.\n  if (!this._resolution) return this._get();\n\n  if (isData) {\n    this._accessors = this._value.map(function(v) { return graph.data(v); });\n    return this._get(); // TODO: support signal as dataTypes\n  }\n\n  for(s in this._signals) {\n    idx  = this._signals[s];\n    val  = graph.signalRef(s);\n\n    if (isField) {\n      this._accessors[idx] = this._value[idx] != val ? \n        dl.accessor(val) : this._accessors[idx];\n    }\n\n    this._value[idx] = val;\n  }\n\n  return this._get();\n};\n\nproto.set = function(transform, value) {\n  var param = this, \n      isExpr = exprType.test(this._type),\n      isData  = dataType.test(this._type),\n      isField = fieldType.test(this._type);\n\n  this._value = dl.array(value).map(function(v, i) {\n    if (dl.isString(v)) {\n      if (isExpr) {\n        var e = expr(v);\n        transform.dependency(C.FIELDS,  e.fields);\n        transform.dependency(C.SIGNALS, e.signals);\n        return e.fn;\n      } else if (isField) {  // Backwards compatibility\n        param._accessors[i] = dl.accessor(v);\n        transform.dependency(C.FIELDS, v);\n      } else if (isData) {\n        param._resolution = true;\n        transform.dependency(C.DATA, v);\n      }\n      return v;\n    } else if (v.value !== undefined) {\n      return v.value;\n    } else if (v.field !== undefined) {\n      param._accessors[i] = dl.accessor(v.field);\n      transform.dependency(C.FIELDS, v.field);\n      return v.field;\n    } else if (v.signal !== undefined) {\n      param._resolution = true;\n      param._signals[v.signal] = i;\n      transform.dependency(C.SIGNALS, v.signal);\n      return v.signal;\n    }\n\n    return v;\n  });\n\n  return transform;\n};\n\nmodule.exports = Parameter;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Pie(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    value:      {type: \"field\", default: null},\n    startAngle: {type: \"value\", default: 0},\n    endAngle:   {type: \"value\", default: 2 * Math.PI},\n    sort:       {type: \"value\", default: false}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n\n  return this;\n}\n\nvar proto = (Pie.prototype = new BatchTransform());\n\nfunction ones() { return 1; }\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      output = this._output,\n      value = this.value.get(g).accessor || ones,\n      start = this.startAngle.get(g),\n      stop = this.endAngle.get(g),\n      sort = this.sort.get(g);\n\n  var values = data.map(value),\n      a = start,\n      k = (stop - start) / d3.sum(values),\n      index = dl.range(data.length),\n      i, t, v;\n\n  if (sort) {\n    index.sort(function(a, b) {\n      return values[a] - values[b];\n    });\n  }\n\n  for (i=0; i<index.length; ++i) {\n    t = data[index[i]];\n    v = values[index[i]];\n    tuple.set(t, output.start, a);\n    tuple.set(t, output.mid, (a + 0.5 * v * k));\n    tuple.set(t, output.stop, (a += v * k));\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nmodule.exports = Pie;\n","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    expr = require('../parse/expr'),\n    debug = require('../util/debug');\n\nfunction Sort(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {by: {type: \"array<field>\"} });\n  return this.router(true);\n}\n\nvar proto = (Sort.prototype = new Transform());\n\nproto.transform = function(input) {\n  debug(input, [\"sorting\"]);\n\n  if(input.add.length || input.mod.length || input.rem.length) {\n    input.sort = dl.comparator(this.by.get(this._graph).fields);\n  }\n\n  return input;\n};\n\nmodule.exports = Sort;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Stack(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    groupby: {type: \"array<field>\"},\n    sortby: {type: \"array<field>\"},\n    value: {type: \"field\"},\n    offset: {type: \"value\", default: \"zero\"}\n  });\n\n  this._output = {\n    \"start\": \"layout:start\",\n    \"stop\":  \"layout:stop\",\n    \"mid\":   \"layout:mid\"\n  };\n  return this;\n}\n\nvar proto = (Stack.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  var g = this._graph,\n      groupby = this.groupby.get(g).accessors,\n      sortby = dl.comparator(this.sortby.get(g).fields),\n      value = this.value.get(g).accessor,\n      offset = this.offset.get(g),\n      output = this._output;\n\n  // partition, sum, and sort the stack groups\n  var groups = partition(data, groupby, sortby, value);\n\n  // compute stack layouts per group\n  for (var i=0, max=groups.max; i<groups.length; ++i) {\n    var group = groups[i],\n        sum = group.sum,\n        off = offset===\"center\" ? (max - sum)/2 : 0,\n        scale = offset===\"normalize\" ? (1/sum) : 1,\n        i, x, a, b = off, v = 0;\n\n    // set stack coordinates for each datum in group\n    for (j=0; j<group.length; ++j) {\n      x = group[j];\n      a = b; // use previous value for start point\n      v += value(x);\n      b = scale * v + off; // compute end point\n      tuple.set(x, output.start, a);\n      tuple.set(x, output.stop, b);\n      tuple.set(x, output.mid, 0.5 * (a + b));\n    }\n  }\n\n  input.fields[output.start] = 1;\n  input.fields[output.stop] = 1;\n  input.fields[output.mid] = 1;\n  return input;\n};\n\nfunction partition(data, groupby, sortby, value) {\n  var groups = [],\n      map, i, x, k, g, s, max;\n\n  // partition data points into stack groups\n  if (groupby == null) {\n    groups.push(data.slice());\n  } else {\n    for (map={}, i=0; i<data.length; ++i) {\n      x = data[i];\n      k = (groupby.map(function(f) { return f(x); }));\n      g = map[k] || (groups.push(map[k] = []), map[k]);\n      g.push(x);\n    }\n  }\n\n  // compute sums of groups, sort groups as needed\n  for (k=0, max=0; k<groups.length; ++k) {\n    g = groups[k];\n    for (i=0, s=0; i<g.length; ++i) {\n      s += value(g[i]);\n    }\n    g.sum = s;\n    if (s > max) max = s;\n    if (sortby != null) g.sort(sortby);\n  }\n  groups.max = max;\n\n  return groups;\n}\n\nmodule.exports = Stack;","var Node = require('../dataflow/Node'),\n    Parameter = require('./Parameter'),\n    C = require('../util/constants');\n\nfunction Transform(graph) {\n  if(graph) Node.prototype.init.call(this, graph);\n  return this;\n}\n\nTransform.addParameters = function(proto, params) {\n  var p;\n  for (var name in params) {\n    p = params[name];\n    proto[name] = new Parameter(name, p.type);\n    if (p.hasOwnProperty('default')) proto[name].set(proto, p.default);\n  }\n  proto._parameters = params;\n};\n\nvar proto = (Transform.prototype = new Node());\n\nproto.clone = function() {\n  var n = Node.prototype.clone.call(this);\n  n.transform = this.transform;\n  n._parameters = this._parameters;\n  for(var k in this) { \n    if(n[k]) continue;\n    n[k] = this[k]; \n  }\n  return n;\n};\n\nproto.transform = function(input, reset) { return input; };\nproto.evaluate = function(input) {\n  // Many transforms store caches that must be invalidated if\n  // a signal value has changed. \n  var reset = this._stamp < input.stamp && this.dependency(C.SIGNALS).some(function(s) { \n    return !!input.signals[s] \n  });\n\n  return this.transform(input, reset);\n};\n\nproto.output = function(map) {\n  for (var key in this._output) {\n    if (map[key] !== undefined) {\n      this._output[key] = map[key];\n    }\n  }\n  return this;\n};\n\nmodule.exports = Transform;","var dl = require('datalib'),\n    d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Transform = require('./Transform'),\n    BatchTransform = require('./BatchTransform'),\n    tuple = require('../dataflow/tuple');\n\nfunction Treemap(graph) {\n  BatchTransform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    // hierarchy parameters\n    sort: {type: \"array<field>\", default: [\"-value\"]},\n    children: {type: \"field\", default: \"children\"},\n    value: {type: \"field\", default: \"value\"},\n    // treemap parameters\n    size: {type: \"array<value>\", default: [500, 500]},\n    round: {type: \"value\", default: true},\n    sticky: {type: \"value\", default: false},\n    ratio: {type: \"value\", default: 0.5 * (1 + Math.sqrt(5))},\n    padding: {type: \"value\", default: null},\n    mode: {type: \"value\", default: \"squarify\"}\n  });\n\n  this._layout = d3.layout.treemap();\n\n  this._output = {\n    \"x\":      \"layout:x\",\n    \"y\":      \"layout:y\",\n    \"width\":  \"layout:width\",\n    \"height\": \"layout:height\"\n  };\n  return this;\n}\n\nvar proto = (Treemap.prototype = new BatchTransform());\n\nproto.batchTransform = function(input, data) {\n  // get variables\n  var g = this._graph,\n      layout = this._layout,\n      output = this._output;\n\n  // configure layout\n  layout\n    .sort(dl.comparator(this.sort.get(g).fields))\n    .children(this.children.get(g).accessor)\n    .value(this.value.get(g).accessor)\n    .size(this.size.get(g))\n    .round(this.round.get(g))\n    .sticky(this.sticky.get(g))\n    .ratio(this.ratio.get(g))\n    .padding(this.padding.get(g))\n    .mode(this.mode.get(g))\n    .nodes(data[0]);\n\n  // copy layout values to nodes\n  data.forEach(function(n) {\n    tuple.set(n, output.x, n.x);\n    tuple.set(n, output.y, n.y);\n    tuple.set(n, output.width, n.dx);\n    tuple.set(n, output.height, n.dy);\n  });\n\n  // return changeset\n  input.fields[output.x] = 1;\n  input.fields[output.y] = 1;\n  input.fields[output.width] = 1;\n  input.fields[output.height] = 1;\n  return input;\n};\n\nmodule.exports = Treemap;","var Transform = require('./Transform'),\n    GroupBy = require('./GroupBy'),\n    tuple = require('../dataflow/tuple'),\n    debug = require('../util/debug');\n\nfunction Unique(graph) {\n  GroupBy.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    field: {type: \"field\"},\n    as: {type: \"value\"}\n  });\n\n  return this;\n}\n\nvar proto = (Unique.prototype = new GroupBy());\n\nproto._new_tuple = function(x) {\n  var o  = {},\n      on = this.field.get(this._graph),\n      as = this.as.get(this._graph);\n\n  o[as] = on.accessor(x);\n  return tuple.ingest(o, null);\n};\n\nproto.transform = function(input, reset) {\n  debug(input, [\"uniques\"]);\n  this._gb = this.field.get(this._graph);\n  return GroupBy.prototype.transform.call(this, input, reset);\n};\n\nmodule.exports = Unique;","var dl = require('datalib'),\n    Transform = require('./Transform'),\n    Collector = require('../dataflow/Collector'),\n    debug = require('../util/debug');\n\nfunction Zip(graph) {\n  Transform.prototype.init.call(this, graph);\n  Transform.addParameters(this, {\n    with: {type: \"data\"},\n    as:  {type: \"value\"},\n    key: {type: \"field\", default: \"data\"},\n    withKey: {type: \"field\", default: null},\n    default: {type: \"value\"}\n  });\n\n  this._map = {};\n  this._collector = new Collector(graph);\n  this._lastJoin = 0;\n\n  return this.revises(true);\n}\n\nvar proto = (Zip.prototype = new Transform());\n\nfunction mp(k) {\n  return this._map[k] || (this._map[k] = []);\n};\n\nproto.transform = function(input) {\n  var w = this.with.get(this._graph),\n      wds = w.source,\n      woutput = wds.last(),\n      wdata = wds.values(),\n      key = this.key.get(this._graph),\n      withKey = this.withKey.get(this._graph),\n      as = this.as.get(this._graph),\n      dflt = this.default.get(this._graph),\n      map = mp.bind(this),\n      rem = {};\n\n  debug(input, [\"zipping\", w.name]);\n\n  if(withKey.field) {\n    if(woutput && woutput.stamp > this._lastJoin) {\n      woutput.rem.forEach(function(x) {\n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = dflt });\n        m[1] = null;\n      });\n\n      woutput.add.forEach(function(x) { \n        var m = map(withKey.accessor(x));\n        if(m[0]) m[0].forEach(function(d) { d[as] = x });\n        m[1] = x;\n      });\n      \n      // Only process woutput.mod tuples if the join key has changed.\n      // Other field updates will auto-propagate via prototype.\n      if(woutput.fields[withKey.field]) {\n        woutput.mod.forEach(function(x) {\n          var prev;\n          if(!x._prev || (prev = withKey.accessor(x._prev)) === undefined) return;\n          var prevm = map(prev);\n          if(prevm[0]) prevm[0].forEach(function(d) { d[as] = dflt });\n          prevm[1] = null;\n\n          var m = map(withKey.accessor(x));\n          if(m[0]) m[0].forEach(function(d) { d[as] = x });\n          m[1] = x;\n        });\n      }\n\n      this._lastJoin = woutput.stamp;\n    }\n  \n    input.add.forEach(function(x) {\n      var m = map(key.accessor(x));\n      x[as] = m[1] || dflt;\n      (m[0]=m[0]||[]).push(x);\n    });\n\n    input.rem.forEach(function(x) { \n      var k = key.accessor(x);\n      (rem[k]=rem[k]||{})[x._id] = 1;\n    });\n\n    if(input.fields[key.field]) {\n      input.mod.forEach(function(x) {\n        var prev;\n        if(!x._prev || (prev = key.accessor(x._prev)) === undefined) return;\n\n        var m = map(key.accessor(x));\n        x[as] = m[1] || dflt;\n        (m[0]=m[0]||[]).push(x);\n        (rem[prev]=rem[prev]||{})[x._id] = 1;\n      });\n    }\n\n    dl.keys(rem).forEach(function(k) { \n      var m = map(k);\n      if(!m[0]) return;\n      m[0] = m[0].filter(function(x) { return rem[k][x._id] !== 1 });\n    });\n  } else {\n    // We only need to run a non-key-join again if we've got any add/rem\n    // on input or woutput\n    if(input.add.length == 0 && input.rem.length == 0 && \n        woutput.add.length == 0 && woutput.rem.length == 0) return input;\n\n    // If we don't have a key-join, then we need to materialize both\n    // data sources to iterate through them. \n    this._collector.evaluate(input);\n\n    var data = this._collector.data(), \n        wlen = wdata.length, i;\n\n    for(i = 0; i < data.length; i++) { data[i][as] = wdata[i%wlen]; }\n  }\n\n  input.fields[as] = 1;\n  return input;\n};\n\nmodule.exports = Zip;","module.exports = {\n  aggregate:  require('./Aggregate'),\n  bin:        require('./Bin'),\n  cross:      require('./Cross'),\n  linkpath:   require('./LinkPath'),\n  facet:      require('./Facet'),\n  filter:     require('./Filter'),\n  fold:       require('./Fold'),\n  force:      require('./Force'),\n  formula:    require('./Formula'),\n  geo:        require('./Geo'),\n  geopath:    require('./GeoPath'),\n  pie:        require('./Pie'),\n  sort:       require('./Sort'),\n  stack:      require('./Stack'),\n  treemap:    require('./Treemap'),\n  unique:     require('./Unique'),\n  zip:        require('./Zip')\n};","var dl = require('datalib'),\n    tuple = require('../dataflow/tuple'),\n    quickselect = require('../util/quickselect'),\n    C = require('../util/constants');\n\nvar types = {\n  \"count\": measure({\n    name: \"count\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.cell.cnt\"\n  }),\n  \"_counts\": measure({\n    name: \"_counts\",\n    init: \"this.cnts = {};\",\n    add:  \"this.cnts[v] = ++this.cnts[v] || 1;\",\n    rem:  \"this.cnts[v] = --this.cnts[v] < 0 ? 0 : this.cnts[v];\",\n    set:  \"\",\n    req:  [\"count\"]\n  }),\n  \"sum\": measure({\n    name: \"sum\",\n    init: \"this.sum = 0;\",\n    add:  \"this.sum += v;\",\n    rem:  \"this.sum -= v;\",\n    set:  \"this.sum\"\n  }),\n  \"avg\": measure({\n    name: \"avg\",\n    init: \"this.avg = 0;\",\n    add:  \"var d = v - this.avg; this.avg += d / this.cell.cnt;\",\n    rem:  \"var d = v - this.avg; this.avg -= d / this.cell.cnt;\",\n    set:  \"this.avg\",\n    req:  [\"count\"], idx: 1\n  }),\n  \"var\": measure({\n    name: \"var\",\n    init: \"this.dev = 0;\",\n    add:  \"this.dev += d * (v - this.avg);\",\n    rem:  \"this.dev -= d * (v - this.avg);\",\n    set:  \"this.dev / (this.cell.cnt-1)\",\n    req:  [\"avg\"], idx: 2\n  }),\n  \"varp\": measure({\n    name: \"varp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"this.dev / this.cell.cnt\",\n    req:  [\"var\"], idx: 3\n  }),\n  \"stdev\": measure({\n    name: \"stdev\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / (this.cell.cnt-1))\",\n    req:  [\"var\"], idx: 4\n  }),\n  \"stdevp\": measure({\n    name: \"stdevp\",\n    init: \"\",\n    add:  \"\",\n    rem:  \"\",\n    set:  \"Math.sqrt(this.dev / this.cell.cnt)\",\n    req:  [\"var\"], idx: 5\n  }),\n  \"min\": measure({\n    name: \"min\",\n    init: \"this.min = +Infinity;\",\n    add:  \"this.min = v < this.min ? v : this.min;\",\n    rem:  \"var self = this; this.min = v == this.min \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v < m ? v : m }, +Infinity) \" + \n          \": this.min;\",\n    set:  \"this.min\",\n    req: [\"_counts\"], idx: 6\n  }),\n  \"max\": measure({\n    name: \"max\",\n    init: \"this.max = -Infinity;\",\n    add:  \"this.max = v > this.max ? v : this.max;\",\n    rem:  \"var self = this; this.max = v == this.max \" +\n          \"? this.keys(this.cnts).reduce(function(m, v) { \" +\n          \"   return self.cnts[(v = +v)] > 0 && v > m ? v : m }, -Infinity) \" + \n          \": this.max;\",\n    set:  \"this.max\",\n    req: [\"_counts\"], idx: 7\n  }),\n  \"median\": measure({\n    name: \"median\",\n    init: \"this.vals = []; \",\n    add:  \"if(this.vals) this.vals.push(v); \",\n    rem:  \"this.vals = null;\",\n    set:  \"this.cell.cnt % 2 ? this.sel(~~(this.cell.cnt/2), this.vals, this.cnts) : \"+\n          \"0.5 * (this.sel(~~(this.cell.cnt/2)-1, this.vals, this.cnts) + this.sel(~~(this.cell.cnt/2), this.vals, this.cnts))\",\n    req: [\"_counts\"], idx: 8\n  })\n};\n\nfunction measure(base) {\n  return function(out) {\n    var m = Object.create(base);\n    m.out = out || base.name;\n    if (!m.idx) m.idx = 0;\n    return m;\n  };\n}\n\nfunction resolve(agg) {\n  function collect(m, a) {\n    (a.req || []).forEach(function(r) {\n      if (!m[r]) collect(m, m[r] = types[r]());\n    });\n    return m;\n  }\n  var map = agg.reduce(collect,\n    agg.reduce(function(m, a) { return (m[a.name] = a, m); }, {}));\n  var all = [];\n  for (var k in map) all.push(map[k]);\n  all.sort(function(a,b) { return a.idx - b.idx; });\n  return all;\n}\n\nfunction compile(agg) {\n  var all = resolve(agg),\n      ctr = \"this.tpl = t; this.cell = c;\",\n      add = \"\",\n      rem = \"\",\n      set = \"var t = this.tpl;\";\n\n  all.forEach(function(a) { ctr += a.init; add += a.add; rem += a.rem; });\n  agg.forEach(function(a) { set += \"this.tuple.set(t,'\"+a.out+\"',\"+a.set+\");\"; });\n  set += \"return t;\";\n\n  ctr = Function(\"c\", \"t\", ctr);\n  ctr.prototype.add = Function(\"v\", add);\n  ctr.prototype.rem = Function(\"v\", rem);\n  ctr.prototype.set = Function(\"stamp\", set);\n  ctr.prototype.mod = mod;\n  ctr.prototype.keys = dl.keys;\n  ctr.prototype.sel = quickselect;\n  ctr.prototype.tuple = tuple;\n  return ctr;\n}\n\nfunction mod(v_new, v_old) {\n  if (v_old === undefined || v_old === v_new) return;\n  this.rem(v_old);\n  this.add(v_new);\n};\n\ntypes.create   = compile;\nmodule.exports = types;","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    Bounds = require('../core/Bounds'),\n    canvas = require('../render/canvas/path'),\n    config = require('./config');\n\nvar parse = canvas.parse,\n    boundPath = canvas.bounds,\n    areaPath = canvas.area,\n    linePath = canvas.line,\n    halfpi = Math.PI / 2,\n    sqrt3 = Math.sqrt(3),\n    tan30 = Math.tan(30 * Math.PI / 180),\n    gfx = null;\n\nfunction fontString(o) {\n  return (o.fontStyle ? o.fontStyle + \" \" : \"\")\n    + (o.fontVariant ? o.fontVariant + \" \" : \"\")\n    + (o.fontWeight ? o.fontWeight + \" \" : \"\")\n    + (o.fontSize != null ? o.fontSize : config.render.fontSize) + \"px \"\n    + (o.font || config.render.font);\n}\n\nfunction context() {\n  // TODO: how to check if nodeJS in requireJS?\n  return gfx || (gfx = (/*config.isNode\n    ? new (require(\"canvas\"))(1,1)\n    : */d3.select(\"body\").append(\"canvas\")\n        .attr(\"class\", \"vega_hidden\")\n        .attr(\"width\", 1)\n        .attr(\"height\", 1)\n        .style(\"display\", \"none\")\n        .node())\n    .getContext(\"2d\"));\n}\n\nfunction pathBounds(o, path, bounds) {\n  if (path == null) {\n    bounds.set(0, 0, 0, 0);\n  } else {\n    boundPath(path, bounds);\n    if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n      bounds.expand(o.strokeWidth);\n    }\n  }\n  return bounds;\n}\n\nfunction path(o, bounds) {\n  var p = o.path\n    ? o.pathCache || (o.pathCache = parse(o.path))\n    : null;\n  return pathBounds(o, p, bounds);\n}\n\nfunction area(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(areaPath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction line(o, bounds) {\n  var items = o.mark.items, o = items[0];\n  var p = o.pathCache || (o.pathCache = parse(linePath(items)));\n  return pathBounds(items[0], p, bounds);\n}\n\nfunction rect(o, bounds) {\n  var x = o.x || 0,\n      y = o.y || 0,\n      w = (x + o.width) || 0,\n      h = (y + o.height) || 0;\n  bounds.set(x, y, w, h);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction image(o, bounds) {\n  var w = o.width || 0,\n      h = o.height || 0,\n      x = (o.x||0) - (o.align === \"center\"\n          ? w/2 : (o.align === \"right\" ? w : 0)),\n      y = (o.y||0) - (o.baseline === \"middle\"\n          ? h/2 : (o.baseline === \"bottom\" ? h : 0));\n  return bounds.set(x, y, x+w, y+h);\n}\n\nfunction rule(o, bounds) {\n  var x1, y1;\n  bounds.set(\n    x1 = o.x || 0,\n    y1 = o.y || 0,\n    o.x2 != null ? o.x2 : x1,\n    o.y2 != null ? o.y2 : y1\n  );\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction arc(o, bounds) {\n  var cx = o.x || 0,\n      cy = o.y || 0,\n      ir = o.innerRadius || 0,\n      or = o.outerRadius || 0,\n      sa = (o.startAngle || 0) - halfpi,\n      ea = (o.endAngle || 0) - halfpi,\n      xmin = Infinity, xmax = -Infinity,\n      ymin = Infinity, ymax = -Infinity,\n      a, i, n, x, y, ix, iy, ox, oy;\n\n  var angles = [sa, ea],\n      s = sa - (sa%halfpi);\n  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {\n    angles.push(s);\n  }\n\n  for (i=0, n=angles.length; i<n; ++i) {\n    a = angles[i];\n    x = Math.cos(a); ix = ir*x; ox = or*x;\n    y = Math.sin(a); iy = ir*y; oy = or*y;\n    xmin = Math.min(xmin, ix, ox);\n    xmax = Math.max(xmax, ix, ox);\n    ymin = Math.min(ymin, iy, oy);\n    ymax = Math.max(ymax, iy, oy);\n  }\n\n  bounds.set(cx+xmin, cy+ymin, cx+xmax, cy+ymax);\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction symbol(o, bounds) {\n  var size = o.size != null ? o.size : 100,\n      x = o.x || 0,\n      y = o.y || 0,\n      r, t, rx, ry;\n\n  switch (o.shape) {\n    case \"cross\":\n      r = Math.sqrt(size / 5) / 2;\n      t = 3*r;\n      bounds.set(x-t, y-r, x+t, y+r);\n      break;\n\n    case \"diamond\":\n      ry = Math.sqrt(size / (2 * tan30));\n      rx = ry * tan30;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"square\":\n      t = Math.sqrt(size);\n      r = t / 2;\n      bounds.set(x-r, y-r, x+r, y+r);\n      break;\n\n    case \"triangle-down\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    case \"triangle-up\":\n      rx = Math.sqrt(size / sqrt3);\n      ry = rx * sqrt3 / 2;\n      bounds.set(x-rx, y-ry, x+rx, y+ry);\n      break;\n\n    default:\n      r = Math.sqrt(size/Math.PI);\n      bounds.set(x-r, y-r, x+r, y+r);\n  }\n  if (o.stroke && o.opacity !== 0 && o.strokeWidth > 0) {\n    bounds.expand(o.strokeWidth);\n  }\n  return bounds;\n}\n\nfunction text(o, bounds, noRotate) {\n  var x = (o.x || 0) + (o.dx || 0),\n      y = (o.y || 0) + (o.dy || 0),\n      h = o.fontSize || config.render.fontSize,\n      a = o.align,\n      b = o.baseline,\n      r = o.radius || 0,\n      g = context(), w, t;\n\n  g.font = fontString(o);\n  g.textAlign = a || \"left\";\n  g.textBaseline = b || \"alphabetic\";\n  w = g.measureText(o.text || \"\").width;\n\n  if (r) {\n    t = (o.theta || 0) - Math.PI/2;\n    x += r * Math.cos(t);\n    y += r * Math.sin(t);\n  }\n\n  // horizontal\n  if (a === \"center\") {\n    x = x - (w / 2);\n  } else if (a === \"right\") {\n    x = x - w;\n  } else {\n    // left by default, do nothing\n  }\n\n  /// TODO find a robust solution for heights.\n  /// These offsets work for some but not all fonts.\n\n  // vertical\n  if (b === \"top\") {\n    y = y + (h/5);\n  } else if (b === \"bottom\") {\n    y = y - h;\n  } else if (b === \"middle\") {\n    y = y - (h/2) + (h/10);\n  } else {\n    y = y - 4*h/5; // alphabetic by default\n  }\n  \n  bounds.set(x, y, x+w, y+h);\n  if (o.angle && !noRotate) {\n    bounds.rotate(o.angle*Math.PI/180, o.x||0, o.y||0);\n  }\n  return bounds.expand(noRotate ? 0 : 1);\n}\n\nfunction group(g, bounds, includeLegends) {\n  var axes = g.axisItems || [],\n      legends = g.legendItems || [], j, m;\n\n  for (j=0, m=axes.length; j<m; ++j) {\n    bounds.union(axes[j].bounds);\n  }\n  for (j=0, m=g.items.length; j<m; ++j) {\n    bounds.union(g.items[j].bounds);\n  }\n  if (includeLegends) {\n    for (j=0, m=legends.length; j<m; ++j) {\n      bounds.union(legends[j].bounds);\n    }\n    if (g.width != null && g.height != null) {\n      bounds.add(g.width, g.height);\n    }\n    if (g.x != null && g.y != null) {\n      bounds.add(0, 0);\n    }\n  }\n  bounds.translate(g.x||0, g.y||0);\n  return bounds;\n}\n\nvar methods = {\n  group:  group,\n  symbol: symbol,\n  image:  image,\n  rect:   rect,\n  rule:   rule,\n  arc:    arc,\n  text:   text,\n  path:   path,\n  area:   area,\n  line:   line\n};\n\nfunction itemBounds(item, func, opt) {\n  func = func || methods[item.mark.marktype];\n  if (!item.bounds_prev) item['bounds:prev'] = new Bounds();\n  var b = item.bounds, pb = item['bounds:prev'];\n  if (b) pb.clear().union(b);\n  item.bounds = func(item, b ? b.clear() : new Bounds(), opt);\n  if (!b) pb.clear().union(item.bounds);\n  return item.bounds;\n}\n\nfunction markBounds(mark, bounds, opt) {\n  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();\n  var type  = mark.marktype,\n      func  = methods[type],\n      items = mark.items,\n      item, i, len;\n      \n  if (type===\"area\" || type===\"line\") {\n    if (items.length) {\n      items[0].bounds = func(items[0], bounds);\n    }\n  } else {\n    for (i=0, len=items.length; i<len; ++i) {\n      bounds.union(itemBounds(items[i], func, opt));\n    }\n  }\n  mark.bounds = bounds;\n}\n\nmodule.exports = {\n  mark:  markBounds,\n  item:  itemBounds,\n  text:  text,\n  group: group\n};","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null),\n    config = {};\n\nconfig.debug = false;\n\nconfig.load = {\n  // base url for loading external data files\n  // used only for server-side operation\n  baseURL: \"\",\n  // Allows domain restriction when using data loading via XHR.\n  // To enable, set it to a list of allowed domains\n  // e.g., ['wikipedia.org', 'eff.org']\n  domainWhiteList: false\n};\n\n// version and namepsaces for exported svg\nconfig.svgNamespace =\n  'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" ' +\n  'xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n\n// inset padding for automatic padding calculation\nconfig.autopadInset = 5;\n\n// extensible scale lookup table\n// all d3.scale.* instances also supported\nconfig.scale = {\n  time: d3.time.scale,\n  utc:  d3.time.scale.utc\n};\n\n// default rendering settings\nconfig.render = {\n  lineWidth: 1,\n  lineCap:   \"butt\",\n  font:      \"sans-serif\",\n  fontSize:  11\n};\n\n// default axis properties\nconfig.axis = {\n  orient: \"bottom\",\n  ticks: 10,\n  padding: 3,\n  axisColor: \"#000\",\n  gridColor: \"#d8d8d8\",\n  tickColor: \"#000\",\n  tickLabelColor: \"#000\",\n  axisWidth: 1,\n  tickWidth: 1,\n  tickSize: 6,\n  tickLabelFontSize: 11,\n  tickLabelFont: \"sans-serif\",\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\",\n  titleOffset: 35\n};\n\n// default legend properties\nconfig.legend = {\n  orient: \"right\",\n  offset: 10,\n  padding: 3,\n  gradientStrokeColor: \"#888\",\n  gradientStrokeWidth: 1,\n  gradientHeight: 16,\n  gradientWidth: 100,\n  labelColor: \"#000\",\n  labelFontSize: 10,\n  labelFont: \"sans-serif\",\n  labelAlign: \"left\",\n  labelBaseline: \"middle\",\n  labelOffset: 8,\n  symbolShape: \"circle\",\n  symbolSize: 50,\n  symbolColor: \"#888\",\n  symbolStrokeWidth: 1,\n  titleColor: \"#000\",\n  titleFont: \"sans-serif\",\n  titleFontSize: 11,\n  titleFontWeight: \"bold\"\n};\n\n// default color values\nconfig.color = {\n  rgb: [128, 128, 128],\n  lab: [50, 0, 0],\n  hcl: [0, 0, 50],\n  hsl: [0, 0, 0.5]\n};\n\n// default scale ranges\nconfig.range = {\n  category10: [\n    \"#1f77b4\",\n    \"#ff7f0e\",\n    \"#2ca02c\",\n    \"#d62728\",\n    \"#9467bd\",\n    \"#8c564b\",\n    \"#e377c2\",\n    \"#7f7f7f\",\n    \"#bcbd22\",\n    \"#17becf\"\n  ],\n  category20: [\n    \"#1f77b4\",\n    \"#aec7e8\",\n    \"#ff7f0e\",\n    \"#ffbb78\",\n    \"#2ca02c\",\n    \"#98df8a\",\n    \"#d62728\",\n    \"#ff9896\",\n    \"#9467bd\",\n    \"#c5b0d5\",\n    \"#8c564b\",\n    \"#c49c94\",\n    \"#e377c2\",\n    \"#f7b6d2\",\n    \"#7f7f7f\",\n    \"#c7c7c7\",\n    \"#bcbd22\",\n    \"#dbdb8d\",\n    \"#17becf\",\n    \"#9edae5\"\n  ],\n  shapes: [\n    \"circle\",\n    \"cross\",\n    \"diamond\",\n    \"square\",\n    \"triangle-down\",\n    \"triangle-up\"\n  ]\n};\n\nmodule.exports = config;","module.exports = {\n  ADD_CELL: 1,\n  MOD_CELL: 2,\n\n  DATA: \"data\",\n  FIELDS:  \"fields\",\n  SCALES:  \"scales\",\n  SIGNAL:  \"signal\",\n  SIGNALS: \"signals\",\n\n  GROUP: \"group\",\n\n  ENTER: \"enter\",\n  UPDATE: \"update\",\n  EXIT: \"exit\",\n\n  SENTINEL: {\"sentinel\": 1},\n  SINGLETON: \"_singleton\",\n\n  ADD: \"add\",\n  REMOVE: \"remove\",\n  TOGGLE: \"toggle\",\n  CLEAR: \"clear\",\n\n  LINEAR: \"linear\",\n  ORDINAL: \"ordinal\",\n  LOG: \"log\",\n  POWER: \"pow\",\n  TIME: \"time\",\n  QUANTILE: \"quantile\",\n\n  DOMAIN: \"domain\",\n  RANGE: \"range\",\n\n  MARK: \"mark\",\n  AXIS: \"axis\",\n\n  COUNT: \"count\",\n  MIN: \"min\",\n  MAX: \"max\",\n\n  ASC: \"asc\",\n  DESC: \"desc\"\n};","var config = require('./config');\nvar ts;\n\nmodule.exports = function(input, args) {\n  if (!config.debug) return;\n  var log = Function.prototype.bind.call(console.log, console);\n  args.unshift(input.stamp||-1);\n  args.unshift(Date.now() - ts);\n  if(input.add) args.push(input.add.length, input.mod.length, input.rem.length, !!input.reflow);\n  log.apply(console, args);\n  ts = Date.now();\n};","var dl = require('datalib');\n\nmodule.exports = function quickselect(k, x, c) {\n  function swap(a, b) {\n    var t = x[a];\n    x[a] = x[b];\n    x[b] = t;\n  }\n\n  // x may be null, in which case assemble an array from c (counts)\n  if(x === null) {\n    x = [];\n    dl.keys(c).forEach(function(k) {\n      var i = 0, len = c[k];\n      k = +k || k;\n      for(; i<len; ++i) x.push(k);\n    });\n  }\n  \n  var left = 0,\n      right = x.length - 1,\n      pos, i, pivot;\n  \n  while (left < right) {\n    pivot = x[k];\n    swap(k, right);\n    for (i = pos = left; i < right; ++i) {\n      if (x[i] < pivot) { swap(i, pos++); }\n    }\n    swap(right, pos);\n    if (pos === k) break;\n    if (pos < k) left = pos + 1;\n    else right = pos - 1;\n  }\n  return x[k];\n};"],"sourceRoot":"/source/"}